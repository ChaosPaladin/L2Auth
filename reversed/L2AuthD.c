/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

UserInfoTable *__thiscall UserInfoTable::UserInfoTable(UserInfoTable *this); // idb
UserInfoTable *__thiscall UserInfoTable::Destructor(UserInfoTable *this);
int __thiscall UserInfoTable::addBlockReason(UserInfoTable *this, char *reasonBuffer); // idb
char __thiscall UserInfoTable::loadInfo(UserInfoTable *this, char *accountName); // idb
char __thiscall UserInfoTable::loadSession(UserInfoTable *this); // idb
char __thiscall UserInfoTable::loadCryptedPassword(UserInfoTable *this, const char *acc, char *hashedPwd); // idb
char __thiscall UserInfoTable::findUser(UserInfoTable *this, char *account, char *realPass);
char __thiscall UserInfoTable::findUser_newCrypt(UserInfoTable *this, const char *accName, const char *realPass); // idb
int SomeStaticInit2();
int sub_4020D4();
UserInfoTable *__thiscall UserInfoTable::DeletingDtor(UserInfoTable *this, char a2);
int SomeBitsInit();
void __cdecl emptystub(); // idb
char __cdecl UserManager::notifyUserLoggedOut(char *accName, int uid, int serverId); // idb
UserManager *__thiscall UserManager::UserManager(UserManager *this);
void __thiscall UserManager::Destructor(UserManager *this);
char __thiscall UserManager::userAuthed(UserManager *this, int uid, char *accountName); // idb
char __thiscall UserManager::userReadyForGS(UserManager *this, int uid, char *accName, int *loginFlag, int *warnFlag, int *payStat, int *sessionKey); // idb
PlayFail __thiscall UserManager::bindUserWithGameServer(UserManager *this, int uid, SOCKET socket, int sessionKey, char serverId);
char __thiscall UserManager::authenticateUser(UserManager *this, UserInfo *accInfo, int uid, CAuthSocket *gameClient, int totalTime, int zero); // idb
char __thiscall UserManager::kickUser(UserManager *this, int uid, char kickReason_, char sendToClient); // idb
void __stdcall UserManager::TimerCallback(PVOID uid, BOOLEAN a2); // idb
char __thiscall UserManager::onTimeout(UserManager *this, int uid); // idb
void __thiscall UserManager::removeServer(UserManager *this, int serverId); // idb
void __thiscall UserManager::clear(UserManager *this); // idb
SOCKET __thiscall UserManager::restartSomeTimer(UserManager *this, int uid, int recreate);
SOCKET __thiscall UserManager::userAcceptedByGS(UserManager *this, int uid, int serverId, int restartTimer, char *selectedGServerId, char *accName); // idb
char __thiscall UserManager::userDroppedFromGS(UserManager *this, int uid, char *accName); // idb
char __thiscall UserManager::loginAborted(UserManager *this, int uid, SOCKET socket); // idb
char __thiscall UserManager::loginCanceled(UserManager *this, int uid, int sessionKey); // idb
char __thiscall UserManager::removeUser(UserManager *this, int uid); // idb
bool __thiscall UserManager::userLoggedToGS(UserManager *this, int uid, char serverId);
char __thiscall UserManager::userQuitsFromGS(UserManager *this, int uid, int a3, int serverId); // idb
signed int __thiscall UserManager::sub_40403B(UserManager *this, int uid, int sessionKey);
char __stdcall UserManager::updateUsedTime(int uid, time_t loginTime, char lastWorld, in_addr userIp, int gameType, char *accountName, int payStat, int a8, int a9, char a10, int age, int someClientCookie); // idb
char __stdcall UserManager::getTotalTime(unsigned int uid, UserInfo *accountInfo, int *userTime); // idb
char __stdcall CAuthSocket::authenticateUser(CAuthSocket *this, UserInfo *accInfo, int uid); // idb
char __stdcall UserManager::getUserGameTime(unsigned int uid, int *userTime); // idb
char __thiscall UserManager::forwardUserToGS(UserManager *this, int uid, char *accName, int totalTime, int loginFlag, int warnFlag, int sessionKey, CAuthSocket *gameClient, signed int serverId, int payStat); // idb
char __thiscall UserManager::userReadyForGS_IP_Session(UserManager *this, int uid, char *accountName, int *loginFlag, int *warnFlag, int *sessionKey, SOCKET *socket); // idb
char __thiscall UserManager::getAccInfo(UserManager *this, int uid, char *accName, int *payStat, int *connectedIP, time_t *loginTime);
char __thiscall UserManager::addUser(UserManager *this, UserInfo *accInfo, int uid, WorldSrvSocket *serverSocket, int unused1, int unused); // idb
int __stdcall UserManager::getUserCharNumber(int uid); // idb
char __stdcall UserManager::addCharacterToServer(int uid, int charId, char serverId); // idb
char __stdcall UserManager::delCharacter(int uid, int charId, char serverId);
char __stdcall UserManager::moveCharacterToServer(int uid, int oldCharId, char oldServerId, int newCharId, int newServerId); // idb
int SomeStaticInit3();
int sub_40517C();
UserManager *__thiscall UserManager::DeletingDtor(UserManager *this, char a2);
// void __thiscall std::map::destructor_2(std::map *this); idb
// void __thiscall std::map::destructor(std::map *this); idb
std::map *__thiscall std::map::map2(std::map *this, _BYTE *a2, _BYTE *a3);
std::_tree::iterator __thiscall std::map::begin(std::map *this, int a2);
std::_tree::iterator *__thiscall std::map::end(std::map *this, std::_tree::iterator *a2); // idb
std::pair_bool_acc *__thiscall std::map::insert(std::map *this, std::pair_bool_acc *a2, std::pair_AccountInfo *a3);
std::_tree::iterator *__thiscall std::map::erase(std::map *this, _DWORD *a2, std::_tree::iterator *a3);
// int __thiscall std::map::erase2(std::map *this, _DWORD *a2); idb
std::_tree::iterator *__thiscall std::map::find(std::map *this, std::_tree::iterator *a2, _DWORD *a3);
void __thiscall std::_tree::destructor(std::_tree *this);
std::pair_AccountInfo *__thiscall std::pair_AccountInfo::pair_AccountInfo(std::pair_AccountInfo *this, int uid, UserInfo *a3); // idb
// void *__thiscall unknown_libname_4(void *this);
// std::pair_AccountInfo *__thiscall std::_tree::iterator::value(std::_tree::iterator *this);
_DWORD *__thiscall std::_tree::iterator::post_increment(std::_tree::iterator *this, _DWORD *a2, int a3); // idb
BOOL __thiscall std::_tree::iterator::not_equal(std::_tree::iterator *this, std::_tree::iterator *a2); // idb
std::map *__thiscall std::map::map(std::map *this, _BYTE *a2, _BYTE *a4); // idb
int __thiscall std::_tree::begin(void *this, int a2);
std::_tree::iterator *__thiscall std::_tree::end(std::_tree *this, std::_tree::iterator *a2);
int __thiscall std::_tree::insert3(std::_tree *this, int a2, struct Concurrency::IExecutionContext *a3); // idb
int __thiscall CAuthSocket::getSessionKey(CAuthSocket *this);
_DWORD *__thiscall std::_tree::erase_2(std::_tree *this, _DWORD *a2, int a3);
_DWORD *__thiscall std::_tree::erase(void *this, _DWORD *a2, int a3, char a4);
// int __thiscall std::_tree::size(int this);
int __thiscall sub_406060(std::_tree *this, _DWORD *a2); // idb
std::_tree::iterator *__thiscall std::_tree::find(std::_tree *this, std::_tree::iterator *a2, _DWORD *a3);
// void __stdcall std::_tree::_Freenode(void *a2);
// void *__thiscall unknown_libname_8(void *this);
void *__thiscall std::_tree::iterator::_Mynode(std::_tree::iterator *this);
// std::_tree::iterator *__thiscall std::_tree::iterator::pre_increment(std::_tree::iterator *this);
BOOL __thiscall std::_tree::iterator_operator_eq(int this, _DWORD *a2);
std::_tree::_Node *__thiscall std::pair::pair_iterator_bool(int this, _DWORD *a2, _BYTE *a3);
BOOL __stdcall std::_tree::key_compare(_DWORD *a1, _DWORD *a2);
// std::_tree::_Node *__stdcall std::_tree::_Kfn(void *a2); idb
// void __stdcall Free_2(LPVOID lpMem, int a2);
int __cdecl sub_406270(int a1);
void *__cdecl std::_tree::_Key(std::_tree::_Node *a1);
// std::_tree::_Node *__cdecl std::_tree::_Left(int a1);
std::_tree::_Node **__cdecl std::_tree::_Parent(std::_tree::_Node *a1);
std::_tree::_Node *__cdecl std::_tree::_Right(int a1);
void *__cdecl std::_tree::_Node::_Value2(std::_tree::_Node *a1);
std::_tree *__thiscall std::_tree::_tree(std::_tree *this, _BYTE *a2, char a3, _BYTE *a4); // idb
int __thiscall std::_tree::lower_bound(std::_tree *this, int a2, _DWORD *a3); // idb
int __thiscall sub_406350(std::_tree *this, int a2, _DWORD *a3); // idb
void *__thiscall sub_406390(std::_tree *this, void *a2);
int __thiscall std::_tree::_Insert(std::_tree *this, int a2, std::_tree::_Node *_X, std::_tree::_Node *_Y, struct Concurrency::IExecutionContext *a5); // idb
std::_tree::_Node *__thiscall std::_tree::_Lmost(std::_tree *this);
std::_tree::_Node **__thiscall sub_4068C0(void *this, int a2);
int __cdecl sub_4069F0(int a1);
int __cdecl sub_406A30(int a1);
std::_tree::_Node *__thiscall std::_tree::_Rmost(int this);
std::_tree::_Node *__thiscall std::_tree::_Root_const(std::_tree *this);
std::_tree::_Node **__thiscall sub_406AB0(void *this, int a2);
void __stdcall sub_406BE0(int a1);
std::_tree::_Node *__thiscall std::_tree::iterator::_Inc(std::_tree::iterator *this);
// int __thiscall unknown_libname_12(void *this);
// std::_tree::iterator *__thiscall std::_tree::iterator::iterator(std::_tree::iterator *this, int a2);
// int __thiscall unknown_libname_14(_DWORD); weak
int __thiscall sub_406CF0(void *this, int a2, _DWORD *a3);
std::_tree::_Node *__thiscall std::_tree::_Init(std::_tree *this);
std::_tree::_Node *__thiscall std::_tree::_Lbound(std::_tree *this, _DWORD *a2);
std::_tree::_Node *__stdcall std::_tree::_Buynode(int a1, int a2);
void *__stdcall std::_tree::_Consval(void *a1, int a2);
// void *__thiscall unknown_libname_15(void *this, int a2);
std::_tree::_Node *__thiscall sub_406F40(int *this);
int __thiscall sub_407010(int this, _DWORD *a2, _DWORD *a3);
char *__stdcall std::_Allocate_2(size_t a1);
std::_tree::_Node **__thiscall std::_tree::_Root(std::_tree *this); // idb
std::_tree::_Node *__thiscall sub_407080(void *this, _DWORD *a2);
int __cdecl sub_407110(int *a1, int *a2);
int __cdecl sub_407140(char a1, char a2, _DWORD *a3);
void sub_407170();
void *__cdecl sub_407180(void *a1, int a2);
// void *__cdecl operator new(unsigned int, void *); idb
// char *__cdecl std::_Allocate(size_t a1);
_BYTE *__cdecl sub_407200(_BYTE *a1);
int __cdecl sub_407220(char a1, char a2, _DWORD *a3);
unsigned __int8 *__cdecl Blowfish::encipher(unsigned __int8 *left, unsigned __int8 *right); // idb
unsigned int *__cdecl Blowfish::decipher(unsigned __int8 *left, unsigned __int8 *right);
unsigned int *__cdecl Blowfish::Decrypt(unsigned __int8 *src, signed int size);
unsigned __int8 *__cdecl Blowfish::Encrypt(unsigned __int8 *src, signed int size); // idb
__int16 __cdecl Blowfish::Initialize(const unsigned __int8 *key, int size);
__int16 __cdecl BlowFishLocal::Initialize(void *a1, int a2, __int16 a3);
int __cdecl BlowFishLocal::encipher(int a1, int *a2, int *a3);
int __cdecl BlowFishLocal::decipher(int a1, int *a2, int *a3);
int __cdecl BlowFishLocal::Decrypt(int a1, int a2, signed int a3);
int __cdecl BlowFishLocal::Encrypt(int a1, int a2, signed int a3);
int StaticInitFor_PwdCrypt();
PwdCrypt *CallStaticCtorPwdCrypt();
int RegisterStaticDtorPwdCrypt();
void __cdecl CallStaticDtorPwdCrypt(); // idb
// PwdCrypt *__thiscall PwdCrypt::PwdCrypt(PwdCrypt *this);
// void PwdCrypt::Destructor();
_BYTE *__stdcall PwdCrypt::Decrypt_2(_BYTE *in, PwdCrypt_small *a2, _BYTE *out); // idb
_BYTE *__thiscall PwdCrypt::Decrypt_7(PwdCrypt *this, _BYTE *a2, char *a3); // idb
char *__stdcall PwdCrypt::Decrypt_5(char *a1, char *a2);
char *__thiscall PwdCrypt::Decrypt_6(PwdCrypt *this, char *a2, char *a3); // idb
_BYTE *__thiscall PwdCrypt::Decrypt_4(PwdCrypt *this, char *a2, int a3, char *a4); // idb
_BYTE *__thiscall PwdCrypt::Decrypt_3(PwdCrypt *this, int a2, char *a3, _BYTE *a4); // idb
int __stdcall PwdCrypt::init_4(int a1, char a2);
void __thiscall PwdCrypt::init_3(PwdCrypt *this); // idb
int __thiscall PwdCrypt::init_keys(PwdCrypt *this, char *key);
int __thiscall PwdCrypt::init_5(PwdCrypt *this); // idb
int __stdcall PwdCrypt::init_1(PwdCrypt_small *arr_size_16, unsigned __int8 *initKey); // idb
_BYTE *__thiscall PwdCrypt::Decrypt_1(PwdCrypt *this, _BYTE *in, _BYTE *out); // idb
_BYTE *__thiscall PwdCrypt::f10_INVALID_CALL_FROM_NOWHERE(PwdCrypt *this, _BYTE *in, _BYTE *out); // idb
char __thiscall DesFrontEnd2::Decrypt(PwdCrypt *this, _BYTE *pass, int size); // idb
int __thiscall DesFrontEnd2::initDesKey(PwdCrypt *this, _BYTE *seed); // idb
int SomeStaticInit5();
int RegisterStatic_EmptyDestructor();
int StaticInitFor_Config();
Config *CallStaticCtorForConfig();
int RegisterStatic_destructorForConfig();
void __cdecl CallConfigDestructor(); // idb
char *__cdecl Config::readFile(char *fileName, int *outSize, int a3);
Config *__thiscall Config::Config(Config *this); // idb
void __thiscall Config::Destructor(Config *this);
int __thiscall Config::Load(Config *this, char *fileName);
char *__thiscall Config::getString(Config *this, char *paramName);
bool __thiscall Config::getBool(Config *this, char *paramName, bool defaultValue); // idb
int __thiscall Config::getInt(Config *this, char *paramName, int defaultValue); // idb
unsigned int *__thiscall Config::getIP(Config *this, int *removeMe, char *paramName);
char *__thiscall Config::EditMode(Config *this, char *a2); // idb
char *__stdcall Config::changeInt(char *fullCommand, char *subCommand, char *paramName, int *valueToChange); // idb
int SomeStaticInit7();
int sub_40AEBF();
// void __thiscall std::map_str_str::Destructor(std::map_str_str *this); idb
// void __thiscall std::map_str_str::Destructor_2(std::map_str_str *this); idb
void *__cdecl sub_40AF20(void *a1);
int __thiscall sub_40AF40(int this, int a2);
char *__thiscall std::istrstream::istrstream(void *this, char *buffer, int size, int a4); // idb
std::strstreambuf *__thiscall sub_40B010(std::strstreambuf *this, char *a2, int a3);
int __thiscall FileStream_dtor(int this);
// int __thiscall std::string::destructor(void *this);
int __thiscall std::pair_str_str::destructor(std::pair_str_str *this); // idb
int __thiscall sub_40B190(std::ios_base *this);
std::ios_base *__thiscall std::basic_ios::basic_ios(std::ios_base *this);
// std::ios_base *__thiscall std::ios_base::ios_base(std::ios_base *this);
// void *__thiscall unknown_libname_21(void *this, int a2);
int *__fastcall sub_40B240(int *a1, int a2, int a3, char a4, int a5);
char *__thiscall sub_40B2E0(char *this);
_DWORD *__thiscall sub_40B300(int this);
// _DWORD __thiscall std::locale::locale(std::locale *__hidden this); idb
// void __thiscall std::locale::facet::_Incref(std::locale::facet *__hidden this); idb
// _DWORD __thiscall std::locale::~locale(std::locale *__hidden this); idb
// struct std::locale::facet *__thiscall std::locale::facet::_Decref(std::locale::facet *__hidden this); idb
int __thiscall sub_40B490(int this);
// int std::char_traits<char>::eof(void); weak
// _DWORD __cdecl std::char_traits<char>::to_int_type(_DWORD); weak
// _DWORD __cdecl std::char_traits<char>::eq_int_type(_DWORD, _DWORD); weak
// int __cdecl std::char_traits<char>::copy(void *, void *, size_t); idb
// _DWORD __cdecl std::char_traits<char>::to_char_type(_DWORD); weak
// int __thiscall std::basic_streambuf<wchar_t,std::char_traits<wchar_t>>::gptr(_DWORD); weak
// int unknown_libname_25();
std::string *__thiscall std::string::string_2(std::string *this, char *a2, int a3);
// int __cdecl std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(_DWORD); weak
char *__thiscall std::string::c_str(std::string *this);
std::map_str_str *__thiscall std::map_str_str::map_str_str(std::map_str_str *this, _BYTE *a2, _BYTE *a3);
std::_tree_str_str::iterator *__thiscall std::map_str_str::find(std::map_str_str *this, std::_tree_str_str::iterator *a2, char *a3); // idb
std::_tree_str_str::iterator *__thiscall std::map_str_str::end(std::map_str_str *this, int a2);
std::pair_int_bool *__thiscall std::map_str_str::insert(std::map_str_str *this, std::_tree_str_str::iterator *a2, std::pair_str_str *a3);
void __thiscall std::_tree_str_str::Destructor(std::_tree_str_str *this); // idb
std::pair_str_str *__thiscall std::pair_str_str::pair_str_str(std::pair_str_str *this, std::string *first, std::string *second); // idb
// std::pair_str_str *__thiscall std::_tree_str_str::iterator::value(std::_tree_str_str::iterator *this);
BOOL __thiscall std::_tree_str_str::iterator::not_equal(std::_tree_str_str::iterator *this, std::_tree_str_str::iterator *a2); // idb
std::string *__thiscall sub_40BB10(std::string *this);
std::ios_base *__thiscall sub_40BB30(std::ios_base *this, char a2);
char *__thiscall sub_40BB60(char *this, char a2);
void *__thiscall sub_40BBA0(void *this, char a2);
// std::string *__thiscall std::string::string(std::string *this, std::string *other); idb
int __thiscall sub_40BBF0(int this);
// _DWORD __stdcall std::basic_ios<char,std::char_traits<char>>::init(_DWORD, _DWORD); weak
void __thiscall I_setstate(void *this, int a2, char a3);
// int __thiscall unknown_libname_29(int this);
// _DWORD __stdcall sub_40BCE0(_DWORD, char); weak
// int __thiscall std::basic_streambuf<char,std::char_traits<char>>::egptr(_DWORD); weak
// int __thiscall std::basic_streambuf<char,std::char_traits<char>>::_Gninc(_DWORD); weak
// int __thiscall std::basic_streambuf<char,std::char_traits<char>>::_Init(_DWORD); weak
// _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(_DWORD); weak
// _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *, _DWORD); weak
void *sub_40BF50();
// _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(_DWORD); weak
std::map_str_str *__thiscall std::map_str_str::map_str_str_2(std::map_str_str *this, _BYTE *a2, _BYTE *a3);
int __thiscall sub_40C050(void *this, int a2);
int __thiscall sub_40C080(int this, int a2);
std::_tree_str_str::iterator *__thiscall std::_tree_str_str::end(std::_tree_str_str *this, std::_tree_str_str::iterator *a2);
int __thiscall std::_tree_str_str::insert(std::_tree_str_str *this, int a2, struct Concurrency::IExecutionContext *a3); // idb
bool __stdcall sub_40C290(int a1, int a2);
_DWORD *__thiscall sub_40C2C0(void *this, _DWORD *a2, int a3, char a4);
// void __stdcall std::_tree_str_str::_Freenode(std::_tree_str_str *a2); idb
// std::_tree_str_str::iterator *__thiscall unknown_libname_32(std::_tree_str_str::iterator *this, std::_tree_str_str::_Node *a2); idb
int __thiscall sub_40C400(int *this);
BOOL __thiscall sub_40C420(void *this, _DWORD *a2);
// std::string *__thiscall unknown_libname_33(std::string *this);
std::_tree_str_str::_Node *__thiscall sub_40C460(std::_tree_str_str::_Node *this, _DWORD *a2, _BYTE *a3);
int __thiscall std::_tree_str_str::find(std::_tree_str_str *this, int a2, char *a3); // idb
bool __stdcall sub_40C530(char *a1, int a2);
// _DWORD *__thiscall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(_DWORD *this, int a2, unsigned int a3, unsigned int a4);
_DWORD *__thiscall sub_40C740(_DWORD *this, char *a2);
// int __cdecl unknown_libname_34(char *); idb
// _DWORD __stdcall sub_40C790(_DWORD); weak
// void __stdcall unknown_libname_35(LPVOID lpMem, int a2);
// struct Concurrency::details::InternalContextBase *__stdcall some_cast(struct Concurrency::IExecutionContext *a2);
// void __stdcall unknown_libname_36(LPVOID lpMem, int a2);
struct Concurrency::details::InternalContextBase *__cdecl getInternalContext(int a1);
// std::_tree_str_str::_Node **__cdecl std::_tree_str_str::_Left(std::_tree_str_str::_Node *a1);
std::_tree_str_str::_Node **__cdecl std::_tree_str_str::_Right(std::_tree_str_str::_Node *a1);
int __cdecl sub_40C840(int a1);
std::_tree_str_str *__thiscall std::_tree_str_str::_tree_str_str(std::_tree_str_str *this, _BYTE *a2, char a3, _BYTE *a4);
// int unknown_libname_38(void); weak
_DWORD *__thiscall sub_40C8B0(std::_tree *this, _DWORD *a2, int a3);
void *__thiscall sub_40D100(std::_tree *this, void *a2);
int __thiscall sub_40D180(void *this, int a2, int a3, int a4, struct Concurrency::IExecutionContext *a5);
std::_tree_str_str::_Node **__thiscall std::_tree_str_str::_Lmost(std::_tree_str_str *this); // idb
std::_tree_str_str::_Node **__thiscall std::_tree_str_str::_Rmost(std::_tree_str_str *this); // idb
int __thiscall sub_40D650(int this);
// std::string *__thiscall unknown_libname_39(std::string *this);
// std::_tree_str_str::iterator *__thiscall std::_tree_str_str::iterator::iterator(std::_tree_str_str::iterator *this, int a2);
// int __thiscall unknown_libname_41(void *this);
// void *__thiscall unknown_libname_42(void *this, int a2);
_DWORD *__thiscall sub_40D6D0(void *this, _DWORD *a2, int a3);
// int __thiscall unknown_libname_43(_DWORD); weak
BOOL __thiscall sub_40D720(void *this, _DWORD *a2);
BOOL __thiscall sub_40D740(void *this, _DWORD *a2);
int __thiscall sub_40D770(void *this, int a2, char *a3);
_DWORD *__thiscall sub_40D7A0(_DWORD *this, void *a2, size_t a3);
// int __thiscall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(int this, unsigned int a2, unsigned int a3);
void *__cdecl sub_40D8A0(void *a1, void *a2, size_t a3);
// int __thiscall unknown_libname_44(int this);
// int __thiscall unknown_libname_45(_DWORD); weak
// _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(_DWORD); weak
char __thiscall sub_40D950(_DWORD *this, unsigned int a2, char a3);
int __cdecl sub_40DA90(int a1);
int __cdecl sub_40DAA0(int a1);
std::_tree_str_str::_Node *__thiscall std::_tree_str_str::_Init(std::_tree_str_str *this); // idb
std::_tree_str_str::_Node **__thiscall sub_40DBB0(void *this, int a2);
int __cdecl sub_40DCE0(int a1);
int __cdecl sub_40DD20(int a1);
std::_tree_str_str::_Node **__thiscall sub_40DD60(void *this, int a2);
std::_tree_str_str::_Node *__stdcall std::_tree_str_str::_Buynode(std::_tree_str_str *a1, int a2);
void *__stdcall sub_40DEE0(void *a1, int a2);
void __stdcall sub_40DF00(void *a1);
std::_tree_str_str::_Node **__thiscall sub_40DF20(int *this);
// int __cdecl unknown_libname_46(_DWORD); weak
std::_tree_str_str::_Node *__thiscall sub_40E010(void *this, char *a2);
bool __stdcall readNextToken(int a1, char *a2);
// int std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void); weak
// _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(_DWORD); weak
_DWORD *__thiscall sub_40E280(int this);
char *__stdcall sub_40E2F0(size_t a1);
int __thiscall sub_40E310(int this);
std::_tree_str_str::_Node **__thiscall sub_40E330(int *this);
char sub_40E3F0();
int __cdecl sub_40E410(int *a1, int *a2);
void *__cdecl sub_40E440(void *a1, int a2);
void sub_40E4B0();
// void __cdecl __ExceptionPtrDestroy(void *); idb
void *__thiscall sub_40E4D0(void *this, int a2);
char *__thiscall sub_40E530(char *this, char a2);
void __cdecl CSocketInt::packet00_kickByUid(CSocketInt *this, char *command); // idb
char *__cdecl CSocketInt::subcommand(char *out, char *in); // idb
void __cdecl CSocketInt::packet02_getUserNumber(CSocketInt *this); // idb
void __cdecl CSocketInt::packet03_kickByAccNameFromAuthServer(CSocketInt *this, char *command); // idb
void __cdecl CSocketInt::packet04_changeGmMode(CSocketInt *this, char *command); // idb
void __cdecl CSocketInt::packet01_changeSocketLimit(CSocketInt *this, char *command); // idb
void CSocketInt::packet05_stub();
void __cdecl CSocketInt::packet06_changeGmIp(CSocketInt *this, char *command); // idb
void CSocketInt::packet07_stub();
void __cdecl CSocketInt::packet08_changeServerMode(CSocketInt *this, char *command); // idb
void __cdecl CSocketInt::packet09_getLoginFlag(CSocketInt *this, char *command); // idb
void __cdecl CSocketInt::packet10_checkUser(CSocketInt *this, char *command); // idb
UserInfoTable *__cdecl CSocketInt::packet11_kickUserFromWorldServer(CSocketInt *this, char *command);
CSocketInt *__thiscall CSocketInt::CSocketInt(CSocketInt *this, SOCKET socket);
MemoryObject *__thiscall CSocketInt::Dtor(CSocketInt *this);
CSocketInt *__cdecl CSocketInt::Create(SOCKET socket);
LogWindow *__thiscall CSocketInt::OnClose(CSocketInt *this); // idb
LONG __thiscall CSocketInt::OnRead(CSocketInt *this); // idb
int __thiscall CSocketInt::handleCommand(CSocketInt *this, char *command); // idb
char *__thiscall CSocketInt::addrToStr(CSocketInt *this); // idb
int __thiscall CSocketInt::OnCreate(CSocketInt *this); // idb
CSocketInt *__thiscall CSocketInt::setIPAddress(CSocketInt *this, int ipAddress); // idb
void CSocketInt::send(CSocketInt *this, char *format, ...); // idb
void __thiscall CSocketInt::sendString(CSocketInt *this, char *message, size_t size); // idb
int SomeStaticInit8();
int sub_40F59A();
int __thiscall UserManager::getUsersNumber(UserManager *this); // idb
CSocketInt *__thiscall CSocketInt::CallDtor(CSocketInt *this, char a2);
// void __cdecl operator_delete(LPVOID lpMem);
// void *__cdecl operator_new(size_t a1);
// int __thiscall std::vector::size(void *this);
char __cdecl WorldSrvSocket::packet00_playOk(WorldSrvSocket *this, char *buffer); // idb
char __cdecl WorldSrvSocket::packet01_playFail(WorldSrvSocket *this, char *buffer); // idb
char __cdecl WorldSrvSocket::packet02_userLoggedToGs(WorldSrvSocket *this, char *buffer); // idb
char __cdecl WorldSrvSocket::packet03_userQuitsWithError(WorldSrvSocket *this, char *buffer); // idb
char __cdecl WorldSrvSocket::packet04_userDropped(WorldSrvSocket *this, char *buffer); // idb
char __cdecl WorldSrvSocket::packet05_setUserLimit(WorldSrvSocket *this, char *buffer); // idb
char __cdecl WorldSrvSocket::packet06_stub(WorldSrvSocket *this, char *buffer); // idb
char __cdecl WorldSrvSocket::packet07_stub(WorldSrvSocket *this, char *buffer); // idb
char __cdecl WorldSrvSocket::packet08_pingAck(WorldSrvSocket *this, char *buffer); // idb
char __cdecl WorldSrvSocket::packet09_updateUserData(WorldSrvSocket *this, char *buffer); // idb
char __cdecl WorldSrvSocket::packet10_updateWorldStatus(WorldSrvSocket *this); // idb
char __cdecl WorldSrvSocket::packet11_gsReconnected(WorldSrvSocket *this, char *buffer); // idb
char __cdecl WorldSrvSocket::packet12_newCharCreated(WorldSrvSocket *this, char *buffer); // idb
char __cdecl WorldSrvSocket::packet13_charDeleted(WorldSrvSocket *this, char *buffer); // idb
char __cdecl WorldSrvSocket::packet14_charManipulation(WorldSrvSocket *this, char *buffer); // idb
char __cdecl WorldSrvSocket::packet21_moveCharToGS(WorldSrvSocket *this, char *buffer); // idb
char __cdecl WorldSrvSocket::packet15_serverSelected(WorldSrvSocket *this, char *buffer); // idb
char WorldSrvSocket::packet16_handler();
char __cdecl WorldSrvSocket::packet17_userDropped(WorldSrvSocket *this, char *buffer); // idb
char __cdecl WorldSrvSocket::packet18_updateGSStatus(WorldSrvSocket *this, char *buffer); // idb
char __cdecl WorldSrvSocket::packet19_updateUsersNumber(WorldSrvSocket *this, char *buffer); // idb
char __cdecl WorldSrvSocket::packet20_getServerList(WorldSrvSocket *this); // idb
signed int CAuthSocket::send(SOCKET socket, const char *format, ...);
WorldSrvSocket *__thiscall WorldSrvSocket::WorldSrvSocket(WorldSrvSocket *this, SOCKET socket); // idb
MemoryObject *__thiscall WorldSrvSocket::Destructor(WorldSrvSocket *this);
WorldSrvSocket *__cdecl WorldSrvSocket::Create(SOCKET socket);
void __thiscall WorldSrvSocket::OnClose(WorldSrvSocket *this); // idb
LONG __thiscall WorldSrvSocket::OnRead(WorldSrvSocket *this); // idb
char *__thiscall WorldSrvSocket::addrToStr(WorldSrvSocket *this); // idb
void __thiscall WorldSrvSocket::OnCreate(WorldSrvSocket *this); // idb
void __thiscall WorldSrvSocket::setIPAddress(WorldSrvSocket *this, in_addr ipAddress); // idb
void WorldSrvSocket::send(WorldSrvSocket *this, char *format, ...);
char __thiscall ThreadSafeMap::insert(ThreadSafeMap *this, int uid, char *accName); // idb
char __thiscall ThreadSafeMap::dumpKickedUsers(ThreadSafeMap *this, WorldSrvSocket *socket); // idb
int SomeStaticInit9();
int sub_41146D();
int __cdecl BufferReader::ReadInt(char **buffer); // idb
char __cdecl BufferReader::ReadByte(char **buffer); // idb
__int16 __cdecl BufferReader::ReadShort(char **buffer);
int __thiscall WorldSrvSocket::getWorldServerIp(WorldSrvSocket *this, _DWORD *a2);
int __cdecl BufferReader::ReadUInt(char **buffer);
char **__cdecl BufferReader::ReadString(char **buffer, signed int size, char *out); // idb
int __thiscall ServerList::getServerCount(ServerList *this); // idb
ThreadSafeMap *__thiscall ThreadSafeMap::ThreadSafeMap(ThreadSafeMap *this);
// void __thiscall std::map_uid_acc::destructor(std::map_uid_acc *this);
// void __thiscall unknown_libname_52(std::_tree *this);
WorldSrvSocket *__thiscall WorldSrvSocket::CallDtor(WorldSrvSocket *this, char a2);
void __thiscall ThreadSafeMap::Destructor(ThreadSafeMap *this);
LONG __thiscall CIOBuffer::AddRef(CIOBuffer *this); // idb
// int __thiscall unknown_libname_53(int this);
std::map_uid_acc *__thiscall sub_411710(std::map_uid_acc *this, _BYTE *a2, _BYTE *a3);
std::_tree_uid_acc::iterator *__thiscall std::map_uid_acc::begin(std::map_uid_acc *this, std::_tree_uid_acc::iterator *a2);
std::_tree_uid_acc::iterator *__thiscall std::map_uid_acc::end(std::map_uid_acc *this, std::_tree_uid_acc::iterator *a2); // idb
int __thiscall std::map_uid_acc::insert(std::map_uid_acc *this, int a2, struct Concurrency::IExecutionContext *a3); // idb
// _DWORD *__thiscall std::map_uid_acc::clear(std::map_uid_acc *this); idb
void __thiscall sub_4117D0(std::_tree *this);
// int __thiscall unknown_libname_55(int this, _DWORD *a2, int a3);
// std::_tree_uid_acc::iterator *__thiscall unknown_libname_56(std::_tree_uid_acc::iterator *this);
// int __thiscall std::_tree_uid_acc::iterator::value(std::_tree_uid_acc::iterator *this); idb
_DWORD *__thiscall std::_tree_uid_acc::iterator::post_increment(std::_tree_uid_acc::iterator *this, _DWORD *a2, int a3); // idb
BOOL __thiscall std::_tree_uid_acc::iterator::not_equal(void *this, _DWORD *a2);
std::map_uid_acc *__thiscall std::map_uid_acc::map_uid_acc(std::map_uid_acc *this, _BYTE *a2, _BYTE *a3);
std::_tree_uid_acc::iterator *__thiscall std::_tree_uid_acc1::begin(std::_tree_uid_acc1 *this, std::_tree_uid_acc::iterator *a2);
std::_tree_uid_acc::iterator *__thiscall std::_tree_uid_acc1::end(std::_tree_uid_acc1 *this, std::_tree_uid_acc::iterator *a2); // idb
int __thiscall std::_tree_uid_acc1::insert3(std::_tree_uid_acc1 *this, int a2, struct Concurrency::IExecutionContext *a3); // idb
_DWORD *__thiscall std::_tree_uid_acc1::erase(std::_tree_uid_acc1 *this, _DWORD *a2, int a3, char a4); // idb
_DWORD *__thiscall std::_tree_uid_acc1::clear(std::_tree_uid_acc1 *this); // idb
// void __stdcall std::_tree_uid_acc1::_Freenode(std::_tree_uid_acc::_Node *a2); idb
// std::_tree_uid_acc::iterator *__thiscall unknown_libname_58(std::_tree_uid_acc::iterator *this);
void **__thiscall sub_411D10(std::_tree_uid_acc::iterator *this);
// std::_tree_uid_acc::iterator *__thiscall unknown_libname_59(std::_tree_uid_acc::iterator *this);
BOOL __thiscall std::_tree_uid_acc::iterator::iterator_operator_eq(void *this, _DWORD *a2);
int __thiscall sub_411D70(int this, _DWORD *a2, _BYTE *a3);
// struct Concurrency::details::InternalContextBase *__stdcall std::_tree_uid_acc1::_Kfn(struct Concurrency::IExecutionContext *a2);
struct Concurrency::details::InternalContextBase *__cdecl std::_tree_uid_acc1::_Key(int a1);
// std::_tree_uid_acc::_Node *__cdecl std::_tree_uid_acc::_Left(std::_tree_uid_acc::_Node *a1);
std::_tree_uid_acc::_Node *__cdecl std::_tree_uid_acc::_Right(std::_tree_uid_acc::_Node *a1);
void **__cdecl sub_411DF0(std::_tree_uid_acc::_Node *a1);
std::_tree_uid_acc1 *__thiscall std::_tree_uid_acc1::_tree_uid_acc1(std::_tree_uid_acc1 *this, _BYTE *a2, char a3, _BYTE *a4);
// int __thiscall std::_tree_uid_acc1::size(int this);
_DWORD *__thiscall std::_tree_uid_acc1::erase2(std::_tree *this, _DWORD *a2, int a3);
void *__thiscall sub_4126B0(std::_tree *this, void *a2);
int __thiscall std::_tree_uid_acc1::_Insert(void *this, int a2, int a3, int a4, struct Concurrency::IExecutionContext *a5);
std::_tree_uid_acc::_Node *__thiscall std::_tree_uid_acc1::_Lmost(std::_tree_uid_acc1 *this); // idb
std::_tree_uid_acc::_Node *__thiscall std::_tree_uid_acc1::_Rmost(std::_tree_uid_acc1 *this); // idb
std::_tree_uid_acc::_Node *__thiscall std::_tree_uid_acc1::_Root_const(std::_tree_uid_acc1 *this);
std::_tree_uid_acc::_Node *__thiscall std::_tree_uid_acc::iterator::_Inc(std::_tree_uid_acc::iterator *this); // idb
// int __thiscall unknown_libname_62(_DWORD); weak
// std::_tree_uid_acc::iterator *__thiscall std::_tree_uid_acc::iterator::iterator(std::_tree_uid_acc::iterator *this, std::_tree_uid_acc::_Node *a2); idb
// int __thiscall unknown_libname_64(_DWORD); weak
// int __cdecl _tolower(int);
std::_tree_uid_acc::_Node *__cdecl std::_tree_uid_acc1::_Parent(std::_tree_uid_acc1 *a1);
std::_tree_uid_acc::_Node *__thiscall std::_tree_uid_acc1::_Init(std::_tree_uid_acc1 *this);
std::_tree_uid_acc::_Node *__thiscall sub_412E30(void *this, int a2);
int __cdecl sub_412F60(int a1);
int __cdecl sub_412FA0(int a1);
std::_tree_uid_acc::_Node *__thiscall sub_412FE0(void *this, int a2);
std::_tree_uid_acc::_Node *__stdcall std::_tree_uid_acc1::_Buynode(std::_tree_uid_acc::_Node *a1, int a2);
void *__stdcall sub_413160(void *a1, int a2);
void __stdcall sub_413180(void *a1);
// _DWORD __stdcall unknown_libname_65(_DWORD); weak
std::_tree_uid_acc::_Node *__thiscall sub_4131C0(int *this);
int __cdecl sub_413290(int *a1, int *a2);
void *__cdecl sub_4132C0(void *a1, int a2);
// void __cdecl __ExceptionPtrDestroy(void *); idb
// _DWORD __stdcall unknown_libname_66(_DWORD); weak
void *__thiscall sub_413370(void *this, char a2);
int StaticInit_Database();
Database *CallStaticCtorForDatabase();
int RegisterStatic_destructorForDatabase();
void __cdecl CallDatabaseDestructor(); // idb
Database *__thiscall Database::Database(Database *this); // idb
MemoryObject *__thiscall Database::Destructor(Database *this);
Database *__thiscall Database::init(Database *this, int dbConnectionNumber);
char __thiscall Database::showDBConnectDialog(Database *this, char reconnect);
Database *__thiscall Database::initConnections(Database *this);
int __thiscall Database::clearConnections(Database *this); // idb
char __thiscall Database::loadConnectionString(Database *this); // idb
LSTATUS __thiscall Database::storeConnectionString(Database *this); // idb
LONG __thiscall Database::OnTimerCallback(Database *this); // idb
int __thiscall SqlQuery::SqlQuery(SqlQuery *this, Database *dbManager);
void __thiscall SqlQuery::Destructor(SqlQuery *this); // idb
BOOL __stdcall Database::dialogFunc(HWND hDlg, UINT msgType, WPARAM wparam, LPARAM lparam); // idb
char SqlQuery::exec(SqlQuery *this, char *format, ...); // idb
char sub_4141A6(SqlQuery *a1, char *a2, ...);
char unused_sub_41423B(SqlQuery *this, char *format, ...); // idb
char unused_sub_4142C7(SQLHSTMT *a1, char *a2, ...);
char SqlQuery::sub_41435C(SqlQuery *a1, char *a2, ...);
char __thiscall SqlQuery::fetch(SqlQuery *this, bool *notFound); // idb
char __thiscall SqlQuery::sub_414463(SqlQuery *this, char a2);
void __thiscall SqlQuery::printError(SqlQuery *this, SQLSMALLINT handlerType, SQLHANDLE handler, char *sqlQuery); // idb
int __stdcall SqlQuery::printError2(SQLSMALLINT handlerType, SQLHANDLE handler, char *sqlQuery);
SQLRETURN __thiscall SqlQuery::bindByte(SqlQuery *this, SQLPOINTER value); // idb
SQLRETURN __thiscall SqlQuery::bindBool(SqlQuery *this, SQLPOINTER value); // idb
SQLRETURN __thiscall SqlQuery::bindStr(SqlQuery *this, SQLPOINTER value, SQLINTEGER length); // idb
SQLRETURN __thiscall SqlQuery::bindUInt(SqlQuery *this, SQLPOINTER value); // idb
SQLRETURN __thiscall SqlQuery::bindInt(SqlQuery *this, SQLPOINTER value); // idb
SQLRETURN __thiscall SqlQuery::bindShort(SqlQuery *this, SQLPOINTER TargetValue); // idb
SQLRETURN __thiscall SqlQuery::bindSmthng(SqlQuery *this, SQLPOINTER rgbValue, SQLSMALLINT fParamType); // idb
SQLRETURN __thiscall SqlQuery::sub_4148EE(SqlQuery *this, SQLPOINTER rgbValue, SQLSMALLINT fParamType); // idb
SQLRETURN __thiscall SqlQuery::sub_41493C(SqlQuery *this, SQLPOINTER rgbValue, SQLUINTEGER cbColDef, SQLSMALLINT fParamType); // idb
SQLRETURN __thiscall SqlQuery::sub_414991(SqlQuery *this, SQLPOINTER rgbValue, SQLSMALLINT fParamType); // idb
SQLRETURN __thiscall SqlQuery::sub_4149DF(SqlQuery *this, SQLPOINTER rgbValue, SQLSMALLINT fParamType); // idb
SQLRETURN __thiscall SqlQuery::sub_414A2D(SqlQuery *this, SQLPOINTER rgbValue, SQLSMALLINT fParamType); // idb
SQLRETURN __thiscall SqlQuery::reset(SqlQuery *this); // idb
int SomeStaticInit11();
int sub_414AC3();
void Database::OnWaitCallback();
void __stdcall Database::OnIOCallback(Database *this, int a2, int a3); // idb
Database *__thiscall Database::DestructorCall(Database *this, char a2);
char *__cdecl DesFrontEnd::encodeData(char *data, int size); // idb
char *__cdecl DesFrontEnd::processData(char *data, int size, int encrypt);
_BYTE *__cdecl DesFrontEnd::encryptBlock(_BYTE *a1, _BYTE *a2);
_BYTE *__cdecl Des::decrypt_encrypt(char *a1, DesInner *a2, _BYTE *a3); // idb
_BYTE *__cdecl Des::Ffunc(int index, char *a2, _BYTE *a3);
_BYTE *__cdecl Des::Ffunc_inner(int a1, int a2, int a3);
_BYTE *__cdecl Des::sub_4150DF(_BYTE *a1, int a2);
int __cdecl Des::sub_415201(int a1, int a2);
unsigned __int8 *__cdecl Des::sub_4153A3(unsigned __int8 *a1, unsigned __int8 *a2); // idb
_BYTE *__cdecl DesFrontEnd::decryptBlock(char *a1, char *a2); // idb
char *__cdecl DesFrontEnd::decodeData(char *data, int size);
int __cdecl DesFrontEnd::initDesKey(const char *stringKey); // idb
void Des::init_Sfunc();
int __cdecl Des::init_getFrom_S_Table(int row, int collumn); // idb
int __cdecl Des::init_sub_4157F0(char *desKey); // idb
int Des::init_sub_415984();
int __cdecl Des::init_sub_415AD1(DesItem *a1, const unsigned __int8 *constants); // idb
int Static_ExceptionHandler();
ExceptionHandler *CallExceptionHandler_Ctor();
int RegisterExceptionHandlerDestructor();
void __cdecl CallExceptionHandlerDestructor(); // idb
int __cdecl CoreDump::writeModule_Raw(LPCVOID pcOffset, LPSTR lpFilename, DWORD nSize, int *numberOfSections, int *a5); // idb
BOOL __cdecl CoreDump::writeCallStackWithSymbols(HANDLE hFile, CONTEXT *contextRecord); // idb
BOOL CoreDump::writeLine(HANDLE hFile, const char *format, ...); // idb
char *__cdecl Utils::getFileName(char *str); // idb
char *__cdecl CoreDump::writeCallStackWithoutSymbols(HANDLE hFile, CONTEXT *contextRecord);
LONG __stdcall ExceptionHandler::TopLevelExceptionFilter(struct _EXCEPTION_POINTERS *exceptionInfo); // idb
MyBool __cdecl ExceptionHandler::sendMail(char *ipAddress, char *mailFrom, char *mailTo, LPCSTR errorLogPath);
char __cdecl ExceptionHandler::sendFile(SOCKET socket, LPCSTR lpFileName); // idb
void __cdecl CoreDump::createReport(_EXCEPTION_POINTERS *ex); // idb
unsigned int __cdecl CoreDump::writeModules(HANDLE hFile);
_IMAGE_DOS_HEADER *__cdecl CoreDump::writeModuleInfo(HANDLE hFile_1, HMODULE hModule);
int __cdecl CoreDump::getFileTime(char *out, FILETIME fileTime); // idb
int __cdecl CoreDump::writeExtraInfo(HANDLE hFile); // idb
char *__cdecl CoreDump::exceptionToString(int exceptionCode); // idb
LONG *__cdecl ExceptionHandler::installTopLevelFilter();
LPTOP_LEVEL_EXCEPTION_FILTER ExceptionHandler::restoreTopLevelFilter();
ExceptionHandler *__thiscall ExceptionHandler::ExceptionHandler(ExceptionHandler *this);
void ExceptionHandler::Destructor();
void ExceptionHandler::logException(char *format, ...);
MACRO_EXCEPTION __cdecl ExceptionHandler::exceptionFilter(_EXCEPTION_POINTERS *ex); // idb
void __cdecl ExceptionHandler::sendExceptionLog(char fatal); // idb
void ExceptionHandler::sendLastCrashReport();
void ExceptionHandler::intentionalException();
int SomeStaticInit13();
int sub_417C7F();
void *__cdecl ExceptionHandler::enterCritSection();
void ExceptionHandler::leaveCritSection();
void __cdecl ExceptionHandler::initCritSection();
void ExceptionHandler::deleteCritSection();
CIOBuffer *__thiscall CIOBuffer::CIOBuffer(CIOBuffer *this);
CIOBuffer *__thiscall CIOBuffer::Destructor(CIOBuffer *this);
int Static_InitCallCIOBufferPool::g_slotDestructor();
int CallCIOBufferPool::g_slotConstructor();
int RegisterlCIOBufferPool::g_slotDestructor();
void __cdecl CallCIOBufferPool::g_slotDestructor(); // idb
int StaticInitIOBufferPool();
void CallIOBufferPoolCtor();
int RegisterIOBufferPoolDestructor();
void __cdecl CallIOBufferPoolDestructor(); // idb
CIOBuffer *CIOBuffer::Alloc();
void __thiscall CIOBuffer::Free(CIOBuffer *this); // idb
void CIOBuffer::FreeAll();
int SomeStaticInit16();
int sub_417FB4();
void *__thiscall CallCIOBufferDestructor(void *this, char a2);
// void __thiscall CIOBufferSlot::Destructor(CIOBufferSlot *this); idb
CIOBufferSlot *__thiscall CIOBufferSlot::CIOBufferSlot(CIOBufferSlot *this);
void IOBufferPool::Destructor();
MemoryObject *__thiscall MemoryObject::MemoryObject(MemoryObject *this);
MemoryObject *__thiscall MemoryObject::Destructor(MemoryObject *this);
int __thiscall MemoryObject::AddRef(MemoryObject *this);
LONG __thiscall MemoryObject::Release(MemoryObject *this); // idb
BOOL __thiscall CPacket::PostObject(WorldSrvPacket *this, DWORD id, HANDLE completionPort); // idb
signed int __thiscall MemoryObject::AddTimer(MemoryObject *this, unsigned int dwTime, int id); // idb
bool __thiscall MemoryObject::RegisterWait(MemoryObject *this, HANDLE eventObject);
void __stdcall MemoryObject::OnIOCallback_empty(MemoryObject *this, int a2, int a3); // idb
LONG __thiscall MemoryObject::OnTimerCallback(MemoryObject *this); // idb
void __cdecl MemoryObject::OnWaitCallback(MemoryObject *this);
int SomeStaticInit17();
int sub_4181B7();
MemoryObject *__thiscall MemoryObject::DeletingDestructor(MemoryObject *this, char a2);
int StaticInit_WorldSrvServer();
WorldSrvServer *CallStaticCtorForWorldSrvServer();
int RegisterStatic_destructorForWorldSrvServer();
void __cdecl CallStaticDestructorForWorldSrvServer(); // idb
int StaticInit_CAuthServer();
CAuthServer *CallStaticCtorFor_CAuthServer();
int RegisterStaticDtor_CAuthServer();
void __cdecl CallStaticDtorFor_CAuthServer(); // idb
int StaticInit_CIOServerInt();
CIOServerInt *CallStaticCtorForCIOServerInt();
int RegisterStatic_destructorForCIOServerInt();
void __cdecl CIOServerInt::static_destructor(); // idb
CIOServer *__thiscall CIOServer::CIOServer(CIOServer *this); // idb
MemoryObject *__thiscall CIOServer::Destructor(CIOServer *this);
CIOServer *__thiscall CIOServer::Close(CIOServer *this);
MyBool __thiscall CIOServer::Create(CIOServer *this, int port);
LogWindow *__thiscall CIOServer::OnIOCallback(CIOServer *this); // idb
BOOL __thiscall CIOServer::OnWaitCallback(CIOServer *this); // idb
WorldSrvServer *__thiscall WorldSrvServer::WorldSrvServer(WorldSrvServer *this);
WorldSrvServer *__thiscall WorldSrvServer::Destructor(WorldSrvServer *this);
WorldSrvSocket *__thiscall WorldSrvServer::CreateSocket(WorldSrvServer *this, SOCKET socket, sockaddr_in *address); // idb
WorldSrvServer *__thiscall WorldSrvServer::Create(WorldSrvServer *this, int port, WorldSrvSocket *(__cdecl *factoryMethod)(SOCKET), char a4);
WorldSrvSocket *__thiscall WorldSrvServer::getSocket(WorldSrvServer *this, int ipAddress);
char __thiscall WorldSrvServer::socketExists(WorldSrvServer *this, int ipAddress); // idb
void __thiscall WorldSrvServer::removeServer(WorldSrvServer *this, int ipAddress); // idb
CIOServerInt *__thiscall CIOServerInt::CIOServerInt(CIOServerInt *this); // idb
MemoryObject *__thiscall CIOServerInt::Destructor(CIOServerInt *this);
LogWindow *__thiscall CIOServerInt::OnIOCallback(CIOServerInt *this, int a2, int a3, int a4); // idb
CSocketInt *__thiscall CIOServerInt::CreateSocket(CIOServerInt *this, SOCKET socket, sockaddr_in *clientAddress); // idb
int __thiscall CIOServerInt::Create(CIOServerInt *this, int port, MemoryObject *(__cdecl *factoryMethod)(int));
int StaticInitFor_LSOverlappedPool::g_overlapped();
int LSOverlappedPool::g_overlapped_construction();
int LSOverlappedPool::Call_g_overlapped_destruction();
void __cdecl LSOverlappedPool::g_overlapped_destruction(); // idb
int StaticInit_ForLSOverlappedPool();
void CallLSOverlappedPoolStaticCtor();
int RegitsterLSOverlappedPoolDestructor();
void __cdecl CallLSOverlappedPoolDestructor(); // idb
AuthOverlapped *__cdecl LSOverlapped::Alloc();
void __cdecl LSOverlapped::Free(AuthOverlapped *this); // idb
int LSOverlapped::FreeAll();
CAuthServer *__thiscall CAuthServer::CAuthServer(CAuthServer *this); // idb
MemoryObject *__thiscall CAuthServer::Destructor(CAuthServer *this);
void __thiscall CAuthServer::OnIOCallback(CAuthServer *this, int success, DWORD dwTransferred, AuthOverlapped *lpOverlapped);
bool __thiscall CAuthServer::initListenSocket(CAuthServer *this);
DWORD __stdcall CAuthServer::initListenSocketJob(LPVOID lpThreadParameter); // idb
LogWindow *__thiscall CAuthServer::OnWaitCallback(CAuthServer *this); // idb
CAuthServer *__thiscall CAuthServer::stop(CAuthServer *this);
CAuthServer *__thiscall CAuthServer::close(CAuthServer *this);
CAuthServer *__thiscall CAuthServer::Create(CAuthServer *this, int hostshort, CAuthSocket *(__cdecl *authSocketFactory)(SOCKET));
CAuthSocket *__thiscall CAuthServer::CreateSocket(CAuthServer *this, SOCKET socket, sockaddr_in *addr); // idb
CAuthSocket *__thiscall CAuthServer::getIOSocket(CAuthServer *this, SOCKET socket);
char __thiscall CAuthServer::removeSocket(CAuthServer *this, SOCKET socket); // idb
int SomeStaticInit23();
int sub_4195F6();
CIOServer *__thiscall CIOServer::DeletingDestructor(CIOServer *this, char a2);
WorldSrvServer *__thiscall WorldSrvServer::DeletingDestructor(WorldSrvServer *this, char a2);
// void __thiscall std::map_ip_sock::destructor(std::map_ip_sock *this); idb
// void __thiscall unknown_libname_73(std::_tree_ip_sock *this); idb
CIOServerInt *__thiscall CIOServerInt::DestructorCall(CIOServerInt *this, char a2);
void __thiscall OverlappedSlot::Destructor(OverlappedSlot *this); // idb
CAuthServer *__thiscall CAuthServer::DeletingDestructor(CAuthServer *this, char a2);
// void __thiscall unknown_libname_75(void *this);
// void __thiscall unknown_libname_76(std::_tree *this);
std::map_ip_sock *__thiscall std::map_ip_sock::map_ip_sock(std::map_ip_sock *this, _BYTE *a2, _BYTE *a3);
std::_tree_ip_sock::iterator *__thiscall std::map_ip_sock::end(void *this, int a2);
// size_t __thiscall std::map_ip_sock::size(std::map_ip_sock *this);
int __thiscall std::map_ip_sock::insert(std::map_ip_sock *this, int a2, struct Concurrency::IExecutionContext *a3); // idb
_DWORD *__thiscall std::map_ip_sock::erase(std::map_ip_sock *this, _DWORD *a2, std::_tree_ip_sock::iterator *a3); // idb
_DWORD *__thiscall std::map_ip_sock::find(void *this, _DWORD *a2, _DWORD *a3);
void __thiscall sub_419850(std::_tree_ip_sock *this); // idb
std::pair_ip_socket *__thiscall std::pair_ip_socket::pair_ip_socket(std::pair_ip_socket *this, int *a2, CIOSocket **a3); // idb
// std::pair_ip_socket *__thiscall std::_tree_ip_sock::iterator::value(std::_tree_ip_sock::iterator *this);
BOOL __thiscall std::_tree_ip_sock::iterator::not_equal(std::_tree_ip_sock::iterator *this, std::_tree_ip_sock::iterator *a2); // idb
std::map_sock_sock *__thiscall std::map_sock_sock::map_sock_sock(std::map_sock_sock *this, _BYTE *a2, _BYTE *a3);
std::_tree_sock_sock::iterator *__thiscall std::map_sock_sock::end(std::map_sock_sock *this, std::_tree_sock_sock::iterator *a2);
int __thiscall std::map_sock_sock::insert(std::map_sock_sock *this, int a2, std::pair_Socket *a3); // idb
// int __thiscall std::map_sock_sock::erase(std::map_sock_sock *this, _DWORD *a2); idb
_DWORD *__thiscall std::map_sock_sock::find(std::map_sock_sock *this, _DWORD *a2, _DWORD *a3); // idb
void __thiscall sub_419A40(std::_tree *this);
std::pair_Socket *__thiscall std::pair_Socket::pair_Socket(std::pair_Socket *this, SOCKET *a2, CAuthSocket **a3); // idb
// std::pair_Socket *__thiscall std::_tree_sock_sock::iterator::value(std::_tree_sock_sock::iterator *this);
BOOL __thiscall std::_tree_sock_sock::iterator::iterator_operator_not_eq(std::_tree_sock_sock::iterator *this, std::_tree_sock_sock::iterator *a2); // idb
std::map_ip_sock *__thiscall std::map_ip_sock::map_ip_sock2(std::map_ip_sock *this, _BYTE *a2, _BYTE *a3);
int __thiscall sub_419BA0(void *this, int a2);
int __thiscall sub_419BD0(int this, int a2);
// size_t __thiscall unknown_libname_81(std::_tree_ip_sock *this);
int __thiscall sub_419C10(void *this, int a2, struct Concurrency::IExecutionContext *a3);
_DWORD *__thiscall sub_419DE0(std::_tree_ip_sock *this, _DWORD *a2, int a3); // idb
_DWORD *__thiscall sub_41A630(void *this, _DWORD *a2, int a3, char a4);
_DWORD *__thiscall sub_41A730(void *this, _DWORD *a2, _DWORD *a3);
// void __thiscall Concurrency::details::_NonReentrantPPLLock::_Acquire(std::_tree *this, void *); idb
void **__thiscall sub_41A7F0(std::_tree_ip_sock::iterator *this);
BOOL __thiscall sub_41A810(void *this, _DWORD *a2);
std::map_sock_sock *__thiscall std::map_sock_sock::map_sock_sock2(std::map_sock_sock *this, _BYTE *a2, _BYTE *a3); // idb
std::_tree_sock_sock::iterator *__thiscall std::_tree_sock_sock::begin(void *this, int a2);
std::_tree_sock_sock::iterator *__thiscall std::_tree_sock_sock::end(std::_tree_sock_sock *this, std::_tree_sock_sock::iterator *a2);
int __thiscall std::_tree_sock_sock::insert3(std::_tree_sock_sock *this, int a2, std::pair_Socket *a3); // idb
_DWORD *__thiscall std::_tree_sock_sock::erase(std::_tree_sock_sock *this, _DWORD *a2, std::_tree_sock_sock::iterator *a3, char a4); // idb
int __thiscall std::_tree_sock_sock::erase3(std::_tree_sock_sock *this, _DWORD *a2); // idb
_DWORD *__thiscall std::_tree_sock_sock::find(std::_tree_sock_sock *this, _DWORD *a2, _DWORD *a3); // idb
// void __stdcall std::_tree_sock_sock::_Freenode(std::_tree_sock_sock *a2); idb
void **__thiscall std::_tree_sock_sock::iterator::_Mynode(std::_tree_sock_sock::iterator *this);
BOOL __thiscall std::_tree_sock_sock::iterator::iterator_operator_eq(void *this, _DWORD *a2);
int __thiscall sub_41ACE0(int this, _DWORD *a2, _BYTE *a3);
int __thiscall std::pair::pair_iterator_bool_2(int this, _DWORD *a2, _BYTE *a3);
OverlappedSlot *__thiscall OverlappedSlot::OverlappedSlot(OverlappedSlot *this);
int __thiscall LSOverlappedPool::Destructor(void *this);
// struct Concurrency::details::InternalContextBase *__thiscall Concurrency::details::VirtualProcessor::ToInternalContext(Concurrency::details::VirtualProcessor *this, struct Concurrency::IExecutionContext *); idb
BOOL __stdcall sub_41AD90(_DWORD *a1, _DWORD *a2);
int __cdecl sub_41ADD0(int a1);
struct Concurrency::details::InternalContextBase *__cdecl sub_41ADE0(int a1);
// _DWORD __cdecl unknown_libname_83(_DWORD); weak
int __cdecl sub_41AE10(int a1);
int __cdecl sub_41AE20(int a1);
void **__cdecl sub_41AE30(std::_tree_ip_sock::_Node *a1);
std::_tree_ip_sock *__thiscall std::_tree_ip_sock::_tree_ip_sock(std::_tree_ip_sock *this, _BYTE *a2, char a3, _BYTE *a4);
int __thiscall sub_41AE80(void *this, int a2, _DWORD *a3);
void *__thiscall sub_41AEB0(std::_tree *this, void *a2);
int __thiscall sub_41AF30(void *this, int a2, int a3, int a4, struct Concurrency::IExecutionContext *a5);
int __thiscall sub_41B3C0(int this);
int *__thiscall sub_41B3E0(void *this, int a2);
int __cdecl sub_41B510(int a1);
int __cdecl sub_41B550(int a1);
int __thiscall sub_41B590(int this);
int __thiscall sub_41B5B0(int this);
int *__thiscall sub_41B5D0(void *this, int a2);
void __stdcall sub_41B700(int a1);
// int __thiscall unknown_libname_84(void *this);
// void *__thiscall unknown_libname_85(void *this, int a2);
_DWORD *__thiscall sub_41B750(void *this, _DWORD *a2, int a3);
// int *__thiscall unknown_libname_86(int *this);
// struct Concurrency::details::InternalContextBase *__stdcall std::_tree_sock_sock::_Kfn(struct Concurrency::IExecutionContext *a2);
BOOL __stdcall std::_tree_sock_sock::key_compare(_DWORD *a1, _DWORD *a2);
// void __stdcall unknown_libname_87(LPVOID lpMem, int a2);
struct Concurrency::details::InternalContextBase *__cdecl std::_tree_sock_sock::_Key(int a1);
// std::_tree_sock_sock::_Node *__cdecl std::_tree_sock_sock::_Left(std::_tree_sock_sock::_Node *a1);
std::_tree_sock_sock::_Node *__cdecl std::_tree_sock_sock::_Right(std::_tree_sock_sock::_Node *a1);
void **__cdecl std::_tree_sock_sock::_Node::_Value2(std::_tree_sock_sock::_Node *a1);
std::_tree_sock_sock *__thiscall std::_tree_sock_sock::_tree_sock_sock(std::_tree_sock_sock *this, _BYTE *a2, char a3, _BYTE *a4);
// int __thiscall std::_tree_sock_sock::size(int this);
_DWORD *__thiscall std::_tree_sock_sock::erase2(std::_tree_sock_sock *this, _DWORD *a2, int a3); // idb
int __thiscall std::_tree_sock_sock::lower_bound(void *this, int a2, _DWORD *a3);
int __thiscall std::_tree_sock_sock::equal_range(std::_tree_sock_sock *this, int a2, _DWORD *a3); // idb
void *__thiscall sub_41C160(std::_tree *this, void *a2);
int __thiscall std::_tree_sock_sock::_Insert(void *this, int a2, int a3, int a4, struct Concurrency::IExecutionContext *a5);
std::_tree_sock_sock::_Node *__thiscall std::_tree_sock_sock::_Lmost(std::_tree_sock_sock *this); // idb
std::_tree_sock_sock::_Node *__thiscall std::_tree_sock_sock::_Rmost(std::_tree_sock_sock *this);
std::_tree_sock_sock::_Node *__thiscall std::_tree_sock_sock::_Root_const(std::_tree_sock_sock *this);
// int __thiscall unknown_libname_90(_DWORD); weak
// std::_tree_sock_sock::iterator *__thiscall std::_tree_sock_sock::iterator::iterator(std::_tree_sock_sock::iterator *this, std::_tree_sock_sock::_Node *a2); idb
_DWORD *__thiscall std::_tree_sock_sock::iterator::post_increment(void *this, _DWORD *a2, int a3);
// int *__thiscall unknown_libname_92(int *this);
std::_tree_ip_sock::_Node *__thiscall std::_tree_ip_sock::_Init(std::_tree_ip_sock *this);
int __thiscall sub_41C850(void *this, _DWORD *a2);
char *__stdcall sub_41C8E0(int a1, int a2);
_DWORD *__stdcall sub_41C930(void *a1, int a2);
// void *__thiscall unknown_libname_93(void *this, int a2);
int *__thiscall sub_41C970(int *this);
// int __cdecl unknown_libname_94(_DWORD); weak
int __cdecl sub_41CA60(int a1);
int __cdecl sub_41CA70(int a1);
int __thiscall std::_tree_sock_sock::upper_bound(void *this, int a2, _DWORD *a3);
std::_tree_sock_sock::_Node *__thiscall std::_tree_sock_sock::_Init(std::_tree_sock_sock *this); // idb
std::_tree_sock_sock::_Node *__thiscall sub_41CBB0(void *this, _DWORD *a2);
std::_tree_sock_sock::_Node **__thiscall sub_41CC40(void *this, int a2);
int __cdecl sub_41CD70(int a1);
int __cdecl sub_41CDB0(int a1);
std::_tree_sock_sock::_Node **__thiscall sub_41CDF0(void *this, int a2);
std::_tree_sock_sock::_Node *__stdcall std::_tree_sock_sock::_Buynode(std::_tree_sock_sock::_Node *a1, std::_tree_sock_sock::_Node *a2);
_DWORD *__stdcall sub_41CF70(void *a1, int a2);
void __stdcall sub_41CF90(int a1);
// void *__thiscall unknown_libname_95(void *this, int a2);
std::_tree_sock_sock::_Node *__thiscall sub_41CFD0(int *this);
// int __cdecl unknown_libname_96(_DWORD); weak
int __thiscall sub_41D0C0(int this, _DWORD *a2, _DWORD *a3);
char *__stdcall sub_41D0F0(size_t a1);
int __thiscall sub_41D110(int this);
_DWORD *__thiscall sub_41D130(int *this);
char *__stdcall sub_41D1D0(size_t a1);
int __thiscall sub_41D1F0(int this);
std::_tree_sock_sock::_Node *__thiscall sub_41D210(void *this, _DWORD *a2);
std::_tree_sock_sock::_Node *__thiscall sub_41D2A0(int *this);
int __cdecl sub_41D340(int *a1, int *a2);
int __cdecl std::_tree_sock_sock::_Distance(char a1, char a2, _DWORD *a3);
void sub_41D3A0();
int __cdecl sub_41D3B0(int *a1, int *a2);
_DWORD *__cdecl sub_41D3E0(void *a1, int a2);
_DWORD *__cdecl sub_41D420(void *a1, int a2);
void sub_41D460();
_BYTE *__cdecl sub_41D470(_BYTE *a1);
int __cdecl sub_41D490(char a1, char a2, _DWORD *a3);
CIOSocket *__thiscall CIOSocket::CIOSocket(CIOSocket *this, SOCKET socket); // idb
MemoryObject *__thiscall CIOSocket::Destructor(CIOSocket *this);
void CIOSocket::OnClose();
LONG __thiscall CIOSocket::Close(CIOSocket *this); // idb
int __thiscall CIOSocket::Initialize(CIOSocket *this, HANDLE ExistingCompletionPort); // idb
int __thiscall CIOSocket::OnCreate(CIOSocket *this); // idb
LONG __thiscall CIOSocket::OnIOCallback(CIOSocket *this, int bSuccess, int dwTransferred, LPOVERLAPPED lpOverlapped); // idb
LogWindow *__thiscall CIOSocket::ReadCallback(CIOSocket *this, int dwTransferred);
void __thiscall CIOSocket::WriteCallback(CIOSocket *this, int dwTransferred); // idb
LONG __thiscall CIOSocket::Read(CIOSocket *this, size_t dwLeft); // idb
void __thiscall CIOSocket::Write(CIOSocket *this, CIOBuffer *buff); // idb
int StaticVectorInit_For_CPacketPool::CSlot();
int VectorInitializationFor_CPacketPool::CSlot();
int RegisterCPacketPool_CSlotDtor();
void __cdecl CallVectorDtorFor_CPacketPool::CSlot(); // idb
int StaticRegisterCPacketPool();
void callEmptyCtor();
int RegisterCPacketPoolDtor();
void __cdecl CalDtorCPacketPool(); // idb
WorldSrvPacket *WorldSrvPacket::Alloc();
void __thiscall WorldSrvPacket::Free(WorldSrvPacket *this); // idb
void WorldSrvPacket::FreeAll();
void __thiscall WorldSrvPacket::OnIOCallback(WorldSrvPacket *this, int bSuccess, int dwTransferred, int LPOVERLAPPED); // idb
int SomeStaticInit26();
int sub_41E052();
CIOSocket *__thiscall CallCIOSocketDestructor(CIOSocket *this, char a2);
WorldSrvPacketSlot *__thiscall WorldSrvPacketSlot::WorldSrvPacketSlot(WorldSrvPacketSlot *this);
void __thiscall WorldSrvPacketSlot::Destructor(WorldSrvPacketSlot *this); // idb
void WorldSrvPacketPool::Destructor();
WorldSrvPacket *__thiscall WorldSrvPacket::WorldSrvPacket(WorldSrvPacket *this);
WorldSrvPacket *__thiscall WorldSrvPacket::CallDestructor(WorldSrvPacket *this, char a2);
MemoryObject *__thiscall WorldSrvPacket::Destructor(WorldSrvPacket *this);
void __thiscall CIOBuffer::Release(CIOBuffer *this); // idb
int StaticInit_ForIpRegistry();
IpRegistry *CallIpRegistryCtor();
int IpRegistry_RegisterDestructor();
void __cdecl IpRegistry_CallDestructor(); // idb
IPList *__thiscall IPList::IPList(IPList *this); // idb
IpRegistry *__thiscall IpRegistry::IpRegistry(IpRegistry *this); // idb
int __thiscall IpRegistry::Destructor(IpRegistry *this); // idb
unsigned int __stdcall IpRegistry::hash(int ipAddress); // idb
char __thiscall IpRegistry::insert(IpRegistry *this, int ipAddress); // idb
char __thiscall IpRegistry::remove(IpRegistry *this, int ipAddress); // idb
int SomeStaticInit_ForIPList();
IPList *StaticCallIPListConstructor();
int RegisterIPListDestructor();
void __cdecl StaticCallIPListDestructor(); // idb
int StaticInit_IPList_2();
IPList *StaticCall_IPList_2_Constructor();
int Register_IPList_2_Destructor();
void __cdecl StaticCall_IPList_2_Destructor(); // idb
signed int __thiscall IPList::load(IPList *this, char *fileName); // idb
BOOL __thiscall IPList::contains(IPList *this, unsigned int ipAddress);
int sub_41EDA3();
int sub_41EDB5();
void *__thiscall sub_41EDD0(void *this, char a2);
#1023 *__thiscall sub_41EE00(#1023 *this);
// void __thiscall unknown_libname_101(void *); idb
// void __thiscall unknown_libname_102(std::_tree *this);
std::vector_IPRange *__thiscall IPList::Destructor(IPList *this);
// int __thiscall std::istrstream::`vbase destructor(int this);
int __fastcall std::basic_istream::getline(int a1, int a2, _BYTE *a3, int a4);
#1023 *__thiscall sub_41EF20(#1023 *this, _BYTE *a2, _BYTE *a3);
std::_tree_int_int::iterator *__thiscall std::map_ip::end(std::map_int_int *this, std::_tree_int_int::iterator *a2);
int __thiscall std::map_ip::insert(std::map_int_int *this, int a2, std::pair_int_int *a3); // idb
_DWORD *__thiscall std::map_ip::erase(std::map_int_int *this, _DWORD *a2, int a3); // idb
std::_tree_int_int::iterator *__thiscall std::map_ip::find(std::map_int_int *this, _DWORD *a2, _DWORD *a3);
void __thiscall sub_41EFE0(std::_tree *this);
std::pair_int_int *__thiscall std::pair_unt_int(std::pair_int_int *this, _DWORD *a2, _DWORD *a3);
// int __thiscall std::_tree_uint_int::iterator::iterator(_DWORD); weak
// std::pair_int_int *__thiscall std::map_ip::iterator::value(std::_tree_int_int::iterator *this);
BOOL __thiscall std::map_ip::iterator::not_equal(void *this, _DWORD *a2);
std::vector_IPRange *__thiscall std::vector_IPRange::vector_IPRange(std::vector_IPRange *this, _BYTE *a2);
std::vector_IPRange *__thiscall std::vector_IPRange::Destructor(std::vector_IPRange *this);
// std::vector_IPRange::iterator *__thiscall std::vector_IPRange::begin(std::vector_IPRange *this);
// std::vector_IPRange::iterator *__thiscall std::vector_IPRange::end(std::vector_IPRange *this);
std::vector_IPRange::iterator *__thiscall std::vector_IPRange::insert(std::vector_IPRange *this, std::vector_IPRange::iterator *a2, IPRange *value); // idb
std::vector_IPRange::iterator *__thiscall std::vector_IPRange::erase(std::vector_IPRange *this, std::vector_IPRange::iterator *a3); // idb
std::vector_IPRange::iterator *__thiscall std::vector_IPRange::clear(std::vector_IPRange *this); // idb
int __thiscall sub_41F2F0(int this, char *a2, int a3, int a4);
// _DWORD __thiscall std::istrstream::~istrstream(std::istrstream *__hidden this); idb
int __thiscall sub_41F440(__int32 this);
int __thiscall sub_41F8C0(void *this);
void *__thiscall sub_41FCF0(void *this, char a2);
void *__thiscall sub_41FD20(void *this, char a2);
int sub_41FD50();
// int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(size_t, int); idb
// _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(_DWORD, _DWORD); weak
int __thiscall sub_41FEC0(_DWORD *this);
int __thiscall sub_41FEE0(_DWORD *this);
// _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(_DWORD); weak
int __stdcall Myios::widen(char a1);
int __fastcall sub_4200F0(int a1, int a2, _BYTE *a3, int a4, char a5);
// int __thiscall unknown_libname_110(_DWORD); weak
char *__fastcall Myis::sentry(char *a1, int a2, int a3, char a4);
char __thiscall sub_420340(void *this);
// int __thiscall std::basic_streambuf<char,std::char_traits<char>>::sgetc(_DWORD); weak
int __thiscall sub_4203B0(void *this);
char __fastcall sub_420410(int a1, int a2, char a3);
char *__thiscall sub_420620(char *this);
// _DWORD __stdcall std::ctype<char>::is(__int16, _DWORD); weak
// int __thiscall sub_4206C0(_DWORD); weak
// int __thiscall std::basic_streambuf<char,std::char_traits<char>>::sbumpc(_DWORD); weak
// int __thiscall std::basic_streambuf<wchar_t,std::char_traits<wchar_t>>::eback(_DWORD); weak
// _DWORD __stdcall std::ctype<char>::do_widen(char); weak
// int __thiscall std::basic_streambuf<char,std::char_traits<char>>::_Gndec(_DWORD); weak
void *__thiscall sub_4207F0(void *this, _BYTE *a2, _BYTE *a3);
int __thiscall sub_420820(void *this, int a2);
std::_tree_int_int::iterator *__thiscall sub_420850(std::_tree_int_int *this, std::_tree_int_int::iterator *a2);
int __thiscall sub_420870(void *this, int a2, struct Concurrency::IExecutionContext *a3);
BOOL __thiscall sub_420A40(void *this);
// BOOL __thiscall std::ios_base::fail(std::ios_base *this);
_DWORD *__thiscall sub_420A80(std::_tree *this, _DWORD *a2, int a3);
// int __thiscall unknown_libname_111(_DWORD); weak
// int __stdcall std::ios_base::getloc(_DWORD); weak
// _DWORD __thiscall std::locale::locale(std::locale *this, const struct std::locale *); idb
_DWORD *__thiscall sub_421360(void *this, _DWORD *a2, int a3, char a4);
_DWORD *__thiscall sub_421460(void *this, _DWORD *a2, _DWORD *a3);
// void __thiscall Concurrency::details::_NonReentrantPPLLock::_Acquire(std::_tree *this, void *); idb
int __thiscall sub_421530(int *this);
BOOL __thiscall sub_421550(void *this, _DWORD *a2);
std::vector_IPRange *__thiscall std::vector_IPRange::insert_2(std::vector_IPRange *this, std::vector_IPRange::iterator *a2, unsigned int a3, IPRange *a4); // idb
std::vector_IPRange::iterator *__thiscall std::vector_IPRange::erase_3(std::vector_IPRange *this, std::vector_IPRange::iterator *a2, std::vector_IPRange::iterator *a3); // idb
std::vector_IPRange::iterator *__stdcall std::vector_IPRange::Destroy(std::vector_IPRange::iterator *a1, std::vector_IPRange::iterator *a2); // idb
// void __stdcall std::vector_IPRange::allocator_deallocate(void *a1, int a2);
int __thiscall sub_421830(int this, _DWORD *a2, _BYTE *a3);
void *__thiscall sub_421860(void *this, int a2);
void *__thiscall sub_4218D0(int this, char *a2, int a3);
// int __thiscall std::basic_filebuf<char,std::char_traits<char>>::close(_DWORD); weak
_BYTE *__thiscall sub_421A20(int this);
// _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(_DWORD, _DWORD); weak
// _DWORD __cdecl std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Psum(_DWORD, _DWORD); weak
// _DWORD __stdcall sub_421C10(_DWORD); weak
_BYTE *__thiscall sub_421C30(int this);
// int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *); idb
// int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *, size_t); idb
// int __thiscall unknown_libname_116(_DWORD); weak
int __thiscall sub_421D60(void *this);
// struct Concurrency::details::InternalContextBase *__thiscall Concurrency::details::VirtualProcessor::ToInternalContext(Concurrency::details::VirtualProcessor *this, struct Concurrency::IExecutionContext *); idb
// _DWORD __stdcall unknown_libname_117(LPVOID lpMem, _DWORD); weak
int __cdecl sub_421DE0(int a1);
struct Concurrency::details::InternalContextBase *__cdecl sub_421DF0(int a1);
// _DWORD __cdecl unknown_libname_118(_DWORD); weak
int __cdecl sub_421E50(int a1);
int __cdecl sub_421E60(int a1);
int __cdecl sub_421E70(int a1);
int __thiscall sub_421E80(int this, _BYTE *a2, char a3, _BYTE *a4);
// int unknown_libname_121(void); weak
int __thiscall sub_421F30(void *this, int a2, _DWORD *a3);
void *__thiscall sub_421F60(std::_tree *this, void *a2);
int __thiscall sub_421FE0(void *this, int a2, int a3, int a4, struct Concurrency::IExecutionContext *a5);
int __thiscall sub_422470(int this);
int *__thiscall sub_422490(void *this, int a2);
int __cdecl sub_4225C0(int a1);
int __cdecl sub_422600(int a1);
int __thiscall sub_422640(int this);
int __thiscall sub_422660(int this);
int *__thiscall sub_422680(void *this, int a2);
void __stdcall sub_4227B0(int a1);
// int __thiscall unknown_libname_122(_DWORD); weak
// void *__thiscall unknown_libname_123(void *this, int a2);
_DWORD *__thiscall sub_422800(void *this, _DWORD *a2, int a3);
// int __thiscall unknown_libname_124(_DWORD); weak
int __thiscall std::vector_IPRange::size(std::vector_IPRange *this); // idb
void *__stdcall sub_422890(int a1, int a2, void *a3);
int __stdcall sub_4228D0(void *, int, int); // idb
void *__stdcall sub_422910(int a1, int a2);
void __stdcall some_stub(int a1);
// _DWORD __stdcall std::basic_filebuf<char,std::char_traits<char>>::_Init(_DWORD, _DWORD); weak
void *__thiscall sub_422A30(void *this);
// _DWORD __stdcall std::locale::operator=(_DWORD); weak
// int __thiscall sub_422BD0(_DWORD); weak
void *__thiscall sub_422BF0(void *this, _BYTE *a2);
std::locale *__thiscall sub_422DA0(int this, std::locale *a2);
std::_tree::_Node **__thiscall sub_422E30(std::_tree *this);
int __thiscall sub_422F30(void *this, _DWORD *a2);
char *__stdcall sub_422FC0(int a1, int a2);
_DWORD *__stdcall sub_423010(void *a1, int a2);
// void *__thiscall unknown_libname_126(void *this, int a2);
int *__thiscall sub_423050(int *this);
// int __cdecl unknown_libname_127(_DWORD); weak
_DWORD *__stdcall sub_423140(void *a1, int a2);
char *__stdcall sub_423160(int a1, int a2);
char *__stdcall sub_423180(size_t a1);
int __thiscall sub_4231A0(int this);
_DWORD *__thiscall sub_4231C0(int *this);
// int __cdecl std::use_facet(std::locale *, int, int); idb
_DWORD *__thiscall sub_423380(_DWORD *this, char a2);
void __thiscall sub_4233B0(void *this);
void __thiscall __noreturn sub_4233D0(void *this);
void *__thiscall sub_423400(void *this, char a2);
// _DWORD *__thiscall unknown_libname_128(_DWORD *this, int a2);
// int __thiscall std::locale::id::operator unsigned int(_DWORD); weak
// void *__thiscall std::ctype<char>::ctype<char>(void *this, int a2, unsigned __int8 a3, unsigned int a4);
// _DWORD __stdcall unknown_libname_129(unsigned int); weak
// std::locale::facet *__thiscall std::locale::facet::facet(std::locale::facet *this, unsigned int a2);
void *__thiscall sub_423600(void *this, char a2);
void *__thiscall sub_423630(void *this);
void *__thiscall sub_423650(void *this, char a2);
// int __thiscall unknown_libname_130(_DWORD); weak
// int __stdcall std::ctype<char>::_Init(std::_Locinfo *); idb
void __cdecl sub_423790(); // idb
void *__thiscall sub_423890(void *this, char a2);
int __thiscall sub_4238C0(int this);
std::vector_IPRange::iterator *__cdecl std::algorithm::lower_bound(std::vector_IPRange::iterator *_First, std::vector_IPRange::iterator *_Last, unsigned int *_Val); // idb
std::vector_IPRange::iterator *__cdecl sub_423930(std::vector_IPRange::iterator *a1, std::vector_IPRange::iterator *a2, std::vector_IPRange::iterator *a3); // idb
int __cdecl sub_4239F0(int *a1, int *a2);
int __cdecl sub_423A20(int a1, int a2, int a3);
int __cdecl sub_423A50(int a1, int a2, int a3);
void sub_423A90();
void *__cdecl sub_423AA0(int a1);
void some_empty();
const struct std::locale::facet *__cdecl sub_423AE0(std::locale *a1, int a2, int a3);
std::locale *__cdecl sub_423C00(std::locale *a1, char a2, int a3);
_DWORD *__cdecl sub_423C90(void *a1, int a2);
_DWORD *__cdecl sub_423CD0(void *a1, int a2);
// char *__cdecl std::_Allocate(int, char *); idb
_DWORD *__thiscall sub_423D30(_DWORD *this, unsigned int a2);
// _DWORD __stdcall unknown_libname_131(unsigned int); weak
void *__thiscall sub_423E20(void *this, char a2);
// int __cdecl unknown_libname_135(_DWORD); weak
void *__thiscall sub_423F00(void *this, char a2);
int __thiscall sub_423F30(void *this);
// struct Concurrency::details::_CancellationTokenState *__cdecl Concurrency::details::_CancellationTokenState::_None(); idb
std::locale::facet *__cdecl sub_423F60(std::locale::facet *a1);
std::locale::facet *__cdecl sub_423FD0(std::locale::facet *a1);
_DWORD *__thiscall sub_424040(_DWORD *this, int a2);
int __stdcall sub_424070(int a1);
void __cdecl sub_4240A0(); // idb
void __cdecl sub_424130(); // idb
int sub_4241C0();
std::vector_IPRange::iterator *__cdecl std::algorithm::_Lower_bound(std::vector_IPRange::iterator *_First, std::vector_IPRange::iterator *_Last, unsigned int *_Val); // idb
BOOL __cdecl IPList::IPRange::operator_less(int ipAddress, IPRange *this_); // idb
int sub_424290();
void __cdecl sub_4242C0(); // idb
_DWORD *__cdecl std::algorithm::_Distance(std::vector_IPRange::iterator *a1, std::vector_IPRange::iterator *a2, _DWORD *a3); // idb
u_long __cdecl std::algorithm::advance(std::vector_IPRange::iterator *a1, int a2);
_BYTE *__cdecl sub_424330(_BYTE *a1);
_DWORD *__cdecl sub_424350(std::vector_IPRange::iterator *a1, std::vector_IPRange::iterator *a2, _DWORD *a3); // idb
// u_long __cdecl unknown_libname_137(std::vector_IPRange::iterator *a1, int a2);
int SaticInit_FroIPSocket_ReadWriteLock();
ReadWriteLock *CallReadWriteLockCtor();
int RegisterReadWriteLockDtor();
void __cdecl CallReadWriteLockDtor(); // idb
int StaticInit_IPSessionDB();
IPSessionDB *CallStaticCtorForIPSessionDB();
int RegisterDtorForIPSessionDB();
void __cdecl CallStaticDestructorForIPSessionDB(); // idb
void __stdcall IPSocket::onTimeout(PVOID, BOOLEAN); // idb
int IPPacketPool::g_slot_statis_init();
int IPPacketPool::g_slot_construction();
int IPPacketPool::Call_g_slot_destruction();
void __cdecl IPPacketPool::g_slot_destruction(); // idb
int StaticInitForIPPacketPool();
void StaticCallFor_IPPacketPoolCtor();
int Register_StaticCallFor_IPPacketPoolDestructor();
void __cdecl StaticCallFor_IPPacketPoolDestructor(); // idb
IPPacket *__cdecl IPPacket::Alloc();
void IPPacket::FreeAll();
void __thiscall IPPacket::Free(IPPacket *this); // idb
void __thiscall IPPacket::OnIOCallback(IPPacket *this, BOOL bSuccess, DWORD dwTransferred, LPOVERLAPPED lpOverlapped);
IPSessionDB *__thiscall IPSessionDB::IPSessionDB(IPSessionDB *this); // idb
int __thiscall IPSessionDB::Destructor(IPSessionDB *this); // idb
char __thiscall IPSessionDB::takeWaitingAcc(IPSessionDB *this, int uid, UserInfo **account); // idb
char __thiscall IPSessionDB::addAccInfo(IPSessionDB *this, int uid, UserInfo *accInfo);
int __thiscall IPSessionDB::getSessionKey(IPSessionDB *this, int uid); // idb
int __thiscall IPSessionDB::takeSessionKey(IPSessionDB *this, int uid);
char __thiscall IPSessionDB::clearWaitinAccs(IPSessionDB *this); // idb
int __thiscall IPSessionDB::registerSessionKey(IPSessionDB *this, int uid, int sessionKey); // idb
char __thiscall IPSessionDB::registerWaitingAcc(IPSessionDB *this, UserInfo *accInfo, int uid); // idb
char __thiscall IPSessionDB::sendPayStats(IPSessionDB *this, int sessionKey, int clientIP, int payStat);
char __thiscall IPSessionDB::handleAuthLogin(IPSessionDB *this, int uid, int sessionKey, bool defaultResut, int totalTime, int payStat); // idb
char __thiscall IPSessionDB::continueLogIn(IPSessionDB *this, int uid, int a3, char status); // idb
bool __cdecl IPSocket::packet_dummy_handler(CIOSocket *this, unsigned __int8 *buffer);
char __cdecl IPSocket::packet4_handler(IPSocket *this, unsigned __int8 *buffer); // idb
char __cdecl IPSocket::packet3_handler(IPSocket *this, unsigned __int8 *buffer); // idb
char __cdecl IPSocket::packet2_handler(IPSocket *this, unsigned __int8 *buffer);
char __cdecl IPSocket::packet5_handler(IPSocket *this, unsigned __int8 *buffer); // idb
char __cdecl IPSocket::packet0_handler(IPSocket *this, unsigned __int8 *buffer); // idb
char __cdecl IPSocket::packet9_handler(IPSocket *this, unsigned __int8 *buffer); // idb
char __cdecl IPSocket::packet11_handler(IPSocket *this, unsigned __int8 *buffer); // idb
char __cdecl IPSocket::packet10_handler(IPSocket *this, unsigned __int8 *buffer); // idb
char __cdecl IPSocket::packet13_handler(IPSocket *this, unsigned __int8 *buffer); // idb
char __cdecl IPSocket::packet15_handler(IPSocket *this, unsigned __int8 *buffer); // idb
char __cdecl IPSocket::packet14_handler(IPSocket *this, unsigned __int8 *buffer); // idb
IPSocket *__cdecl IPSocket::Create(SOCKET socket); // idb
IPSocket *__thiscall IPSocket::IPSocket(IPSocket *this, SOCKET socket); // idb
MemoryObject *__fastcall IPSocket::Destructor(IPSocket *this); // idb
BOOL __thiscall IPSocket::OnClose(IPSocket *this); // idb
void IPSocket::OnTimerCallback();
char *__thiscall IPSocket::addrToStr(IPSocket *this); // idb
char __thiscall IPSocket::OnCreate(IPSocket *this); // idb
LONG __thiscall IPSocket::OnRead(IPSocket *this); // idb
char IPSocket::send(IPSocket *this, char *format, ...);
char __thiscall IPSessionDB::unused(IPSessionDB *this, int uid, int a2, int a3, char a4);
char __thiscall IPSessionDB::sendSomethingToIPSocket(IPSessionDB *this, int uid, int connectedIp, int payStatus, int a5, int loginTime, char serverId, char *accName); // idb
char __thiscall IPSessionDB::sendServerLoginRequested(IPSessionDB *this, int uid, int ipAddress, int payStat, char serverId); // idb
char __thiscall IPSessionDB::sendUserLoggedIn(IPSessionDB *this, int uid, int connectedIP, int payStat, char serverId); // idb
int SomeStaticInit41();
int sub_4268E7();
IPSlot *__thiscall IPSlot::IPSlot(IPSlot *this);
// void __thiscall IPSlot::Destructor(IPSlot *this); idb
void IPPacketPool::Destructor();
IPPacket *__thiscall IPPacket::IPPacket(IPPacket *this);
IPPacket *__thiscall IPPacket::DeletingDestructor(IPPacket *this, char a2);
MemoryObject *__thiscall IPPacket::Destructor(IPPacket *this); // idb
IPSessionDB *__thiscall IPSessionDB::DestructorCall(IPSessionDB *this, char a2);
// int __thiscall std::map_int_int::Destructor(void *this);
// void __thiscall std::map_int_sockid::Destructor(std::map_int_acc *this); idb
// int __cdecl unknown_libname_143(_DWORD); weak
// void __thiscall unknown_libname_144(std::_tree *this);
IPSocket *__thiscall IPSocket::DeletingDestructor(IPSocket *this, char a2);
std::map_int_int *__thiscall std::map_int_int::map_int_int(std::map_int_int *this, _BYTE *a2, _BYTE *a3);
std::_tree_int_int::iterator *__thiscall std::map_int_int::end(std::map_int_int *this, std::_tree_int_int::iterator *a2);
std::pair_bool_int *__thiscall std::map_int_int::insert(std::map_int_int *this, std::pair_bool_int *res, std::pair_int_int *a3); // idb
_DWORD *__thiscall std::map_int_int::erase(std::map_int_int *this, _DWORD *a2, std::_tree_int_int::iterator *_P); // idb
_DWORD *__thiscall std::map_int_int::find(std::map_int_int *this, _DWORD *a2, _DWORD *a3); // idb
void __thiscall sub_426B70(std::_tree *this);
std::pair_int_int *__thiscall std::pair_int_int::pair_int_int(std::pair_int_int *this, _DWORD *a2, _DWORD *a3);
// std::pair_int_int *__thiscall std::_tree_int_int::iterator::value(std::_tree_int_int::iterator *this);
BOOL __thiscall std::_tree_int_int::iterator::not_eq(std::_tree_int_int::iterator *this, std::_tree_int_int::iterator *a2); // idb
std::map_int_acc *__thiscall std::map_int_sockid::map_int_sockid(std::map_int_acc *this, _BYTE *a2, _BYTE *a3);
std::_tree_int_acc::iterator *__thiscall std::map_int_acc::begin(std::map_int_acc *this, std::_tree_int_acc::iterator *a2);
std::_tree_int_acc::iterator *__thiscall std::map_int_acc::end(std::map_int_acc *this, std::_tree_int_acc::iterator *a2);
std::pair_bool_acc *__thiscall std::map_int_acc::insert(std::map_int_acc *this, std::pair_bool_acc *a2, std::pair_int_acc *pair);
_DWORD *__thiscall std::map_int_acc::erase(std::map_int_acc *this, _DWORD *a2, std::_tree_int_acc::iterator *a3); // idb
std::_tree_int_acc::iterator *__thiscall std::map_int_acc::find(std::map_int_acc *this, _DWORD *a2, _DWORD *a3);
void __thiscall sub_426D80(std::_tree *this);
std::pair_int_acc *__thiscall std::pair_int_acc::pair_int_acc(std::pair_int_acc *this, _DWORD *a2, UserInfo **a3); // idb
// std::_tree_int_acc::iterator *__thiscall std::_tree_int_acc::iterator::iterator2(std::_tree_int_acc::iterator *this);
// std::pair_int_acc *__thiscall std::_tree_int_acc::iterator::value(std::_tree_int_acc::iterator *this);
BOOL __thiscall std::map_int_acc::iterator::not_eq(std::_tree_int_acc::iterator *this, std::_tree_int_acc::iterator *a2); // idb
std::map_int_int *__thiscall std::map_int_int::map_int_int_2(std::map_int_int *this, _BYTE *a2, _BYTE *a3);
int __thiscall sub_426F00(void *this, int a2);
std::_tree_int_int::iterator *__thiscall std::_tree_int_int::end(std::_tree_int_int *this, std::_tree_int_int::iterator *a2);
int __thiscall std::_tree_int_int::insert(std::_tree_int_int *this, int a2, struct Concurrency::IExecutionContext *a3); // idb
_DWORD *__thiscall std::_tree_int_int::erase2(std::_tree_int_int *this, _DWORD *a2, std::_tree_int_int::iterator *_P); // idb
_DWORD *__thiscall sub_427970(void *this, _DWORD *a2, int a3, char a4);
_DWORD *__thiscall std::_tree_int_int::find(std::_tree_int_int *this, _DWORD *a2, _DWORD *a3); // idb
// void __stdcall std::_tree_int_int::_Freenode(std::_tree_int_int::_Node *a2); idb
void **__thiscall std::_tree_int_int::iterator::_Mynode(std::_tree_int_int::iterator *this); // idb
BOOL __thiscall std::_tree_int_int::iterator_operator_eq(std::_tree_int_int::iterator *this, std::_tree_int_int::iterator *a2); // idb
std::map_int_acc *__thiscall std::map_int_sockid::map_int_sockid2(std::map_int_acc *this, _BYTE *a2, _BYTE *a3);
std::_tree_int_acc::iterator *__thiscall std::_tree_int_acc::begin(std::_tree_int_acc *this, std::_tree_int_acc::iterator *a2);
std::_tree_int_acc::iterator *__thiscall std::_tree_int_acc::end(std::_tree_int_acc *this, std::_tree_int_acc::iterator *a2);
int __thiscall sub_427BF0(void *this, int a2, struct Concurrency::IExecutionContext *a3);
_DWORD *__thiscall std::_tree_int_sockid::erase2(std::_tree_int_acc *this, _DWORD *a2, std::_tree_int_acc::iterator *_P); // idb
IPSocket *__thiscall IPSocket::setIPAddress(IPSocket *this, int ipAddress); // idb
IPSocket *__thiscall IPSocket::set_field_2(IPSocket *this, int a2);
_DWORD *__thiscall sub_428650(void *this, _DWORD *a2, int a3, char a4);
_DWORD *__thiscall std::_tree_int_sockid::find(std::_tree_int_acc *this, _DWORD *a2, _DWORD *a3); // idb
// void __stdcall std::_tree_int_sockid::_Freenode(#548 *a2); idb
// std::_tree_int_acc::iterator *__thiscall unknown_libname_148(std::_tree_int_acc::iterator *this);
std::pair_int_acc **__thiscall std::_tree_int_sockid::iterator::_Mynode(std::_tree_int_acc::iterator *this);
BOOL __thiscall std::map_int_acc::iterator::operator_eq(std::_tree_int_acc::iterator *this, std::_tree_int_acc::iterator *a2); // idb
int __thiscall sub_428860(int this, _DWORD *a2, _BYTE *a3);
std::map_int_int *__thiscall sub_428890(std::map_int_int *this, _DWORD *a2, _BYTE *a3);
// struct Concurrency::details::InternalContextBase *__thiscall Concurrency::details::VirtualProcessor::ToInternalContext(Concurrency::details::VirtualProcessor *this, struct Concurrency::IExecutionContext *); idb
int __cdecl std::_tree_int_int::_Color(std::_tree_int_int::_Node *a1);
struct Concurrency::details::InternalContextBase *__cdecl std::_tree_int_int::_Key(int a1);
// std::_tree_int_int::_Node **__cdecl std::_tree_int_int::_Left(std::_tree_int_int::_Node *a1);
std::_tree_int_int::_Node **__cdecl std::_tree_int_int::_Parent(std::_tree_int_int::_Node *a1);
std::_tree_int_int::_Node **__cdecl std::_tree_int_int::_Right(std::_tree_int_int::_Node *a1);
void **__cdecl std::_tree_int_int::Node::_Value2(std::_tree_int_int::_Node *a1); // idb
std::_tree_int_int *__thiscall std::_tree_int_int::_tree_int_int(std::_tree_int_int *this, _BYTE *a2, char a3, _BYTE *a4);
// int unknown_libname_150(void); weak
std::_tree_int_int::iterator *__thiscall std::_tree_int_int::lower_bound(std::_tree_int_int *this, std::_tree_int_int::iterator *a2, _DWORD *a3);
void *__thiscall sub_4289D0(std::_tree *this, void *a2);
int __thiscall sub_428A50(void *this, int a2, int a3, int a4, struct Concurrency::IExecutionContext *a5);
std::_tree_int_int::_Node **__thiscall std::_tree_int_int::_Lmost(std::_tree_int_int *this); // idb
std::_tree_int_int::_Node **__thiscall sub_428F00(void *this, int a2);
int __cdecl sub_429030(int a1);
std::_tree_int_int::_Node *__cdecl std::_tree_int_int::_Min(std::_tree_int_int::_Node *a1);
std::_tree_int_int::_Node **__thiscall std::_tree_int_int::_Rmost(std::_tree_int_int *this); // idb
std::_tree_int_int::_Node **__thiscall std::_tree_int_int::_Root(std::_tree_int_int *this); // idb
std::_tree_int_int::_Node **__thiscall sub_4290F0(void *this, int a2);
void __stdcall sub_429220(int a1);
// std::_tree_int_int::_Node *__thiscall std::_tree_int_int::iterator::_Mynode2(std::_tree_int_int::iterator *this);
// std::_tree_int_int::iterator *__thiscall std::_tree_int_int::iterator::iterator(std::_tree_int_int::iterator *this, std::_tree_int_int::_Node *a2); idb
std::_tree_int_int::iterator *__thiscall std::_tree_int_int::iterator::post_increment(std::_tree_int_int::iterator *this, _DWORD *a2, int a3);
// int __thiscall unknown_libname_153(_DWORD); weak
// struct Concurrency::details::InternalContextBase *__thiscall Concurrency::details::VirtualProcessor::ToInternalContext(Concurrency::details::VirtualProcessor *this, struct Concurrency::IExecutionContext *); idb
// _DWORD __stdcall unknown_libname_154(LPVOID lpMem, _DWORD); weak
int __cdecl sub_4292F0(int a1);
struct Concurrency::details::InternalContextBase *__cdecl std::_tree_int_sockid::_Key(int a1);
// #548 **__cdecl std::_tree_int_sockid::_Left(#548 *a1);
int __cdecl std::_tree_int_sockid::_Parent(int a1);
#548 **__cdecl std::_tree_int_sockid::_Right(#548 *a1);
std::pair_int_acc **__cdecl std::_tree_int_sockid::_Node::Valu2(#548 *a1);
std::_tree_int_acc *__thiscall std::_tree_int_sockid::_tree_int_sockid(std::_tree_int_acc *this, _BYTE *a2, char a3, _BYTE *a4);
// int unknown_libname_156(void); weak
std::_tree_int_acc::iterator *__thiscall std::_tree_int_sockid::lower_bound(std::_tree_int_acc *this, std::_tree_int_acc::iterator *a2, _DWORD *a3);
void *__thiscall sub_4293F0(std::_tree *this, void *a2);
int __thiscall sub_429470(void *this, int a2, int a3, int a4, struct Concurrency::IExecutionContext *a5);
#548 **__thiscall std::_tree_int_acc::_Lmost(std::_tree_int_acc *this); // idb
#548 **__thiscall sub_429920(void *this, int a2);
int __cdecl sub_429A50(int a1);
int __cdecl std::_tree_int_sockid::_Min(int a1);
#548 **__thiscall std::_tree_int_sockid::_Rmost(std::_tree_int_acc *this); // idb
int __thiscall std::_tree_int_sockid::_Root(int this);
#548 **__thiscall sub_429B10(void *this, int a2);
void __stdcall sub_429C40(int a1);
// #548 *__thiscall std::_tree_int_sockid::iterator::_Mynode2(std::_tree_int_acc::iterator *this);
// std::_tree_int_acc::iterator *__thiscall std::_tree_int_acc::iterator::iterator(std::_tree_int_acc::iterator *this, #548 *a2); idb
_DWORD *__thiscall std::_tree_int_sockid::iterator::post_increment(void *this, _DWORD *a2, int a3);
// int __thiscall unknown_libname_159(_DWORD); weak
std::_tree_int_int::_Node **__thiscall std::_tree_int_int::_Init(std::_tree_int_int *this); // idb
std::_tree_int_int::_Node *__thiscall std::_tree_int_int::_Lbound(std::_tree_int_int *this, _DWORD *a2);
std::_tree_int_int::_Node *__stdcall std::_tree_int_int::_Buynode(std::_tree_int_int::_Node *a1, int a2);
_DWORD *__stdcall sub_429EC0(void *a1, int a2);
// std::_tree_int_int::iterator *__thiscall unknown_libname_160(std::_tree_int_int::iterator *this, std::_tree_int_int::_Node *a2); idb
std::_tree_int_int::_Node **__thiscall sub_429F00(int *this);
// int *__thiscall unknown_libname_161(int *this);
#548 **__thiscall std::_tree_int_sockid::_Init(std::_tree_int_acc *this);
#548 *__thiscall std::_tree_int_sockid::_Lbound(std::_tree_int_acc *this, _DWORD *a2); // idb
#548 *__stdcall std::_tree_int_sockid::_Buynode(#548 *a1, int a2);
_DWORD *__stdcall sub_42A1D0(void *a1, int a2);
// _DWORD __stdcall unknown_libname_162(_DWORD); weak
#548 **__thiscall sub_42A210(int *this);
// int __cdecl unknown_libname_163(_DWORD); weak
std::_tree_int_int::_Node **__thiscall sub_42A300(int this);
std::_tree_int_int::_Node **__thiscall sub_42A320(int *this);
char *__stdcall sub_42A3C0(size_t a1);
int __thiscall sub_42A3E0(int this);
#548 **__thiscall sub_42A400(int *this);
int __cdecl sub_42A4A0(int *a1, int *a2);
int __cdecl sub_42A4D0(int *a1, int *a2);
void sub_42A500();
void sub_42A510();
_DWORD *__cdecl sub_42A520(void *a1, int a2);
_DWORD *__cdecl sub_42A560(void *a1, int a2);
int StaticInit_TimerQueue();
TimerQueue *CallStaticCtorForTimerQueue();
int RegisterStatic_destructorForTimerQueue();
void __cdecl CallTimerQueueDestructor(); // idb
void __thiscall TimerQueue::TimerDispatch(TimerQueue *this);
std::vector_MemoryObject::iterator *__thiscall TimerQueue::execWaitLoop(TimerQueue *this);
int __thiscall TimerQueue::AddTimer(TimerQueue *this, MemoryObject *timerInstance, unsigned int delay, int id); // idb
signed int __thiscall TimerQueue::RegisterWait(TimerQueue *this, HANDLE event, MemoryObject *client);
TimerQueue *__thiscall TimerQueue::TimerQueue(TimerQueue *this); // idb
void __thiscall TimerQueue::Destructor(TimerQueue *this); // idb
BOOL __thiscall TimerQueue::terminate(TimerQueue *this);
int __thiscall CIOTimerInstance::OnTimerCallback(CIOTimerInstance *this);
int SomeStaticInit43();
int sub_42AC37();
// int __thiscall std::vector_HANDLE::Destructor(std::vector_HANDLE *this); idb
// std::vector_MemoryObject *__thiscall std::vector_DNameNode::Destructor(std::vector_MemoryObject *this); idb
// std::vector_CIOTimer *__thiscall std::priority_queue::Destructor(std::priority_queue *this);
// std::vector_CIOTimer *__thiscall std::priority_queue::Destructor_2(std::priority_queue *this); idb
// std::vector_CIOTimer *__thiscall std::vector_CIOTimer::Destructor_2(std::vector_CIOTimer *this); idb
std::vector_CIOTimer *__thiscall std::vector_CIOTimer::Destructor(std::vector_CIOTimer *this);
// std::vector_HANDLE *__thiscall std::vector_HANDLE::vector_HANDLE(std::vector_HANDLE *this, _BYTE *a2);
std::vector_HANDLE *__thiscall std::vector_HANDLE::Destructor_2(std::vector_HANDLE *this);
// std::vector_HANDLE::iterator *__thiscall std::vector_HANDLE::begin(std::vector_HANDLE *this);
size_t __thiscall std::vector_HANDLE::size(std::vector_HANDLE *this);
int __thiscall std::vector_HANDLE::push_back(std::vector_HANDLE *this, HANDLE event);
// std::vector_MemoryObject *__thiscall std::vector_DNameNode::vector_DNameNode(std::vector_MemoryObject *this, _BYTE *a2);
std::vector_MemoryObject *__thiscall std::vector_DNameNode::Destructor_2(std::vector_MemoryObject *this);
// std::vector_MemoryObject::iterator *__thiscall std::vector_DNameNode::begin(std::vector_MemoryObject *this);
// std::vector_MemoryObject::iterator *__thiscall std::vector_DNameNode::end(std::vector_MemoryObject *this);
int __thiscall std::vector_DNameNode::size(std::vector_MemoryObject *this); // idb
std::vector_MemoryObject::iterator *__thiscall std::vector_DNameNode::operator[](std::vector_MemoryObject *this, int a2);
int __thiscall std::vector_DNameNode::push_back(std::vector_MemoryObject *this, MemoryObject **a2);
std::vector_MemoryObject::iterator *__thiscall std::vector_DNameNode::erase(std::vector_MemoryObject *this, std::vector_MemoryObject::iterator *a2); // idb
std::priority_queue *__thiscall std::priority_queue::priority_queue(std::priority_queue *this, _BYTE *a2, int a3);
// unsigned __int8 __thiscall std::priority_queue::empty(std::priority_queue *this);
// CIOTimer *__thiscall queue::top(std::priority_queue *this);
std::vector_CIOTimer::iterator *__thiscall std::priority_queue::push(std::priority_queue *this, CIOTimer *value);
std::vector_CIOTimer::iterator *__thiscall queue::pop(std::priority_queue *this);
// std::vector_CIOTimer::iterator *__thiscall std::vector_CIOTimer::begin(std::vector_CIOTimer *this);
// std::vector_CIOTimer::iterator *__thiscall std::vector_CIOTimer::end(std::vector_CIOTimer *this);
BOOL __thiscall std::vector_CIOTimer::empty(std::vector_CIOTimer *this); // idb
// std::vector_CIOTimer::iterator *__thiscall std::vector_CIOTimer::front(std::vector_CIOTimer *this); idb
std::vector_CIOTimer::iterator *__thiscall std::vector_CIOTimer::push_back(std::vector_CIOTimer *this, CIOTimer *a2);
std::vector_CIOTimer::iterator *__thiscall std::vector_CIOTimer::pop_back(std::vector_CIOTimer *this);
std::vector_CIOTimer::iterator *__stdcall std::vector_CIOTimer::_Destroy(std::vector_CIOTimer::iterator *a1, std::vector_CIOTimer::iterator *a2); // idb
// void __stdcall std::vector_CIOTimer::allocator_deallocate(LPVOID lpMem, int a2);
std::vector_HANDLE *__thiscall std::vector_HANDLE::vector_HANDLE_2(std::vector_HANDLE *this, _BYTE *a2);
// std::vector_HANDLE::iterator *__thiscall std::vector_HANDLE::end(std::vector_HANDLE *this);
std::vector_HANDLE::iterator *__thiscall std::vector_HANDLE::insert(std::vector_HANDLE *this, std::vector_HANDLE::iterator *a2, HANDLE *handle);
int __stdcall std::vector_HANDLE::_Destroy(int a1, int a2);
// _DWORD __stdcall std::vector_HANDLE::allocator_deallocate(LPVOID lpMem, _DWORD); weak
std::vector_MemoryObject *__thiscall std::vector_DNameNode::vector_DNameNode_2(std::vector_MemoryObject *this, _BYTE *a2);
std::vector_MemoryObject::iterator *__thiscall std::vector_DNameNode::insert(std::vector_MemoryObject *this, std::vector_MemoryObject::iterator *a2, MemoryObject *a3);
std::vector_MemoryObject::iterator *__stdcall std::vector_DNameNode::_Destroy(std::vector_MemoryObject::iterator *a1, std::vector_MemoryObject::iterator *a2); // idb
// _DWORD __stdcall std::vector_DNameNode::allocator_deallocate(LPVOID lpMem, _DWORD); weak
std::priority_queue *__thiscall std::priority_queue::priority_queue_2(std::priority_queue *this, _BYTE *a2, int a3); // idb
// std::priority_queue *__thiscall std::vector_CIOTimer::vector_CIOTimer(std::vector_CIOTimer *this, _BYTE *a2);
int __thiscall std::vector_CIOTimer::size(std::vector_CIOTimer *this); // idb
std::vector_CIOTimer::iterator *__thiscall std::vector_CIOTimer::insert(std::vector_CIOTimer *this, std::vector_CIOTimer::iterator *a2, int a3); // idb
std::vector_CIOTimer::iterator *__thiscall std::vector_CIOTimer::erase(std::vector_CIOTimer *this, std::vector_CIOTimer::iterator *a2);
void __stdcall sub_42B530(int a1);
std::vector_HANDLE *__thiscall std::vector_HANDLE::insert_2(std::vector_HANDLE *this, std::vector_HANDLE::iterator *a2, unsigned int a3, _DWORD *a4); // idb
void __stdcall sub_42B770(int a1);
std::vector_MemoryObject *__thiscall std::vector_DNameNode::insert_2(std::vector_MemoryObject *this, _DWORD *a2, unsigned int a3, _DWORD *a4);
void __stdcall sub_42B9B0(int a1);
std::vector_CIOTimer *__thiscall std::vector_CIOTimer::vector_CIOTimer_2(std::vector_CIOTimer *this, _BYTE *a2);
std::vector_CIOTimer *__thiscall std::vector_CIOTimer::insert_2(std::vector_CIOTimer *this, int a2, unsigned int a3, int a4);
void *__stdcall sub_42BC30(int a1, int a2, void *a3);
int __stdcall sub_42BC70(void *, int, int); // idb
void *__stdcall sub_42BCB0(int a1, int a2);
void *__stdcall sub_42BCD0(int a1, int a2, void *a3);
int __stdcall sub_42BD10(void *, int, int); // idb
void *__stdcall sub_42BD50(int a1, int a2);
void *__stdcall sub_42BD70(int a1, int a2, void *a3);
int __stdcall sub_42BDB0(void *, int, int); // idb
void *__stdcall sub_42BDF0(int a1, int a2);
_DWORD *__stdcall sub_42BE10(void *a1, int a2);
_DWORD *__stdcall sub_42BE30(void *a1, int a2);
_DWORD *__stdcall sub_42BE50(void *a1, int a2);
std::vector_MemoryObject::iterator *__cdecl sub_42BE70(std::vector_MemoryObject::iterator *a1, std::vector_MemoryObject::iterator *a2, std::vector_MemoryObject::iterator *a3);
std::vector_CIOTimer::iterator *__cdecl std::push_heap(std::vector_CIOTimer::iterator *_First, std::vector_CIOTimer::iterator *_Last); // idb
std::vector_CIOTimer::iterator *__cdecl std::pop_heap(int a1, int a2);
std::vector_CIOTimer::iterator *__cdecl sub_42BF10(std::vector_CIOTimer::iterator *a1, std::vector_CIOTimer::iterator *a2, std::vector_CIOTimer::iterator *a3);
void sub_42BF50();
_DWORD *__cdecl sub_42BF60(_DWORD *a1, _DWORD *a2, _DWORD *a3);
_DWORD *__cdecl sub_42BF90(_DWORD *a1, _DWORD *a2, _DWORD *a3);
void sub_42BFC0();
_DWORD *__cdecl sub_42BFD0(_DWORD *a1, _DWORD *a2, _DWORD *a3);
_DWORD *__cdecl sub_42C000(_DWORD *a1, _DWORD *a2, _DWORD *a3);
void sub_42C030();
int __cdecl sub_42C040(int a1, int a2, int a3);
int __cdecl sub_42C070(int a1, int a2, int a3);
void *__cdecl sub_42C0B0(int a1);
void *__cdecl sub_42C0E0(int a1);
void *__cdecl sub_42C110(int a1);
_DWORD *__cdecl sub_42C140(void *a1, int a2);
_DWORD *__cdecl sub_42C180(void *a1, int a2);
_DWORD *__cdecl sub_42C1C0(void *a1, int a2);
int sub_42C200();
int sub_42C210();
std::vector_CIOTimer::iterator *__cdecl std::_Push_heap_0(std::vector_CIOTimer::iterator *_First, std::vector_CIOTimer::iterator *_Last); // idb
std::vector_CIOTimer::iterator *__cdecl sub_42C270(int a1, int a2);
std::vector_CIOTimer::iterator *__cdecl std::_Push_heap(std::vector_CIOTimer::iterator *_First, int _Hole, int _Top, int _Val, int _Pred);
std::vector_CIOTimer::iterator *__cdecl sub_42C350(int a1, int a2, int a3, int a4, int a5);
bool __stdcall sub_42C390(std::vector_CIOTimer::iterator *a1, _DWORD *a2); // idb
std::vector_CIOTimer::iterator *__cdecl sub_42C3B0(int a1, int a2, int a3, int a4, int a5);
CIOTimer *__thiscall CIOTimer::CIOTimer(CIOTimer *this, MemoryObject *timerInstance, unsigned int delay); // idb
bool __thiscall CIOTimer::operator_less(CIOTimer *this, CIOTimer *other); // idb
CIOTimerInstance *__thiscall CIOTimerInstance::CIOTimerInstance(CIOTimerInstance *this);
void CIOTimerInstance::OnWaitCallback();
void __stdcall CIOTimerInstance::vfunc7(CIOTimerInstance *this_, int a2, int a3); // idb
CIOTimerInstance *__thiscall CIOTimerInstance::DeletingDestructor(CIOTimerInstance *this, char a2);
MemoryObject *__thiscall CIOTimerInstance::Destructor(CIOTimerInstance *this);
LRESULT __stdcall wndProc(HWND hWndParent, UINT Msg, WPARAM wParam, LPARAM lParam);
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd);
BOOL __stdcall wndProc::DialogFunc(HWND, UINT, WPARAM, LPARAM); // idb
int SomeStaticInit44();
int sub_42D3C0();
CLogSocket *__thiscall CLogSocket::setIPAddress(CLogSocket *this, int ipAddress); // idb
CWantedSocket *__thiscall CWantedSocket::setIPAddress(CWantedSocket *this, in_addr ipAddress); // idb
SpinLock *__thiscall SpinLock::SpinLock(SpinLock *this, LockType lockType, DWORD dwSpinCount); // idb
void __thiscall SpinLock::Destructor(SpinLock *this); // idb
void __thiscall SpinLock::Enter(SpinLock *this);
void __thiscall SpinLock::Leave(SpinLock *this); // idb
void __thiscall SpinLock::Wait(SpinLock *this);
ReadWriteLock *__thiscall ReadWriteLock::ReadWriteLock(ReadWriteLock *this);
void __thiscall ReadWriteLock::Destructor(ReadWriteLock *this); // idb
void __fastcall ReadWriteLock::readLock(ReadWriteLock *this); // idb
void __thiscall ReadWriteLock::releaseReadLock(ReadWriteLock *this); // idb
DWORD __thiscall ReadWriteLock::writeLock(ReadWriteLock *this); // idb
LogWindow *__thiscall ReadWriteLock::releaseWriteLock(ReadWriteLock *this); // idb
int SomeStaticInit45();
int sub_42D748();
int StaticInit_LogWindow();
LogWindow *CallLogWindowCtor();
int RegisterDtorForLogWindow();
void __cdecl CallLogWindowDtor(); // idb
int StaticInit_UserLog();
FileLog *CallUserLogCtor();
int RegisterDtorForUserLog();
void __cdecl CallUserLogDtor(); // idb
int StaticInit_ActLog();
FileLog *CallActLogCtor();
int RegisterDtorForActLog();
void __cdecl sub_42D822(); // idb
int StaticInit_ErrLog();
FileLog *CallErrLogCtor();
int RegisterDtorForErrLog();
void __cdecl CallErrLogDtor(); // idb
int StaticInit_GeneralLog();
GeneralLog *CallGeneralLogCtor();
int RegisterDtorForGeneralLog();
void __cdecl CallGeneralLogDtor(); // idb
void __thiscall LogWindow::Destructor(LogWindow *this); // idb
LogWindow *__thiscall LogWindow::LogWindow(LogWindow *this, int bufferLength, char *extension); // idb
// void __thiscall LogWindow::SetWindow(LogWindow *this, HWND wnd); idb
LogWindow *__thiscall LogWindow::Update(LogWindow *this); // idb
BOOL __thiscall LogWindow::Move(LogWindow *this, int right, int botton); // idb
BOOL __thiscall LogWindow::InvalidateWindow(LogWindow *this, char hasWindow); // idb
LogWindow *LogWindow::Add(LogWindow *this, int log_type, char *format, ...); // idb
struct tm *__thiscall LogWindow::init(LogWindow *this, char *fileName); // idb
FileLog *__thiscall FileLog::FileLog(FileLog *this, char *fileExtension); // idb
void __thiscall FileLog::Destructor(FileLog *this); // idb
struct tm *__thiscall FileLog::Init(FileLog *this, char *aDirName); // idb
int FileLog::write(FileLog *this, int logType, char *format, ...); // idb
GeneralLog *__thiscall GeneralLog::GeneralLog(GeneralLog *this, char *extension); // idb
void __thiscall GeneralLog::Destructor(GeneralLog *this); // idb
int GeneralLog::write(GeneralLog *this_, int logType, char *format, ...); // idb
GeneralLog *__thiscall GeneralLog::Init(GeneralLog *this, char *aDirName); // idb
int sub_42E63A();
int sub_42E649();
LogWindow *__thiscall LogWindow::DeletingDestructor(LogWindow *this, char a2);
int StaticInitLogDLock();
ReadWriteLock *CallLogDLockConstructor();
int RegisterLogDLockDestructor();
void __cdecl CallLogDLockDestructor(); // idb
void __stdcall onTimeout(PVOID, BOOLEAN); // idb
int StaticInitCLogPacketPool::g_slot();
int CLogPacketPool::g_slot::construction();
int CLogPacketPool::g_slot::registerDtor();
void __cdecl CLogPacketPool::g_slot::destruction(); // idb
int StaticInitCLogPacketPool();
void CallCLogPacketPoolConstructor();
int RegisterCLogPacketPoolDestructor();
void __cdecl CallCLogPacketPoolDestructor(); // idb
CLogPacket *CLogPacket::Alloc();
void CLogPacket::FreeAll();
void __thiscall CLogPacket::Free(CLogPacket *this); // idb
void __thiscall CLogPacket::OnIOCallback(CLogPacket *this, int bSuccess, int dwTransferred, int lpOverlapped);
char CLogSocket::packet0_dummy_handler();
MemoryObject *__thiscall CLogSocket::Destructor(CLogSocket *this);
CLogSocket *__thiscall CLogSocket::CLogSocket(CLogSocket *this, int socket); // idb
CLogSocket *__cdecl CLogSocket::Create(SOCKET socket); // idb
LONG __thiscall CLogSocket::OnRead(CLogSocket *this); // idb
int __thiscall CLogSocket::OnCreate(CLogSocket *this); // idb
LONG CLogSocket::send(CLogSocket *this, char *format, ...);
LONG CLogSocket::send2(CLogSocket *this_, char *format, ...);
char *__thiscall CLogSocket::addrToStr(CLogSocket *this); // idb
void CLogSocket::OnTimerCallback();
BOOL __thiscall CLogSocket::OnClose(CLogSocket *this); // idb
int sub_42F3B4();
int sub_42F3C3();
CLogSlot *__thiscall CLogSlot::CLogSlot(CLogSlot *this);
// void __thiscall CLogSlot::Destructor(CLogSlot *this); idb
void __thiscall CLogPacketPool::Destructor(CLogPacketPool *this);
CLogPacket *__thiscall CLogPacket::CLogPacket(CLogPacket *this);
CLogPacket *__thiscall CLogPacket::DeletingDestructor(CLogPacket *this, char a2);
// MemoryObject *__thiscall CLogPacket::Destructor(CLogPacket *this); idb
CLogSocket *__thiscall CLogSocket::CallDtor(CLogSocket *this, char a2);
int __thiscall SHA_1::SHA_1(int this);
void __thiscall MD5::CallHash(int this, unsigned __int8 *a2, int a3); // idb
unsigned int __thiscall MD5::sub_42F62D(void *this, int a2);
unsigned int __cdecl MD5::Hash(unsigned __int8 *field, unsigned __int8 *param);
int __cdecl MD5::sub_43056E(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int size); // idb
int __cdecl MD5::sub_43060E(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int size); // idb
// void __cdecl und_memcpy(char *, const char *, unsigned int); idb
unsigned int __cdecl MD5::sub_4306BB(int a1, char a2, unsigned int a3);
int Static_MemoryAllocatorsInitializer();
void *CallStaticCtorForMemoryAllocatorsInitializer();
int RegisterStatic_destructorForMemoryAllocatorsInitializer();
void __cdecl CallDtorForMemoryAllocatorsInitializer(); // idb
void *__thiscall MemoryAllocatorsInitializer::Ctor(void *this);
void *__thiscall MemoryAllocators::Destructor(void *this);
int __thiscall sub_430828(int this);
void __thiscall sub_430855(void *this);
signed int __thiscall sub_430875(HANDLE *this);
BOOL __thiscall sub_4308CF(int this);
signed int __thiscall sub_43097B(int this, int a2);
_DWORD *__cdecl managed_New(int a1);
LPVOID __thiscall MemoryAllocator::GetNewMemory(int this, SIZE_T dwBytes);
_DWORD *__thiscall MemoryAllocator::New(int this, int a2);
int __thiscall MemoryAllocator::Alloc(int this);
signed int __stdcall sub_431104(int a1);
void __cdecl delete_table(int a1);
void __thiscall sub_43134E(HANDLE *this, LPVOID lpMem);
unsigned int __thiscall sub_4313A6(int this, int a2);
int __thiscall sub_431401(int this, unsigned int a2, int a3);
int SomeStaticInit1();
int sub_4319FB();
void *__thiscall MemoryAllocatorsCallDestructor(void *this, char a2);
void *__thiscall MemoryAllocators::Free(void *this, char a2);
void __thiscall MemoryAllocator::lockGuardEnter(int this);
void __thiscall MemoryAllocator::lockGuardExit(int this);
int StaticInitFor_CAuthPacketPool::g_slot();
int CAuthPacketPool::g_slot_construction();
int CAuthPacketPool::g_slot_registerDtor();
void __cdecl CAuthPacketPool::g_slot_destruction(); // idb
int StaticInitFor_CAuthPacketPool();
void StaticCallFor_CAuthPacketPool();
int Register_StaticCallFor_CAuthPacketPoolDestructor();
void __cdecl CallFor_CAuthPacketPoolDestructor(); // idb
CAuthPacket *__cdecl CAuthPacket::Alloc();
void __thiscall CAuthPacket::Free(CAuthPacket *this); // idb
void CAuthPacket::FreeAll();
void __thiscall CAuthPacket::OnIOCallback(CAuthPacket *this, int bSuccess, int dwTransferred, int lpOverlapped); // idb
int sub_431D6A();
int sub_431D79();
CAuthSlot *__thiscall CAuthSlot::CAuthSlot(CAuthSlot *this);
void __thiscall CAuthSlot::Destructor(CAuthSlot *this); // idb
void CAuthPacketPool::Destructor();
CAuthPacket *__thiscall CAuthPacket::CAuthPacket(CAuthPacket *this);
CAuthPacket *__thiscall CAuthPacket::CallDTor(CAuthPacket *this, char a2);
MemoryObject *__thiscall CAuthPacket::Destructor(CAuthPacket *this); // idb
Symbol __cdecl Config::readToken(void *a1, char *token, bool lookForWord);
int sub_43230C();
int sub_43231B();
bool __cdecl Reader::is_digit(char a1);
bool __cdecl Reader::is_whiteSpace(char a1);
bool __cdecl Reader::is_alpha(char a1);
int __fastcall std::basic_istream::putback(int a1, int a2, char a3);
int __thiscall sub_4324F0(void *this, char a2);
bool __cdecl sub_432580(_BYTE *a1, _BYTE *a2);
// int __usercall strstream::getc@<eax>(int a1@<edx>, int a2, _BYTE *a3);
// int __usercall basic_iostream::getc@<eax>(int a1@<edx>, int a2, _BYTE *a3);
int __thiscall std::basic_ios::eof(void *this);
BOOL __thiscall sub_432700(void *this);
int StaticInitStatusLine();
StatusLine *CallStatusLineCtor();
int RegisterStatusLineDtor();
void __cdecl CallStatusLineDtor(); // idb
StatusLine *__thiscall StatusLine::StatusLine(StatusLine *this);
StatusLine *__thiscall StatusLine::Destructor(StatusLine *this);
StatusLine *__thiscall StatusLine::SetWindow(StatusLine *this, HWND a2); // idb
BOOL __thiscall StatusLine::updateTime(StatusLine *this); // idb
BOOL __thiscall StatusLine::Update(StatusLine *this); // idb
BOOL __thiscall StatusLine::Move(StatusLine *this, int a2, int a3); // idb
int sub_4329AA();
int sub_4329B9();
StatusLine *__thiscall StatusLine::CallDestructor(StatusLine *this, char a2);
int Static_InitMailServer();
MailServer *CallMailServerConstructor();
int RegisterMailServerDestructor();
void __cdecl CallMailServerDestructor(); // idb
// MailServer *__thiscall MailServer::MailServer(MailServer *this);
// void __thiscall MailServer::Destructor(MailServer *this);
SOCKET __thiscall MailServer::CloseSocket(MailServer *this); // idb
signed int __thiscall MailServer::Init(MailServer *this); // idb
char *__thiscall MailServer::PrintErrorMessage(MailServer *this, DWORD dwMessageId, char *message);
int __thiscall MailServer::openSocket(MailServer *this); // idb
int __thiscall MailServer::SendMail(MailServer *this, char *mailTo, char *subj, char *body); // idb
int __thiscall MailServer::SendHello(MailServer *this); // idb
int __thiscall MailServer::SendMailFrom(MailServer *this); // idb
int __thiscall MailServer::SendRcptTo(MailServer *this); // idb
int __thiscall MailServer::SendMailBody(MailServer *this, char *subject, char *body); // idb
int __thiscall MailServer::SendQuit(MailServer *this); // idb
int sub_43371E();
int sub_43372D();
int StaticInitForServerList();
ServerList *CallServerListConstructor();
int RegisterServerListDestructor();
void __cdecl CallServerListDestructor(); // idb
int StaticInitUserCountTable();
UserCountTable *CallUserCountTableCtor();
int RegisterUserCountTableDtor();
void __cdecl CallUserCountTableDtor(); // idb
ServerList *__thiscall ServerList::ServerList(ServerList *this); // idb
void __thiscall ServerList::Destructor(ServerList *this); // idb
void __thiscall ServerList::reload(ServerList *this); // idb
ServerInfo *__thiscall ServerList::getServerInfo(ServerList *this, ServerInfo *outServerInfo, int serverId);
int __thiscall ServerList::updateServerAndGetServerID(ServerList *this, int ipAddress, SOCKET socket); // idb
int __thiscall ServerList::setUserNumber(ServerList *this, int outerServerIP, int usersNumber, char serverId); // idb
void __thiscall ServerList::reloadFrame_GameClient(ServerList *this); // idb
int __thiscall ServerList::reloadFrame_Extended(ServerList *this);
int __thiscall ServerList::reloadFrame_WithKind(ServerList *this);
LogWindow *__thiscall ServerList::setServerStatus(ServerList *this, char serverId, char status); // idb
void __thiscall ServerList::setStatuses(ServerList *this); // idb
char __thiscall ServerList::isServerOn(ServerList *this, char serverId); // idb
void __stdcall UserCountTable::onTimeout(UserCountTable *table, BOOLEAN a2); // idb
UserCountTable *__thiscall UserCountTable::UserCountTable(UserCountTable *this);
BOOL __thiscall UserCountTable::Destructor(UserCountTable *this); // idb
void __thiscall UserCountTable::setUsers(UserCountTable *this, unsigned __int8 serverId, __int16 users, __int16 socketLimit); // idb
void __thiscall UserCountTable::refreshAuthUsers(UserCountTable *this); // idb
void __thiscall UserCountTable::updateDb(UserCountTable *this); // idb
signed int __cdecl ServersProvider::updateServerAndGetServerID(int IPaddress, SOCKET socket); // idb
void __cdecl ServersProvider::setServerStatus(char serverID, char status);
char __cdecl ServersProvider::isServerOn(char serverId); // idb
ServerInfo *__cdecl ServersProvider::getServerInfo(ServerInfo *out, char serverId); // idb
void __cdecl ServersProvider::setUserNumber(int outerServerIP, int usersNumber, int serverId);
int sub_435265();
int sub_435274();
ServerList *__thiscall ServerList::CallDestructor(ServerList *this, char a2);
// std::vector_ServerInfo *__thiscall std::vector_ServerInfo::Destructor2(std::vector_ServerInfo *this);
// std::vector_ServerInfo *__thiscall std::vector_ServerInfo::vector_ServerInfo(std::vector_ServerInfo *this, _BYTE *a2);
std::vector_ServerInfo *__thiscall std::vector_ServerInfo::Destructor(std::vector_ServerInfo *this);
// std::vector_ServerInfo::iterator *__thiscall std::vector_ServerInfo::begin(std::vector_ServerInfo *this);
// std::vector_ServerInfo::iterator *__thiscall std::vector_ServerInfo::end(std::vector_ServerInfo *this);
int __thiscall std::vector_ServerInfo::size(std::vector_ServerInfo *this); // idb
BOOL __thiscall std::vector_ServerInfo::empty(void *this);
ServerInfo *__thiscall std::vector_ServerInfo::at(std::vector_ServerInfo *retstr, size_t index, unsigned int a2);
std::vector_ServerInfo::iterator *__thiscall std::vector_ServerInfo::at2(std::vector_ServerInfo *this, int a2); // idb
int __thiscall std::vector_ServerInfo::push_back(std::vector_ServerInfo *this, const ServerInfo *a2);
std::vector_ServerInfo::iterator *__thiscall std::vector_ServerInfo::erase(std::vector_ServerInfo *this, std::vector_ServerInfo::iterator *a2);
std::vector_ServerInfo *__thiscall sub_435500(std::vector_ServerInfo *this, _BYTE *a2); // idb
std::vector_ServerInfo::iterator *__thiscall std::vector_ServerInfo::insert(std::vector_ServerInfo *this, char *_P, const void *_X);
char *__stdcall std::vector_ServerInfo::_Destroy(std::vector_ServerInfo::iterator *a1, std::vector_ServerInfo::iterator *a2); // idb
void __noreturn std::vector_ServerInfo::_Xran();
void *__thiscall sub_435620(void *this, int a2);
void __thiscall __noreturn sub_4356B0(void *this);
void __thiscall sub_4356E0(void *this);
void *__thiscall sub_435740(void *this, char a2);
// _DWORD *__thiscall unknown_libname_196(_DWORD *this, _BYTE *a2);
void *__thiscall sub_4357A0(void *this, _BYTE *a2);
void __thiscall sub_435810(void *this);
void __thiscall __noreturn sub_435830(void *this);
void *__thiscall sub_435860(void *this, char a2);
// _DWORD *__thiscall unknown_libname_197(_DWORD *this, int a2);
void *__thiscall sub_4358C0(void *this, _BYTE *a2);
void *__thiscall sub_435900(void *this, char *a2, int a3);
void *__thiscall sub_435930(int this);
// _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(_DWORD, _DWORD, _DWORD); weak
void *sub_435AC0();
// _DWORD __stdcall std::vector_ServerInfo::allocator_deallocate(LPVOID lpMem, _DWORD); weak
std::vector_ServerInfo *__thiscall std::vector_ServerInfo::insert_2(std::vector_ServerInfo *this, char *_P, unsigned int _M, const void *_X); // idb
void __stdcall sub_435D50(int a1);
ServerInfo *__stdcall std::vector_ServerInfo::_Ucopy(int a1, int a2, ServerInfo *a3);
int __stdcall std::vector_ServerInfo::_Ufill(void *, int, int); // idb
void *__stdcall std::vector_ServerInfo::allocator_allocate(int a1, int a2);
void *__stdcall sub_435E10(ServerInfo *a1, int a2); // idb
void *__cdecl sub_435E30(const void *a1, const void *a2, void *a3);
char *__cdecl std::vector_ServerInfo::fill(void *a1, void *a2, const void *a3);
char *__cdecl std::vector_ServerInfo::copy_backward(char *a1, char *a2, char *a3);
void sub_435EE0();
void *__cdecl sub_435EF0(int a1);
void *__cdecl sub_435F20(ServerInfo *a1, int a2); // idb
int StaticInit_ServerTable();
ServerTable *CallStaticCtorForServerTable();
int RegisterStaticDtorServerTable();
void __cdecl CallStaticDtorForServerTable(); // idb
ServerFrameList *__thiscall ServerFrameList::ServerFrameList(ServerFrameList *this); // idb
void __thiscall ServerFrameList::Destructor(ServerFrameList *this); // idb
ServerFrameList *__thiscall ServerFrameList::init(ServerFrameList *this, FrameType frameType, int serverKindIndex); // idb
char __thiscall ServerFrameList::addFrame(ServerFrameList *this, char serverId, char *outerIPStr, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23); // idb
char __thiscall ServerFrameList::addCompressedFrame(ServerFrameList *this, char serverId_, char outerIPStr_0, int outerIPStr_4, int outerIPStr_8, int outerIPStr_12, int innerIPStr_0, int innerIPStr_4, int innerIPStr_8, int innerIPStr_12, int serverName_0, int serverName_4, int serverName_8, int serverName_12, int serverName_16, int serverName_20, char outerIP, int ipAddress, int age_pvp_, int userNumber, int socket, int kind, char serverPort);
char __thiscall ServerFrameList::addGameClientFrame(ServerFrameList *this, char serverId_, char outerIPStr_0, int outerIPStr_4, int outerIPStr_8, int outerIPStr_12, int innerIPStr_0, int innerIPStr_4, int innerIPStr_8, int innerIPStr_12, int serverName_0, int serverName_4, int serverName_8, int serverName_12, int serverName_16, int serverName_20, char outerIP, int ipAddress, int age_pvp_, int userNumber, int socket, int kind, char serverPort);
char __thiscall ServerFrameList::addExtendedFrame(ServerFrameList *this, char serverId_, char outerIPStr_0, int outerIPStr_4, int outerIPStr_8, int outerIPStr_12, int innerIPStr_0, int innerIPStr_4, int innerIPStr_8, int innerIPStr_12, int serverName_0, int serverName_4, int serverName_8, int serverName_12, int serverName_16, int serverName_20, char outerIP, int ipAddress, int age_pvp_, int userNumber, int socket, int kind, char serverPort);
char __thiscall ServerFrameList::addWithKindFrame(ServerFrameList *this, char serverId_, char outerIPStr_0, int outerIPStr_4, int outerIPStr_8, int outerIPStr_12, int innerIPStr_0, int innerIPStr_4, int innerIPStr_8, int innerIPStr_12, int serverName_0, int serverName_4, int serverName_8, int serverName_12, int serverName_16, int serverName_20, char outerIP, int ipAddress, int age_pvp_, int userNumber, int socket, int kind, char serverPort);
void __thiscall ServerFrameList::adjustFrameSize(ServerFrameList *this); // idb
int __thiscall ServerFrameList::setServerStatus(ServerFrameList *this, int serverId, bool status); // idb
int __thiscall ServerFrameList::setStatus_GameClientFrame(ServerFrameList *this, int serverId, bool status); // idb
int __thiscall ServerFrameList::setStatus_ExtendedFrame(ServerFrameList *this, int serverId, bool status); // idb
int __thiscall ServerFrameList::setStatus_WithKindFrame(ServerFrameList *this, int serverId, bool status); // idb
int __thiscall ServerFrameList::setUserNumber(ServerFrameList *this, int serverId, int userNumber); // idb
int __thiscall ServerFrameList::setUserNumber_GameClientFrame(ServerFrameList *this, int serverId, int userNumber); // idb
int __thiscall ServerFrameList::setUserNumber_ExtendedFrame(ServerFrameList *this, int serverId, int userNumber); // idb
int __thiscall ServerFrameList::setUserNumber_WithKindFrame(ServerFrameList *this, int serverId, int userNumber); // idb
int __thiscall ServerFrameList::getBuffer(ServerFrameList *this, char **buffer);
char __thiscall ServerFrameList::copyFromBuffer(ServerFrameList *this, FrameType frameType, int serverKind, int usedBuffSize, char *buffer); // idb
char __thiscall ServerFrameList::isServerOn(ServerFrameList *this, int serverId); // idb
char __thiscall ServerFrameList::isServerOnExtended(ServerFrameList *this, char serverId); // idb
ServerTable *__thiscall ServerTable::ServerTable(ServerTable *this); // idb
std::vector_ServerInfo *__thiscall ServerTable::Destructor(ServerTable *this);
void __thiscall ServerTable::loadServerKindList(ServerTable *this);
int __thiscall ServerTable::getServerCount(ServerTable *this); // idb
ServerInfo *__thiscall ServerTable::getServerInfo(ServerTable *this, ServerInfo *serverInfo, int serverId); // idb
signed int __thiscall ServerTable::updateServerAndGetServerID(ServerTable *this, int IPaddress, SOCKET socket); // idb
void __thiscall ServerTable::setServerStatus(ServerTable *this, char serverId, char status);
void __thiscall ServerTable::setUserNumber(ServerTable *this, char serverId, int userNumber);
void __thiscall ServerTable::reloadServerKindList(ServerTable *this);
void __thiscall ServerTable::updateListFrames(ServerTable *this);
int __thiscall ServerTable::getServerKindsNumber(ServerTable *this); // idb
int __thiscall ServerTable::getServerList(ServerTable *this, char frameFormat, int serverKindIndex, char **buffer); // idb
int __thiscall ServerTable::updateStatuses(ServerTable *this); // idb
char __thiscall ServerTable::isServerOn(ServerTable *this, int serverId); // idb
int sub_4380C9();
int sub_4380D8();
void *__thiscall ServerFrameList::DeletingDestructor(void *this, char a2);
ServerTable *__thiscall ServerTableCallDestructor(ServerTable *this, char a2);
int StaticInit_ForUserManager();
UserManager *CallUserManagerStaticCtor();
int RegisterStaticDestructorForUserManager();
void __cdecl CallStaticDestructorForUserManager(); // idb
char __cdecl CAuthSocket::packet00_RequestAuthLogin(CAuthSocket *this_, char *buffer); // idb
char __cdecl CAuthSocket::packet01_ServerListPacket(CAuthSocket *this, char *buffer); // idb
char __cdecl CAuthSocket::packet02_RequestServerLogin(CAuthSocket *this, char *buffer); // idb
bool __cdecl CAuthSocket::packet03_CancelLogin(CAuthSocket *this, char *buffer); // idb
char __cdecl CAuthSocket::packet05_RequestServerList_C4(CAuthSocket *this, char *buffer); // idb
signed int WorldSrvServer::sendToWorldServer(int ipAddress, char *format, ...);
char __cdecl CAuthSocket::packet04_unknownHandler(CAuthSocket *this); // idb
char __cdecl CAuthSocket::packet06_unknownHandler(CAuthSocket *this, char *buffer); // idb
char __cdecl CAuthSocket::packet07_charsHandler(CAuthSocket *this, char *buffer); // idb
char __cdecl CAuthSocket::packet08_unknownHandler(CAuthSocket *this, char *buffer); // idb
void __stdcall CAuthSocket::onTimeout(PVOID socket, BOOLEAN a2); // idb
CAuthSocket *__thiscall CAuthSocket::CAuthSocket(CAuthSocket *this, SOCKET socket); // idb
MemoryObject *__thiscall CAuthSocket::Destructor(CAuthSocket *this);
CAuthSocket *__cdecl CAuthSocket::Create(SOCKET socket); // idb
char __thiscall CAuthSocket::OnClose(CAuthSocket *this); // idb
LONG __thiscall CAuthSocket::OnRead(CAuthSocket *this); // idb
int __thiscall CAuthSocket::OnCreate(CAuthSocket *this); // idb
CAuthSocket *__thiscall CAuthSocket::setIPAddress(CAuthSocket *this, int ipAddress); // idb
int CAuthSocket::assembleAndSend(CAuthSocket *this, char *format, ...);
int CAuthSocket::sendInit(CAuthSocket *this, char *format, ...);
void __thiscall CAuthSocket::sendPacket(CAuthSocket *this, const char *packet, size_t fullSize); // idb
LONG __thiscall CAuthSocket::OnTimerCallback(CAuthSocket *this); // idb
int sub_43A02B();
int sub_43A03A();
CAuthSocket *__thiscall CAuthSocket::DeletingDestructor(CAuthSocket *this, char a2);
int *__thiscall CAuthSocket::getUserIp(CAuthSocket *this, int *ipAddress);
int __thiscall ServerList::getAgeLimit(ServerList *this); // idb
int __stdcall Threading::timersThread(int a1);
unsigned int __stdcall Threading::IOThread(void *arglist);
unsigned int __stdcall Threading::IOThreadExtra(void *a1);
int __stdcall Threading::startServersLoop(int); // weak
signed int Threading::prepareThreads();
int sub_43A66B();
int sub_43A67A();
int __cdecl PacketUtils::VAssemble(char *buff, int size, const char *format, va_list ap);
int sub_43A9A3(unsigned __int8 *buff, int size, char *format, ...);
signed int __cdecl BufferReader::copyStrBuffer(char *out, const char *in, signed int size); // idb
int __cdecl Hash::hash_unusual(char *password); // idb
int __cdecl Hash::hash(char *password); // idb
void Hash::hash_empty_stub();
char __cdecl Crypt::decrypt_75FE(char *data, char *xorKey, signed int size); // idb
int __cdecl Crypt::encrypt_75FE(char *data, char *xorKey, int size);
int __cdecl Crypt::unused(int a1, int a2, int a3, int a4, char a5, int a6, int a7);
int __cdecl Utils::normalizeName(char *accName);
HFONT sub_43AF16();
void __cdecl Utils::sendToLog(int type, const char *accName, int connectedIP, int payStat, int age, int a6, int zero, int variant, int uid); // idb
int __cdecl Utils::toWideChar(const char *multiByteStr, int, wchar_t *wideCharStr);
unsigned __int8 *__cdecl Blowfish::EncryptPacket(unsigned __int8 *data, char *xorKey, int *size); // idb
bool __cdecl Blowfish::DecryptPacket(unsigned __int8 *data, char *xorKey, int size); // idb
time_t __cdecl Utils::convertTime(TIMESTAMP_STRUCT *a1, struct tm *a2); // idb
char __cdecl Utils::validateAccName(char *accName); // idb
char __cdecl Utils::isNumber(char *str, int size); // idb
char __cdecl Utils::checkDiskFreeSpace(LPCSTR lpDirectoryName, int a2, int a3);
int sub_43BAD3();
int sub_43BAE2();
int StaticInit_SocketWanted_semaphore();
ReadWriteLock *CallStaticCtorFor_SocketWanted_semaphore();
int RegisterStaticDestructorFor_SocketWanted_semaphore();
void __cdecl CallStaticDestructorFor_SocketWanted_semaphore(); // idb
void __stdcall CWantedSocket::onTimeout(PVOID, BOOLEAN); // idb
int CWantedPacketPool::g_slot_statis_init();
int CWantedPacketPool::g_slot_construction();
int CWantedPacketPool::Call_g_slot_destruction();
void __cdecl CWantedPacketPool::g_slot_destruction(); // idb
int StaticInitFor_CWantedPacketPool();
void StaticCallFor_CWantedPacketPoolCtor();
int Register_StaticCallFor_CWantedPacketPoolDestructor();
void __cdecl StaticCallFor_CWantedPacketPoolDestructor(); // idb
CWantedPacket *__cdecl CWantedPacket::Alloc();
void CWantedPacket::FreeAll();
void __thiscall CWantedPacket::Free(CWantedPacket *this); // idb
void __thiscall CWantedPacket::OnIOCallback(CWantedPacket *this, BOOL bSuccess, DWORD dwTransferred, LPOVERLAPPED lpOverlapped);
char __cdecl CWantedSocket::h4_dummy_packet(CWantedSocket *this, char *buffer);
char __cdecl CWantedSocket::packet1_getVersion(CWantedSocket *this, char *buffer); // idb
char __cdecl CWantedSocket::h2(CWantedSocket *this, char *buffer); // idb
char __cdecl CWantedSocket::h3(CWantedSocket *this, char *buffer); // idb
CWantedSocket *__cdecl CWantedSocket::Create(SOCKET socket); // idb
CWantedSocket *__thiscall CWantedSocket::CWantedSocket(CWantedSocket *this, SOCKET socket); // idb
MemoryObject *__fastcall CWantedSocket::Destructor(CWantedSocket *this);
BOOL __thiscall CWantedSocket::OnClose(CWantedSocket *this); // idb
void CWantedSocket::OnTimerCallback();
char *__thiscall CWantedSocket::addrToStr(CWantedSocket *this); // idb
int __thiscall CWantedSocket::OnCreate(CWantedSocket *this); // idb
LONG __thiscall CWantedSocket::OnRead(CWantedSocket *this); // idb
char CWantedSocket::send(CWantedSocket *this, char *format, ...);
int sub_43C56D();
int sub_43C57C();
CWantedPacketSlot *__thiscall CWantedPacketSlot::CWantedPacketSlot(CWantedPacketSlot *this);
void __thiscall CSlotWanted::Destructor(CWantedPacketSlot *this); // idb
void CWantedPacketPool::Destructor();
CWantedPacket *__thiscall CWantedPacket::CWantedPacket(CWantedPacket *this); // idb
CWantedPacket *__thiscall CWantedPacket::DeletingDestructor(CWantedPacket *this, char a2);
MemoryObject *__thiscall CWantedPacket::Destructor(CWantedPacket *this); // idb
CWantedSocket *__thiscall CWantedSocket::DeletingDestructor(CWantedSocket *this, char a2); // idb
// SQLRETURN __stdcall SqlQuery::execRaw(SqlQuery *this, const char *sqlQuery, int textLength);
// SQLRETURN __stdcall SqlQuery::bindParam(SqlQuery *this, SQLUSMALLINT index, SQLSMALLINT fParamType, SQLSMALLINT fCType, SQLSMALLINT fSqlType, SQLUINTEGER cbColDef, SQLSMALLINT ibScale, SQLPOINTER rgbValue, SQLINTEGER cbValueMax, SQLINTEGER *pcbValue);
// SQLRETURN __stdcall SQLBindCol(SQLHSTMT StatementHandle, SQLUSMALLINT ColumnNumber, SQLSMALLINT TargetType, SQLPOINTER TargetValue, SQLINTEGER BufferLength, SQLINTEGER *StrLen_or_Ind);
// SQLRETURN __stdcall SQLFreeHandle(SQLSMALLINT HandleType, SQLHANDLE Handle);
// SQLRETURN __stdcall SQLAllocHandle(SQLSMALLINT HandleType, SQLHANDLE InputHandle, SQLHANDLE *OutputHandle);
// SQLRETURN __stdcall SQLSetEnvAttr(SQLHENV EnvironmentHandle, SQLINTEGER Attribute, SQLPOINTER Value, SQLINTEGER StringLength);
// SQLRETURN __stdcall SQLDisconnect(SQLHDBC ConnectionHandle);
// SQLRETURN __stdcall SQLDriverConnect(SQLHDBC hdbc, SQLHWND hwnd, SQLCHAR *szConnStrIn, SQLSMALLINT cchConnStrIn, SQLCHAR *szConnStrOut, SQLSMALLINT cchConnStrOutMax, SQLSMALLINT *pcchConnStrOut, SQLUSMALLINT fDriverCompletion);
// SQLRETURN __stdcall SQLSetConnectAttr(SQLHDBC ConnectionHandle, SQLINTEGER Attribute, SQLPOINTER Value, SQLINTEGER StringLength);
// SQLRETURN __stdcall SQLFreeStmt(SQLHSTMT StatementHandle, SQLUSMALLINT Option);
// SQLRETURN __stdcall SQLExecute(SQLHSTMT StatementHandle);
// SQLRETURN __stdcall SQLPrepare(SQLHSTMT StatementHandle, SQLCHAR *StatementText, SQLINTEGER TextLength);
// SQLRETURN __stdcall SQLFetch(SQLHSTMT StatementHandle);
// SQLRETURN __stdcall SQLGetDiagRec(SQLSMALLINT HandleType, SQLHANDLE Handle, SQLSMALLINT RecNumber, SQLCHAR *Sqlstate, SQLINTEGER *NativeError, SQLCHAR *MessageText, SQLSMALLINT BufferLength, SQLSMALLINT *TextLength);
// void __stdcall GetAcceptExSockaddrs(PVOID lpOutputBuffer, DWORD dwReceiveDataLength, DWORD dwLocalAddressLength, DWORD dwRemoteAddressLength, struct sockaddr **LocalSockaddr, LPINT LocalSockaddrLength, struct sockaddr **RemoteSockaddr, LPINT RemoteSockaddrLength);
// BOOL __stdcall AcceptEx(SOCKET sListenSocket, SOCKET sAcceptSocket, PVOID lpOutputBuffer, DWORD dwReceiveDataLength, DWORD dwLocalAddressLength, DWORD dwRemoteAddressLength, LPDWORD lpdwBytesReceived, LPOVERLAPPED lpOverlapped);
void __cdecl _delete_table(LPVOID lpMem);
// std::_Lockit *__thiscall std::_Lockit::_Lockit(std::_Lockit *this);
// void __cdecl loc_43CAA1(); idb
// _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this); idb
// int __thiscall std::istrstream::~istrstream(std::istrstream *this);
// std::ostrstream *__thiscall std::ostrstream::ostrstream(std::ostrstream *this, char *a2, int a3, int a4, char *a5);
// char *__thiscall std::ostrstream::`scalar deleting destructor'(std::ostrstream *this, char a2);
// int __thiscall std::ostrstream::~ostrstream(std::ostrstream *this);
// std::strstream *__fastcall std::strstream::strstream(std::strstream *this, int edx0, char *a2, int a3, char a4, int a5);
// int __thiscall std::strstream::~strstream(std::strstream *this);
// int __thiscall std::strstreambuf::~strstreambuf(std::strstreambuf *this);
// void __thiscall std::strstreambuf::freeze(std::strstreambuf *this, bool); idb
// void __thiscall std::strstreambuf::_Init(std::strstreambuf *this, int, char *, char *, int); idb
// void __thiscall std::strstreambuf::_Tidy(std::strstreambuf *__hidden this); idb
_DWORD *__thiscall sub_43D2E7(_DWORD *this, int a2, int a3, char a4, int a5);
// int __fastcall std::basic_iostream<char,std::char_traits<char>>::basic_iostream<char,std::char_traits<char>>(int a1, int a2, int a3, int a4);
// int __thiscall std::basic_iostream<char,std::char_traits<char>>::~basic_iostream<char,std::char_traits<char>>(char *this);
char *__thiscall sub_43D414(char *this, char a2);
int __thiscall sub_43D45E(void *this);
// int unknown_libname_206();
int sub_43D49D();
void __cdecl nullsub_1(); // idb
// void __thiscall std::ios_base::clear(std::ios_base *this, int a2, int a3);
_BYTE *__thiscall sub_43D552(_BYTE *this, _BYTE *a2);
void __thiscall __noreturn sub_43D5C3(void *this);
// void __thiscall unknown_libname_207(void *this);
void *__thiscall sub_43D61D(void *this, char a2);
_BYTE *__thiscall sub_43D639(_BYTE *this, int a2);
// void __thiscall unknown_libname_208(void *this);
void __thiscall __noreturn sub_43D6D3(void *this);
void *__thiscall sub_43D6F0(void *this, char a2);
_DWORD *__thiscall sub_43D70C(_BYTE *this, int a2);
// int __thiscall std::ios_base::~ios_base(std::ios_base *this);
// struct std::ios_base::_Iosarray *__thiscall std::ios_base::_Findarr(std::ios_base *this, int); idb
// void __thiscall std::ios_base::_Tidy(std::ios_base *__hidden this); idb
int sub_43DA55();
int nullsub_3(void); // weak
void __cdecl sub_43DA6C(); // idb
// const struct std::locale::facet *__thiscall std::locale::_Getfacet(std::locale *this, unsigned int, bool); idb
// bool __thiscall std::locale::_Iscloc(std::locale *__hidden this); idb
void __thiscall sub_43DD3E(void *this);
// std::locale::_Locimp *__thiscall std::locale::_Locimp::_Locimp(std::locale::_Locimp *this, int a2);
// int __thiscall std::locale::_Locimp::~_Locimp(std::locale::_Locimp *this);
// int unknown_libname_209();
int sub_43DF4D();
void __noreturn sub_43DF65();
// void __thiscall unknown_libname_210(void *this);
void __thiscall __noreturn sub_43DFFC(void *this);
void *__thiscall sub_43E019(void *this, char a2);
_DWORD *__thiscall sub_43E035(_DWORD *this, int a2);
void __noreturn sub_43E04D();
int sub_43E0A7();
int sub_43E0D1();
// struct _iobuf *__cdecl std::__Fiopen(const char *, int); idb
int sub_43E18C();
// _DWORD __stdcall std::_Locinfo::_Getname(_DWORD); weak
// struct std::locale *__thiscall std::locale::_Addfac(std::locale *this, struct std::locale::facet *, unsigned int, unsigned int); idb
// struct std::locale::_Locimp *__cdecl std::locale::_Locimp::_Makeloc(const struct std::_Locinfo *, int, struct std::locale::_Locimp *, const struct std::locale *); idb
// std::locale::_Locimp *__thiscall std::locale::_Locimp::_Locimp(std::locale::_Locimp *this, const struct std::locale::_Locimp *a2);
// void __thiscall std::locale::_Locimp::_Addfac(std::locale::_Locimp *this, struct std::locale::facet *, unsigned int); idb
// _DWORD __thiscall std::_Locinfo::_Locinfo(std::_Locinfo *this, const char *); idb
// _DWORD __thiscall std::_Locinfo::~_Locinfo(std::_Locinfo *__hidden this); idb
int __stdcall sub_43EC89(int a1, int a2, int a3, int a4, int a5, int a6, _DWORD *a7, bool *a8);
int __stdcall sub_43EE33(int a1, int a2, int a3, char a4, int a5, int a6, _DWORD *a7, _WORD *a8);
int __stdcall sub_43EEFF(int a1, int a2, int a3, char a4, int a5, int a6, _DWORD *a7, unsigned __int32 *a8);
int __stdcall sub_43F123(int a1, int a2, int a3, char a4, int a5, int a6, _DWORD *a7, float *a8);
int __stdcall sub_43F5BF(int a1, int a2, int a3, int a4, int a5, int a6);
int __stdcall sub_43F617(int a1, int a2, int a3, int a4, int a5, int a6);
int __stdcall sub_43F66F(int, int, int, int, int, double); // idb
int __stdcall sub_43F6ED(int, int, int, int, int, double); // idb
char __thiscall sub_43F835(int this);
char __thiscall sub_43F839(int this);
void *__thiscall sub_43F8DF(void *this, char a2);
void __thiscall sub_43F8FB(void *this);
void *__thiscall sub_43F902(void *this, char a2);
void __thiscall sub_43F91E(void *this);
void *__thiscall sub_43F925(void *this, char a2);
void __thiscall sub_43F941(int this);
// _DWORD __cdecl std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::_Getifld(_DWORD, _DWORD, _DWORD, _DWORD, std::locale *); weak
// _DWORD __cdecl std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::_Getffld(_DWORD, _DWORD, _DWORD, std::locale *); weak
// _DWORD __cdecl unknown_libname_219(_DWORD, char, _DWORD); weak
// int __cdecl std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::_Fput(int, int, int, int, int, void *, int, size_t); idb
// _DWORD __cdecl unknown_libname_220(_DWORD, char, _DWORD); weak
// int __cdecl std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::_Iput(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __thiscall unknown_libname_221(void *this, int a2);
// _DWORD __stdcall unknown_libname_222(_DWORD); weak
// _DWORD __stdcall std::numpunct<char>::_Init(_DWORD); weak
// int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(size_t, char); idb
// int __thiscall unknown_libname_223(_DWORD); weak
// int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(int, int, size_t); idb
const struct std::locale::facet *__cdecl sub_4407E3(std::locale *a1, int a2, int a3);
const struct std::locale::facet *__cdecl sub_4408BF(std::locale *a1, int a2, int a3);
const struct std::locale::facet *__cdecl sub_44099B(std::locale *a1, int a2, int a3);
// int __cdecl std::_Getloctxt(int, int, size_t, int); idb
// char *__cdecl std::_Maklocstr(const char *, char *); idb
signed int __thiscall sub_440C62(int this, int a2);
int __thiscall sub_440CA1(int this, int a2);
std::locale::facet *__cdecl sub_440CFA(std::locale::facet *a1);
std::locale::facet *__cdecl sub_440D48(std::locale::facet *a1);
std::locale::facet *__cdecl sub_440D96(std::locale::facet *a1);
void __thiscall sub_440DE4(void *this);
void __thiscall sub_440E31(void *this);
void __thiscall sub_440E7E(void *this);
int sub_440EF5();
// int __cdecl _Tolower(int, const _Ctypevec *);
// int __cdecl _Tolower_0(int, const _Ctypevec *);
// _Ctypevec *__cdecl _Getctype(_Ctypevec *__return_ptr __struct_ptr retstr);
// int __cdecl _Toupper(int, const _Ctypevec *);
LCID sub_44134E();
// int __cdecl wctob(wint_t);
// void __cdecl std::_Nomemory(); idb
_DWORD *__thiscall sub_4415A2(_DWORD *this, char a2);
void __thiscall sub_4415BB(int this);
void __thiscall __noreturn sub_4415C6(void *this);
void *__thiscall sub_4415E3(void *this, char a2);
_DWORD *__thiscall sub_4415FF(_DWORD *this, int a2);
void __cdecl sub_441617(); // idb
// void __cdecl std::locale::_Locimp::_Makewloc(const struct std::_Locinfo *, int, struct std::locale::_Locimp *, const struct std::locale *); idb
char sub_441D20();
signed int sub_441D23();
int sub_441D27();
void *__thiscall sub_441D2A(void *this, char a2);
void __thiscall sub_441D46(void *this);
_WORD *__thiscall sub_441E4A(void *this, _WORD *a2, _WORD *a3);
_WORD *__thiscall sub_441EA8(void *this, _WORD *a2, _WORD *a3);
int __stdcall sub_441F11(wint_t, int); // idb
int __stdcall sub_442026(int a1, int a2, int a3, int a4, int a5, int a6, _DWORD *a7, bool *a8);
int __stdcall sub_4421D0(int a1, int a2, int a3, char a4, int a5, int a6, _DWORD *a7, _WORD *a8);
int __stdcall sub_44229C(int a1, int a2, int a3, char a4, int a5, int a6, _DWORD *a7, unsigned __int32 *a8);
int __stdcall sub_4424C0(int a1, int a2, int a3, int a4, int a5, int a6, _DWORD *a7, float *a8);
int __stdcall sub_44296F(int a1, int a2, int a3, int a4, int a5, int a6);
int __stdcall sub_4429C7(int a1, int a2, int a3, int a4, int a5, int a6);
int __stdcall sub_442A1F(int, int, int, int, int, double); // idb
int __stdcall sub_442A9D(int, int, int, int, int, double); // idb
// _BYTE *__thiscall unknown_libname_232(int this, _BYTE *a2);
int __stdcall sub_442DD5(int a1, int a2);
int __stdcall sub_442F83(int a1, int a2, int a3, char a4, int a5, char a6, int a7, _DWORD *a8, int a9);
int __thiscall sub_44335F(int this);
signed int sub_44337B();
void *__thiscall sub_443656(void *this, char a2);
void __thiscall sub_443672(int this);
void *__thiscall sub_443692(void *this, char a2);
void __thiscall sub_4436AE(int this);
void *__thiscall sub_4436C8(void *this, char a2);
void __thiscall sub_4436E4(void *this);
void *__thiscall sub_4436EB(void *this, char a2);
void __thiscall sub_443707(void *this);
void *__thiscall sub_44370E(void *this, char a2);
void __thiscall sub_44372A(int this);
void *__thiscall sub_443756(void *this, char a2);
void __thiscall sub_443772(void *this);
void *__thiscall sub_443779(void *this, char a2);
void __thiscall sub_443795(int this);
void *__thiscall sub_4437B8(void *this, char a2);
void __thiscall sub_4437D4(void *this);
void *__thiscall sub_4437DB(void *this, char a2);
void __thiscall sub_4437F7(void *this);
void *__thiscall sub_4437FE(void *this, char a2);
void *__thiscall sub_44381A(void *this, char a2);
void *__thiscall sub_443836(void *this, char a2);
void __thiscall sub_443852(int this);
int sub_443875(void); // weak
void __thiscall sub_44387A(int this);
void *__thiscall sub_4438AE(void *this, char a2);
int sub_4438CA(void); // weak
// _DWORD __stdcall unknown_libname_238(LPVOID lpMem); weak
// int __thiscall std::_Locinfo::_Gettnames(_DWORD, _DWORD); weak
// _DWORD __cdecl std::num_get<unsigned short,std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::_Getifld(_DWORD, _DWORD, _DWORD, _DWORD, std::locale *); weak
// int __cdecl std::num_get<unsigned short,std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::_Getffld(int, int, int, struct std::locale *); idb
// _DWORD __cdecl unknown_libname_239(_DWORD, char, _DWORD); weak
// int __cdecl std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::_Fput(int, int, int, int, int, void *, int, size_t); idb
// _DWORD __cdecl unknown_libname_240(_DWORD, char, _DWORD); weak
// int __cdecl std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::_Iput(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall unknown_libname_241(_DWORD); weak
// _DWORD __stdcall unknown_libname_242(_DWORD); weak
// _DWORD __stdcall std::numpunct<unsigned short>::_Init(_DWORD); weak
// _DWORD __stdcall std::messages<unsigned short>::_Init(_DWORD); weak
// _DWORD __stdcall std::money_get<unsigned short,std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::_Getmfld(_DWORD, _DWORD, _DWORD, char, _DWORD); weak
// _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::append(_DWORD, _DWORD); weak
int __thiscall sub_445667(int this, unsigned int a2);
int __thiscall sub_44568D(int this, int a2, int a3, char a4);
// _DWORD __stdcall std::time_get<unsigned short,std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::_Init(std::_Locinfo *); weak
// _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::assign(_DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::assign(_DWORD, _DWORD); weak
// _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::assign(_DWORD, _DWORD); weak
// _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::erase(_DWORD, _DWORD); weak
// _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::_Tidy(char); weak
// _DWORD __stdcall std::_Mpunct<unsigned short>::_Init(_DWORD); weak
// _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::append(_DWORD, _DWORD, _DWORD); weak
// void *__thiscall unknown_libname_249(int this, void *a2, char a3, char a4, char a5);
const struct std::locale::facet *__cdecl sub_44609B(std::locale *a1, int a2, int a3);
const struct std::locale::facet *__cdecl sub_44615F(std::locale *a1, int a2, int a3);
const struct std::locale::facet *__cdecl sub_44623B(std::locale *a1, int a2, int a3);
const struct std::locale::facet *__cdecl sub_446317(std::locale *a1, int a2, int a3);
const struct std::locale::facet *__cdecl sub_4463DB(std::locale *a1, int a2, int a3);
const struct std::locale::facet *__cdecl sub_44649F(std::locale *a1, int a2, int a3);
const struct std::locale::facet *__cdecl sub_446563(std::locale *a1, int a2, int a3);
const struct std::locale::facet *__cdecl sub_44663F(std::locale *a1, int a2, int a3);
const struct std::locale::facet *__cdecl sub_44671B(std::locale *a1, int a2, int a3);
const struct std::locale::facet *__cdecl sub_4467EA(std::locale *a1, int a2, int a3);
const struct std::locale::facet *__cdecl sub_4468B9(std::locale *a1, int a2, int a3);
const struct std::locale::facet *__cdecl sub_44697D(std::locale *a1, int a2, int a3);
const struct std::locale::facet *__cdecl sub_446A41(std::locale *a1, int a2, int a3);
int __thiscall sub_446B05(int this, int a2);
// int __cdecl std::_Getloctxt(int, int, size_t, int); idb
// unsigned __int16 *__cdecl std::_Maklocstr(const char *, unsigned __int16 *); idb
// int __thiscall std::ctype<unsigned short>::ctype<unsigned short>(int this, int a2);
int __thiscall sub_446DC3(int this, LPVOID lpMem);
// _DWORD __stdcall std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>::equal(_DWORD); weak
int __thiscall sub_446E6F(int this, int a2);
int __thiscall sub_446EC8(int this, int a2);
int __thiscall sub_446F1C(int this, int a2);
int __thiscall sub_446F8E(int this, int a2);
std::locale::facet *__cdecl sub_446FE7(std::locale::facet *a1);
std::locale::facet *__cdecl sub_447035(std::locale::facet *a1);
std::locale::facet *__cdecl sub_447083(std::locale::facet *a1);
std::locale::facet *__cdecl sub_4470D1(std::locale::facet *a1);
std::locale::facet *__cdecl sub_44711F(std::locale::facet *a1);
std::locale::facet *__cdecl sub_44716D(std::locale::facet *a1);
std::locale::facet *__cdecl sub_4471BB(std::locale::facet *a1);
std::locale::facet *__cdecl sub_447209(std::locale::facet *a1);
std::locale::facet *__cdecl sub_447257(std::locale::facet *a1);
std::locale::facet *__cdecl sub_4472A5(std::locale::facet *a1);
std::locale::facet *__cdecl sub_4472F3(std::locale::facet *a1);
std::locale::facet *__cdecl sub_447341(std::locale::facet *a1);
std::locale::facet *__cdecl sub_44738F(std::locale::facet *a1);
int __thiscall sub_4473DD(int this, int a2, char a3);
void __thiscall sub_44743C(void *this);
void __thiscall sub_447489(void *this);
void __thiscall sub_4474D6(void *this);
void __thiscall sub_447523(void *this);
void __thiscall sub_447570(void *this);
void __thiscall sub_4475BD(void *this);
void __thiscall sub_44760A(void *this);
void __thiscall sub_447657(void *this);
void __thiscall sub_4476A4(void *this);
void __thiscall sub_4476F1(void *this);
void __thiscall sub_44773E(void *this);
void __thiscall sub_44778B(void *this);
void __thiscall sub_4477D8(void *this);
// void __cdecl std::locale::_Locimp::_Makexloc(const struct std::_Locinfo *, int, struct std::locale::_Locimp *, const struct std::locale *); idb
int __stdcall sub_447CCC(int a1, int a2);
_BYTE *__thiscall sub_447CD1(int this, _BYTE *a2, int a3, int a4, int a5, _BYTE *a6);
int __stdcall sub_447E73(int a1, int a2, int a3, char a4, int a5, char a6, int a7, _DWORD *a8, int a9);
char __thiscall sub_44813F(int this);
char __thiscall sub_448143(int this);
_BYTE *__thiscall sub_4481E9(int this, _BYTE *a2);
int __thiscall sub_44821F(int this);
signed int sub_44823B();
void *__thiscall sub_4485C0(void *this, char a2);
void __thiscall sub_4485DC(void *this);
void *__thiscall sub_4485E3(void *this, char a2);
void __thiscall sub_4485FF(int this);
void *__thiscall sub_448622(void *this, char a2);
void __thiscall sub_44863E(void *this);
void *__thiscall sub_448645(void *this, char a2);
void __thiscall sub_448661(void *this);
void *__thiscall sub_448668(void *this, char a2);
void *__thiscall sub_448684(void *this, char a2);
void *__thiscall sub_4486A0(void *this, char a2);
void __thiscall sub_4486BC(int this);
void *__thiscall sub_4486DF(void *this, char a2);
void __thiscall sub_4486FB(int this);
int sub_448715(void); // weak
void __thiscall sub_44871A(int this);
void *__thiscall sub_44874E(void *this, char a2);
int sub_44876A(void); // weak
int __thiscall sub_44876F(int this, unsigned int a2);
// _DWORD __stdcall std::messages<char>::_Init(_DWORD); weak
// _DWORD __stdcall std::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::_Getmfld(_DWORD, _DWORD, _DWORD, char, _DWORD); weak
int __thiscall sub_4495DD(int this, int a2, int a3, char a4);
// int __stdcall std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::_Init(std::_Locinfo *); idb
// _DWORD __stdcall unknown_libname_256(LPVOID lpMem); weak
// int __thiscall unknown_libname_258(void *this, int a2);
// _DWORD __stdcall std::_Mpunct<char>::_Init(_DWORD); weak
const struct std::locale::facet *__cdecl sub_4499C5(std::locale *a1, int a2, int a3);
const struct std::locale::facet *__cdecl sub_449A89(std::locale *a1, int a2, int a3);
const struct std::locale::facet *__cdecl sub_449B4D(std::locale *a1, int a2, int a3);
const struct std::locale::facet *__cdecl sub_449C29(std::locale *a1, int a2, int a3);
const struct std::locale::facet *__cdecl sub_449D05(std::locale *a1, int a2, int a3);
const struct std::locale::facet *__cdecl sub_449DD4(std::locale *a1, int a2, int a3);
const struct std::locale::facet *__cdecl sub_449EA3(std::locale *a1, int a2, int a3);
const struct std::locale::facet *__cdecl sub_449F67(std::locale *a1, int a2, int a3);
int __thiscall sub_44A02B(int this, int a2);
int __thiscall sub_44A07F(int this, int a2);
int __thiscall sub_44A0F1(int this, int a2);
int __thiscall sub_44A14A(int this, LPVOID lpMem);
std::locale::facet *__cdecl sub_44A1B7(std::locale::facet *a1);
std::locale::facet *__cdecl sub_44A205(std::locale::facet *a1);
std::locale::facet *__cdecl sub_44A253(std::locale::facet *a1);
std::locale::facet *__cdecl sub_44A2A1(std::locale::facet *a1);
std::locale::facet *__cdecl sub_44A2EF(std::locale::facet *a1);
std::locale::facet *__cdecl sub_44A33D(std::locale::facet *a1);
std::locale::facet *__cdecl sub_44A38B(std::locale::facet *a1);
std::locale::facet *__cdecl sub_44A3D9(std::locale::facet *a1);
int __thiscall sub_44A427(int this, int a2, char a3);
void __thiscall sub_44A486(void *this);
void __thiscall sub_44A4D3(void *this);
void __thiscall sub_44A520(void *this);
void __thiscall sub_44A56D(void *this);
void __thiscall sub_44A5BA(void *this);
void __thiscall sub_44A607(void *this);
void __thiscall sub_44A654(void *this);
void __thiscall sub_44A6A1(void *this);
// double __cdecl _Stod(const char *, char **, __int32);
double __cdecl sub_44A74B(char *a1, char **a2, __int32 a3);
LCID sub_44A86E();
// void *__cdecl memset(void *, int, size_t);
// void *__cdecl memcpy(void *, const void *, size_t);
// int swprintf(wchar_t *, const wchar_t *, ...);
// _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _global_unwind2(PVOID TargetFrame); idb
// _DWORD __cdecl _local_unwind2(_DWORD, _DWORD); weak
// _DWORD __stdcall _NLG_Notify(_DWORD); weak
// int sprintf(char *, const char *, ...);
// size_t __cdecl strlen(const char *);
// int __cdecl atoi(const char *);
// struct tm *__cdecl localtime(const time_t *);
// time_t __cdecl time(time_t *);
// char *__cdecl strcpy(char *, const char *);
// char *__cdecl strcat(char *, const char *);
// int __cdecl strcmp(const char *, const char *);
// int __cdecl memcmp(const void *, const void *, size_t);
// char *__cdecl strncpy(char *, const char *, size_t);
// int __cdecl atexit(void (__cdecl *)());
// int __usercall _except_handler3@<eax>(int a1@<ebp>);
void __cdecl _Free(LPVOID lpMem);
// void *__cdecl malloc(size_t);
// _DWORD __cdecl _nh_malloc(_DWORD, _DWORD); weak
LPVOID __cdecl sub_44BEC7(unsigned int a1);
// int __cdecl _read(int, void *, unsigned int);
// int __cdecl _close(int);
// void *__cdecl operator new(unsigned int); idb
// int __cdecl _stat(const char *, struct _stat *);
// int _open(const char *, int, ...);
// char *__cdecl strstr(const char *, const char *);
// void *__cdecl memmove(void *, const void *, size_t);
// int __cdecl isalpha(int);
// int __cdecl isdigit(int);
// int sscanf(const char *, const char *, ...);
// int __cdecl vsprintf(char *, const char *, va_list);
// char *__cdecl strrchr(const char *, int);
// void *__cdecl memchr(const void *, int, size_t);
// int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
// int _snprintf(char *, size_t, const char *, ...);
// int __stdcall `eh vector constructor iterator'(void *, unsigned int, int, int, void (__thiscall *)(void *)); idb
// int __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *)); idb
void __noreturn pure_call();
// size_t __cdecl strspn(const char *, const char *);
// __int32 __cdecl strtol(const char *, char **, int);
// unsigned __int32 __cdecl strtoul(const char *, char **, int);
size_t __cdecl sub_44D601(void *a1, size_t a2, size_t a3, FILE *a4);
// size_t __cdecl fwrite(const void *, size_t, size_t, FILE *);
int sub_44D9D1();
// _DWORD __cdecl flsall(_DWORD); weak
// int __cdecl fclose(FILE *);
void *__thiscall sub_44DBEE(void *this, char a2);
// _DWORD *__thiscall exception::exception(_DWORD *this, const char **a2);
// int __thiscall exception::exception(int this, int a2);
void __thiscall sub_44DCB0(int this);
// int __thiscall type_info::~type_info(#104 *this);
// _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD); weak
// int __cdecl _beginthreadex(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, int, int, DWORD dwCreationFlags, LPDWORD lpThreadId); idb
// int _cinit();
// void __cdecl __noreturn exit(int);
// _DWORD __cdecl _initterm(_DWORD, _DWORD); weak
// int fprintf(FILE *, const char *, ...);
// FILE *__cdecl fopen(const char *, const char *);
// int __cdecl strncmp(const char *, const char *, size_t);
// char *__cdecl strchr(const char *, int);
// char *__cdecl strtok(char *, const char *);
// char *__cdecl fgets(char *, int, FILE *);
// void __cdecl srand(unsigned int);
// int __cdecl rand();
// size_t __cdecl wcslen(const wchar_t *);
// int __cdecl tolower(int);
// int __cdecl tolower_0(int);
// int __cdecl toupper(int);
// time_t __cdecl mktime(struct tm *);
// void __noreturn start();
// int __cdecl _amsg_exit(DWORD NumberOfBytesWritten); idb
// int __cdecl fast_error_exit(DWORD NumberOfBytesWritten); idb
int sub_44EE45();
void *__cdecl sub_44EF8C(LPVOID lpMem, SIZE_T dwBytes);
// int *__cdecl _errno();
void **sub_44F3A0();
// _DWORD __cdecl _lock(_DWORD); weak
// _DWORD __cdecl _unlock(_DWORD); weak
// int __cdecl __crtLCMapStringA(LCID Locale, DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest, UINT CodePage, int); idb
// int __cdecl _isctype(int, int);
unsigned int __cdecl sub_44FB46(unsigned __int8 *a1, unsigned int a2, unsigned __int8 *a3, int a4, void *a5);
// _DWORD __cdecl _expandtime(char, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int _mtinit(void); weak
// int _getptd(void); weak
// void __cdecl terminate(); idb
// void __noreturn sub_451ABD();
int __cdecl sub_452AF8(LPCVOID lpMem);
char __cdecl sub_452BE6(int a1);
__int32 sub_452C13();
signed int __cdecl sub_452D5B(int a1);
// _DWORD __cdecl __sbh_heap_init(_DWORD); weak
// char *__cdecl __sbh_find_block(int a1);
char *__cdecl sub_452FA5(unsigned int a1, int a2);
// _DWORD __cdecl __sbh_alloc_block(_DWORD); weak
// _DWORD __cdecl __sbh_resize_block(_DWORD, _DWORD, _DWORD); weak
void **sub_453E9B();
int __cdecl sub_453FDF(LPVOID lpMem); // idb
void __cdecl sub_454035(int a1);
unsigned int __cdecl sub_4540F7(unsigned int a1, void ***a2, unsigned int *a3);
void __cdecl sub_45414E(int a1, int a2, _BYTE *a3);
char *__cdecl sub_454193(unsigned int a1);
int __cdecl sub_45439B(int a1, unsigned int a2, unsigned int a3);
signed int __cdecl sub_4544BF(int a1, int a2, _BYTE *a3, unsigned int a4);
// _DWORD __cdecl _callnewh(_DWORD); weak
// int _ioinit(void); weak
// int __initstdio();
// _DWORD __cdecl _lock_file(_DWORD); weak
// _DWORD __cdecl _unlock_file(_DWORD); weak
// __int32 __stdcall __CxxUnhandledExceptionFilter(struct _EXCEPTION_POINTERS *); idb
int (__stdcall *sub_45678B())();
LPTOP_LEVEL_EXCEPTION_FILTER sub_45679C();
void *__cdecl sub_4567A9(int a1, int a2);
// int _wincmdln(void); weak
// int _setenvp(void); weak
// int _setargv(void); weak
// int __crtGetEnvironmentStringsA(void); weak
// signed int __init_time();
// _DWORD __cdecl _get_lc_time(_DWORD); weak
// _DWORD __cdecl _free_lc_time(_DWORD); weak
int sub_457FCC();
// int __cdecl _strcmpi(const char *, const char *);
__int16 __cdecl sub_459225(wchar_t a1, FILE *a2);
// int __cdecl _putwc_lk(wchar_t, FILE *); idb
// char *__cdecl _getcwd(char *, int);
// int __cdecl _getdcwd_lk(CHAR FileName, int, int); idb
signed int __cdecl sub_459DB3(unsigned __int8 a1, int a2, unsigned __int8 a3);
// _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_45A964(int a1, int a2);
int __cdecl sub_45A97A(int a1, int a2);
int __cdecl sub_45AA0A(int a1, int a2);
int __cdecl sub_45AA65(int a1, int a2);
// _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// void __usercall sub_45C440(int a1@<ebp>);
// void __usercall sub_45C456(int a1@<ebp>);
// void __usercall sub_45C46C(int a1@<ebp>);
// void __usercall sub_45C47F(int a1@<ebp>);
// int __cdecl unknown_libname_269(int a1, int a2, int a3, int a4);
// void __usercall sub_45C495(int a1@<ebp>);
// void __usercall sub_45C4B0(int a1@<ebp>);
// void __usercall sub_45C4C6(int a1@<ebp>);
// void __usercall sub_45C4DC(int a1@<ebp>);
// void __usercall sub_45C4E8(int a1@<ebp>);
// void __usercall sub_45C4F4(int a1@<ebp>);
// void __usercall sub_45C50A(int a1@<ebp>);
// void __usercall sub_45C520(int a1@<ebp>);
// void __usercall sub_45C533(int a1@<ebp>);
// void __usercall sub_45C546(int a1@<ebp>);
// int __cdecl unknown_libname_277(int a1, int a2, int a3, int a4);
// void __usercall sub_45C559(int a1@<ebp>);
// int __usercall sub_45C570@<eax>(int a1@<ebp>);
// int __usercall sub_45C590@<eax>(int a1@<ebp>);
// int __usercall sub_45C5B0@<eax>(int a1@<ebp>);
// int __usercall sub_45C5BC@<eax>(int a1@<ebp>);
// int __usercall sub_45C5C8@<eax>(int a1@<ebp>);
// int __usercall sub_45C5D4@<eax>(int a1@<ebp>);
// int __cdecl Config::Load_SEH(int a1, int a2, int a3, int a4);
// int __usercall sub_45C5F0@<eax>(int a1@<ebp>);
// char *__usercall sub_45C60A@<eax>(int a1@<ebp>);
// int __usercall sub_45C620@<eax>(int a1@<ebp>);
// int __usercall sub_45C640@<eax>(int a1@<ebp>);
// int __usercall unknown_libname_286@<eax>(int a1@<ebp>);
// int __usercall sub_45C6B0@<eax>(int a1@<ebp>);
// int __usercall sub_45C6D0@<eax>(int a1@<ebp>);
// int __usercall sub_45C6F0@<eax>(int a1@<ebp>);
// void __usercall sub_45C720(int a1@<ebp>);
// int __usercall sub_45C740@<eax>(int a1@<ebp>);
// void __usercall sub_45C760(int a1@<ebp>);
int __cdecl SEH_40E6E3(int a1, int a2, int a3, int a4);
// UserInfoTable *__usercall sub_45C773@<eax>(int a1@<ebp>);
int __cdecl SEH_40EB66(int a1, int a2, int a3, int a4);
// UserInfoTable *__usercall sub_45C789@<eax>(int a1@<ebp>);
int __cdecl SEH_40EDD3(int a1, int a2, int a3, int a4);
// UserInfoTable *__usercall sub_45C79F@<eax>(int a1@<ebp>);
int __cdecl CSocketInt_SEH(int a1, int a2, int a3, int a4);
// void __usercall sub_45C7D0(int a1@<ebp>);
int __cdecl SEH_40FBBE(int a1, int a2, int a3, int a4);
// void __usercall sub_45C7E3(int a1@<ebp>);
int __cdecl SEH_40FC7A(int a1, int a2, int a3, int a4);
// void __usercall sub_45C7F6(int a1@<ebp>);
int __cdecl SEH_40FD0D(int a1, int a2, int a3, int a4);
// void __usercall sub_45C80C(int a1@<ebp>);
int __cdecl SEH_41070C(int a1, int a2, int a3, int a4);
// MemoryObject *__usercall sub_45C81F@<eax>(int a1@<ebp>);
// MemoryObject *__usercall sub_45C832@<eax>(int a1@<ebp>);
// int __cdecl unknown_libname_295(int a1, int a2, int a3, int a4);
// void __usercall sub_45C85A(int a1@<ebp>);
int __cdecl SEH_410D11(int a1, int a2, int a3, int a4);
// void __usercall sub_45C86D(int a1@<ebp>);
// int __usercall sub_45C880@<eax>(int a1@<ebp>);
// int __usercall sub_45C889@<eax>(int a1@<ebp>);
// void __usercall sub_45C8A0(int a1@<ebp>);
// void __usercall sub_45C8C0(int a1@<ebp>);
// int __usercall sub_45C8E0@<eax>(int a1@<ebp>);
// int __usercall sub_45C900@<eax>(int a1@<ebp>);
// void __usercall sub_45C920(int a1@<ebp>);
// MemoryObject *__usercall sub_45C940@<eax>(int a1@<ebp>);
// int __cdecl unknown_libname_304(int a1, int a2, int a3, int a4);
// MemoryObject *__usercall sub_45C953@<eax>(int a1@<ebp>);
// void __usercall sub_45C95C(int a1@<ebp>);
void sub_45C980();
void sub_45C993();
void sub_45C9A9();
void sub_45C9BC();
// void __usercall sub_45C9D0(int a1@<ebp>);
// MemoryObject *__usercall sub_45C9F0@<eax>(int a1@<ebp>);
// MemoryObject *__usercall sub_45CA03@<eax>(int a1@<ebp>);
// MemoryObject *__usercall sub_45CA16@<eax>(int a1@<ebp>);
// int __cdecl unknown_libname_313(int a1, int a2, int a3, int a4);
// MemoryObject *__usercall sub_45CA29@<eax>(int a1@<ebp>);
// void __usercall sub_45CA32(int a1@<ebp>);
// void __usercall sub_45CA51(int a1@<ebp>);
// int __usercall sub_45CA70@<eax>(int a1@<ebp>);
// int __usercall sub_45CA90@<eax>(int a1@<ebp>);
// int __usercall sub_45CAB0@<eax>(int a1@<ebp>);
// int __usercall sub_45CAD0@<eax>(int a1@<ebp>);
// MemoryObject *__usercall sub_45CAF0@<eax>(int a1@<ebp>);
// MemoryObject *__usercall sub_45CB03@<eax>(int a1@<ebp>);
// void __usercall sub_45CB16(int a1@<ebp>);
// std::vector_IPRange *__usercall sub_45CB30@<eax>(int a1@<ebp>);
// int __usercall sub_45CB43@<eax>(int a1@<ebp>);
// std::vector_IPRange *__usercall sub_45CB60@<eax>(int a1@<ebp>);
// int __usercall sub_45CB80@<eax>(int a1@<ebp>);
// char *__usercall sub_45CB9A@<eax>(int a1@<ebp>);
// int __usercall sub_45CBA6@<eax>(int a1@<ebp>);
// char *__usercall sub_45CBC0@<eax>(int a1@<ebp>);
// int __usercall sub_45CBE9@<eax>(int a1@<ebp>);
// int __usercall sub_45CC00@<eax>(int a1@<ebp>);
// int __usercall sub_45CC30@<eax>(int a1@<ebp>);
// int __usercall sub_45CC50@<eax>(int a1@<ebp>);
// int __cdecl unknown_libname_332(int a1, int a2, int a3, int a4);
// int __usercall sub_45CC79@<eax>(int a1@<ebp>);
// int __usercall sub_45CC90@<eax>(int a1@<ebp>);
// void __usercall sub_45CC99(int a1@<ebp>);
// int __usercall sub_45CCC0@<eax>(int a1@<ebp>);
// void __usercall sub_45CCE9(int a1@<ebp>);
// int __usercall sub_45CD09@<eax>(int a1@<ebp>);
// int __usercall sub_45CD12@<eax>(int a1@<ebp>);
// int __usercall sub_45CD30@<eax>(int a1@<ebp>);
// int __usercall unknown_libname_340@<eax>(int a1@<ebp>);
// void __usercall sub_45CD59(int a1@<ebp>);
// int __usercall sub_45CD70@<eax>(int a1@<ebp>);
// int __usercall sub_45CD79@<eax>(int a1@<ebp>);
// int __usercall sub_45CD82@<eax>(int a1@<ebp>);
// int __usercall sub_45CDB9@<eax>(int a1@<ebp>);
// int __usercall sub_45CDD0@<eax>(int a1@<ebp>);
// int __cdecl unknown_libname_343(int a1, int a2, int a3, int a4);
// int __usercall sub_45CDF0@<eax>(int a1@<ebp>);
// int __usercall sub_45CE10@<eax>(int a1@<ebp>);
// int __usercall sub_45CE30@<eax>(int a1@<ebp>);
// void __usercall sub_45CE50(int a1@<ebp>);
// int __usercall sub_45CE65@<eax>(int a1@<ebp>);
// void __usercall sub_45CE71(int a1@<ebp>);
// void __usercall sub_45CE7D(int a1@<ebp>);
// int __usercall sub_45CE93@<eax>(int a1@<ebp>);
// void __usercall sub_45CE9F(int a1@<ebp>);
// void __usercall sub_45CEAB(int a1@<ebp>);
// void __usercall unknown_libname_350(int a1@<ebp>);
// MemoryObject *__usercall sub_45CED6@<eax>(int a1@<ebp>);
// int __cdecl unknown_libname_351(int a1, int a2, int a3, int a4);
// MemoryObject *__usercall sub_45CEE9@<eax>(int a1@<ebp>);
// int __usercall sub_45CF00@<eax>(int a1@<ebp>);
// int __usercall sub_45CF20@<eax>(int a1@<ebp>);
// int __usercall sub_45CF40@<eax>(int a1@<ebp>);
// int __usercall sub_45CF60@<eax>(int a1@<ebp>);
// void __usercall sub_45CF80(int a1@<ebp>);
// int __usercall sub_45CF8C@<eax>(int a1@<ebp>);
// std::vector_MemoryObject *__usercall sub_45CF98@<eax>(int a1@<ebp>);
// std::vector_CIOTimer *__usercall sub_45CFA4@<eax>(int a1@<ebp>);
// void __usercall sub_45CFB0(int a1@<ebp>);
// void __usercall sub_45CFC5(int a1@<ebp>);
// int __usercall sub_45CFD1@<eax>(int a1@<ebp>);
// std::vector_MemoryObject *__usercall sub_45CFDD@<eax>(int a1@<ebp>);
// int __cdecl unknown_libname_358(int a1, int a2, int a3, int a4);
// void __usercall sub_45D000(int a1@<ebp>);
// MemoryObject *__usercall sub_45D015@<eax>(int a1@<ebp>);
// MemoryObject *__usercall sub_45D028@<eax>(int a1@<ebp>);
// void __usercall sub_45D050(int a1@<ebp>);
// void __usercall sub_45D070(int a1@<ebp>);
// void __usercall sub_45D0B0(int a1@<ebp>);
// void __usercall sub_45D0C6(int a1@<ebp>);
// int __cdecl unknown_libname_368(int a1, int a2, int a3, int a4);
// void __usercall sub_45D0DC(int a1@<ebp>);
// void __usercall sub_45D0EF(int a1@<ebp>);
int sub_45D110();
// void __usercall sub_45D130(int a1@<ebp>);
// void __usercall sub_45D150(int a1@<ebp>);
// void __usercall sub_45D170(int a1@<ebp>);
// std::vector_ServerInfo *__usercall sub_45D190@<eax>(int a1@<ebp>);
// std::vector_ServerInfo *__usercall sub_45D1A6@<eax>(int a1@<ebp>);
// void __usercall sub_45D1B2(int a1@<ebp>);
// int __cdecl unknown_libname_376(int a1, int a2, int a3, int a4);
// void __usercall sub_45D1C8(int a1@<ebp>);
// void __usercall sub_45D1D4(int a1@<ebp>);
// void __usercall sub_45D1EC(int a1@<ebp>);
// void __usercall sub_45D1F8(int a1@<ebp>);
// void __usercall sub_45D210(int a1@<ebp>);
// UserInfoTable *__usercall sub_45D230@<eax>(int a1@<ebp>);
// void __usercall sub_45D23C(int a1@<ebp>);
// void __usercall sub_45D252(int a1@<ebp>);
int __cdecl SEH_43925D(int a1, int a2, int a3, int a4);
// void __usercall sub_45D265(int a1@<ebp>);
int __cdecl SEH_439436(int a1, int a2, int a3, int a4);
// MemoryObject *__usercall sub_45D278@<eax>(int a1@<ebp>);
// void __usercall sub_45D2A0(int a1@<ebp>);
// MemoryObject *__usercall sub_45D2CA@<eax>(int a1@<ebp>);
// MemoryObject *__usercall sub_45D2DD@<eax>(int a1@<ebp>);
// int __usercall sub_45D322@<eax>(int a1@<ebp>);
// int __usercall sub_45D32D@<eax>(int a1@<ebp>);
// int __usercall sub_45D338@<eax>(int a1@<ebp>);
// int __usercall sub_45D37E@<eax>(int a1@<ebp>);
// int __usercall sub_45D389@<eax>(int a1@<ebp>);
// int __usercall sub_45D394@<eax>(int a1@<ebp>);
// int __usercall sub_45D3C0@<eax>(int a1@<ebp>);
// char *__usercall sub_45D412@<eax>(int a1@<ebp>);
int sub_45D428();
// void __usercall sub_45D43C(int a1@<ebp>);
// void __usercall sub_45D450(int a1@<ebp>);
// void __usercall sub_45D464(int a1@<ebp>);
// void __usercall sub_45D478(int a1@<ebp>);
// int __usercall sub_45D48C@<eax>(int a1@<ebp>);
int sub_45D4B8();
// void __usercall sub_45D4CC(int a1@<ebp>);
// int unknown_libname_396();
int sub_45D4E8();
int sub_45D4F0();
// int __usercall sub_45D504@<eax>(int a1@<ebp>);
// void __usercall sub_45D50C(int a1@<ebp>);
// int __usercall sub_45D520@<eax>(int a1@<ebp>);
// void *__usercall sub_45D534@<eax>(int a1@<ebp>);
// void *__usercall sub_45D548@<eax>(int a1@<ebp>);
// int __usercall sub_45D550@<eax>(int a1@<ebp>);
// int __usercall sub_45D55B@<eax>(int a1@<ebp>);
int sub_45D570();
// void __usercall sub_45D584(int a1@<ebp>);
int sub_45D598();
// int __usercall sub_45D5B6@<eax>(int a1@<ebp>);
// int __usercall sub_45D5D2@<eax>(int a1@<ebp>);
int sub_45D5DA();
int sub_45D5E2();
// int __usercall sub_45D5FE@<eax>(int a1@<ebp>);
int sub_45D606();
int sub_45D60E();
// void __usercall sub_45D620(int a1@<ebp>);
// int __usercall sub_45D63C@<eax>(int a1@<ebp>);
// void __usercall sub_45D644(int a1@<ebp>);
// int __usercall sub_45D64E@<eax>(int a1@<ebp>);
// void __usercall sub_45D678(int a1@<ebp>);
// int __usercall sub_45D682@<eax>(int a1@<ebp>);
// void __usercall sub_45D68A(int a1@<ebp>);
// void *__usercall sub_45D694@<eax>(int a1@<ebp>);
int sub_45D69C();
// int __usercall sub_45D6B8@<eax>(int a1@<ebp>);
// int __usercall sub_45D6C3@<eax>(int a1@<ebp>);
// int __usercall sub_45D6CB@<eax>(int a1@<ebp>);
// int __usercall sub_45D6D3@<eax>(int a1@<ebp>);
// int __usercall sub_45D6E8@<eax>(int a1@<ebp>);
// int __usercall sub_45D704@<eax>(int a1@<ebp>);
// int __usercall sub_45D70F@<eax>(int a1@<ebp>);
// int __usercall sub_45D71A@<eax>(int a1@<ebp>);
// int __usercall sub_45D738@<eax>(int a1@<ebp>);
// int __usercall sub_45D743@<eax>(int a1@<ebp>);
// int __usercall sub_45D74E@<eax>(int a1@<ebp>);
// int __usercall sub_45D76C@<eax>(int a1@<ebp>);
// int __usercall sub_45D777@<eax>(int a1@<ebp>);
int sub_45D794();
int sub_45D79C();
int sub_45D7A4();
// int __usercall sub_45D7AC@<eax>(int a1@<ebp>);
// int __usercall sub_45D7C0@<eax>(int a1@<ebp>);
// int __usercall sub_45D7D4@<eax>(int a1@<ebp>);
// int __usercall sub_45D7E8@<eax>(int a1@<ebp>);
// int __usercall sub_45D7FC@<eax>(int a1@<ebp>);
// int __usercall sub_45D810@<eax>(int a1@<ebp>);
// int __usercall sub_45D824@<eax>(int a1@<ebp>);
// int __usercall sub_45D838@<eax>(int a1@<ebp>);
// int __usercall sub_45D84C@<eax>(int a1@<ebp>);
int sub_45D868();
int sub_45D870();
int sub_45D878();
int sub_45D894();
// int __usercall sub_45D8A8@<eax>(int a1@<ebp>);
int sub_45D8C4();
// void __usercall sub_45D8E0(int a1@<ebp>);
// void *__usercall sub_45D8EA@<eax>(int a1@<ebp>);
// void __usercall sub_45D904(int a1@<ebp>);
// void *__usercall sub_45D90E@<eax>(int a1@<ebp>);
// void __usercall sub_45D928(int a1@<ebp>);
int sub_45D93C();
// int __usercall sub_45D958@<eax>(int a1@<ebp>);
// int __usercall sub_45D96C@<eax>(int a1@<ebp>);
// int __usercall sub_45D980@<eax>(int a1@<ebp>);
// int __usercall sub_45D994@<eax>(int a1@<ebp>);
// int __usercall sub_45D9A8@<eax>(int a1@<ebp>);
// int __usercall sub_45D9BC@<eax>(int a1@<ebp>);
// int __usercall sub_45D9D0@<eax>(int a1@<ebp>);
// void __usercall sub_45D9EC(int a1@<ebp>);
// void *__usercall sub_45D9F6@<eax>(int a1@<ebp>);
// void __usercall sub_45D9FE(int a1@<ebp>);
// void __usercall sub_45DA08(int a1@<ebp>);
// void __usercall sub_45DA10(int a1@<ebp>);
// void __usercall sub_45DA1A(int a1@<ebp>);
// void __usercall sub_45DA24(int a1@<ebp>);
// void __usercall sub_45DA2E(int a1@<ebp>);
// void __usercall sub_45DA36(int a1@<ebp>);
// void __usercall sub_45DA40(int a1@<ebp>);
// void __usercall sub_45DA48(int a1@<ebp>);
int sub_45DA60();
int sub_45DA7C();
void sub_45DA84();
void sub_45DA8C();
// int __usercall sub_45DA94@<eax>(int a1@<ebp>);
// int __usercall sub_45DAA8@<eax>(int a1@<ebp>);
// int __usercall sub_45DABC@<eax>(int a1@<ebp>);
// int __usercall sub_45DAD0@<eax>(int a1@<ebp>);
// int __usercall sub_45DAE4@<eax>(int a1@<ebp>);
// int __usercall sub_45DAF8@<eax>(int a1@<ebp>);
// int __usercall sub_45DB0C@<eax>(int a1@<ebp>);
// int __usercall sub_45DB20@<eax>(int a1@<ebp>);
// int __usercall sub_45DB34@<eax>(int a1@<ebp>);
void sub_45DB50();
void sub_45DB58();
void sub_45DB60();
// int __usercall sub_45DB7C@<eax>(int a1@<ebp>);
int sub_45DBA8();
void sub_45DBBC();
void sub_45DBD0();
void sub_45DBEC();
int sub_45DC08();
// int __usercall sub_45DC1C@<eax>(int a1@<ebp>);
int sub_45DC38();
// int __usercall sub_45DC54@<eax>(int a1@<ebp>);
// int __usercall sub_45DC5C@<eax>(int a1@<ebp>);
void sub_45DC64();
void sub_45DC6C();
int sub_45DC74();
int sub_45DC7F();
void sub_45DC87();
void sub_45DC92();
void sub_45DC9D();
void sub_45DCA8();
void sub_45DCB3();
void sub_45DCBE();
void sub_45DCC9();
// int __usercall sub_45DCD1@<eax>(int a1@<ebp>);
// int __usercall sub_45DCFC@<eax>(int a1@<ebp>);
// int __usercall sub_45DD04@<eax>(int a1@<ebp>);
int sub_45DD0C();
void sub_45DD17();
void sub_45DD1F();
void sub_45DD27();
void sub_45DD2F();
void sub_45DD3A();
// void __usercall sub_45DD4C(int a1@<ebp>);
// void __usercall sub_45DD74(int a1@<ebp>);
// void __usercall sub_45DD90(int a1@<ebp>);
// void *__usercall sub_45DD9A@<eax>(int a1@<ebp>);
// void __usercall sub_45DDB4(int a1@<ebp>);
// void *__usercall sub_45DDBE@<eax>(int a1@<ebp>);
// void __usercall sub_45DDD8(int a1@<ebp>);
// void __usercall sub_45DDF4(int a1@<ebp>);
// void __usercall sub_45DE10(int a1@<ebp>);
// void __usercall sub_45DE2C(int a1@<ebp>);
// void *__usercall sub_45DE36@<eax>(int a1@<ebp>);
// void __usercall sub_45DE50(int a1@<ebp>);
// void *__usercall sub_45DE5A@<eax>(int a1@<ebp>);
// void __usercall sub_45DE74(int a1@<ebp>);
// void __usercall sub_45DE90(int a1@<ebp>);
// int __usercall unknown_libname_435@<eax>(int a1@<ebp>);
// void __usercall sub_45DEAC(int a1@<ebp>);
// int __usercall unknown_libname_436@<eax>(int a1@<ebp>);
// void __usercall sub_45DEC8(int a1@<ebp>);
// int __usercall unknown_libname_437@<eax>(int a1@<ebp>);
// void __usercall sub_45DEE4(int a1@<ebp>);
// int __usercall sub_45DEF8@<eax>(int a1@<ebp>, int a2);
int sub_45DF0C();
// int __usercall sub_45DF20@<eax>(int a1@<ebp>);
// void __usercall sub_45DF34(int a1@<ebp>);
// void __usercall sub_45DF3C(int a1@<ebp>);
// int __usercall sub_45DF5C@<eax>(int a1@<ebp>);
// void *__usercall sub_45DF70@<eax>(int a1@<ebp>);
// void __usercall unknown_libname_439(int a1@<ebp>);
// int __usercall sub_45DF8C@<eax>(int a1@<ebp>);
// void __usercall unknown_libname_440(int a1@<ebp>);
// int __usercall sub_45DFA8@<eax>(int a1@<ebp>);
// int __usercall sub_45DFBC@<eax>(int a1@<ebp>);
// int __usercall sub_45DFD0@<eax>(int a1@<ebp>);
// int __usercall sub_45DFE4@<eax>(int a1@<ebp>);
// int __usercall sub_45DFF8@<eax>(int a1@<ebp>);
// int __usercall sub_45E00C@<eax>(int a1@<ebp>);
// int __usercall sub_45E020@<eax>(int a1@<ebp>);
// int __usercall sub_45E034@<eax>(int a1@<ebp>);
// int __usercall sub_45E048@<eax>(int a1@<ebp>);
// int __usercall sub_45E05C@<eax>(int a1@<ebp>);
// int __usercall sub_45E070@<eax>(int a1@<ebp>);
// int __usercall sub_45E084@<eax>(int a1@<ebp>);
// int __usercall sub_45E098@<eax>(int a1@<ebp>);
// int __usercall sub_45E0AC@<eax>(int a1@<ebp>);
// int __usercall sub_45E0C8@<eax>(int a1@<ebp>);
// int __usercall sub_45E0DC@<eax>(int a1@<ebp>);
// int __usercall sub_45E0F0@<eax>(int a1@<ebp>);
// int __usercall sub_45E104@<eax>(int a1@<ebp>);
// int __usercall sub_45E118@<eax>(int a1@<ebp>);
// int __usercall sub_45E12C@<eax>(int a1@<ebp>);
// int __usercall sub_45E140@<eax>(int a1@<ebp>);
// int __usercall sub_45E154@<eax>(int a1@<ebp>);
// int __usercall sub_45E168@<eax>(int a1@<ebp>);
// int __usercall sub_45E17C@<eax>(int a1@<ebp>);
// int __usercall sub_45E190@<eax>(int a1@<ebp>);
// int __usercall sub_45E1A4@<eax>(int a1@<ebp>);
// int __usercall sub_45E1B8@<eax>(int a1@<ebp>);
// int __usercall sub_45E1CC@<eax>(int a1@<ebp>);
// int __usercall unknown_libname_442@<eax>(int a1@<ebp>);
// void __usercall sub_45E1E8(int a1@<ebp>);
// void __usercall sub_45E1F2(int a1@<ebp>);
// void __usercall sub_45E1FA(int a1@<ebp>);
// void __usercall sub_45E204(int a1@<ebp>);
// void __usercall sub_45E20E(int a1@<ebp>);
// void __usercall sub_45E218(int a1@<ebp>);
// void __usercall sub_45E220(int a1@<ebp>);
// void __usercall sub_45E22A(int a1@<ebp>);
// void __usercall sub_45E232(int a1@<ebp>);
// int unknown_libname_443();
// int __usercall sub_45E250@<eax>(int a1@<ebp>);
int sub_45E27C();
int sub_45E290();
int sub_45E2A4();
// int __usercall unknown_libname_445@<eax>(int a1@<ebp>);
int sub_45E2C0();
int sub_45E2D4();
// int __usercall sub_45E2F0@<eax>(int a1@<ebp>);
// int __usercall sub_45E2F8@<eax>(int a1@<ebp>);
int sub_45E300();
int sub_45E308();
int sub_45E310();
int sub_45E31B();
int sub_45E323();
int sub_45E32E();
int sub_45E339();
int sub_45E344();
int sub_45E34F();
int sub_45E35A();
int sub_45E365();
// int __usercall sub_45E380@<eax>(int a1@<ebp>);
// int __usercall sub_45E388@<eax>(int a1@<ebp>);
int sub_45E390();
int sub_45E39B();
int sub_45E3A3();
int sub_45E3AB();
int sub_45E3B3();
int sub_45E3BE();
// void __usercall sub_45E3D0(int a1@<ebp>);
// void __usercall sub_45E3EC(int a1@<ebp>);
// int __usercall unknown_libname_449@<eax>(int a1@<ebp>);
// void __usercall sub_45E408(int a1@<ebp>);
// void __usercall sub_45E424(int a1@<ebp>);
// void *__usercall sub_45E42E@<eax>(int a1@<ebp>);
// void __usercall sub_45E448(int a1@<ebp>);
// void *__usercall sub_45E452@<eax>(int a1@<ebp>);
// void __usercall sub_45E46C(int a1@<ebp>);
// void __usercall sub_45E488(int a1@<ebp>);
// void __usercall sub_45E4A4(int a1@<ebp>);
// void __usercall sub_45E4C0(int a1@<ebp>);
// void *__usercall sub_45E4D4@<eax>(int a1@<ebp>);
// int __usercall sub_45E4F0@<eax>(int a1@<ebp>);
// int __usercall sub_45E50C@<eax>(int a1@<ebp>);
// void __usercall sub_45E520(int a1@<ebp>);
// void __usercall sub_45E528(int a1@<ebp>);
// int __usercall sub_45E540@<eax>(int a1@<ebp>);
// int __usercall sub_45E554@<eax>(int a1@<ebp>);
// int __usercall sub_45E568@<eax>(int a1@<ebp>);
// int __usercall sub_45E57C@<eax>(int a1@<ebp>);
// int __usercall sub_45E590@<eax>(int a1@<ebp>);
// int __usercall sub_45E5A4@<eax>(int a1@<ebp>);
// int __usercall sub_45E5B8@<eax>(int a1@<ebp>);
// int __usercall sub_45E5CC@<eax>(int a1@<ebp>);
// void __usercall unknown_libname_458(int a1@<ebp>);
// int __usercall sub_45E5E8@<eax>(int a1@<ebp>);
// int __usercall sub_45E5FC@<eax>(int a1@<ebp>);
// int __usercall sub_45E610@<eax>(int a1@<ebp>);
// int __usercall sub_45E624@<eax>(int a1@<ebp>);
// int __usercall sub_45E638@<eax>(int a1@<ebp>);
// int __usercall sub_45E64C@<eax>(int a1@<ebp>);
// int __usercall sub_45E660@<eax>(int a1@<ebp>);
// int __usercall sub_45E674@<eax>(int a1@<ebp>);
// int __usercall sub_45E688@<eax>(int a1@<ebp>);
// BOOL __stdcall GetUserNameA(LPSTR lpBuffer, LPDWORD pcbBuffer);
// LSTATUS __stdcall RegCreateKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
// LSTATUS __stdcall RegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// LSTATUS __stdcall RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// LSTATUS __stdcall RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// LSTATUS __stdcall RegCloseKey(HKEY hKey);
// int __stdcall GetObjectA(HANDLE h, int c, LPVOID pv);
// HFONT __stdcall CreateFontA(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCSTR pszFaceName);
// HGDIOBJ __stdcall GetStockObject(int i);
// HGDIOBJ __stdcall SelectObject(HDC hdc, HGDIOBJ h);
// BOOL __stdcall GetTextExtentPoint32A(HDC hdc, LPCSTR lpString, int c, LPSIZE psizl);
// COLORREF __stdcall SetTextColor(HDC hdc, COLORREF color);
// BOOL __stdcall TextOutA(HDC hdc, int x, int y, LPCSTR lpString, int c);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// DWORD __stdcall GetCurrentThreadId();
// void __stdcall GetLocalTime(LPSYSTEMTIME lpSystemTime);
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// void __stdcall OutputDebugStringA(LPCSTR lpOutputString);
// void __stdcall GetSystemInfo(LPSYSTEM_INFO lpSystemInfo);
// BOOL __stdcall GetFileTime(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime);
// DWORD __stdcall GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);
// BOOL __stdcall FileTimeToDosDateTime(const FILETIME *lpFileTime, LPWORD lpFatDate, LPWORD lpFatTime);
// BOOL __stdcall FileTimeToLocalFileTime(const FILETIME *lpFileTime, LPFILETIME lpLocalFileTime);
// void __stdcall GlobalMemoryStatus(LPMEMORYSTATUS lpBuffer);
// LPSTR __stdcall lstrcpyA(LPSTR lpString1, LPCSTR lpString2);
// void __stdcall GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime);
// LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// void __stdcall InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall __noreturn ExitProcess(UINT uExitCode);
// BOOL __stdcall PostQueuedCompletionStatus(HANDLE CompletionPort, DWORD dwNumberOfBytesTransferred, ULONG_PTR dwCompletionKey, LPOVERLAPPED lpOverlapped);
// LONG __stdcall InterlockedExchange(volatile LONG *Target, LONG Value);
// BOOL __stdcall InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount);
// HANDLE __stdcall CreateTimerQueue();
// BOOL __stdcall DeleteTimerQueueEx(HANDLE TimerQueue, HANDLE CompletionEvent);
// BOOL __stdcall QueueUserWorkItem(LPTHREAD_START_ROUTINE Function, PVOID Context, ULONG Flags);
// DWORD __stdcall GetLastError();
// HANDLE __stdcall CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads);
// DWORD __stdcall WaitForMultipleObjects(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
// BOOL __stdcall SetEvent(HANDLE hEvent);
// HANDLE __stdcall CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);
// BOOL __stdcall SetProcessPriorityBoost(HANDLE hProcess, BOOL bDisablePriorityBoost);
// BOOL __stdcall SwitchToThread();
// HANDLE __stdcall CreateSemaphoreA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName);
// DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
// BOOL __stdcall ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);
// BOOL __stdcall HeapDestroy(HANDLE hHeap);
// BOOL __stdcall DeleteFileA(LPCSTR lpFileName);
// void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// BOOL __stdcall VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// LPVOID __stdcall HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);
// HLOCAL __stdcall LocalFree(HLOCAL hMem);
// DWORD __stdcall FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments);
// BOOL __stdcall GetQueuedCompletionStatus(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred, PULONG_PTR lpCompletionKey, LPOVERLAPPED *lpOverlapped, DWORD dwMilliseconds);
// int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// BOOL __stdcall GetDiskFreeSpaceExA(LPCSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes);
// SIZE_T __stdcall VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
// BOOL __stdcall IsBadWritePtr(LPVOID lp, UINT_PTR ucb);
// int __stdcall lstrlenA(LPCSTR lpString);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// HANDLE __stdcall GetCurrentThread();
// HANDLE __stdcall GetCurrentProcess();
// DWORD __stdcall GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// void __stdcall Sleep(DWORD dwMilliseconds);
// DWORD __stdcall GetTickCount();
// LONG __stdcall InterlockedIncrement(volatile LONG *lpAddend);
// BOOL __stdcall CreateTimerQueueTimer(PHANDLE phNewTimer, HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, ULONG Flags);
// LONG __stdcall InterlockedDecrement(volatile LONG *lpAddend);
// BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// HANDLE __stdcall HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
// BOOL __stdcall GetVersionExA(LPOSVERSIONINFOA lpVersionInformation);
// BOOL __stdcall DeleteTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent);
// DWORD __stdcall GetEnvironmentVariableA(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize);
// SIZE_T __stdcall HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);
// void __stdcall GetStartupInfoA(LPSTARTUPINFOA lpStartupInfo);
// DWORD __stdcall GetVersion();
// LPSTR __stdcall GetCommandLine();
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// void __stdcall GetAcceptExSockaddrs(PVOID lpOutputBuffer, DWORD dwReceiveDataLength, DWORD dwLocalAddressLength, DWORD dwRemoteAddressLength, struct sockaddr **LocalSockaddr, LPINT LocalSockaddrLength, struct sockaddr **RemoteSockaddr, LPINT RemoteSockaddrLength);
// BOOL __stdcall AcceptEx(SOCKET sListenSocket, SOCKET sAcceptSocket, PVOID lpOutputBuffer, DWORD dwReceiveDataLength, DWORD dwLocalAddressLength, DWORD dwRemoteAddressLength, LPDWORD lpdwBytesReceived, LPOVERLAPPED lpOverlapped);
// SQLRETURN __stdcall SQLFreeStmt(SQLHSTMT StatementHandle, SQLUSMALLINT Option);
// SQLRETURN __stdcall SQLGetDiagRec(SQLSMALLINT HandleType, SQLHANDLE Handle, SQLSMALLINT RecNumber, SQLCHAR *Sqlstate, SQLINTEGER *NativeError, SQLCHAR *MessageText, SQLSMALLINT BufferLength, SQLSMALLINT *TextLength);
// SQLRETURN __stdcall SQLFetch(SQLHSTMT StatementHandle);
// SQLRETURN __stdcall SQLDriverConnect(SQLHDBC hdbc, SQLHWND hwnd, SQLCHAR *szConnStrIn, SQLSMALLINT cchConnStrIn, SQLCHAR *szConnStrOut, SQLSMALLINT cchConnStrOutMax, SQLSMALLINT *pcchConnStrOut, SQLUSMALLINT fDriverCompletion);
// SQLRETURN __stdcall SQLBindParameter(SQLHSTMT hstmt, SQLUSMALLINT ipar, SQLSMALLINT fParamType, SQLSMALLINT fCType, SQLSMALLINT fSqlType, SQLUINTEGER cbColDef, SQLSMALLINT ibScale, SQLPOINTER rgbValue, SQLINTEGER cbValueMax, SQLINTEGER *pcbValue);
// SQLRETURN __stdcall SQLExecDirect(SQLHSTMT StatementHandle, SQLCHAR *StatementText, SQLINTEGER TextLength);
// BOOL __stdcall ShowWindow(HWND hWnd, int nCmdShow);
// INT_PTR __stdcall DialogBoxParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
// BOOL __stdcall EndDialog(HWND hDlg, INT_PTR nResult);
// BOOL __stdcall SetWindowTextA(HWND hWnd, LPCSTR lpString);
// LRESULT __stdcall SendDlgItemMessageA(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam);
// int __stdcall wvsprintfA(LPSTR, LPCSTR, va_list arglist);
// int wsprintfA(LPSTR, LPCSTR, ...);
// LRESULT __stdcall DefWindowProcA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// BOOL __stdcall MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint);
// LRESULT __stdcall DispatchMessageA(const MSG *lpMsg);
// BOOL __stdcall TranslateMessage(const MSG *lpMsg);
// BOOL __stdcall GetMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
// UINT_PTR __stdcall SetTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc);
// BOOL __stdcall UpdateWindow(HWND hWnd);
// HWND __stdcall CreateWindowExA(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// ATOM __stdcall RegisterClassExA(const WNDCLASSEXA *);
// HCURSOR __stdcall LoadCursorA(HINSTANCE hInstance, LPCSTR lpCursorName);
// int __stdcall MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
// HWND __stdcall FindWindowA(LPCSTR lpClassName, LPCSTR lpWindowName);
// BOOL __stdcall DestroyWindow(HWND hWnd);
// BOOL __stdcall EndPaint(HWND hWnd, const PAINTSTRUCT *lpPaint);
// int __stdcall FillRect(HDC hDC, const RECT *lprc, HBRUSH hbr);
// BOOL __stdcall GetClientRect(HWND hWnd, LPRECT lpRect);
// HDC __stdcall BeginPaint(HWND hWnd, LPPAINTSTRUCT lpPaint);
// HWND __stdcall CreateDialogParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
// void __stdcall PostQuitMessage(int nExitCode);
// BOOL __stdcall InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase);
// struct hostent *__stdcall gethostbyname(const char *name);
// int __stdcall recv(SOCKET s, char *buf, int len, int flags);
// int __stdcall bind(SOCKET s, const struct sockaddr *name, int namelen);
// char *__stdcall inet_ntoa(struct in_addr in);
// unsigned __int32 __stdcall inet_addr(const char *cp);
// int __stdcall setsockopt(SOCKET s, int level, int optname, const char *optval, int optlen);
// int __stdcall WSACleanup();
// SOCKET __stdcall socket(int af, int type, int protocol);
// int __stdcall WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);
// BOOL __stdcall WSACloseEvent(HANDLE hEvent);
// int __stdcall WSAEventSelect(SOCKET s, HANDLE hEventObject, __int32 lNetworkEvents);
// HANDLE __stdcall WSACreateEvent();
// int __stdcall listen(SOCKET s, int backlog);
// u_long __stdcall htonl(u_long hostlong);
// int __stdcall WSAGetLastError();
// SOCKET __stdcall accept(SOCKET s, struct sockaddr *addr, int *addrlen);
// BOOL __stdcall WSAResetEvent(HANDLE hEvent);
// int __stdcall WSASend(SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesSent, DWORD dwFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
// int __stdcall WSARecv(SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesRecvd, LPDWORD lpFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
// int __stdcall send(SOCKET s, const char *buf, int len, int flags);
// int __stdcall getsockname(SOCKET s, struct sockaddr *name, int *namelen);
// u_short __stdcall htons(u_short hostshort);
// int __stdcall connect(SOCKET s, const struct sockaddr *name, int namelen);
// int __stdcall closesocket(SOCKET s);
// BOOL __stdcall SymGetSymFromAddr(HANDLE hProcess, DWORD dwAddr, PDWORD pdwDisplacement, PIMAGEHLP_SYMBOL Symbol);
// BOOL __stdcall StackWalk(DWORD MachineType, HANDLE hProcess, HANDLE hThread, LPSTACKFRAME StackFrame, PVOID ContextRecord, PREAD_PROCESS_MEMORY_ROUTINE ReadMemoryRoutine, PFUNCTION_TABLE_ACCESS_ROUTINE FunctionTableAccessRoutine, PGET_MODULE_BASE_ROUTINE GetModuleBaseRoutine, PTRANSLATE_ADDRESS_ROUTINE TranslateAddress);
// PVOID __stdcall SymFunctionTableAccess(HANDLE hProcess, DWORD AddrBase);
// DWORD __stdcall SymGetModuleBase(HANDLE hProcess, DWORD dwAddr);
// DWORD __stdcall SymSetOptions(DWORD SymOptions);
// BOOL __stdcall SymCleanup(HANDLE hProcess);
// BOOL __stdcall SymInitialize(HANDLE hProcess, PCSTR UserSearchPath, BOOL fInvadeProcess);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_441B73; // weak
_UNKNOWN loc_441D4D; // weak
_UNKNOWN loc_441D54; // weak
_UNKNOWN loc_4455F6; // weak
_UNKNOWN loc_4456CD; // weak
int (__stdcall *UserInfoTable_vtable_off_45F38C[2])(int) = { &UserInfoTable::DeletingDtor, &UserManager::DeletingDtor }; // weak
int (__stdcall *UserManager_vtable_off_45F390)(int) = &UserManager::DeletingDtor; // weak
_UNKNOWN unk_45F3D4; // weak
_UNKNOWN unk_45F3DC; // weak
_UNKNOWN unk_45F3E8; // weak
int (__stdcall *CSocketInt_vptr_off_45F3EC)(int) = &CSocketInt::CallDtor; // weak
int (__stdcall *GameServSocket_vtable_off_45F484)(int) = &WorldSrvSocket::CallDtor; // weak
int (__stdcall *Database_vtable_45F4B0)(int) = &Database::DestructorCall; // weak
int (__stdcall *CIOBuffer_vtable_off_45F51C[2])(int) = { &CallCIOBufferDestructor, &MemoryObject::DeletingDestructor }; // weak
MemoryObject_VTABLE_45F520 MemoryObject_vftable_offset_45F520 =
{
  &MemoryObject::DeletingDestructor,
  &MemoryObject::OnIOCallback_empty,
  &MemoryObject::OnTimerCallback,
  &MemoryObject::AddTimer,
  &MemoryObject::OnWaitCallback,
  &MemoryObject::RegisterWait,
  4298256,
  4293869,
  &MemoryObject::OnTimerCallback
};
int (__stdcall *CIOServerBase_vftable_offset_45F538)(int) = &CIOServer::DeletingDestructor; // weak
int (__stdcall *WorldServServer_vftable_offset_45F574)(int) = &WorldSrvServer::DeletingDestructor; // weak
int (__stdcall *CIOServerInt_vftable_off_45F590)(int) = &CIOServerInt::DestructorCall; // weak
int (__stdcall *UserLoginServer_vtable_off_45F5AC)(int) = &CAuthServer::DeletingDestructor; // weak
int (__stdcall *CIOSocket_vtable_off_45F5C8)(int) = &CallCIOSocketDestructor; // weak
int (__stdcall *WorldSrvPacket_vtable_off_45F5F4)(int) = &WorldSrvPacket::CallDestructor; // weak
int (__stdcall *off_45F60C[2])(int) = { &sub_41EDD0, &std::strstream::`scalar deleting destructor' }; // weak
int (__stdcall *off_45F610)(int) = &std::strstream::`scalar deleting destructor'; // weak
_UNKNOWN unk_45F614; // weak
int (__stdcall *off_45F61C[3])(int) =
{
  &sub_41FCF0,
  &std::basic_filebuf<char,std::char_traits<char>>::overflow,
  &std::basic_filebuf<char,std::char_traits<char>>::pbackfail
}; // weak
int (__stdcall *IPPacket_vtable_off_45F668)(int) = &IPPacket::DeletingDestructor; // weak
int (__stdcall *IPSessionDB_vtable_offset_45F7DC[2])(int) = { &IPSessionDB::DestructorCall, &IPSocket::DeletingDestructor }; // weak
int (__stdcall *IPSocket_vtable_off_45F7E0)(int) = &IPSocket::DeletingDestructor; // weak
int (__stdcall *CIOTimerInstance_vftable)(int) = &CIOTimerInstance::DeletingDestructor; // weak
int (__stdcall *LogWindow_vftable_off_45F854)(int) = &LogWindow::DeletingDestructor; // weak
int (__cdecl *FileLog_vtable_off_45F858[2])(int, int, char *, char) = { &FileLog::write, &GeneralLog::write }; // weak
int (__cdecl *GeneralLog_vtable_off_45F85C)(int, int, char *, char) = &GeneralLog::write; // weak
int (__stdcall *CLogPacket_vtable_off_45F860)(int) = &CLogPacket::DeletingDestructor; // weak
int (__stdcall *CLogSocket_VTABLE_off_45F8B4)(int) = &CLogSocket::CallDtor; // weak
int (__stdcall *off_45F8E0[2])(int) = { &MemoryAllocatorsCallDestructor, &CAuthPacket::CallDTor }; // weak
int (__stdcall *CAuthPacket_vtable_off_45F8E4)(int) = &CAuthPacket::CallDTor; // weak
int (__stdcall *StatusLine_vtable_offset_45F8FC)(int) = &StatusLine::CallDestructor; // weak
int (__stdcall *ServerList_vtable_off_45F90C)(int) = &ServerList::CallDestructor; // weak
_UNKNOWN unk_45F91C; // weak
ServerFrameList_Vtable ServerFrameList_vtable_off_45F920 = { &ServerFrameList::DeletingDestructor };
int (__stdcall *ServerDB_vtable_off_45F924)(int) = &ServerTableCallDestructor; // weak
int (__stdcall *CAuthSocket_vtable_offset_0045F944)(int) = &CAuthSocket::DeletingDestructor; // weak
int (__stdcall *CWantedPacket_vtable_off_45F9DC)(int) = &CWantedPacket::DeletingDestructor; // weak
int (__stdcall *CSocketWanted_vtable_off_45FA14)(int) = &CWantedSocket::DeletingDestructor; // weak
int (__stdcall *std::basic_istream<char,std::char_traits<char>>::`vftable'{for `std::basic_ios<char,std::char_traits<char>>'})(int) = &sub_40BB60; // weak
int (__stdcall *std::istrstream::`vftable'{for `std::basic_ios<char,std::char_traits<char>>'})(int) = &std::istrstream::`scalar deleting destructor'; // weak
int (__stdcall *std::strstreambuf::`vftable')(int) = &std::strstreambuf::`scalar deleting destructor'; // weak
int (__stdcall *std::basic_streambuf<char,std::char_traits<char>>::`vftable'[3])(int) = { &sub_40BBA0, &unknown_libname_22, &unknown_libname_23 }; // weak
int (__stdcall *std::basic_ios<char,std::char_traits<char>>::`vftable')(int) = &sub_40BB30; // weak
int (__stdcall *std::basic_ostream<char,std::char_traits<char>>::`vftable'{for `std::basic_ios<char,std::char_traits<char>>'})(char) = &sub_43D414; // weak
_UNKNOWN unk_45FAF8; // weak
int (__stdcall *std::ios_base::failure::`vftable')(char) = &sub_43D6F0; // weak
int (__stdcall *std::runtime_error::`vftable')(char) = &sub_43D61D; // weak
int (__stdcall *std::locale::facet::`vftable')(int) = &sub_423600; // weak
int (__stdcall *std::length_error::`vftable')(char) = &sub_43E019; // weak
int (__stdcall *std::logic_error::`vftable')(int) = &sub_435740; // weak
int (__stdcall *std::out_of_range::`vftable')(int) = &sub_435860; // weak
int (__stdcall *std::codecvt<char,char,int>::`vftable')(int) = &sub_423F00; // weak
int (__stdcall *std::numpunct<char>::`vftable')(char) = &sub_43F925; // weak
int (__stdcall *std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::`vftable')(char) = &sub_43F902; // weak
int (__stdcall *std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::`vftable')(char) = &sub_43F8DF; // weak
int (__stdcall *std::ctype<char>::`vftable')(int) = &sub_423890; // weak
int (__stdcall *std::bad_cast::`vftable')(int) = &sub_423400; // weak
int (__stdcall *std::bad_alloc::`vftable')(char) = &sub_4415E3; // weak
int (__stdcall *std::codecvt<unsigned short,char,int>::`vftable')(char) = &sub_441D2A; // weak
int (__stdcall *std::time_put<unsigned short,std::ostreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::`vftable')(char) = &sub_443692; // weak
int (__stdcall *std::time_get<unsigned short,std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::`vftable')(char) = &sub_443836; // weak
int (__stdcall *std::moneypunct<unsigned short,1>::`vftable')(char) = &sub_44381A; // weak
int (__stdcall *std::moneypunct<unsigned short,0>::`vftable')(char) = &sub_4437FE; // weak
int (__stdcall *std::money_put<unsigned short,std::ostreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::`vftable')(char) = &sub_4437DB; // weak
int (__stdcall *std::money_get<unsigned short,std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::`vftable')(char) = &sub_4437B8; // weak
int (__stdcall *std::messages<unsigned short>::`vftable')(char) = &sub_443779; // weak
int (__stdcall *std::collate<unsigned short>::`vftable')(char) = &sub_443756; // weak
int (__stdcall *std::numpunct<unsigned short>::`vftable')(char) = &sub_44370E; // weak
int (__stdcall *std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::`vftable')(char) = &sub_4436EB; // weak
int (__stdcall *std::num_get<unsigned short,std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::`vftable')(char) = &sub_4436C8; // weak
int (__stdcall *std::ctype<unsigned short>::`vftable')(char) = &sub_443656; // weak
_UNKNOWN unk_45FF28; // weak
int (__stdcall *std::_Mpunct<unsigned short>::`vftable')(char) = &sub_4438AE; // weak
int (__stdcall *std::time_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::`vftable')(char) = &sub_4486DF; // weak
int (__stdcall *std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::`vftable')(char) = &sub_4486A0; // weak
int (__stdcall *std::moneypunct<char,1>::`vftable')(char) = &sub_448684; // weak
int (__stdcall *std::moneypunct<char,0>::`vftable')(char) = &sub_448668; // weak
int (__stdcall *std::money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::`vftable')(char) = &sub_448645; // weak
int (__stdcall *std::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::`vftable')(char) = &sub_448622; // weak
int (__stdcall *std::messages<char>::`vftable')(char) = &sub_4485E3; // weak
int (__stdcall *std::collate<char>::`vftable')(char) = &sub_4485C0; // weak
int (__stdcall *std::_Mpunct<char>::`vftable')(char) = &sub_44874E; // weak
int (__stdcall *exception::`vftable')(char) = &sub_44DBEE; // weak
_UNKNOWN unk_462ED8; // weak
_UNKNOWN unk_463570; // weak
_UNKNOWN unk_4635E0; // weak
_UNKNOWN unk_463A58; // weak
_UNKNOWN unk_463AC8; // weak
_UNKNOWN unk_463D10; // weak
_UNKNOWN unk_464490; // weak
char aSelectReasonMs[] = " Select reason, msg From block_msg with (nolock) Where uid = %d"; // idb
wchar_t aS[] = L"%S"; // idb
char aCallDbo_ap_gst[] = "{CALL dbo.ap_GStat (?,?,?,?,?,?,?,?,?,?) }"; // idb
char aSelectSsnFromU[] = "Select ssn From user_info with (nolock) Where account = '%s'"; // idb
char aCallDbo_ap_gpw[] = "{CALL dbo.ap_GPwd (?,?) }"; // idb
char aCallDbo_ap_g_0[] = "{CALL dbo.ap_GPwdWithFlag(?,?,?) }"; // idb
char aCallDbo_ap_sne[] = "{CALL dbo.ap_SNewPwd(?,?) }"; // idb
char aWantedUserLogo[] = "Wanted User LogOut, %s"; // idb
char aCb[] = "cb"; // idb
char aCc__1[] = "cc"; // idb
char aCdsdddd[] = "cdsdddd"; // idb
char aCc_0[] = "cc"; // idb
char aCddddddddd[] = "cddddddddd"; // idb
char aCdcs[] = "cdcs"; // idb
char aCc_1[] = "cc"; // idb
char aCdcs_0[] = "cdcs"; // idb
char aCdcs_1[] = "cdcs"; // idb
char aCc_2[] = "cc"; // idb
char aCb_0[] = "cb"; // idb
char aD_D_D_D[] = "%d.%d.%d.%d"; // idb
char aCallDbo_ap_slo[] = "{CALL dbo.ap_SLog (?,?,?,?,?,?) }"; // idb
char aDDDDDDDDDDDDSD[] = "%d-%d-%d %d:%d:%d,%d-%d-%d %d:%d:%d,%s,%d,%s,%d,%d,%d,%06d%07d,%d,%d,%d,%d\r\n"; // idb
char aCallDbo_ap_sus[] = "{CALL dbo.ap_SUserTime (?,?) }"; // idb
char aCallDbo_ap_log[] = "{CALL dbo.ap_LogoutWithPoint( ?,?,? )}"; // idb
char aCc_3[] = "cc"; // idb
char aCallDbo_ap_gus[] = "{CALL dbo.ap_GUserTime (?,?) }"; // idb
char aCc_4[] = "cc"; // idb
char aSelectUser_dat[] = "SELECT user_data FROM user_data with (nolock) WHERE  uid = %d"; // idb
char aCdsdddbd[] = "cdsdddbd"; // idb
char aCdsdddd_0[] = "cdsdddd"; // idb
char aCc_5[] = "cc"; // idb
char aCc_6[] = "cc"; // idb
char aSelectUser_cha[] = "SELECT user_char_num FROM user_data with (nolock) WHERE uid = %d"; // idb
char aInsertIntoUser[] = "INSERT INTO user_char ( uid, world_id, char_id ) values ( %d, %d, %d)"; // idb
char aUpdateUser_dat[] = "update user_data set user_char_num = user_char_num + 1 WHERE uid = %d"; // idb
char aCallDbo_ap_del[] = "{CALL dbo.ap_delchar (?,?,?) }"; // idb
char aUpdateUser_cha[] = "UPDATE user_char set char_id=%d, world_id=%d WHERE uid =%d and char_id = %d and world_id = %d"; // idb
unsigned int BF::initial_pary[18] =
{
  608135816u,
  2242054355u,
  320440878u,
  57701188u,
  2752067618u,
  698298832u,
  137296536u,
  3964562569u,
  1160258022u,
  953160567u,
  3193202383u,
  887688300u,
  3232508343u,
  3380367581u,
  1065670069u,
  3041331479u,
  2450970073u,
  2306472731u
};
unsigned int BF::initial_sbox[4][256] =
{
  {
    3509652390u,
    2564797868u,
    805139163u,
    3491422135u,
    3101798381u,
    1780907670u,
    3128725573u,
    4046225305u,
    614570311u,
    3012652279u,
    134345442u,
    2240740374u,
    1667834072u,
    1901547113u,
    2757295779u,
    4103290238u,
    227898511u,
    1921955416u,
    1904987480u,
    2182433518u,
    2069144605u,
    3260701109u,
    2620446009u,
    720527379u,
    3318853667u,
    677414384u,
    3393288472u,
    3101374703u,
    2390351024u,
    1614419982u,
    1822297739u,
    2954791486u,
    3608508353u,
    3174124327u,
    2024746970u,
    1432378464u,
    3864339955u,
    2857741204u,
    1464375394u,
    1676153920u,
    1439316330u,
    715854006u,
    3033291828u,
    289532110u,
    2706671279u,
    2087905683u,
    3018724369u,
    1668267050u,
    732546397u,
    1947742710u,
    3462151702u,
    2609353502u,
    2950085171u,
    1814351708u,
    2050118529u,
    680887927u,
    999245976u,
    1800124847u,
    3300911131u,
    1713906067u,
    1641548236u,
    4213287313u,
    1216130144u,
    1575780402u,
    4018429277u,
    3917837745u,
    3693486850u,
    3949271944u,
    596196993u,
    3549867205u,
    258830323u,
    2213823033u,
    772490370u,
    2760122372u,
    1774776394u,
    2652871518u,
    566650946u,
    4142492826u,
    1728879713u,
    2882767088u,
    1783734482u,
    3629395816u,
    2517608232u,
    2874225571u,
    1861159788u,
    326777828u,
    3124490320u,
    2130389656u,
    2716951837u,
    967770486u,
    1724537150u,
    2185432712u,
    2364442137u,
    1164943284u,
    2105845187u,
    998989502u,
    3765401048u,
    2244026483u,
    1075463327u,
    1455516326u,
    1322494562u,
    910128902u,
    469688178u,
    1117454909u,
    936433444u,
    3490320968u,
    3675253459u,
    1240580251u,
    122909385u,
    2157517691u,
    634681816u,
    4142456567u,
    3825094682u,
    3061402683u,
    2540495037u,
    79693498u,
    3249098678u,
    1084186820u,
    1583128258u,
    426386531u,
    1761308591u,
    1047286709u,
    322548459u,
    995290223u,
    1845252383u,
    2603652396u,
    3431023940u,
    2942221577u,
    3202600964u,
    3727903485u,
    1712269319u,
    422464435u,
    3234572375u,
    1170764815u,
    3523960633u,
    3117677531u,
    1434042557u,
    442511882u,
    3600875718u,
    1076654713u,
    1738483198u,
    4213154764u,
    2393238008u,
    3677496056u,
    1014306527u,
    4251020053u,
    793779912u,
    2902807211u,
    842905082u,
    4246964064u,
    1395751752u,
    1040244610u,
    2656851899u,
    3396308128u,
    445077038u,
    3742853595u,
    3577915638u,
    679411651u,
    2892444358u,
    2354009459u,
    1767581616u,
    3150600392u,
    3791627101u,
    3102740896u,
    284835224u,
    4246832056u,
    1258075500u,
    768725851u,
    2589189241u,
    3069724005u,
    3532540348u,
    1274779536u,
    3789419226u,
    2764799539u,
    1660621633u,
    3471099624u,
    4011903706u,
    913787905u,
    3497959166u,
    737222580u,
    2514213453u,
    2928710040u,
    3937242737u,
    1804850592u,
    3499020752u,
    2949064160u,
    2386320175u,
    2390070455u,
    2415321851u,
    4061277028u,
    2290661394u,
    2416832540u,
    1336762016u,
    1754252060u,
    3520065937u,
    3014181293u,
    791618072u,
    3188594551u,
    3933548030u,
    2332172193u,
    3852520463u,
    3043980520u,
    413987798u,
    3465142937u,
    3030929376u,
    4245938359u,
    2093235073u,
    3534596313u,
    375366246u,
    2157278981u,
    2479649556u,
    555357303u,
    3870105701u,
    2008414854u,
    3344188149u,
    4221384143u,
    3956125452u,
    2067696032u,
    3594591187u,
    2921233993u,
    2428461u,
    544322398u,
    577241275u,
    1471733935u,
    610547355u,
    4027169054u,
    1432588573u,
    1507829418u,
    2025931657u,
    3646575487u,
    545086370u,
    48609733u,
    2200306550u,
    1653985193u,
    298326376u,
    1316178497u,
    3007786442u,
    2064951626u,
    458293330u,
    2589141269u,
    3591329599u,
    3164325604u,
    727753846u,
    2179363840u,
    146436021u,
    1461446943u,
    4069977195u,
    705550613u,
    3059967265u,
    3887724982u,
    4281599278u,
    3313849956u,
    1404054877u,
    2845806497u,
    146425753u,
    1854211946u
  },
  {
    1266315497u,
    3048417604u,
    3681880366u,
    3289982499u,
    2909710000u,
    1235738493u,
    2632868024u,
    2414719590u,
    3970600049u,
    1771706367u,
    1449415276u,
    3266420449u,
    422970021u,
    1963543593u,
    2690192192u,
    3826793022u,
    1062508698u,
    1531092325u,
    1804592342u,
    2583117782u,
    2714934279u,
    4024971509u,
    1294809318u,
    4028980673u,
    1289560198u,
    2221992742u,
    1669523910u,
    35572830u,
    157838143u,
    1052438473u,
    1016535060u,
    1802137761u,
    1753167236u,
    1386275462u,
    3080475397u,
    2857371447u,
    1040679964u,
    2145300060u,
    2390574316u,
    1461121720u,
    2956646967u,
    4031777805u,
    4028374788u,
    33600511u,
    2920084762u,
    1018524850u,
    629373528u,
    3691585981u,
    3515945977u,
    2091462646u,
    2486323059u,
    586499841u,
    988145025u,
    935516892u,
    3367335476u,
    2599673255u,
    2839830854u,
    265290510u,
    3972581182u,
    2759138881u,
    3795373465u,
    1005194799u,
    847297441u,
    406762289u,
    1314163512u,
    1332590856u,
    1866599683u,
    4127851711u,
    750260880u,
    613907577u,
    1450815602u,
    3165620655u,
    3734664991u,
    3650291728u,
    3012275730u,
    3704569646u,
    1427272223u,
    778793252u,
    1343938022u,
    2676280711u,
    2052605720u,
    1946737175u,
    3164576444u,
    3914038668u,
    3967478842u,
    3682934266u,
    1661551462u,
    3294938066u,
    4011595847u,
    840292616u,
    3712170807u,
    616741398u,
    312560963u,
    711312465u,
    1351876610u,
    322626781u,
    1910503582u,
    271666773u,
    2175563734u,
    1594956187u,
    70604529u,
    3617834859u,
    1007753275u,
    1495573769u,
    4069517037u,
    2549218298u,
    2663038764u,
    504708206u,
    2263041392u,
    3941167025u,
    2249088522u,
    1514023603u,
    1998579484u,
    1312622330u,
    694541497u,
    2582060303u,
    2151582166u,
    1382467621u,
    776784248u,
    2618340202u,
    3323268794u,
    2497899128u,
    2784771155u,
    503983604u,
    4076293799u,
    907881277u,
    423175695u,
    432175456u,
    1378068232u,
    4145222326u,
    3954048622u,
    3938656102u,
    3820766613u,
    2793130115u,
    2977904593u,
    26017576u,
    3274890735u,
    3194772133u,
    1700274565u,
    1756076034u,
    4006520079u,
    3677328699u,
    720338349u,
    1533947780u,
    354530856u,
    688349552u,
    3973924725u,
    1637815568u,
    332179504u,
    3949051286u,
    53804574u,
    2852348879u,
    3044236432u,
    1282449977u,
    3583942155u,
    3416972820u,
    4006381244u,
    1617046695u,
    2628476075u,
    3002303598u,
    1686838959u,
    431878346u,
    2686675385u,
    1700445008u,
    1080580658u,
    1009431731u,
    832498133u,
    3223435511u,
    2605976345u,
    2271191193u,
    2516031870u,
    1648197032u,
    4164389018u,
    2548247927u,
    300782431u,
    375919233u,
    238389289u,
    3353747414u,
    2531188641u,
    2019080857u,
    1475708069u,
    455242339u,
    2609103871u,
    448939670u,
    3451063019u,
    1395535956u,
    2413381860u,
    1841049896u,
    1491858159u,
    885456874u,
    4264095073u,
    4001119347u,
    1565136089u,
    3898914787u,
    1108368660u,
    540939232u,
    1173283510u,
    2745871338u,
    3681308437u,
    4207628240u,
    3343053890u,
    4016749493u,
    1699691293u,
    1103962373u,
    3625875870u,
    2256883143u,
    3830138730u,
    1031889488u,
    3479347698u,
    1535977030u,
    4236805024u,
    3251091107u,
    2132092099u,
    1774941330u,
    1199868427u,
    1452454533u,
    157007616u,
    2904115357u,
    342012276u,
    595725824u,
    1480756522u,
    206960106u,
    497939518u,
    591360097u,
    863170706u,
    2375253569u,
    3596610801u,
    1814182875u,
    2094937945u,
    3421402208u,
    1082520231u,
    3463918190u,
    2785509508u,
    435703966u,
    3908032597u,
    1641649973u,
    2842273706u,
    3305899714u,
    1510255612u,
    2148256476u,
    2655287854u,
    3276092548u,
    4258621189u,
    236887753u,
    3681803219u,
    274041037u,
    1734335097u,
    3815195456u,
    3317970021u,
    1899903192u,
    1026095262u,
    4050517792u,
    356393447u,
    2410691914u,
    3873677099u,
    3682840055u
  },
  {
    3913112168u,
    2491498743u,
    4132185628u,
    2489919796u,
    1091903735u,
    1979897079u,
    3170134830u,
    3567386728u,
    3557303409u,
    857797738u,
    1136121015u,
    1342202287u,
    507115054u,
    2535736646u,
    337727348u,
    3213592640u,
    1301675037u,
    2528481711u,
    1895095763u,
    1721773893u,
    3216771564u,
    62756741u,
    2142006736u,
    835421444u,
    2531993523u,
    1442658625u,
    3659876326u,
    2882144922u,
    676362277u,
    1392781812u,
    170690266u,
    3921047035u,
    1759253602u,
    3611846912u,
    1745797284u,
    664899054u,
    1329594018u,
    3901205900u,
    3045908486u,
    2062866102u,
    2865634940u,
    3543621612u,
    3464012697u,
    1080764994u,
    553557557u,
    3656615353u,
    3996768171u,
    991055499u,
    499776247u,
    1265440854u,
    648242737u,
    3940784050u,
    980351604u,
    3713745714u,
    1749149687u,
    3396870395u,
    4211799374u,
    3640570775u,
    1161844396u,
    3125318951u,
    1431517754u,
    545492359u,
    4268468663u,
    3499529547u,
    1437099964u,
    2702547544u,
    3433638243u,
    2581715763u,
    2787789398u,
    1060185593u,
    1593081372u,
    2418618748u,
    4260947970u,
    69676912u,
    2159744348u,
    86519011u,
    2512459080u,
    3838209314u,
    1220612927u,
    3339683548u,
    133810670u,
    1090789135u,
    1078426020u,
    1569222167u,
    845107691u,
    3583754449u,
    4072456591u,
    1091646820u,
    628848692u,
    1613405280u,
    3757631651u,
    526609435u,
    236106946u,
    48312990u,
    2942717905u,
    3402727701u,
    1797494240u,
    859738849u,
    992217954u,
    4005476642u,
    2243076622u,
    3870952857u,
    3732016268u,
    765654824u,
    3490871365u,
    2511836413u,
    1685915746u,
    3888969200u,
    1414112111u,
    2273134842u,
    3281911079u,
    4080962846u,
    172450625u,
    2569994100u,
    980381355u,
    4109958455u,
    2819808352u,
    2716589560u,
    2568741196u,
    3681446669u,
    3329971472u,
    1835478071u,
    660984891u,
    3704678404u,
    4045999559u,
    3422617507u,
    3040415634u,
    1762651403u,
    1719377915u,
    3470491036u,
    2693910283u,
    3642056355u,
    3138596744u,
    1364962596u,
    2073328063u,
    1983633131u,
    926494387u,
    3423689081u,
    2150032023u,
    4096667949u,
    1749200295u,
    3328846651u,
    309677260u,
    2016342300u,
    1779581495u,
    3079819751u,
    111262694u,
    1274766160u,
    443224088u,
    298511866u,
    1025883608u,
    3806446537u,
    1145181785u,
    168956806u,
    3641502830u,
    3584813610u,
    1689216846u,
    3666258015u,
    3200248200u,
    1692713982u,
    2646376535u,
    4042768518u,
    1618508792u,
    1610833997u,
    3523052358u,
    4130873264u,
    2001055236u,
    3610705100u,
    2202168115u,
    4028541809u,
    2961195399u,
    1006657119u,
    2006996926u,
    3186142756u,
    1430667929u,
    3210227297u,
    1314452623u,
    4074634658u,
    4101304120u,
    2273951170u,
    1399257539u,
    3367210612u,
    3027628629u,
    1190975929u,
    2062231137u,
    2333990788u,
    2221543033u,
    2438960610u,
    1181637006u,
    548689776u,
    2362791313u,
    3372408396u,
    3104550113u,
    3145860560u,
    296247880u,
    1970579870u,
    3078560182u,
    3769228297u,
    1714227617u,
    3291629107u,
    3898220290u,
    166772364u,
    1251581989u,
    493813264u,
    448347421u,
    195405023u,
    2709975567u,
    677966185u,
    3703036547u,
    1463355134u,
    2715995803u,
    1338867538u,
    1343315457u,
    2802222074u,
    2684532164u,
    233230375u,
    2599980071u,
    2000651841u,
    3277868038u,
    1638401717u,
    4028070440u,
    3237316320u,
    6314154u,
    819756386u,
    300326615u,
    590932579u,
    1405279636u,
    3267499572u,
    3150704214u,
    2428286686u,
    3959192993u,
    3461946742u,
    1862657033u,
    1266418056u,
    963775037u,
    2089974820u,
    2263052895u,
    1917689273u,
    448879540u,
    3550394620u,
    3981727096u,
    150775221u,
    3627908307u,
    1303187396u,
    508620638u,
    2975983352u,
    2726630617u,
    1817252668u,
    1876281319u,
    1457606340u,
    908771278u,
    3720792119u,
    3617206836u,
    2455994898u,
    1729034894u,
    1080033504u
  },
  {
    976866871u,
    3556439503u,
    2881648439u,
    1522871579u,
    1555064734u,
    1336096578u,
    3548522304u,
    2579274686u,
    3574697629u,
    3205460757u,
    3593280638u,
    3338716283u,
    3079412587u,
    564236357u,
    2993598910u,
    1781952180u,
    1464380207u,
    3163844217u,
    3332601554u,
    1699332808u,
    1393555694u,
    1183702653u,
    3581086237u,
    1288719814u,
    691649499u,
    2847557200u,
    2895455976u,
    3193889540u,
    2717570544u,
    1781354906u,
    1676643554u,
    2592534050u,
    3230253752u,
    1126444790u,
    2770207658u,
    2633158820u,
    2210423226u,
    2615765581u,
    2414155088u,
    3127139286u,
    673620729u,
    2805611233u,
    1269405062u,
    4015350505u,
    3341807571u,
    4149409754u,
    1057255273u,
    2012875353u,
    2162469141u,
    2276492801u,
    2601117357u,
    993977747u,
    3918593370u,
    2654263191u,
    753973209u,
    36408145u,
    2530585658u,
    25011837u,
    3520020182u,
    2088578344u,
    530523599u,
    2918365339u,
    1524020338u,
    1518925132u,
    3760827505u,
    3759777254u,
    1202760957u,
    3985898139u,
    3906192525u,
    674977740u,
    4174734889u,
    2031300136u,
    2019492241u,
    3983892565u,
    4153806404u,
    3822280332u,
    352677332u,
    2297720250u,
    60907813u,
    90501309u,
    3286998549u,
    1016092578u,
    2535922412u,
    2839152426u,
    457141659u,
    509813237u,
    4120667899u,
    652014361u,
    1966332200u,
    2975202805u,
    55981186u,
    2327461051u,
    676427537u,
    3255491064u,
    2882294119u,
    3433927263u,
    1307055953u,
    942726286u,
    933058658u,
    2468411793u,
    3933900994u,
    4215176142u,
    1361170020u,
    2001714738u,
    2830558078u,
    3274259782u,
    1222529897u,
    1679025792u,
    2729314320u,
    3714953764u,
    1770335741u,
    151462246u,
    3013232138u,
    1682292957u,
    1483529935u,
    471910574u,
    1539241949u,
    458788160u,
    3436315007u,
    1807016891u,
    3718408830u,
    978976581u,
    1043663428u,
    3165965781u,
    1927990952u,
    4200891579u,
    2372276910u,
    3208408903u,
    3533431907u,
    1412390302u,
    2931980059u,
    4132332400u,
    1947078029u,
    3881505623u,
    4168226417u,
    2941484381u,
    1077988104u,
    1320477388u,
    886195818u,
    18198404u,
    3786409000u,
    2509781533u,
    112762804u,
    3463356488u,
    1866414978u,
    891333506u,
    18488651u,
    661792760u,
    1628790961u,
    3885187036u,
    3141171499u,
    876946877u,
    2693282273u,
    1372485963u,
    791857591u,
    2686433993u,
    3759982718u,
    3167212022u,
    3472953795u,
    2716379847u,
    445679433u,
    3561995674u,
    3504004811u,
    3574258232u,
    54117162u,
    3331405415u,
    2381918588u,
    3769707343u,
    4154350007u,
    1140177722u,
    4074052095u,
    668550556u,
    3214352940u,
    367459370u,
    261225585u,
    2610173221u,
    4209349473u,
    3468074219u,
    3265815641u,
    314222801u,
    3066103646u,
    3808782860u,
    282218597u,
    3406013506u,
    3773591054u,
    379116347u,
    1285071038u,
    846784868u,
    2669647154u,
    3771962079u,
    3550491691u,
    2305946142u,
    453669953u,
    1268987020u,
    3317592352u,
    3279303384u,
    3744833421u,
    2610507566u,
    3859509063u,
    266596637u,
    3847019092u,
    517658769u,
    3462560207u,
    3443424879u,
    370717030u,
    4247526661u,
    2224018117u,
    4143653529u,
    4112773975u,
    2788324899u,
    2477274417u,
    1456262402u,
    2901442914u,
    1517677493u,
    1846949527u,
    2295493580u,
    3734397586u,
    2176403920u,
    1280348187u,
    1908823572u,
    3871786941u,
    846861322u,
    1172426758u,
    3287448474u,
    3383383037u,
    1655181056u,
    3139813346u,
    901632758u,
    1897031941u,
    2986607138u,
    3066810236u,
    3447102507u,
    1393639104u,
    373351379u,
    950779232u,
    625454576u,
    3124240540u,
    4148612726u,
    2007998917u,
    544563296u,
    2244738638u,
    2330496472u,
    2058025392u,
    1291430526u,
    424198748u,
    50039436u,
    29584100u,
    3605783033u,
    2429876329u,
    2791104160u,
    1057563949u,
    3255363231u,
    3075367218u,
    3463963227u,
    1469046755u,
    985887462u
  }
};
unsigned int BF::pary[18] =
{
  608135816u,
  2242054355u,
  320440878u,
  57701188u,
  2752067618u,
  698298832u,
  137296536u,
  3964562569u,
  1160258022u,
  953160567u,
  3193202383u,
  887688300u,
  3232508343u,
  3380367581u,
  1065670069u,
  3041331479u,
  2450970073u,
  2306472731u
};
unsigned int BF::sbox[4][256] =
{
  {
    3509652390u,
    2564797868u,
    805139163u,
    3491422135u,
    3101798381u,
    1780907670u,
    3128725573u,
    4046225305u,
    614570311u,
    3012652279u,
    134345442u,
    2240740374u,
    1667834072u,
    1901547113u,
    2757295779u,
    4103290238u,
    227898511u,
    1921955416u,
    1904987480u,
    2182433518u,
    2069144605u,
    3260701109u,
    2620446009u,
    720527379u,
    3318853667u,
    677414384u,
    3393288472u,
    3101374703u,
    2390351024u,
    1614419982u,
    1822297739u,
    2954791486u,
    3608508353u,
    3174124327u,
    2024746970u,
    1432378464u,
    3864339955u,
    2857741204u,
    1464375394u,
    1676153920u,
    1439316330u,
    715854006u,
    3033291828u,
    289532110u,
    2706671279u,
    2087905683u,
    3018724369u,
    1668267050u,
    732546397u,
    1947742710u,
    3462151702u,
    2609353502u,
    2950085171u,
    1814351708u,
    2050118529u,
    680887927u,
    999245976u,
    1800124847u,
    3300911131u,
    1713906067u,
    1641548236u,
    4213287313u,
    1216130144u,
    1575780402u,
    4018429277u,
    3917837745u,
    3693486850u,
    3949271944u,
    596196993u,
    3549867205u,
    258830323u,
    2213823033u,
    772490370u,
    2760122372u,
    1774776394u,
    2652871518u,
    566650946u,
    4142492826u,
    1728879713u,
    2882767088u,
    1783734482u,
    3629395816u,
    2517608232u,
    2874225571u,
    1861159788u,
    326777828u,
    3124490320u,
    2130389656u,
    2716951837u,
    967770486u,
    1724537150u,
    2185432712u,
    2364442137u,
    1164943284u,
    2105845187u,
    998989502u,
    3765401048u,
    2244026483u,
    1075463327u,
    1455516326u,
    1322494562u,
    910128902u,
    469688178u,
    1117454909u,
    936433444u,
    3490320968u,
    3675253459u,
    1240580251u,
    122909385u,
    2157517691u,
    634681816u,
    4142456567u,
    3825094682u,
    3061402683u,
    2540495037u,
    79693498u,
    3249098678u,
    1084186820u,
    1583128258u,
    426386531u,
    1761308591u,
    1047286709u,
    322548459u,
    995290223u,
    1845252383u,
    2603652396u,
    3431023940u,
    2942221577u,
    3202600964u,
    3727903485u,
    1712269319u,
    422464435u,
    3234572375u,
    1170764815u,
    3523960633u,
    3117677531u,
    1434042557u,
    442511882u,
    3600875718u,
    1076654713u,
    1738483198u,
    4213154764u,
    2393238008u,
    3677496056u,
    1014306527u,
    4251020053u,
    793779912u,
    2902807211u,
    842905082u,
    4246964064u,
    1395751752u,
    1040244610u,
    2656851899u,
    3396308128u,
    445077038u,
    3742853595u,
    3577915638u,
    679411651u,
    2892444358u,
    2354009459u,
    1767581616u,
    3150600392u,
    3791627101u,
    3102740896u,
    284835224u,
    4246832056u,
    1258075500u,
    768725851u,
    2589189241u,
    3069724005u,
    3532540348u,
    1274779536u,
    3789419226u,
    2764799539u,
    1660621633u,
    3471099624u,
    4011903706u,
    913787905u,
    3497959166u,
    737222580u,
    2514213453u,
    2928710040u,
    3937242737u,
    1804850592u,
    3499020752u,
    2949064160u,
    2386320175u,
    2390070455u,
    2415321851u,
    4061277028u,
    2290661394u,
    2416832540u,
    1336762016u,
    1754252060u,
    3520065937u,
    3014181293u,
    791618072u,
    3188594551u,
    3933548030u,
    2332172193u,
    3852520463u,
    3043980520u,
    413987798u,
    3465142937u,
    3030929376u,
    4245938359u,
    2093235073u,
    3534596313u,
    375366246u,
    2157278981u,
    2479649556u,
    555357303u,
    3870105701u,
    2008414854u,
    3344188149u,
    4221384143u,
    3956125452u,
    2067696032u,
    3594591187u,
    2921233993u,
    2428461u,
    544322398u,
    577241275u,
    1471733935u,
    610547355u,
    4027169054u,
    1432588573u,
    1507829418u,
    2025931657u,
    3646575487u,
    545086370u,
    48609733u,
    2200306550u,
    1653985193u,
    298326376u,
    1316178497u,
    3007786442u,
    2064951626u,
    458293330u,
    2589141269u,
    3591329599u,
    3164325604u,
    727753846u,
    2179363840u,
    146436021u,
    1461446943u,
    4069977195u,
    705550613u,
    3059967265u,
    3887724982u,
    4281599278u,
    3313849956u,
    1404054877u,
    2845806497u,
    146425753u,
    1854211946u
  },
  {
    1266315497u,
    3048417604u,
    3681880366u,
    3289982499u,
    2909710000u,
    1235738493u,
    2632868024u,
    2414719590u,
    3970600049u,
    1771706367u,
    1449415276u,
    3266420449u,
    422970021u,
    1963543593u,
    2690192192u,
    3826793022u,
    1062508698u,
    1531092325u,
    1804592342u,
    2583117782u,
    2714934279u,
    4024971509u,
    1294809318u,
    4028980673u,
    1289560198u,
    2221992742u,
    1669523910u,
    35572830u,
    157838143u,
    1052438473u,
    1016535060u,
    1802137761u,
    1753167236u,
    1386275462u,
    3080475397u,
    2857371447u,
    1040679964u,
    2145300060u,
    2390574316u,
    1461121720u,
    2956646967u,
    4031777805u,
    4028374788u,
    33600511u,
    2920084762u,
    1018524850u,
    629373528u,
    3691585981u,
    3515945977u,
    2091462646u,
    2486323059u,
    586499841u,
    988145025u,
    935516892u,
    3367335476u,
    2599673255u,
    2839830854u,
    265290510u,
    3972581182u,
    2759138881u,
    3795373465u,
    1005194799u,
    847297441u,
    406762289u,
    1314163512u,
    1332590856u,
    1866599683u,
    4127851711u,
    750260880u,
    613907577u,
    1450815602u,
    3165620655u,
    3734664991u,
    3650291728u,
    3012275730u,
    3704569646u,
    1427272223u,
    778793252u,
    1343938022u,
    2676280711u,
    2052605720u,
    1946737175u,
    3164576444u,
    3914038668u,
    3967478842u,
    3682934266u,
    1661551462u,
    3294938066u,
    4011595847u,
    840292616u,
    3712170807u,
    616741398u,
    312560963u,
    711312465u,
    1351876610u,
    322626781u,
    1910503582u,
    271666773u,
    2175563734u,
    1594956187u,
    70604529u,
    3617834859u,
    1007753275u,
    1495573769u,
    4069517037u,
    2549218298u,
    2663038764u,
    504708206u,
    2263041392u,
    3941167025u,
    2249088522u,
    1514023603u,
    1998579484u,
    1312622330u,
    694541497u,
    2582060303u,
    2151582166u,
    1382467621u,
    776784248u,
    2618340202u,
    3323268794u,
    2497899128u,
    2784771155u,
    503983604u,
    4076293799u,
    907881277u,
    423175695u,
    432175456u,
    1378068232u,
    4145222326u,
    3954048622u,
    3938656102u,
    3820766613u,
    2793130115u,
    2977904593u,
    26017576u,
    3274890735u,
    3194772133u,
    1700274565u,
    1756076034u,
    4006520079u,
    3677328699u,
    720338349u,
    1533947780u,
    354530856u,
    688349552u,
    3973924725u,
    1637815568u,
    332179504u,
    3949051286u,
    53804574u,
    2852348879u,
    3044236432u,
    1282449977u,
    3583942155u,
    3416972820u,
    4006381244u,
    1617046695u,
    2628476075u,
    3002303598u,
    1686838959u,
    431878346u,
    2686675385u,
    1700445008u,
    1080580658u,
    1009431731u,
    832498133u,
    3223435511u,
    2605976345u,
    2271191193u,
    2516031870u,
    1648197032u,
    4164389018u,
    2548247927u,
    300782431u,
    375919233u,
    238389289u,
    3353747414u,
    2531188641u,
    2019080857u,
    1475708069u,
    455242339u,
    2609103871u,
    448939670u,
    3451063019u,
    1395535956u,
    2413381860u,
    1841049896u,
    1491858159u,
    885456874u,
    4264095073u,
    4001119347u,
    1565136089u,
    3898914787u,
    1108368660u,
    540939232u,
    1173283510u,
    2745871338u,
    3681308437u,
    4207628240u,
    3343053890u,
    4016749493u,
    1699691293u,
    1103962373u,
    3625875870u,
    2256883143u,
    3830138730u,
    1031889488u,
    3479347698u,
    1535977030u,
    4236805024u,
    3251091107u,
    2132092099u,
    1774941330u,
    1199868427u,
    1452454533u,
    157007616u,
    2904115357u,
    342012276u,
    595725824u,
    1480756522u,
    206960106u,
    497939518u,
    591360097u,
    863170706u,
    2375253569u,
    3596610801u,
    1814182875u,
    2094937945u,
    3421402208u,
    1082520231u,
    3463918190u,
    2785509508u,
    435703966u,
    3908032597u,
    1641649973u,
    2842273706u,
    3305899714u,
    1510255612u,
    2148256476u,
    2655287854u,
    3276092548u,
    4258621189u,
    236887753u,
    3681803219u,
    274041037u,
    1734335097u,
    3815195456u,
    3317970021u,
    1899903192u,
    1026095262u,
    4050517792u,
    356393447u,
    2410691914u,
    3873677099u,
    3682840055u
  },
  {
    3913112168u,
    2491498743u,
    4132185628u,
    2489919796u,
    1091903735u,
    1979897079u,
    3170134830u,
    3567386728u,
    3557303409u,
    857797738u,
    1136121015u,
    1342202287u,
    507115054u,
    2535736646u,
    337727348u,
    3213592640u,
    1301675037u,
    2528481711u,
    1895095763u,
    1721773893u,
    3216771564u,
    62756741u,
    2142006736u,
    835421444u,
    2531993523u,
    1442658625u,
    3659876326u,
    2882144922u,
    676362277u,
    1392781812u,
    170690266u,
    3921047035u,
    1759253602u,
    3611846912u,
    1745797284u,
    664899054u,
    1329594018u,
    3901205900u,
    3045908486u,
    2062866102u,
    2865634940u,
    3543621612u,
    3464012697u,
    1080764994u,
    553557557u,
    3656615353u,
    3996768171u,
    991055499u,
    499776247u,
    1265440854u,
    648242737u,
    3940784050u,
    980351604u,
    3713745714u,
    1749149687u,
    3396870395u,
    4211799374u,
    3640570775u,
    1161844396u,
    3125318951u,
    1431517754u,
    545492359u,
    4268468663u,
    3499529547u,
    1437099964u,
    2702547544u,
    3433638243u,
    2581715763u,
    2787789398u,
    1060185593u,
    1593081372u,
    2418618748u,
    4260947970u,
    69676912u,
    2159744348u,
    86519011u,
    2512459080u,
    3838209314u,
    1220612927u,
    3339683548u,
    133810670u,
    1090789135u,
    1078426020u,
    1569222167u,
    845107691u,
    3583754449u,
    4072456591u,
    1091646820u,
    628848692u,
    1613405280u,
    3757631651u,
    526609435u,
    236106946u,
    48312990u,
    2942717905u,
    3402727701u,
    1797494240u,
    859738849u,
    992217954u,
    4005476642u,
    2243076622u,
    3870952857u,
    3732016268u,
    765654824u,
    3490871365u,
    2511836413u,
    1685915746u,
    3888969200u,
    1414112111u,
    2273134842u,
    3281911079u,
    4080962846u,
    172450625u,
    2569994100u,
    980381355u,
    4109958455u,
    2819808352u,
    2716589560u,
    2568741196u,
    3681446669u,
    3329971472u,
    1835478071u,
    660984891u,
    3704678404u,
    4045999559u,
    3422617507u,
    3040415634u,
    1762651403u,
    1719377915u,
    3470491036u,
    2693910283u,
    3642056355u,
    3138596744u,
    1364962596u,
    2073328063u,
    1983633131u,
    926494387u,
    3423689081u,
    2150032023u,
    4096667949u,
    1749200295u,
    3328846651u,
    309677260u,
    2016342300u,
    1779581495u,
    3079819751u,
    111262694u,
    1274766160u,
    443224088u,
    298511866u,
    1025883608u,
    3806446537u,
    1145181785u,
    168956806u,
    3641502830u,
    3584813610u,
    1689216846u,
    3666258015u,
    3200248200u,
    1692713982u,
    2646376535u,
    4042768518u,
    1618508792u,
    1610833997u,
    3523052358u,
    4130873264u,
    2001055236u,
    3610705100u,
    2202168115u,
    4028541809u,
    2961195399u,
    1006657119u,
    2006996926u,
    3186142756u,
    1430667929u,
    3210227297u,
    1314452623u,
    4074634658u,
    4101304120u,
    2273951170u,
    1399257539u,
    3367210612u,
    3027628629u,
    1190975929u,
    2062231137u,
    2333990788u,
    2221543033u,
    2438960610u,
    1181637006u,
    548689776u,
    2362791313u,
    3372408396u,
    3104550113u,
    3145860560u,
    296247880u,
    1970579870u,
    3078560182u,
    3769228297u,
    1714227617u,
    3291629107u,
    3898220290u,
    166772364u,
    1251581989u,
    493813264u,
    448347421u,
    195405023u,
    2709975567u,
    677966185u,
    3703036547u,
    1463355134u,
    2715995803u,
    1338867538u,
    1343315457u,
    2802222074u,
    2684532164u,
    233230375u,
    2599980071u,
    2000651841u,
    3277868038u,
    1638401717u,
    4028070440u,
    3237316320u,
    6314154u,
    819756386u,
    300326615u,
    590932579u,
    1405279636u,
    3267499572u,
    3150704214u,
    2428286686u,
    3959192993u,
    3461946742u,
    1862657033u,
    1266418056u,
    963775037u,
    2089974820u,
    2263052895u,
    1917689273u,
    448879540u,
    3550394620u,
    3981727096u,
    150775221u,
    3627908307u,
    1303187396u,
    508620638u,
    2975983352u,
    2726630617u,
    1817252668u,
    1876281319u,
    1457606340u,
    908771278u,
    3720792119u,
    3617206836u,
    2455994898u,
    1729034894u,
    1080033504u
  },
  {
    976866871u,
    3556439503u,
    2881648439u,
    1522871579u,
    1555064734u,
    1336096578u,
    3548522304u,
    2579274686u,
    3574697629u,
    3205460757u,
    3593280638u,
    3338716283u,
    3079412587u,
    564236357u,
    2993598910u,
    1781952180u,
    1464380207u,
    3163844217u,
    3332601554u,
    1699332808u,
    1393555694u,
    1183702653u,
    3581086237u,
    1288719814u,
    691649499u,
    2847557200u,
    2895455976u,
    3193889540u,
    2717570544u,
    1781354906u,
    1676643554u,
    2592534050u,
    3230253752u,
    1126444790u,
    2770207658u,
    2633158820u,
    2210423226u,
    2615765581u,
    2414155088u,
    3127139286u,
    673620729u,
    2805611233u,
    1269405062u,
    4015350505u,
    3341807571u,
    4149409754u,
    1057255273u,
    2012875353u,
    2162469141u,
    2276492801u,
    2601117357u,
    993977747u,
    3918593370u,
    2654263191u,
    753973209u,
    36408145u,
    2530585658u,
    25011837u,
    3520020182u,
    2088578344u,
    530523599u,
    2918365339u,
    1524020338u,
    1518925132u,
    3760827505u,
    3759777254u,
    1202760957u,
    3985898139u,
    3906192525u,
    674977740u,
    4174734889u,
    2031300136u,
    2019492241u,
    3983892565u,
    4153806404u,
    3822280332u,
    352677332u,
    2297720250u,
    60907813u,
    90501309u,
    3286998549u,
    1016092578u,
    2535922412u,
    2839152426u,
    457141659u,
    509813237u,
    4120667899u,
    652014361u,
    1966332200u,
    2975202805u,
    55981186u,
    2327461051u,
    676427537u,
    3255491064u,
    2882294119u,
    3433927263u,
    1307055953u,
    942726286u,
    933058658u,
    2468411793u,
    3933900994u,
    4215176142u,
    1361170020u,
    2001714738u,
    2830558078u,
    3274259782u,
    1222529897u,
    1679025792u,
    2729314320u,
    3714953764u,
    1770335741u,
    151462246u,
    3013232138u,
    1682292957u,
    1483529935u,
    471910574u,
    1539241949u,
    458788160u,
    3436315007u,
    1807016891u,
    3718408830u,
    978976581u,
    1043663428u,
    3165965781u,
    1927990952u,
    4200891579u,
    2372276910u,
    3208408903u,
    3533431907u,
    1412390302u,
    2931980059u,
    4132332400u,
    1947078029u,
    3881505623u,
    4168226417u,
    2941484381u,
    1077988104u,
    1320477388u,
    886195818u,
    18198404u,
    3786409000u,
    2509781533u,
    112762804u,
    3463356488u,
    1866414978u,
    891333506u,
    18488651u,
    661792760u,
    1628790961u,
    3885187036u,
    3141171499u,
    876946877u,
    2693282273u,
    1372485963u,
    791857591u,
    2686433993u,
    3759982718u,
    3167212022u,
    3472953795u,
    2716379847u,
    445679433u,
    3561995674u,
    3504004811u,
    3574258232u,
    54117162u,
    3331405415u,
    2381918588u,
    3769707343u,
    4154350007u,
    1140177722u,
    4074052095u,
    668550556u,
    3214352940u,
    367459370u,
    261225585u,
    2610173221u,
    4209349473u,
    3468074219u,
    3265815641u,
    314222801u,
    3066103646u,
    3808782860u,
    282218597u,
    3406013506u,
    3773591054u,
    379116347u,
    1285071038u,
    846784868u,
    2669647154u,
    3771962079u,
    3550491691u,
    2305946142u,
    453669953u,
    1268987020u,
    3317592352u,
    3279303384u,
    3744833421u,
    2610507566u,
    3859509063u,
    266596637u,
    3847019092u,
    517658769u,
    3462560207u,
    3443424879u,
    370717030u,
    4247526661u,
    2224018117u,
    4143653529u,
    4112773975u,
    2788324899u,
    2477274417u,
    1456262402u,
    2901442914u,
    1517677493u,
    1846949527u,
    2295493580u,
    3734397586u,
    2176403920u,
    1280348187u,
    1908823572u,
    3871786941u,
    846861322u,
    1172426758u,
    3287448474u,
    3383383037u,
    1655181056u,
    3139813346u,
    901632758u,
    1897031941u,
    2986607138u,
    3066810236u,
    3447102507u,
    1393639104u,
    373351379u,
    950779232u,
    625454576u,
    3124240540u,
    4148612726u,
    2007998917u,
    544563296u,
    2244738638u,
    2330496472u,
    2058025392u,
    1291430526u,
    424198748u,
    50039436u,
    29584100u,
    3605783033u,
    2429876329u,
    2791104160u,
    1057563949u,
    3255363231u,
    3075367218u,
    3463963227u,
    1469046755u,
    985887462u
  }
};
int g_buildNumber = 40504;
unsigned __int8 PwdCrypt::IP[64] =
{
  58u,
  50u,
  42u,
  34u,
  26u,
  18u,
  10u,
  2u,
  60u,
  52u,
  44u,
  36u,
  28u,
  20u,
  12u,
  4u,
  62u,
  54u,
  46u,
  38u,
  30u,
  22u,
  14u,
  6u,
  64u,
  56u,
  48u,
  40u,
  32u,
  24u,
  16u,
  8u,
  57u,
  49u,
  41u,
  33u,
  25u,
  17u,
  9u,
  1u,
  59u,
  51u,
  43u,
  35u,
  27u,
  19u,
  11u,
  3u,
  61u,
  53u,
  45u,
  37u,
  29u,
  21u,
  13u,
  5u,
  63u,
  55u,
  47u,
  39u,
  31u,
  23u,
  15u,
  7u
};
unsigned __int8 PwdCrypt::FP[64] =
{
  40u,
  8u,
  48u,
  16u,
  56u,
  24u,
  64u,
  32u,
  39u,
  7u,
  47u,
  15u,
  55u,
  23u,
  63u,
  31u,
  38u,
  6u,
  46u,
  14u,
  54u,
  22u,
  62u,
  30u,
  37u,
  5u,
  45u,
  13u,
  53u,
  21u,
  61u,
  29u,
  36u,
  4u,
  44u,
  12u,
  52u,
  20u,
  60u,
  28u,
  35u,
  3u,
  43u,
  11u,
  51u,
  19u,
  59u,
  27u,
  34u,
  2u,
  42u,
  10u,
  50u,
  18u,
  58u,
  26u,
  33u,
  1u,
  41u,
  9u,
  49u,
  17u,
  57u,
  25u
};
char PwdCrypt::PC_1[56] =
{
  '9',
  '1',
  ')',
  '!',
  '\x19',
  '\x11',
  '\t',
  '\x01',
  ':',
  '2',
  '*',
  '\"',
  '\x1A',
  '\x12',
  '\n',
  '\x02',
  ';',
  '3',
  '+',
  '#',
  '\x1B',
  '\x13',
  '\v',
  '\x03',
  '<',
  '4',
  ',',
  '$',
  '?',
  '7',
  '/',
  '\'',
  '\x1F',
  '\x17',
  '\x0F',
  '\a',
  '>',
  '6',
  '.',
  '&',
  '\x1E',
  '\x16',
  '\x0E',
  '\x06',
  '=',
  '5',
  '-',
  '%',
  '\x1D',
  '\x15',
  '\r',
  '\x05',
  '\x1C',
  '\x14',
  '\f',
  '\x04'
};
char g_PwdCrypt_key4[16] =
{
  '\x01',
  '\x02',
  '\x04',
  '\x06',
  '\b',
  '\n',
  '\f',
  '\x0E',
  '\x0F',
  '\x11',
  '\x13',
  '\x15',
  '\x17',
  '\x19',
  '\x1B',
  '\x1C'
};
char PwdCrypt::PC_2[48] =
{
  '\x0E',
  '\x11',
  '\v',
  '\x18',
  '\x01',
  '\x05',
  '\x03',
  '\x1C',
  '\x0F',
  '\x06',
  '\x15',
  '\n',
  '\x17',
  '\x13',
  '\f',
  '\x04',
  '\x1A',
  '\b',
  '\x10',
  '\a',
  '\x1B',
  '\x14',
  '\r',
  '\x02',
  ')',
  '4',
  '\x1F',
  '%',
  '/',
  '7',
  '\x1E',
  '(',
  '3',
  '-',
  '!',
  '0',
  ',',
  '1',
  '\'',
  '8',
  '\"',
  '5',
  '.',
  '*',
  '2',
  '$',
  '\x1D',
  ' '
};
unsigned __int8 PwdCrypt::SBoxes[8][64] =
{
  {
    14u,
    4u,
    13u,
    1u,
    2u,
    15u,
    11u,
    8u,
    3u,
    10u,
    6u,
    12u,
    5u,
    9u,
    0u,
    7u,
    0u,
    15u,
    7u,
    4u,
    14u,
    2u,
    13u,
    1u,
    10u,
    6u,
    12u,
    11u,
    9u,
    5u,
    3u,
    8u,
    4u,
    1u,
    14u,
    8u,
    13u,
    6u,
    2u,
    11u,
    15u,
    12u,
    9u,
    7u,
    3u,
    10u,
    5u,
    0u,
    15u,
    12u,
    8u,
    2u,
    4u,
    9u,
    1u,
    7u,
    5u,
    11u,
    3u,
    14u,
    10u,
    0u,
    6u,
    13u
  },
  {
    15u,
    1u,
    8u,
    14u,
    6u,
    11u,
    3u,
    4u,
    9u,
    7u,
    2u,
    13u,
    12u,
    0u,
    5u,
    10u,
    3u,
    13u,
    4u,
    7u,
    15u,
    2u,
    8u,
    14u,
    12u,
    0u,
    1u,
    10u,
    6u,
    9u,
    11u,
    5u,
    0u,
    14u,
    7u,
    11u,
    10u,
    4u,
    13u,
    1u,
    5u,
    8u,
    12u,
    6u,
    9u,
    3u,
    2u,
    15u,
    13u,
    8u,
    10u,
    1u,
    3u,
    15u,
    4u,
    2u,
    11u,
    6u,
    7u,
    12u,
    0u,
    5u,
    14u,
    9u
  },
  {
    10u,
    0u,
    9u,
    14u,
    6u,
    3u,
    15u,
    5u,
    1u,
    13u,
    12u,
    7u,
    11u,
    4u,
    2u,
    8u,
    13u,
    7u,
    0u,
    9u,
    3u,
    4u,
    6u,
    10u,
    2u,
    8u,
    5u,
    14u,
    12u,
    11u,
    15u,
    1u,
    13u,
    6u,
    4u,
    9u,
    8u,
    15u,
    3u,
    0u,
    11u,
    1u,
    2u,
    12u,
    5u,
    10u,
    14u,
    7u,
    1u,
    10u,
    13u,
    0u,
    6u,
    9u,
    8u,
    7u,
    4u,
    15u,
    14u,
    3u,
    11u,
    5u,
    2u,
    12u
  },
  {
    7u,
    13u,
    14u,
    3u,
    0u,
    6u,
    9u,
    10u,
    1u,
    2u,
    8u,
    5u,
    11u,
    12u,
    4u,
    15u,
    13u,
    8u,
    11u,
    5u,
    6u,
    15u,
    0u,
    3u,
    4u,
    7u,
    2u,
    12u,
    1u,
    10u,
    14u,
    9u,
    10u,
    6u,
    9u,
    0u,
    12u,
    11u,
    7u,
    13u,
    15u,
    1u,
    3u,
    14u,
    5u,
    2u,
    8u,
    4u,
    3u,
    15u,
    0u,
    6u,
    10u,
    1u,
    13u,
    8u,
    9u,
    4u,
    5u,
    11u,
    12u,
    7u,
    2u,
    14u
  },
  {
    2u,
    12u,
    4u,
    1u,
    7u,
    10u,
    11u,
    6u,
    8u,
    5u,
    3u,
    15u,
    13u,
    0u,
    14u,
    9u,
    14u,
    11u,
    2u,
    12u,
    4u,
    7u,
    13u,
    1u,
    5u,
    0u,
    15u,
    10u,
    3u,
    9u,
    8u,
    6u,
    4u,
    2u,
    1u,
    11u,
    10u,
    13u,
    7u,
    8u,
    15u,
    9u,
    12u,
    5u,
    6u,
    3u,
    0u,
    14u,
    11u,
    8u,
    12u,
    7u,
    1u,
    14u,
    2u,
    13u,
    6u,
    15u,
    0u,
    9u,
    10u,
    4u,
    5u,
    3u
  },
  {
    12u,
    1u,
    10u,
    15u,
    9u,
    2u,
    6u,
    8u,
    0u,
    13u,
    3u,
    4u,
    14u,
    7u,
    5u,
    11u,
    10u,
    15u,
    4u,
    2u,
    7u,
    12u,
    9u,
    5u,
    6u,
    1u,
    13u,
    14u,
    0u,
    11u,
    3u,
    8u,
    9u,
    14u,
    15u,
    5u,
    2u,
    8u,
    12u,
    3u,
    7u,
    0u,
    4u,
    10u,
    1u,
    13u,
    11u,
    6u,
    4u,
    3u,
    2u,
    12u,
    9u,
    5u,
    15u,
    10u,
    11u,
    14u,
    1u,
    7u,
    6u,
    0u,
    8u,
    13u
  },
  {
    4u,
    11u,
    2u,
    14u,
    15u,
    0u,
    8u,
    13u,
    3u,
    12u,
    9u,
    7u,
    5u,
    10u,
    6u,
    1u,
    13u,
    0u,
    11u,
    7u,
    4u,
    9u,
    1u,
    10u,
    14u,
    3u,
    5u,
    12u,
    2u,
    15u,
    8u,
    6u,
    1u,
    4u,
    11u,
    13u,
    12u,
    3u,
    7u,
    14u,
    10u,
    15u,
    6u,
    8u,
    0u,
    5u,
    9u,
    2u,
    6u,
    11u,
    13u,
    8u,
    1u,
    4u,
    10u,
    7u,
    9u,
    5u,
    0u,
    15u,
    14u,
    2u,
    3u,
    12u
  },
  {
    13u,
    2u,
    8u,
    4u,
    6u,
    15u,
    11u,
    1u,
    10u,
    9u,
    3u,
    14u,
    5u,
    0u,
    12u,
    7u,
    1u,
    15u,
    13u,
    8u,
    10u,
    3u,
    7u,
    4u,
    12u,
    5u,
    6u,
    11u,
    0u,
    14u,
    9u,
    2u,
    7u,
    11u,
    4u,
    1u,
    9u,
    12u,
    14u,
    2u,
    0u,
    6u,
    10u,
    13u,
    15u,
    3u,
    5u,
    8u,
    2u,
    1u,
    14u,
    7u,
    4u,
    10u,
    8u,
    13u,
    15u,
    12u,
    9u,
    0u,
    3u,
    5u,
    6u,
    11u
  }
};
char PwdCrypt::P[32] =
{
  '\x10',
  '\a',
  '\x14',
  '\x15',
  '\x1D',
  '\f',
  '\x1C',
  '\x11',
  '\x01',
  '\x0F',
  '\x17',
  '\x1A',
  '\x05',
  '\x12',
  '\x1F',
  '\n',
  '\x02',
  '\b',
  '\x18',
  '\x0E',
  ' ',
  '\x1B',
  '\x03',
  '\t',
  '\x13',
  '\r',
  '\x1E',
  '\x06',
  '\x16',
  '\v',
  '\x04',
  '\x19'
};
unsigned __int32 PwdCrypt::BoolMask[8] = { 128u, 64u, 32u, 16u, 8u, 4u, 2u, 1u };
int PwdCrypt::BoolMaskSmall[] = { 8, 4, 2, 1 }; // idb
char aInsertTwiceSAt[] = "Insert twice %s at line %d in %s"; // idb
char aInvalidStateAt[] = "Invalid state at line %d in %s"; // idb
char aInvalidTokenSA[] = "Invalid token %s at line %d in %s"; // idb
char aCanTLoadS[] = "Can't load %s"; // idb
char aServerPort[] = "serverPort"; // idb
char aServerExPort[] = "serverExPort"; // idb
char aServerintport[] = "serverIntPort"; // idb
char aWorldport[] = "WorldPort"; // idb
char aDbconnectionnu[] = "DBConnectionNum"; // idb
char aNumserverthrea[] = "numServerThread"; // idb
char aNumserverintth[] = "numServerIntThread"; // idb
char aGameid[] = "GameID"; // idb
char aSockettimeout[] = "SocketTimeOut"; // idb
char aSocketlimit[] = "SocketLimit"; // idb
char aAcceptcallnum[] = "AcceptCallNum"; // idb
char aWaitinguserlim[] = "WaitingUserLimit"; // idb
char aPacketsizetype[] = "PacketSizeType"; // idb
char aEncrypt[] = "Encrypt"; // idb
char aLogDirectory[] = "logDirectory"; // idb
char aProtocolversio[] = "ProtocolVersion"; // idb
char aDesapply[] = "DesApply"; // idb
char aDeskey[] = "deskey"; // idb
char aReadlocalserve[] = "ReadLocalServerList"; // idb
char aOnetimelogout[] = "OneTimeLogOut"; // idb
char aGmcheckmode[] = "GMCheckMode"; // idb
char aCountrycode[] = "CountryCode"; // idb
char aUserdata[] = "UserData"; // idb
char aDevconnectoute[] = "DevConnectOuter"; // idb
char aDevserverip[] = "DevServerIP"; // idb
char aDumppacket[] = "DumpPacket"; // idb
char aPccafefirst[] = "PCCafeFirst"; // idb
char aUseipserver[] = "UseIPServer"; // idb
char aIPServer[] = "IPServer"; // idb
char aIpport[] = "IPPort"; // idb
char aIpinterval[] = "IPInterval"; // idb
char aUselogd[] = "uselogd"; // idb
char aLogDIp[] = "logdip"; // idb
char aLogdport[] = "logdport"; // idb
char aLogdconnectint[] = "logdconnectinterval"; // idb
char aRestrictgmip[] = "RestrictGMIP"; // idb
char aGmip[] = "GMIP"; // idb
char aUsewantedsyste[] = "UseWantedSystem"; // idb
char aWantedip[] = "WantedIP"; // idb
char aWantedport[] = "WantedPort"; // idb
char aWantedreconnec[] = "WantedReconnectInterval"; // idb
char aIpaccesslimit[] = "IPAccessLimit"; // idb
char aFreeserver[] = "FreeServer"; // idb
char aUseforbiddenip[] = "useForbiddenIPList"; // idb
char aSupportreconne[] = "supportReconnect"; // idb
char aMailserver[] = "mailServer"; // idb
char aMailfrom[] = "mailFrom"; // idb
char aMailto[] = "mailTo"; // idb
char aNewserverlist[] = "NewServerList"; // idb
char aAutokickaccoun[] = "AutoKickAccount"; // idb
char aNewencrypt[] = "NewEncrypt"; // idb
char aYes[] = "yes"; // idb
char aTrue[] = "true"; // idb
char a1[] = "1"; // idb
char aServerport_0[11] = "serverport"; // weak
char aServerport_1[] = "-serverport="; // idb
char aServerexport_0[13] = "serverexport"; // weak
char aServerexport_1[] = "-serverexport="; // idb
char aServerintpor_0[14] = "serverintport"; // weak
char aServerintpor_1[] = "-serverintport="; // idb
char aWorldport_0[10] = "worldport"; // weak
char aWorldport_1[] = "-worldport="; // idb
char aEditorModeSD[] = "Editor Mode, %s=%d\n"; // idb
int (__cdecl *CSocketInt_handlers[12])(CSocketInt *, char *) =
{
  &CSocketInt::packet00_kickByUid,
  &CSocketInt::packet01_changeSocketLimit,
  &CSocketInt::packet02_getUserNumber,
  &CSocketInt::packet03_kickByAccNameFromAuthServer,
  &CSocketInt::packet04_changeGmMode,
  &CSocketInt::packet05_stub,
  &CSocketInt::packet06_changeGmIp,
  &CSocketInt::packet07_stub,
  &CSocketInt::packet08_changeServerMode,
  &CSocketInt::packet09_getLoginFlag,
  &CSocketInt::packet10_checkUser,
  &CSocketInt::packet11_kickUserFromWorldServer
};
char arg4[2] = "0"; // idb
char a0_3[2] = "0"; // idb
char a1_7[2] = "1"; // idb
char aD_12[3] = "%d"; // idb
char aIncorrectFormat[] = "0,incorrect format"; // idb
char aSelectUidFromU[] = "SELECT uid FROM user_account with (NOLOCK) WHERE account = '%s'"; // idb
char a0Invalidaccoun[] = "0,InvalidAccount"; // idb
char a1_0[] = "1"; // idb
char a0Invalidacco_0[] = "0,InvalidAccount"; // idb
char a0IncorrectFo_0[] = "0,Incorrect Format"; // idb
char aGmOnlyModeOff[] = "GM ONLY MODE OFF"; // idb
char a1_1[] = "1"; // idb
char aGmOnlyModeOn[] = "GM ONLY MODE ON"; // idb
char a1_2[] = "1"; // idb
char aChangeSocketli[] = "Change socketlimit, %d"; // idb
char a1_3[] = "1"; // idb
char a0[] = "0"; // idb
char aChangeGmipD_D_[] = "Change GMIP, %d.%d.%d.%d"; // idb
char a1_4[] = "1"; // idb
char a0_0[] = "0"; // idb
char aConfigFreeserv[] = "Config FreeServer is chaged to false"; // idb
char a1_5[] = "1"; // idb
char aConfigFreese_0[] = "Config FreeServer is changed to true"; // idb
char a1_6[] = "1"; // idb
char a0_1[] = "0"; // idb
char aOchk201ErrorS[] = "-OCHK\t201\tError\t%s\r\n"; // idb
char aOchk202ErrorS[] = "-OCHK\t202\tError\t%s\r\n"; // idb
char aOchkDSD[] = "+OCHK\t%d\t%s\t%d\r\n"; // idb
char aOchkDSD_0[] = "+OCHK\t%d\t%s\t%d\r\n"; // idb
char aOchk003Error[] = "-OCHK\t003\tError\r\n"; // idb
char aOchk003Error_0[] = "-OCHK\t003\tError\r\n"; // idb
char aOchk004[] = "-OCHK\t004\t\n"; // idb
char aD[] = "%d"; // idb
char aD_0[] = "%d"; // idb
char aD_1[] = "%d"; // idb
char aD_2[] = "%d"; // idb
char aD_3[] = "%d"; // idb
char aD_4[] = "%d"; // idb
char aS_0[] = "%s"; // idb
char aC[] = "%c"; // idb
char aCdcs_2[] = "cdcs"; // idb
char aD_5[] = "%d"; // idb
char aD_6[] = "%d"; // idb
char aD_7[] = "%d"; // idb
char aD_8[] = "%d"; // idb
char aD_9[] = "%d"; // idb
char aD_10[] = "%d"; // idb
char aCloseConnectio[] = "*close connection from %s, %x(%x)"; // idb
char aD_11[] = "%d"; // idb
bool (__cdecl *WorldSrvSocket_handlers[22])(WorldSrvSocket *this_, char *buffer) =
{
  &WorldSrvSocket::packet00_playOk,
  &WorldSrvSocket::packet01_playFail,
  &WorldSrvSocket::packet02_userLoggedToGs,
  &WorldSrvSocket::packet03_userQuitsWithError,
  &WorldSrvSocket::packet04_userDropped,
  &WorldSrvSocket::packet05_setUserLimit,
  &WorldSrvSocket::packet06_stub,
  &WorldSrvSocket::packet07_stub,
  &WorldSrvSocket::packet08_pingAck,
  &WorldSrvSocket::packet09_updateUserData,
  &WorldSrvSocket::packet10_updateWorldStatus,
  &WorldSrvSocket::packet11_gsReconnected,
  &WorldSrvSocket::packet12_newCharCreated,
  &WorldSrvSocket::packet13_charDeleted,
  &WorldSrvSocket::packet14_charManipulation,
  &WorldSrvSocket::packet15_serverSelected,
  &WorldSrvSocket::packet16_handler,
  &WorldSrvSocket::packet17_userDropped,
  &WorldSrvSocket::packet18_updateGSStatus,
  &WorldSrvSocket::packet19_updateUsersNumber,
  &WorldSrvSocket::packet20_getServerList,
  &WorldSrvSocket::packet21_moveCharToGS
};
char aCdcs_3[] = "cdcs"; // idb
char aCdcs_4[] = "cdcs"; // idb
char aCddc[] = "cddc"; // idb
char aCdcs_5[] = "cdcs"; // idb
char aCc_7[] = "cc"; // idb
char aQuitGameErrorU[] = "quit game error, uid %d, reason %d, usetime %d\r\n"; // idb
char aCd_2[] = "cd"; // idb
char aUpdateUser_d_0[] = "UPDATE user_data SET user_data=? WHERE uid = %d"; // idb
char aUpdateWorldsta[] = "update worldstatus set status=1 where idx=%d"; // idb
char aSelectSsnFro_0[] = "Select ssn From user_info with (nolock) Where account = '%s'"; // idb
char aCd[] = "cd"; // idb
char aCcddchb[] = "ccddchb"; // idb
char aCcddc[] = "ccddc"; // idb
char aCdccchb[] = "cdccchb"; // idb
char aCc_8[] = "cc"; // idb
char aCddd[] = "cddd"; // idb
char aCc_9[] = "cc"; // idb
char aDServeridIsMan[] = "%d serverid is manage servers (not allow protocol)"; // idb
char aUpdateWorlds_0[] = "update worldstatus set status=%d where idx=%d"; // idb
char aCb_1[] = "cb"; // idb
char aDAssembleTooLa[] = "%d: assemble too large packet. format %s"; // idb
char aCloseConnect_0[] = "*close connection from %s, %x(%x)"; // idb
char aDDDDDDMainServ[] = "%d-%d-%d %d:%d:%d,main server connection close from %s, 0x%x\r\n"; // idb
char aUpdateWorlds_1[] = "update worldstatus set status=0 where idx=%d"; // idb
char aDBadPacketSize[] = "%d: bad packet size %d"; // idb
char aUnknownProtoco[] = "unknown protocol %d"; // idb
char aMainServerConn[] = "main server connection close. invalid status and protocol %s, errorNum :%d\r\n"; // idb
char aCdd[] = "cdd"; // idb
char aUpdateWorlds_2[] = "update worldstatus set status=1 where idx=%d"; // idb
char aDAssembleToo_0[] = "%d: assemble too large packet. format %s"; // idb
char aCdcs_6[] = "cdcs"; // idb
char aDbLoginFailed[] = "db login failed"; // idb
char aDbEnvAllocatio[] = "db env allocation failed"; // idb
char format[] = "hdbc allocation failed"; // idb
char aStmtAllocation[] = "stmt allocation failed"; // idb
char aHdbcConnection[] = "hdbc connection failed"; // idb
char aHdbcAllocati_0[] = "hdbc allocation failed"; // idb
char aL2conn[7] = "L2Conn"; // weak
char aSldb[5] = "sldb"; // weak
CHAR SubKey[] = "Software\\NCSoft\\L2AUTHD"; // idb
char aL2conn_0[7] = "L2Conn"; // weak
char aSldb_0[5] = "sldb"; // weak
CHAR aSoftwareNcso_0[] = "Software\\NCSoft\\L2AUTHD"; // idb
char aDbRecoverySucc[] = "db recovery succeeded"; // idb
char aDbRecoveryFail[] = "db recovery failed: env allocation"; // idb
char aDbRecoveryFa_0[] = "db recovery failed: login impossible"; // idb
char aL2conn_1[7] = "L2Conn"; // weak
char aL2OdbcConnecti[24] = "L2 ODBC Connection Info"; // weak
char aFiledsn[] = "FILEDSN="; // idb
char aUid[] = ";UID="; // idb
char aPwd[] = ";PWD="; // idb
char aFetchErrorD[] = "Fetch error = %d"; // idb
char aSqlFormat[] = "sql: %s"; // idb
char aSS[] = "%s:%s"; // idb
char a08s01[] = "08S01"; // idb
char a23000[] = "23000"; // idb
char aSqlS_0[] = "sql: %s"; // idb
char aSS_0[] = "%s:%s"; // idb
unsigned __int8 Des::ip[64] =
{
  58u,
  50u,
  42u,
  34u,
  26u,
  18u,
  10u,
  2u,
  60u,
  52u,
  44u,
  36u,
  28u,
  20u,
  12u,
  4u,
  62u,
  54u,
  46u,
  38u,
  30u,
  22u,
  14u,
  6u,
  64u,
  56u,
  48u,
  40u,
  32u,
  24u,
  16u,
  8u,
  57u,
  49u,
  41u,
  33u,
  25u,
  17u,
  9u,
  1u,
  59u,
  51u,
  43u,
  35u,
  27u,
  19u,
  11u,
  3u,
  61u,
  53u,
  45u,
  37u,
  29u,
  21u,
  13u,
  5u,
  63u,
  55u,
  47u,
  39u,
  31u,
  23u,
  15u,
  7u
};
unsigned __int8 Des::fp[64] =
{
  40u,
  8u,
  48u,
  16u,
  56u,
  24u,
  64u,
  32u,
  39u,
  7u,
  47u,
  15u,
  55u,
  23u,
  63u,
  31u,
  38u,
  6u,
  46u,
  14u,
  54u,
  22u,
  62u,
  30u,
  37u,
  5u,
  45u,
  13u,
  53u,
  21u,
  61u,
  29u,
  36u,
  4u,
  44u,
  12u,
  52u,
  20u,
  60u,
  28u,
  35u,
  3u,
  43u,
  11u,
  51u,
  19u,
  59u,
  27u,
  34u,
  2u,
  42u,
  10u,
  50u,
  18u,
  58u,
  26u,
  33u,
  1u,
  41u,
  9u,
  49u,
  17u,
  57u,
  25u
};
char Des::kp_PC[56] =
{
  '9',
  '1',
  ')',
  '!',
  '\x19',
  '\x11',
  '\t',
  '\x01',
  ':',
  '2',
  '*',
  '\"',
  '\x1A',
  '\x12',
  '\n',
  '\x02',
  ';',
  '3',
  '+',
  '#',
  '\x1B',
  '\x13',
  '\v',
  '\x03',
  '<',
  '4',
  ',',
  '$',
  '?',
  '7',
  '/',
  '\'',
  '\x1F',
  '\x17',
  '\x0F',
  '\a',
  '>',
  '6',
  '.',
  '&',
  '\x1E',
  '\x16',
  '\x0E',
  '\x06',
  '=',
  '5',
  '-',
  '%',
  '\x1D',
  '\x15',
  '\r',
  '\x05',
  '\x1C',
  '\x14',
  '\f',
  '\x04'
};
char Des::loop_table_[16] =
{
  '\x01',
  '\x02',
  '\x04',
  '\x06',
  '\b',
  '\n',
  '\f',
  '\x0E',
  '\x0F',
  '\x11',
  '\x13',
  '\x15',
  '\x17',
  '\x19',
  '\x1B',
  '\x1C'
};
char Des::kp2[48] =
{
  '\x0E',
  '\x11',
  '\v',
  '\x18',
  '\x01',
  '\x05',
  '\x03',
  '\x1C',
  '\x0F',
  '\x06',
  '\x15',
  '\n',
  '\x17',
  '\x13',
  '\f',
  '\x04',
  '\x1A',
  '\b',
  '\x10',
  '\a',
  '\x1B',
  '\x14',
  '\r',
  '\x02',
  ')',
  '4',
  '\x1F',
  '%',
  '/',
  '7',
  '\x1E',
  '(',
  '3',
  '-',
  '!',
  '0',
  ',',
  '1',
  '\'',
  '8',
  '\"',
  '5',
  '.',
  '*',
  '2',
  '$',
  '\x1D',
  ' '
};
unsigned __int8 Des::SBoxes[8][64] =
{
  {
    14u,
    4u,
    13u,
    1u,
    2u,
    15u,
    11u,
    8u,
    3u,
    10u,
    6u,
    12u,
    5u,
    9u,
    0u,
    7u,
    0u,
    15u,
    7u,
    4u,
    14u,
    2u,
    13u,
    1u,
    10u,
    6u,
    12u,
    11u,
    9u,
    5u,
    3u,
    8u,
    4u,
    1u,
    14u,
    8u,
    13u,
    6u,
    2u,
    11u,
    15u,
    12u,
    9u,
    7u,
    3u,
    10u,
    5u,
    0u,
    15u,
    12u,
    8u,
    2u,
    4u,
    9u,
    1u,
    7u,
    5u,
    11u,
    3u,
    14u,
    10u,
    0u,
    6u,
    13u
  },
  {
    15u,
    1u,
    8u,
    14u,
    6u,
    11u,
    3u,
    4u,
    9u,
    7u,
    2u,
    13u,
    12u,
    0u,
    5u,
    10u,
    3u,
    13u,
    4u,
    7u,
    15u,
    2u,
    8u,
    14u,
    12u,
    0u,
    1u,
    10u,
    6u,
    9u,
    11u,
    5u,
    0u,
    14u,
    7u,
    11u,
    10u,
    4u,
    13u,
    1u,
    5u,
    8u,
    12u,
    6u,
    9u,
    3u,
    2u,
    15u,
    13u,
    8u,
    10u,
    1u,
    3u,
    15u,
    4u,
    2u,
    11u,
    6u,
    7u,
    12u,
    0u,
    5u,
    14u,
    9u
  },
  {
    10u,
    0u,
    9u,
    14u,
    6u,
    3u,
    15u,
    5u,
    1u,
    13u,
    12u,
    7u,
    11u,
    4u,
    2u,
    8u,
    13u,
    7u,
    0u,
    9u,
    3u,
    4u,
    6u,
    10u,
    2u,
    8u,
    5u,
    14u,
    12u,
    11u,
    15u,
    1u,
    13u,
    6u,
    4u,
    9u,
    8u,
    15u,
    3u,
    0u,
    11u,
    1u,
    2u,
    12u,
    5u,
    10u,
    14u,
    7u,
    1u,
    10u,
    13u,
    0u,
    6u,
    9u,
    8u,
    7u,
    4u,
    15u,
    14u,
    3u,
    11u,
    5u,
    2u,
    12u
  },
  {
    7u,
    13u,
    14u,
    3u,
    0u,
    6u,
    9u,
    10u,
    1u,
    2u,
    8u,
    5u,
    11u,
    12u,
    4u,
    15u,
    13u,
    8u,
    11u,
    5u,
    6u,
    15u,
    0u,
    3u,
    4u,
    7u,
    2u,
    12u,
    1u,
    10u,
    14u,
    9u,
    10u,
    6u,
    9u,
    0u,
    12u,
    11u,
    7u,
    13u,
    15u,
    1u,
    3u,
    14u,
    5u,
    2u,
    8u,
    4u,
    3u,
    15u,
    0u,
    6u,
    10u,
    1u,
    13u,
    8u,
    9u,
    4u,
    5u,
    11u,
    12u,
    7u,
    2u,
    14u
  },
  {
    2u,
    12u,
    4u,
    1u,
    7u,
    10u,
    11u,
    6u,
    8u,
    5u,
    3u,
    15u,
    13u,
    0u,
    14u,
    9u,
    14u,
    11u,
    2u,
    12u,
    4u,
    7u,
    13u,
    1u,
    5u,
    0u,
    15u,
    10u,
    3u,
    9u,
    8u,
    6u,
    4u,
    2u,
    1u,
    11u,
    10u,
    13u,
    7u,
    8u,
    15u,
    9u,
    12u,
    5u,
    6u,
    3u,
    0u,
    14u,
    11u,
    8u,
    12u,
    7u,
    1u,
    14u,
    2u,
    13u,
    6u,
    15u,
    0u,
    9u,
    10u,
    4u,
    5u,
    3u
  },
  {
    12u,
    1u,
    10u,
    15u,
    9u,
    2u,
    6u,
    8u,
    0u,
    13u,
    3u,
    4u,
    14u,
    7u,
    5u,
    11u,
    10u,
    15u,
    4u,
    2u,
    7u,
    12u,
    9u,
    5u,
    6u,
    1u,
    13u,
    14u,
    0u,
    11u,
    3u,
    8u,
    9u,
    14u,
    15u,
    5u,
    2u,
    8u,
    12u,
    3u,
    7u,
    0u,
    4u,
    10u,
    1u,
    13u,
    11u,
    6u,
    4u,
    3u,
    2u,
    12u,
    9u,
    5u,
    15u,
    10u,
    11u,
    14u,
    1u,
    7u,
    6u,
    0u,
    8u,
    13u
  },
  {
    4u,
    11u,
    2u,
    14u,
    15u,
    0u,
    8u,
    13u,
    3u,
    12u,
    9u,
    7u,
    5u,
    10u,
    6u,
    1u,
    13u,
    0u,
    11u,
    7u,
    4u,
    9u,
    1u,
    10u,
    14u,
    3u,
    5u,
    12u,
    2u,
    15u,
    8u,
    6u,
    1u,
    4u,
    11u,
    13u,
    12u,
    3u,
    7u,
    14u,
    10u,
    15u,
    6u,
    8u,
    0u,
    5u,
    9u,
    2u,
    6u,
    11u,
    13u,
    8u,
    1u,
    4u,
    10u,
    7u,
    9u,
    5u,
    0u,
    15u,
    14u,
    2u,
    3u,
    12u
  },
  {
    13u,
    2u,
    8u,
    4u,
    6u,
    15u,
    11u,
    1u,
    10u,
    9u,
    3u,
    14u,
    5u,
    0u,
    12u,
    7u,
    1u,
    15u,
    13u,
    8u,
    10u,
    3u,
    7u,
    4u,
    12u,
    5u,
    6u,
    11u,
    0u,
    14u,
    9u,
    2u,
    7u,
    11u,
    4u,
    1u,
    9u,
    12u,
    14u,
    2u,
    0u,
    6u,
    10u,
    13u,
    15u,
    3u,
    5u,
    8u,
    2u,
    1u,
    14u,
    7u,
    4u,
    10u,
    8u,
    13u,
    15u,
    12u,
    9u,
    0u,
    3u,
    5u,
    6u,
    11u
  }
};
char Des::pc[32] =
{
  '\x10',
  '\a',
  '\x14',
  '\x15',
  '\x1D',
  '\f',
  '\x1C',
  '\x11',
  '\x01',
  '\x0F',
  '\x17',
  '\x1A',
  '\x05',
  '\x12',
  '\x1F',
  '\n',
  '\x02',
  '\b',
  '\x18',
  '\x0E',
  ' ',
  '\x1B',
  '\x03',
  '\t',
  '\x13',
  '\r',
  '\x1E',
  '\x06',
  '\x16',
  '\v',
  '\x04',
  '\x19'
};
int Des::PTBIT[8] = { 128, 64, 32, 16, 8, 4, 2, 1 };
int Des::SmallBoolMask[] = { 8, 4, 2, 1 };
char mailHeader[] = "HELO main1.ncsoft.co.kr\r\n"; // idb
char aMail_From[] = "MAIL From: <darkangel@ncsoft.co.kr>\r\n"; // idb
char aRcptToDarkange[] = "RCPT To: <darkangel@ncsoft.co.kr>\r\n"; // idb
char aData[] = "DATA\r\n"; // idb
char aNewLine[] = "\r\n.\r\n"; // idb
char aQuit[] = "QUIT\r\n"; // idb
char ExceptionHandler::s_intentionException = '\x01'; // weak
CHAR aCallStackInfor[] = "\r\nCall Stack Information\r\n"; // idb
CHAR a08x08x[] = "%08x  %08x  "; // idb
CHAR aSX[] = "%s+%x "; // idb
char aUnknown[8] = "Unknown"; // weak
CHAR a04x08xS[] = "%04x:%08x %s\r\n"; // idb
CHAR aParams08x08x08[] = "Params: %08x %08x %08x %08x\r\n"; // idb
CHAR aSBytesAtCsEip[] = "[%s] Bytes at CS:EIP: "; // idb
CHAR a02x[] = "%02x "; // idb
CHAR asc_46B030[] = "\r\n\r\n"; // idb
CHAR aIntelCallStack[] = "\r\nIntel Call Stack Information\r\n"; // idb
CHAR a08x08x04x08xS[] = "%08x  %08x  %04x:%08x %s\r\n"; // idb
CHAR aBytesAtCsEip[] = "Bytes at CS:EIP: "; // idb
CHAR a02x_0[] = "%02x "; // idb
CHAR asc_46B098[] = "\r\n\r\n"; // idb
char aDarkangel_ncso[] = "darkangel@ncsoft.co.kr"; // idb
char aServer_ncsoft_[20] = "server@ncsoft.co.kr"; // weak
char aMailFromS[] = "MAIL From: <%s>\r\n"; // idb
char aRcptToS[] = "RCPT To: <%s>\r\n"; // idb
CHAR anOutputString[] = "Error creating exception report"; // idb
CHAR aD04d02d02d02d0[] = "[(%d) %04d/%02d/%02d %02d:%02d:%02d]: =======================\r\n"; // idb
char aUnknown_0[8] = "Unknown"; // weak
CHAR aSInModuleSAt04[] = "%s in module %s at %04x:%08x.\r\n"; // idb
CHAR aExceptionHandl[] = "Exception handler called in the L2AuthD Server.\r\n"; // idb
CHAR aStartAtDDD02d0[] = "start at %d/%d/%d %02d:%02d:%02d\r\n"; // idb
char aReadFrom[10] = "Read from"; // weak
char aWriteTo[9] = "Write to"; // weak
CHAR aSLocation08xCa[] = "%s location %08x caused an access violation.\r\n"; // idb
CHAR aS_1[] = "%s"; // idb
char asc_46B21C[2] = { '\r', '\n' };
CHAR aRegisters[] = "Registers:\r\n"; // idb
CHAR aEax08xCs04xEip[] = "EAX=%08x CS=%04x EIP=%08x EFLGS=%08x\r\n"; // idb
CHAR aEbx08xSs04xEsp[] = "EBX=%08x SS=%04x ESP=%08x EBP=%08x\r\n"; // idb
CHAR aEcx08xDs04xEsi[] = "ECX=%08x DS=%04x ESI=%08x FS=%04x\r\n"; // idb
CHAR aEdx08xEs04xEdi[] = "EDX=%08x ES=%04x EDI=%08x GS=%04x\r\n"; // idb
CHAR aBytesAtCsEip_0[] = "Bytes at CS:EIP:\r\n"; // idb
CHAR a02x_1[] = "%02x "; // idb
CHAR aStackDump[] = "\r\nStack dump:\r\n"; // idb
CHAR a08x[] = "%08x: "; // idb
char asc_46B300[2] = " "; // weak
char asc_46B304[3] = "\r\n"; // weak
CHAR a08xS[] = "%08x%s"; // idb
CHAR aS_2[] = "%s"; // idb
CHAR aS_3[] = "%s"; // idb
CHAR aModuleListName[] = "\r\n\tModule list: names, addresses, sizes, time stamps and file times:\r\n"; // idb
CHAR aFileDateIs[] = " - file date is "; // idb
CHAR aSLoadedAt0x08x[] = "%s, loaded at 0x%08x - %d bytes - %08x%s\r\n"; // idb
CHAR aDDD02d02d02d[] = "%d/%d/%d %02d:%02d:%02d"; // idb
CHAR aErrorOccurredA[] = "Error occurred at %s.\r\n"; // idb
CHAR String2[] = "Unknown"; // idb
CHAR aUnknown_2[] = "Unknown"; // idb
CHAR aSRunByS_[] = "%s, run by %s.\r\n"; // idb
CHAR aDProcessorSTyp[] = "%d processor(s), type %d.\r\n"; // idb
CHAR aDMbytesPhysica[] = "%d MBytes physical memory.\r\n"; // idb
char aAControlC[12] = "a Control-C"; // weak
char aAControlBreak[16] = "a Control-Break"; // weak
char aADatatypeMisal[24] = "a Datatype Misalignment"; // weak
char aABreakpoint[13] = "a Breakpoint"; // weak
char aAnAccessViolat[20] = "an Access Violation"; // weak
char aAnInPageError[17] = "an In Page Error"; // weak
char aANoMemory[12] = "a No Memory"; // weak
char aAnIllegalInstr[23] = "an Illegal Instruction"; // weak
char aANoncontinuabl[27] = "a Noncontinuable Exception"; // weak
char aAnInvalidDispo[23] = "an Invalid Disposition"; // weak
char aAArrayBoundsEx[24] = "a Array Bounds Exceeded"; // weak
char aAFloatDenormal[25] = "a Float Denormal Operand"; // weak
char aAFloatDivideBy[23] = "a Float Divide by Zero"; // weak
char aAFloatInexactR[23] = "a Float Inexact Result"; // weak
char aAFloatInvalidO[26] = "a Float Invalid Operation"; // weak
char aAFloatOverflow[17] = "a Float Overflow"; // weak
char aAFloatStackChe[20] = "a Float Stack Check"; // weak
char aAFloatUnderflo[18] = "a Float Underflow"; // weak
char aAnIntegerDivid[26] = "an Integer Divide by Zero"; // weak
char aAnIntegerOverf[20] = "an Integer Overflow"; // weak
char aAPrivilegedIns[25] = "a Privileged Instruction"; // weak
char aAStackOverflow[17] = "a Stack Overflow"; // weak
char aADllInitializa[28] = "a DLL Initialization Failed"; // weak
char aAMicrosoftCExc[26] = "a Microsoft C++ Exception"; // weak
char aUnknownExcepti[23] = "Unknown exception type"; // weak
CHAR aL2authderror_t[] = "L2AuthDError.txt"; // idb
char aD04d02d02d02_0[] = "[(%d) %04d/%02d/%02d %02d:%02d:%02d]: "; // idb
char aDarkangel_nc_0[] = "darkangel@ncsoft.co.kr"; // idb
char aServer_ncsof_0[20] = "server@ncsoft.co.kr"; // weak
char ExceptionHandler::toMail[] = "darkangel@ncsoft.co.kr"; // idb
char ExceptionHandler::fromMail[20] = "server@ncsoft.co.kr"; // weak
char aIntentionalExc[] = "Intentional Exception\n"; // idb
volatile LONG CIOBufferPool::g_nAlloc = 4294967295; // idb
volatile LONG LSOverlappedPool::g_nAlloc = 4294967295; // idb
char aSocketErrorD[] = "socket error %d"; // idb
char aBindErrorD[] = "bind error %d"; // idb
char aListenErrorD[] = "listen error %d"; // idb
char aRegisterwaitEr[] = "RegisterWait error on port %d"; // idb
char aAcceptErrorD[] = "accept error: %d"; // idb
char aServercloseCre[] = "ServerClose:CreateSocket Fail"; // idb
char aNewWorldServer[] = "*new world server connection from %d.%d.%d.%d"; // idb
char aNonRegisteredW[] = "non-registered world server %d.%d.%d.%d"; // idb
char aIpD_D_D_DWorld[] = "ip: %d.%d.%d.%d world server socket already used"; // idb
char aServerReadyOnP[] = "server ready on port %d"; // idb
char aAcceptErrorD_0[] = "accept error: %d"; // idb
char aNewInteractive[] = "*new interactive socket connection from %d.%d.%d.%d"; // idb
char aInteractiveSer[] = "interactive server ready on port %d"; // idb
char aCioserverexCon[] = "CIOServerEx Constructor create socket timer fails"; // idb
char aSocketErrorD_0[] = "socket error %d"; // idb
char aAcceptexErrorD[] = "AcceptEx error %d"; // idb
char aAcceptexThread[] = "AcceptEx Thread Added %d"; // idb
char aAcceptexSocket[] = "acceptex socket error %d"; // idb
char aBindPortDError[] = "bind(port %d) error %d"; // idb
char aListenErrorD_0[] = "listen error %d"; // idb
char aCreateiocomple[] = "CreateIoCompletionPort: %d %x %x\n"; // idb
char aServiceReadyOn[] = "service ready on port %d"; // idb
char aAccesslimitExp[] = "AccessLimit Expire,%d.%d.%d.%d"; // idb
volatile LONG CPacketPool::g_nAlloc = 4294967295; // idb
char aInitilizeCompl[] = "Initilize CompletionPort Error CloseSocket"; // idb
char aInvalidSocket[] = "Invalid Socket!"; // idb
char aDifferentWrite[] = "different write count %x(%x) %d != %d"; // idb
char aCiosocketWrite[] = "CIOSocket::WriteCallback %x(%x) err=%d"; // idb
char aCiosocketReadX[] = "CIOSocket::Read %x(%x) err = %d"; // idb
char aCiosocketWri_0[] = "CIOSocket::Write %x(%x) err=%d"; // idb
char aServerclosePac[] = "ServerClose:PacketServerClose"; // idb
char asc_46BBEC[] = " \t"; // idb
char asc_46BBF0[] = " \t"; // idb
char aIplistStartAdd[] = "IPList: start address address is greater than end address at line %d"; // idb
char aIplistAddressI[] = "IPList: address is merged with %d.%d.%d.%d-%d.%d.%d.%d at line %d"; // idb
char aIplistAddres_0[] = "IPList: address is merged with %d.%d.%d.%d-%d.%d.%d.%d at line %d"; // idb
char aIplistLoadedFr[] = "IPList loaded from %s"; // idb
char aMissingLocaleF[21] = "missing locale facet"; // weak
char aC_0[] = "C"; // idb
volatile LONG IPPacketPool::g_nAlloc = 4294967295; // idb
bool (__cdecl *IPSocket::handlers[16])(IPSocket *, const unsigned __int8 *) =
{
  &IPSocket::packet0_handler,
  &IPSocket::packet_dummy_handler,
  &IPSocket::packet2_handler,
  &IPSocket::packet3_handler,
  &IPSocket::packet4_handler,
  &IPSocket::packet5_handler,
  &IPSocket::packet_dummy_handler,
  &IPSocket::packet_dummy_handler,
  &IPSocket::packet_dummy_handler,
  &IPSocket::packet9_handler,
  &IPSocket::packet10_handler,
  &IPSocket::packet11_handler,
  &IPSocket::packet_dummy_handler,
  &IPSocket::packet13_handler,
  &IPSocket::packet14_handler,
  &IPSocket::packet15_handler
};
char aIpsockettimerr[] = "IPSocketTimerRoutine"; // idb
char aCsddd[] = "csddd"; // idb
char aCddddd[] = "cddddd"; // idb
char aCc_23[] = "cc"; // idb
char aCallDummypacke[] = "Call DummyPacket What What What"; // idb
char aIpsocketDelete[] = "IPSocket Deleted"; // idb
char aCloseConnect_1[] = "*close connection IPServer from %s, %x(%x)"; // idb
char aCdc[] = "cdc"; // idb
char aDBadPacketSi_0[] = "%d: bad packet size %d"; // idb
char aUnknownProto_0[] = "unknown protocol %d"; // idb
char aDAssembleToo_1[] = "%d: assemble too large packet. format %s"; // idb
char aCdddcdd[] = "cdddcdd"; // idb
char aCddddcddsd[] = "cddddcddsd"; // idb
char aCdddcdd_0[] = "cdddcdd"; // idb
char aCdddcdd_1[] = "cdddcdd"; // idb
unsigned __int8 g_C1_BF_Key[21] =
{
  95u,
  59u,
  53u,
  46u,
  93u,
  57u,
  52u,
  45u,
  51u,
  49u,
  61u,
  61u,
  45u,
  37u,
  120u,
  84u,
  33u,
  94u,
  91u,
  36u,
  0u
};
char aC_1[] = "c"; // idb
CHAR WindowName[] = "AuthServer"; // idb
unsigned __int8 Caption[] = { 176u, 230u, 176u, 237u, 0u };
CHAR Text[8] = { '', '', '', '', ' ', '', '', '' }; // idb
char aNewCryptKey[40] = "9=3*2;x]11sa;/4sd.%+$@a*'!2z0~g`{z]?n8(";
char aAuthserver_0[11] = "AuthServer"; // weak
char aWsastartupErro[] = "WSAStartup error 0x%x"; // idb
char aAuthserverD[] = "AuthServer-%d"; // idb
CHAR aReset[] = "Reset"; // idb
CHAR ClassName[] = "BUTTON"; // idb
CHAR aReload[] = "Reload"; // idb
CHAR aButton_0[] = "BUTTON"; // idb
char configFileName[] = "etc/config.txt"; // idb
char stringKey[] = "TEST"; // idb
char fileName[] = "log"; // idb
char aErrorLoadConfi[] = "Error load config.txt"; // idb
char aLoadedConfig[] = "LOADED Config"; // idb
char aBuildnumberD[] = "BuildNumber : %d"; // idb
char aAcceptcallnull0SUM[33] = "AcceptCallNull  0   "; // idb
char aSockettimeout0SConnection[41] = "SocketTimeOut 0 Connection  "; // idb
char aWaitinguserlimit[25] =
{
  'W',
  'a',
  'i',
  't',
  'i',
  'n',
  'g',
  'U',
  's',
  'e',
  'r',
  'L',
  'i',
  'm',
  'i',
  't',
  '',
  '',
  ' ',
  '0',
  '',
  '',
  '',
  '',
  ' '
};
char byte_46C924[8] = { '', '', '', '', ' ', '', '', '' }; // idb
char aLoadForbiddenIpList[] = "LOAD FORBIDDEN IP LIST"; // idb
char a2[] = "etc\\BlockIPs.txt"; // idb
char aSendmailInitia[] = "Sendmail initialize Fail"; // idb
char aUpdateWorlds_3[] = "update worldstatus set status=0"; // idb
char aReadlockFailed[] = "ReadLock failed on dataLock"; // idb
char aWriteunlockSem[] = "WriteUnlock semaphore was not locked"; // idb
COLORREF color[4] = { 0u, 128u, 16711680u, 255u };
char aWinlog[] = "winlog"; // idb
char aUse[] = "use"; // idb
char aAct[] = "act"; // idb
char aErr[] = "err"; // idb
char aLog_0[] = "log"; // idb
CHAR sizeString[] = "H"; // idb
char aS04d02d02d_02d[] = "%s\\%04d-%02d-%02d.%02d.%s"; // idb
char aA[] = "a"; // idb
char a02d_02d_02d02d[] = "%02d.%02d.%02d %02d:%02d.%02d: "; // idb
char aS_4[] = "%s\r\n"; // idb
char aS04d02d02d_0_0[] = "%s\\%04d-%02d-%02d.%02d.%s"; // idb
char aA_0[] = "a"; // idb
char g_logFileNameFormat[] = "%s\\%04d-%02d-%02d.%02d.%s"; // idb
char aS04d02d02d_0_2[] = "%s\\%04d-%02d-%02d.%02d.%s"; // idb
char aS04d02d02d1000[] = "%s\\%04d-%02d-%02d-100%02d-201-authd-in%d.%s"; // idb
char aS04d02d02d10_0[] = "%s\\%04d-%02d-%02d-100%02d-201-authd-in0.%s"; // idb
char aS04d02d02d10_1[] = "%s\\%04d-%02d-%02d-100%02d-201-authd-in1.%s"; // idb
volatile LONG CLogPacketPool::g_nAlloc = 4294967295; // idb
void *CLogSocket::handlers = &CLogSocket::packet0_dummy_handler; // weak
char aCallDummypac_0[] = "Call DummyPacket What What What"; // idb
char aDeleteLogsocke[] = "DELETE LogSocket 0x%x"; // idb
char aDBadPacketSi_1[] = "%d: bad packet size %d"; // idb
char aUnknownProto_1[] = "unknown protocol %d"; // idb
char aLogdServerConn[] = "logd server connection close. invalid status and protocol %s, errorNum :%d\r\n"; // idb
char aCd_0[3] = "cd"; // weak
char aCdd_0[4] = "cdd"; // weak
char aLogdsocketCall[] = "logdsocket Call invalid"; // idb
char aDAssembleToo_2[] = "%d: assemble too large packet. format %s"; // idb
char aLogdsocketCa_0[] = "logdsocket Call invalid send2"; // idb
char aDAssembleToo_3[] = "%d: assemble too large packet. format %s"; // idb
char aCloseLogdConne[] = "*close logd connection from %s, %x(%x)"; // idb
char aDDDDDDMainSe_0[] = "%d-%d-%d %d:%d:%d,main server connection close from %s, 0x%x\r\n"; // idb
unsigned __int8 aA_1[] =
{
  128u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
};
volatile LONG CAuthPacketPool::g_nAlloc = 4294967295; // idb
char aPutback[] = "putback"; // idb
char aUnexpectedChar[] = "unexpected char '%c'"; // idb
CHAR asc_46CEC4[] = "H"; // idb
char aUser6dSocket4d[] = " user %-6d  | socket %-4d | AcceptCall %-3d  | RunningThread %-3d "; // idb
char aS0xX[] = "%s(0x%x)"; // idb
char a220[] = "220"; // idb
char aMailsendErrorS[] = "mailsend error , %s"; // idb
char aHeloMail_ncsof[] = "HELO mail.ncsoft.net\r\n"; // idb
char a250[] = "250"; // idb
char aMailFromS_0[] = "MAIL From:<%s>\r\n"; // idb
char a250_0[] = "250"; // idb
char asc_46CFBC[] = ";"; // idb
char aRcptToS_0[] = "RCPT TO:<%s>\r\n"; // idb
char a250_1[] = "250"; // idb
char asc_46CFD4[] = ";"; // idb
char aData_0[] = "DATA\r\n"; // idb
char aSubjectSToS[] = "Subject:%s\r\nTo:%s\r\n\r\n"; // idb
char aS_5[] = "%s\r\n"; // idb
char a__0[] = "\r\n.\r\n"; // idb
char byte_46D008[6] = { '\r', '\n', '.', '\r', '\n', '\0' };
char a250_3[] = "250"; // idb
char aQuit_0[] = "QUIT\r\n"; // idb
char aRt[] = "rt"; // idb
char aEtcServerlist[] = "etc\\serverlist"; // idb
char aCanTLoadServer[] = "can't load serverlist file"; // idb
char asc_46D04C[] = ","; // idb
char asc_46D050[] = ","; // idb
char asc_46D054[] = ","; // idb
char asc_46D058[] = ","; // idb
char asc_46D05C[] = ","; // idb
char asc_46D060[] = ","; // idb
char aServerDLoadedI[] = "Server %d loaded,innerip:%s,outerip:%s,%d"; // idb
char aSelectIdNameIp[] = "Select id, name, ip, inner_ip, ageLimit, pk_flag, kind, port From server Order by id"; // idb
char aLoadingServerl[] = "loading serverlist fail, serverid is not serialized"; // idb
char aServerDLoade_0[] = "Server %d loaded, innerip:%s,outerip:%s,port:%d,agelimit:%d,pk:%d"; // idb
char aSelectIdName_0[] = "Select id, name, ip, inner_ip, ageLimit, pk_flag, kind, port From server Order by id"; // idb
char aLoadingServe_0[] = "loading serverlist fail, serverid is not serialized"; // idb
char aServerDLoade_1[] = "Server %d loaded, innerip:%s,outerip:%s, %d"; // idb
char aServerLoadFail[] = "Server load fail, please check server table or DB connection string"; // idb
wchar_t aS_6[] = L"%S"; // idb
wchar_t aS_7[] = L"%S"; // idb
char aInsertUser_cou[] = "INSERT user_count ( server_id, world_user, limit_user, auth_user, wait_user) VALUES ( %d, %d, %d, %d, %d )"; // idb
char aInvalidVectorT[] = "invalid vector<T> subscript"; // idb
wchar_t aS_8[] = L"%S"; // idb
wchar_t aS_9[] = L"%S"; // idb
char aSelectMaxKindF[] = "Select Max(kind) From server With (Nolock)"; // idb
char aLoadServerkind[] = "Load ServerKindList fail!"; // idb
char aLoadServerki_0[] = "Load ServerKindList Memory Allocation Fail"; // idb
char aLoadServerki_1[] = "Load ServerKindList Memory Allocation Fail"; // idb
char aLoadServerki_2[] = "Load ServerKindList fail!"; // idb
char aSelectIdName_1[] = "Select id, name, ip, inner_ip, ageLimit, pk_flag,kind, port From server Order by id"; // idb
char aLoadingServe_1[] = "loading serverlist fail, serverid is not serialized"; // idb
char aLoadingServe_2[] = "Loading ServerList Fail."; // idb
char aReloadServerki[] = "Reload ServerKindList Fail!"; // idb
char aSelectMaxKin_0[] = "Select Max(kind) From server With (Nolock)"; // idb
char aReloadServer_0[] = "Reload ServerKindList Fail!"; // idb
char aReloadServer_1[] = "Reload ServerKindList Fail!"; // idb
char aReloadServer_2[] = "Reload ServerKindList Fail!, Memory Allocation Fail"; // idb
char aSelectIdName_2[] = "Select id, name, ip, inner_ip, ageLimit, pk_flag,kind, port From server Order by id"; // idb
char aReloadingServe[] = "Reloading serverlist fail, serverid is not serialized"; // idb
char aReloadServerli[] = "Reload ServerList Fail."; // idb
char aReloadServer_3[] = "Reload ServerKindList Fail!"; // idb
char aReloadserverli[] = "ReLoadServerListFrame Fail!!"; // idb
void (__cdecl *CAuthSocket_handlers_off_46D690[9])(CAuthSocket *, char *) =
{
  &CAuthSocket::packet00_RequestAuthLogin,
  &CAuthSocket::packet01_ServerListPacket,
  &CAuthSocket::packet02_RequestServerLogin,
  &CAuthSocket::packet03_CancelLogin,
  &CAuthSocket::packet04_unknownHandler,
  &CAuthSocket::packet05_RequestServerList_C4,
  &CAuthSocket::packet06_unknownHandler,
  &CAuthSocket::packet07_charsHandler,
  &CAuthSocket::packet08_unknownHandler
};
char aCc_27[3] = "cc"; // idb
char aCc_25[3] = "cc"; // idb
char aCdd_3[4] = "cdd"; // idb
char aCc_26[3] = "cc"; // idb
char aInsertGm_illeg[] = "INSERT gm_illegal_login ( account, ip ) VALUES ( '%s', '%d.%d.%d.%d' )"; // idb
char aCc_10[] = "cc"; // idb
char aCc_11[] = "cc"; // idb
char aCc_12[] = "cc"; // idb
char aServerListErro[] = "Server List Error, Check lin2DB Server Table"; // idb
char aCc_13[] = "cc"; // idb
char aCc_14[] = "cc"; // idb
char aCc_15[] = "cc"; // idb
char aMd5keyDoesNotM[] = "md5key does not matching"; // idb
char aCc_16[] = "cc"; // idb
char aCc_17[] = "cc"; // idb
char aCc_18[] = "cc"; // idb
char aServerListEr_0[] = "Server List Error, Check lin2DB Server Table"; // idb
char aCc_19[] = "cc"; // idb
char aCc_20[] = "cc"; // idb
char aCc_21[] = "cc"; // idb
char aCc_22[] = "cc"; // idb
char aDAssembleToo_4[] = "%d: assemble too large packet. format %s"; // idb
char aSelectWorld_id[] = "SELECT world_id FROM user_char WITH (NOLOCK) WHERE uid = %d"; // idb
char aCd_1[] = "cd"; // idb
char aCcdd[] = "ccdd"; // idb
char aCcdd_0[] = "ccdd"; // idb
char aCdchb[] = "cdchb"; // idb
char aCcdd_1[] = "ccdd"; // idb
char aCcdd_2[] = "ccdd"; // idb
char aCdcd[] = "cdcd"; // idb
char aCdch[] = "cdch"; // idb
char aCdch_0[] = "cdch"; // idb
char aCreateSocketT[] = "create socket timer error"; // idb
char aDBadPacketSi_2[] = "%d: bad packet size %d"; // idb
char aUnknownProto_2[] = "unknown protocol %d"; // idb
char aCdd_1[] = "cdd"; // idb
char aCdd_2[] = "cdd"; // idb
char aDAssembleToo_5[] = "%d: assemble too large packet. format %s"; // idb
char aDAssembleToo_6[] = "%d: assemble too large packet. format %s"; // idb
char aTimerThreadTer[] = "Timer thread terminated"; // idb
char aTerminateIothr[] = "terminate IOThreadServer"; // idb
char aIothreadServer[] = "IOThread Server Exit"; // idb
char aTerminateIot_0[] = "terminate IOThreadInt"; // idb
char aDDDDDDSSDD_D_D[] = "%d-%d-%d %d:%d:%d,%s,%s,%d,%d.%d.%d.%d,%d,%06d,%d\r\n"; // idb
wchar_t a02d02d04d02d02[] = L"%02d/%02d/%04d %02d:%02d:%02d.%03d ,%d,,%d,,,,,,%d.%d.%d.%d,,,%d,%d,%d,%d,%d,,,,,,,%s,,,\r\n"; // idb
wchar_t a02d02d04d02d_0[] = L"%02d/%02d/%04d %02d:%02d:%02d.%03d ,%d,,%d,,,,,,%d.%d.%d.%d,,,%d,%d,%d,%d,%d,,,,,,,%s,,,\r\n"; // idb
wchar_t a02d02d04d02d_1[] = L"%02d/%02d/%04d %02d:%02d:%02d.%03d ,%d,,%d,,,,,,%d.%d.%d.%d,,,%d,%d,%d,%d,%d,,,,,,,%s,,,\r\n"; // idb
wchar_t a02d02d04d02d_2[] = L"%02d/%02d/%04d %02d:%02d:%02d.%03d ,%d,,%d,,,,,,%d.%d.%d.%d,,,%d,%d,%d,,,,,,,,,%s,,,\r\n"; // idb
char aCdds[] = "cddS"; // idb
char a02d02d04d02d_3[] = "%02d/%02d/%04d %02d:%02d:%02d.%03d ,%d,,%d,,,,,,%d.%d.%d.%d,,,%d,%d,%d,%d,%d,,,,,,,%s,,,\r\n"; // idb
char a02d02d04d02d_4[] = "%02d/%02d/%04d %02d:%02d:%02d.%03d ,%d,,%d,,,,,,%d.%d.%d.%d,,,%d,%d,%d,%d,%d,,,,,,,%s,,,\r\n"; // idb
char a02d02d04d02d_5[] = "%02d/%02d/%04d %02d:%02d:%02d.%03d ,%d,,%d,,,,,,%d.%d.%d.%d,,,%d,%d,%d,%d,%d,,,,,,,%s,,,\r\n"; // idb
char a02d02d04d02d_6[] = "%02d/%02d/%04d %02d:%02d:%02d.%03d ,%d,,%d,,,,,,%d.%d.%d.%d,,,%d,%d,%d,,,,,,,,,%s,,,\r\n"; // idb
char aS_10[] = "%s"; // idb
char aInsufficientFr[] = "Insufficient FreeSpace!!!!, %s"; // idb
char subj[] = "AuthD Insufficient FreeSpace"; // idb
char aCheckdiskfrees[] = "CheckDiskFreeSpace ErrorCode %d"; // idb
volatile LONG CWantedPacketPool::g_nAlloc = 4294967295; // idb
int (__cdecl *CSocketWanted_handlers[4])(CWantedSocket *, char *) =
{
  &CWantedSocket::packet1_getVersion,
  &CWantedSocket::h2,
  &CWantedSocket::h3,
  &CWantedSocket::h4_dummy_packet
};
char aCallDummypac_1[] = "Call DummyPacket What What What"; // idb
char aGetVersionD[] = "Get Version %d"; // idb
char aWantedsocketDe[] = "WantedSocket Deleted"; // idb
char aCloseConnect_2[] = "*close connection WantedSocket from %s, %x(%x)"; // idb
char aDBadPacketSi_3[] = "%d: bad packet size %d"; // idb
char aUnknownProto_3[] = "unknown protocol %d"; // idb
char aDAssembleToo_7[] = "%d: assemble too large packet. format %s"; // idb
void **off_46F018 = &off_46EFE8; // weak
void *off_46F0E0 = (void *)0x46F0EA; // idb
unsigned __int16 _ctype[] = { 0u, 32u };
void *off_46F2F8 = &off_46F300; // idb
void *off_46F478 = &off_46F478; // weak
LPVOID lpMem = &off_46F478; // idb
int dword_46F488 = 4294967295; // weak
void **off_471498 = &off_46F478; // weak
int dword_47149C = 480; // weak
_UNKNOWN unk_472170; // weak
_UNKNOWN unk_472188; // weak
std::_tree::_Node *std::_tree::_Nil = NULL;
int std::_tree::_Nilrefs = 0; // weak
PwdCrypt g_PwdCrypt =
{
  {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  },
  {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  },
  {
    {
      {
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }
      }
    },
    {
      {
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }
      }
    },
    {
      {
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }
      }
    },
    {
      {
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }
      }
    },
    {
      {
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }
      }
    },
    {
      {
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }
      }
    },
    {
      {
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }
      }
    },
    {
      {
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }
      }
    },
    {
      {
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }
      }
    },
    {
      {
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }
      }
    },
    {
      {
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }
      }
    },
    {
      {
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }
      }
    },
    {
      {
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }
      }
    },
    {
      {
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }
      }
    },
    {
      {
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }
      }
    },
    {
      {
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }
      }
    }
  },
  {
    {
      {
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }
      }
    },
    {
      {
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }
      }
    },
    {
      {
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }
      }
    },
    {
      {
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }
      }
    },
    {
      {
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }
      }
    },
    {
      {
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }
      }
    },
    {
      {
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
        {  }
      }
    }
  }
};
Config g_Config;
std::_tree_str_str::_Node *std::_tree_str_str::_Nil;
int std::_tree_str_str::_Nilrefs; // weak
std::_tree_uid_acc::_Node *std::_tree_uid_acc1::_Nil;
int std::_tree_uid_acc1::_Nilrefs; // weak
Database g_dbManager;
Database *Database::instance;
CHAR aRegClass[4]; // idb
char Crypto::byte_47874C[4][256][4];
char Crypto::byte_47974C[16][1024];
unsigned __int8 Des::permutedKeyBits[56];
char Crypto::byte_47D784[56];
DesItem Crypto::some_des_key;
char Crypto::byte_47DFBC[16][6];
DesItem Crypto::some_other_des_key;
int ExceptionHandler::s_errorReported; // weak
LPTOP_LEVEL_EXCEPTION_FILTER ExceptionHandler::s_oldFilter; // idb
struct _RTL_CRITICAL_SECTION ExceptionHandler::g_criticalSection; // idb
char *ExceptionHandler::s_mailServerIP = ; // idb
CHAR ExceptionHandler::s_logPath[260];
int ExceptionHandler::bBeenHere; // weak
char ExceptionHandler::s_mailTemplate[256];
ExceptionHandler g_ExceptionHandler;
time_t ExceptionHandler::s_startTime; // idb
int dword_47EA54; // weak
char *dword_47EA58;
int dword_47EA5C; // weak
int dword_47EA60; // weak
CIOBufferSlot CIOBufferPool::g_slot[16];
char byte_47ECA9; // weak
volatile LONG CIOBufferPool::g_nFree; // idb
_UNKNOWN unk_47ECB0; // weak
CAuthServer g_authServer;
CIOServerInt g_CIOServerInt;
OverlappedSlot CAuthOverlappedPool::g_slot[16];
HANDLE g_SocketTimer; // idb
WorldSrvServer g_worldServServer;
volatile LONG StatusLine::g_acceptCalls; // idb
char byte_47EFD4; // weak
volatile LONG LSOverlappedPool::g_nFree; // idb
int dword_47EFDC; // weak
int dword_47EFE0; // weak
std::_tree_sock_sock::_Node *std::_tree_sock_sock::_Nil;
int std::_tree_sock_sock::_Nilrefs; // weak
WorldSrvPacketSlot WorldSrvPacketPool::g_slot[16];
volatile LONG WorldSrvPacket::g_nPendingPacket; // idb
char byte_47F235; // weak
volatile LONG CPacketPool::g_nFree; // idb
IpRegistry g_ipRegistry;
IPList g_blockedIPs;
IPList g_unusedIPs;
int dword_47F528; // weak
int dword_47F52C; // weak
int dword_47F534; // weak
std::locale::facet *dword_47F538; // idb
std::locale::facet *dword_47F53C; // idb
volatile LONG IPPacket::g_nPendingPacket; // idb
IPSessionDB g_IPSessionDB;
IPSlot IPPacketPool::g_slot[16];
ReadWriteLock IPSocket::s_lock; // idb
char byte_47F810; // weak
char IPSocket::isReconnecting; // weak
HANDLE IPSocket::s_timer; // idb
volatile LONG IPPacketPool::g_nFree; // idb
std::_tree_int_int::_Node *std::_tree_int_int::_Nil;
int std::_tree_int_int::_Nilrefs; // weak
#548 *std::_tree_int_sockid::_Nil;
int std::_tree_int_sockid::_Nilrefs; // weak
TimerQueue g_timerQueue;
int (__cdecl *UserInfoTable::pwdHash)(char *password);
HWND someDialog; // idb
HWND hWnd; // idb
HWND statusLineWindow; // idb
HWND resetBtn; // idb
HWND reloadBtn; // idb
HWND g_logHwnd; // idb
HINSTANCE hInstance; // idb
char Threading::s_threadsClosed; // weak
CHAR byte_47F8BC[4]; // idb
CHAR byte_47F8C0[8]; // idb
FileLog g_errLog; // idb
LogWindow g_LogWindow;
FileLog g_userLog; // idb
GeneralLog g_genLog; // idb
FileLog g_actLog; // idb
ReadWriteLock CLogSocket::s_lock; // idb
_UNKNOWN g_LogPacketPool; // weak
volatile LONG CLogPacket::g_nPendingPacket; // idb
CLogSlot CLogPacketPool::g_slot[16];
char byte_480178; // weak
char CLogSocket::isReconnecting; // weak
char CLogSocket::created; // weak
HANDLE CLogSocket::s_timer; // idb
volatile LONG CLogPacketPool::g_nFree; // idb
_UNKNOWN g_MemoryAllocatorsInitializer; // weak
volatile LONG g_CurrentMemoryAllocator; // idb
int g_MemoryAllocators[]; // weak
volatile LONG CAuthPacket::g_nPendingPacket; // idb
CAuthSlot CAuthPacketPool::g_slot[16];
char byte_480419; // weak
volatile LONG CAuthPacketPool::g_nFree; // idb
StatusLine g_StatusLine;
MailServer g_mailServer;
UserCountTable g_UserTable;
ServerList g_ServerList;
CHAR byte_481640[8]; // idb
ServerTable g_serverTable;
UserManager g_userManager;
HANDLE *g_hThread;
unsigned int *g_nThreadId;
HANDLE Threading::g_hCompletionPort; // idb
HANDLE *g_hThreadExtra;
HANDLE Threading::g_hCompletionPortExtra; // idb
unsigned int *g_nThreadIdExtra;
char g_bTerminating; // weak
volatile LONG StatusLine::g_nRunningThread; // idb
int UserManager::authCookie1; // weak
int UserManager::authCookie2; // weak
IPSocket *g_IPSocket;
CLogSocket *g_LogDSocket;
int cHeight; // idb
int cWidth; // idb
int cEscapement; // idb
int cOrientation; // idb
int cWeight; // idb
char byte_48171C; // weak
char byte_48171D; // weak
char byte_48171E; // weak
char byte_48171F; // weak
char byte_481720; // weak
char byte_481721; // weak
char byte_481722; // weak
char byte_481723; // weak
CHAR pszFaceName[36]; // idb
volatile LONG CWantedPacket::g_nPendingPacket; // idb
CWantedSocket *g_SocketWanted;
ReadWriteLock CWantedSocket::s_lock; // idb
CWantedPacketSlot CWantedPacketPool::g_slot[16];
char byte_4819B8; // weak
char CWantedSocket::isReconnecting; // weak
HANDLE g_WantedSockTimer; // idb
volatile LONG CWantedPacketPool::g_nFree; // idb
int dword_481A18; // weak
std::locale::facet *dword_481A20; // idb
LPVOID dword_481A28; // idb
_UNKNOWN unk_481A2C; // weak
_UNKNOWN unk_481A30; // weak
_UNKNOWN unk_481A38; // weak
_UNKNOWN unk_481A3C; // weak
int dword_481A40; // weak
int dword_481A44; // weak
int dword_481A48; // weak
std::locale::facet *dword_481A4C; // idb
std::locale::facet *dword_481A50; // idb
std::locale::facet *dword_481A54; // idb
_UNKNOWN unk_481A60; // weak
_UNKNOWN unk_481A6C; // weak
_UNKNOWN unk_481A70; // weak
_UNKNOWN unk_481A74; // weak
_UNKNOWN unk_481A78; // weak
_UNKNOWN unk_481A7C; // weak
_UNKNOWN unk_481A80; // weak
_UNKNOWN unk_481A84; // weak
_UNKNOWN unk_481A88; // weak
_UNKNOWN unk_481A8C; // weak
_UNKNOWN unk_481A90; // weak
_UNKNOWN unk_481A94; // weak
_UNKNOWN unk_481A98; // weak
_UNKNOWN unk_481A9C; // weak
int dword_481AA0; // weak
int dword_481AA4; // weak
int dword_481AA8; // weak
int dword_481AAC; // weak
int dword_481AB0; // weak
int dword_481AB4; // weak
int dword_481AB8; // weak
int dword_481ABC; // weak
int dword_481AC0; // weak
int dword_481AC4; // weak
int dword_481AC8; // weak
int dword_481ACC; // weak
int dword_481AD0; // weak
std::locale::facet *dword_481AD4; // idb
std::locale::facet *dword_481AD8; // idb
std::locale::facet *dword_481ADC; // idb
std::locale::facet *dword_481AE0; // idb
std::locale::facet *dword_481AE4; // idb
std::locale::facet *dword_481AE8; // idb
std::locale::facet *dword_481AEC; // idb
std::locale::facet *dword_481AF0; // idb
std::locale::facet *dword_481AF4; // idb
std::locale::facet *dword_481AF8; // idb
std::locale::facet *dword_481AFC; // idb
std::locale::facet *dword_481B00; // idb
std::locale::facet *dword_481B04; // idb
_UNKNOWN unk_481B08; // weak
_UNKNOWN unk_481B0C; // weak
_UNKNOWN unk_481B10; // weak
_UNKNOWN unk_481B14; // weak
_UNKNOWN unk_481B18; // weak
_UNKNOWN unk_481B1C; // weak
_UNKNOWN unk_481B20; // weak
_UNKNOWN unk_481B24; // weak
int dword_481B28; // weak
int dword_481B2C; // weak
int dword_481B30; // weak
int dword_481B34; // weak
int dword_481B38; // weak
int dword_481B3C; // weak
int dword_481B40; // weak
int dword_481B44; // weak
std::locale::facet *dword_481B48; // idb
std::locale::facet *dword_481B4C; // idb
std::locale::facet *dword_481B50; // idb
std::locale::facet *dword_481B54; // idb
std::locale::facet *dword_481B58; // idb
std::locale::facet *dword_481B5C; // idb
std::locale::facet *dword_481B60; // idb
std::locale::facet *dword_481B64; // idb
LCID dword_481C5C; // idb
LCID dword_481C60; // idb
int dword_481D64; // weak
int dword_481D68; // weak
FARPROC lpfn; // idb
char byte_481F34; // weak
char byte_481F40; // weak
char byte_481F41; // weak
char byte_482061[]; // weak
int dword_4832A8; // weak
int dword_4832AC; // weak
void *dword_4832B4; // idb
int dword_4832B8; // weak
LPVOID lp; // idb
int dword_4832C0; // weak
HANDLE hHeap; // idb
int dword_4832C8; // weak
int dword_4832CC; // weak
int dword_4832D4; // weak
volatile LONG dword_4832D8; // idb


//----- (00401000) --------------------------------------------------------
UserInfoTable *__thiscall UserInfoTable::UserInfoTable(UserInfoTable *this)
{
  UserInfoTable *this_; // ST0C_4@1

  this_ = this;
  this->vftable = (int)UserInfoTable_vtable_off_45F38C;
  this->flagUnused2 = 0;
  this->flagUnused = 0;
  this->blockFlag_custom = 0;
  this->blockFlag_standard = 0;
  this->flag_113 = 0;
  this->someChar2 = 0;
  memset(this->session, 0, 13u);
  this_->restOfSsn = 0;
  this_->lastworld = 0;
  return this_;
}
// 45F38C: using guessed type int (__stdcall *UserInfoTable_vtable_off_45F38C[2])(int);

//----- (00401074) --------------------------------------------------------
UserInfoTable *__thiscall UserInfoTable::Destructor(UserInfoTable *this)
{
  UserInfoTable *result; // eax@1

  result = this;
  this->vftable = (int)UserInfoTable_vtable_off_45F38C;
  return result;
}
// 45F38C: using guessed type int (__stdcall *UserInfoTable_vtable_off_45F38C[2])(int);

//----- (00401088) --------------------------------------------------------
int __thiscall UserInfoTable::addBlockReason(UserInfoTable *this, char *reasonBuffer)
{
  UserInfoTable *this_; // ST0C_4@1
  signed int length; // ST10_4@6
  SqlQuery sql; // [sp+8h] [bp-23Ch]@1
  char blockMsg[256]; // [sp+1Ch] [bp-228h]@1
  size_t msgLength; // [sp+11Ch] [bp-128h]@1
  char *iterator; // [sp+120h] [bp-124h]@1
  bool notFound[4]; // [sp+124h] [bp-120h]@2
  char blockCount; // [sp+128h] [bp-11Ch]@1
  int unused_1; // [sp+12Ch] [bp-118h]@1
  int totalLength; // [sp+130h] [bp-114h]@1
  wchar_t var110[256]; // [sp+134h] [bp-110h]@4
  int reasonCode; // [sp+234h] [bp-10h]@1
  int unused_; // [sp+240h] [bp-4h]@1

  this_ = this;
  totalLength = 1;
  reasonCode = 0;
  msgLength = 0;
  blockCount = 0;
  iterator = reasonBuffer;
  unused_1 = 256;
  SqlQuery::SqlQuery(&sql, &g_dbManager);
  unused_ = 0;
  SqlQuery::bindInt(&sql, &reasonCode);
  SqlQuery::bindStr(&sql, blockMsg, 256);
  ++iterator;
  if ( SqlQuery::exec(&sql, aSelectReasonMs, this_->uid) )
  {
    while ( SqlQuery::fetch(&sql, notFound) )
    {
      if ( notFound[0] )
        break;
      msgLength = 0;
      msgLength = 2 * swprintf(var110, aS, blockMsg) + 2;
      if ( (signed int)(msgLength + totalLength + 4) >= 0x1000 )
        break;
      memcpy(iterator, &reasonCode, 4u);
      iterator += 4;
      memcpy(iterator, var110, msgLength);
      iterator += msgLength;
      ++blockCount;
      totalLength += msgLength + 4;
    }
  }
  memcpy(reasonBuffer, &blockCount, 1u);
  length = iterator - reasonBuffer;
  unused_ = -1;
  SqlQuery::Destructor(&sql);
  return length;
}

//----- (004012A9) --------------------------------------------------------
char __thiscall UserInfoTable::loadInfo(UserInfoTable *this, char *accountName)
{
  UserInfoTable *this_; // ST28_4@1
  SQLINTEGER accLength; // eax@1
  char result; // al@4
  SqlQuery sql; // [sp+14h] [bp-150h]@1
  SQLINTEGER null_8; // [sp+28h] [bp-13Ch]@1
  SQLINTEGER null_4; // [sp+2Ch] [bp-138h]@1
  SQLINTEGER ll_6; // [sp+30h] [bp-134h]@1
  SQLINTEGER nll_8; // [sp+34h] [bp-130h]@1
  SQLINTEGER null_9; // [sp+38h] [bp-12Ch]@1
  char sqlQuery[256]; // [sp+3Ch] [bp-128h]@1
  bool notFound[4]; // [sp+13Ch] [bp-28h]@2
  SQLINTEGER null_3; // [sp+140h] [bp-24h]@1
  SQLINTEGER null_1; // [sp+144h] [bp-20h]@1
  SQLINTEGER null_2; // [sp+148h] [bp-1Ch]@1
  SQLINTEGER ll; // [sp+14Ch] [bp-18h]@1
  SQLINTEGER null_5; // [sp+150h] [bp-14h]@1
  SQLRETURN sqlFailed; // [sp+154h] [bp-10h]@1
  int unused_1; // [sp+160h] [bp-4h]@1

  this_ = this;
  SqlQuery::SqlQuery(&sql, &g_dbManager);
  unused_1 = 0;
  null_1 = SQL_NTS;
  accLength = strlen(accountName);
  SqlQuery::bindParam(
    (SqlQuery *)sql.sqlHandler,
    1u,
    SQL_PARAM_INPUT,
    SQL_C_CHAR,
    SQL_VARCHAR,
    14u,
    0,
    accountName,
    accLength,
    &null_1);
  null_2 = 0;
  SqlQuery::bindParam((SqlQuery *)sql.sqlHandler, 2u, SQL_PARAM_OUTPUT, -18, SQL_INTEGER, 0, 0, &this_->uid, 0, &null_2);
  null_3 = 0;
  SqlQuery::bindParam(
    (SqlQuery *)sql.sqlHandler,
    3u,
    SQL_PARAM_OUTPUT,
    -18,
    SQL_INTEGER,
    0,
    0,
    &this_->payStat,
    0,
    &null_3);
  null_4 = 0;
  SqlQuery::bindParam(
    (SqlQuery *)sql.sqlHandler,
    4u,
    SQL_PARAM_OUTPUT,
    -18,
    SQL_INTEGER,
    0,
    0,
    &this_->loginFlag,
    0,
    &null_4);
  null_5 = 0;
  SqlQuery::bindParam(
    (SqlQuery *)sql.sqlHandler,
    5u,
    SQL_PARAM_OUTPUT,
    -18,
    SQL_INTEGER,
    0,
    0,
    &this_->warnFlag,
    0,
    &null_5);
  ll_6 = 0;
  SqlQuery::bindParam(
    (SqlQuery *)sql.sqlHandler,
    6u,
    SQL_PARAM_OUTPUT,
    -18,
    SQL_INTEGER,
    0,
    0,
    &this_->blockFlag_custom,
    0,
    &ll_6);
  ll = 0;
  SqlQuery::bindParam(
    (SqlQuery *)sql.sqlHandler,
    7u,
    SQL_PARAM_OUTPUT,
    -18,
    SQL_INTEGER,
    0,
    0,
    &this_->blockFlag_standard,
    0,
    &ll);
  nll_8 = 0;
  SqlQuery::bindParam(
    (SqlQuery *)sql.sqlHandler,
    8u,
    SQL_PARAM_OUTPUT,
    -18,
    SQL_INTEGER,
    0,
    0,
    &this_->subscriptionFlag,
    0,
    &nll_8);
  null_9 = 0;
  SqlQuery::bindParam((SqlQuery *)sql.sqlHandler, 9u, SQL_PARAM_OUTPUT, -28, -6, 0, 0, &this_->lastworld, 0, &null_9);// SQL_C_UTINYINT, SQL_TINYINT
  this_->block_end_date.year = -1;
  null_8 = 0;
  SqlQuery::bindParam(
    (SqlQuery *)sql.sqlHandler,
    10u,
    SQL_PARAM_OUTPUT,
    SQL_TYPE_TIMESTAMP,                         // SQL_C_TYPE_TIMESTAMP
    SQL_TYPE_TIMESTAMP,
    23u,
    3,
    &this_->block_end_date,
    0,
    &null_8);
  sprintf(sqlQuery, aCallDbo_ap_gst);
  sqlFailed = SqlQuery::execRaw((SqlQuery *)sql.sqlHandler, sqlQuery, SQL_NTS);
  if ( sqlFailed )
  {
    SqlQuery::printError(&sql, SQL_HANDLE_STMT, sql.sqlHandler, sqlQuery);
    SqlQuery::reset(&sql);
    unused_1 = -1;
    SqlQuery::Destructor(&sql);
    result = REASON_SYSTEM_ERROR_LOGIN_LATER;
  }
  else if ( SqlQuery::fetch(&sql, notFound) )
  {
    if ( notFound[0] )
    {
      SqlQuery::reset(&sql);
      unused_1 = -1;
      SqlQuery::Destructor(&sql);
      result = REASON_ACCESS_FAILED_TRY_AGAIN_LATER;
    }
    else
    {
      SqlQuery::reset(&sql);
      unused_1 = -1;
      SqlQuery::Destructor(&sql);
      result = REASON_SUCCESS;
    }
  }
  else
  {
    SqlQuery::reset(&sql);
    unused_1 = -1;
    SqlQuery::Destructor(&sql);
    result = REASON_ACCESS_FAILED_TRY_AGAIN_LATER;
  }
  return result;
}

//----- (00401627) --------------------------------------------------------
char __thiscall UserInfoTable::loadSession(UserInfoTable *this)
{
  struct tm *now; // eax@6
  UserInfoTable *this_; // [sp+0h] [bp-48h]@1
  SqlQuery sql; // [sp+10h] [bp-38h]@2
  int dayMonthEncoded; // [sp+24h] [bp-24h]@15
  struct tm *now_; // [sp+28h] [bp-20h]@9
  bool notFound[4]; // [sp+2Ch] [bp-1Ch]@2
  char yearRest; // [sp+30h] [bp-18h]@9
  char modulo; // [sp+31h] [bp-17h]@9
  int sessionData; // [sp+34h] [bp-14h]@15
  time_t sysTime; // [sp+38h] [bp-10h]@6
  int unused_; // [sp+44h] [bp-4h]@2

  this_ = this;
  if ( !g_Config.CountryCode )
  {
    SqlQuery::SqlQuery(&sql, &g_dbManager);
    unused_ = 0;
    SqlQuery::reset(&sql);
    SqlQuery::bindStr(&sql, this_->session, 14);
    notFound[0] = 1;
    if ( !SqlQuery::exec(&sql, aSelectSsnFromU, this_->account) )
    {
      unused_ = -1;
      SqlQuery::Destructor(&sql);
      return REASON_SYSTEM_ERROR_LOGIN_LATER;
    }
    if ( !SqlQuery::fetch(&sql, notFound) )
    {
      unused_ = -1;
      SqlQuery::Destructor(&sql);
      return REASON_ACCOUNT_INFO_INCORRECT_CONTACT_SUPPORT;
    }
    if ( notFound[0] )
    {
      unused_ = -1;
      SqlQuery::Destructor(&sql);
      return REASON_ACCOUNT_INFO_INCORRECT_CONTACT_SUPPORT;
    }
    sysTime = time(0);
    now = localtime(&sysTime);
    now_ = now;
    yearRest = now->tm_year / 10 + '0';
    modulo = now->tm_year % 10 + '0';
    this_->someChar2 = this_->session[6] - '0';
    if ( this_->session[6] != '1' && this_->session[6] != '2' && this_->session[6] != '5' && this_->session[6] != '6' )
      this_->age = 10 * (this_->session[0] - '0') + this_->session[1] - '0';
    else
      this_->age = modulo - this_->session[1] + 10 * (yearRest - this_->session[0]);
    dayMonthEncoded = now_->tm_mday + 100 * (now_->tm_mon + 1);
    sessionData = 10 * (this_->session[4] - '0')
                + 100 * (this_->session[3] - '0')
                + 1000 * (this_->session[2] - '0')
                + this_->session[5]
                - '0';
    if ( dayMonthEncoded < sessionData )
      --this_->age;
    if ( this_->age < 0 )
      this_->age = 0;
    this_->flag_113 = 10000 * (10 * (this_->session[0] - '0') + this_->session[1] - '0') + sessionData;
    this_->restOfSsn = atoi(&this_->session[6]);
    unused_ = -1;
    SqlQuery::Destructor(&sql);
  }
  return 0;
}

//----- (004018BB) --------------------------------------------------------
char __thiscall UserInfoTable::loadCryptedPassword(UserInfoTable *this, const char *acc, char *hashedPwd)
{
  SQLINTEGER accLength; // eax@1
  char result; // al@4
  UserInfoTable *this_; // [sp+0h] [bp-144h]@1
  bool notFound[4]; // [sp+14h] [bp-130h]@2
  SqlQuery sql; // [sp+18h] [bp-12Ch]@1
  SQLINTEGER null_1; // [sp+2Ch] [bp-118h]@1
  char sqlSelect[256]; // [sp+30h] [bp-114h]@1
  SQLINTEGER null_0; // [sp+130h] [bp-14h]@1
  SQLRETURN sqlFailed; // [sp+134h] [bp-10h]@1
  int unused_; // [sp+140h] [bp-4h]@1

  this_ = this;
  *hashedPwd = 0;
  SqlQuery::SqlQuery(&sql, &g_dbManager);
  unused_ = 0;
  null_0 = SQL_NTS;
  accLength = strlen(acc);
  SqlQuery::bindParam(
    (SqlQuery *)sql.sqlHandler,
    1u,
    SQL_PARAM_INPUT,
    SQL_C_CHAR,
    SQL_VARCHAR,
    14u,
    0,
    (SQLPOINTER)acc,
    accLength,
    &null_0);
  null_1 = SQL_NTS;
  SqlQuery::bindParam((SqlQuery *)sql.sqlHandler, 2u, SQL_PARAM_OUTPUT, -2, -2, 16u, 0, hashedPwd, 16, &null_1);// SQL_C_BINARY, SQL_BINARY
  sprintf(sqlSelect, aCallDbo_ap_gpw);
  sqlFailed = SqlQuery::execRaw((SqlQuery *)sql.sqlHandler, sqlSelect, SQL_NTS);
  if ( sqlFailed )
  {
    SqlQuery::printError(&sql, SQL_HANDLE_STMT, sql.sqlHandler, sqlSelect);
    SqlQuery::reset(&sql);
    unused_ = -1;
    SqlQuery::Destructor(&sql);
    result = REASON_SYSTEM_ERROR_LOGIN_LATER;
  }
  else if ( SqlQuery::fetch(&sql, notFound) )
  {
    if ( notFound[0] )
    {
      SqlQuery::reset(&sql);
      unused_ = -1;
      SqlQuery::Destructor(&sql);
      result = REASON_PASS_WRONG;
    }
    else
    {
      memset(this_->account, 0, 15u);
      strcpy(this_->account, acc);
      SqlQuery::reset(&sql);
      unused_ = -1;
      SqlQuery::Destructor(&sql);
      result = REASON_SUCCESS;
    }
  }
  else
  {
    SqlQuery::reset(&sql);
    unused_ = -1;
    SqlQuery::Destructor(&sql);
    result = REASON_PASS_WRONG;
  }
  return result;
}

//----- (00401ACF) --------------------------------------------------------
char __thiscall UserInfoTable::findUser(UserInfoTable *this, char *account, char *realPass)
{
  char result; // al@3
  UserInfoTable *this_; // [sp+0h] [bp-1Ch]@1
  char errorCode; // [sp+4h] [bp-18h]@1
  char errorCode_; // [sp+4h] [bp-18h]@4
  char storedHashedPwd[16]; // [sp+8h] [bp-14h]@1
  char unused_; // [sp+18h] [bp-4h]@2

  this_ = this;
  errorCode = UserInfoTable::loadCryptedPassword(this, account, storedHashedPwd);
  if ( errorCode )
  {
    result = errorCode;
  }
  else
  {
    UserInfoTable::pwdHash(realPass);
    unused_ = 0;
    if ( !strcmp(realPass, storedHashedPwd) )
    {
      errorCode_ = UserInfoTable::loadInfo(this_, account);
      if ( errorCode_ )
      {
        result = errorCode_;
      }
      else if ( !g_Config.Gmcheckmode || this_->loginFlag & 0x10 || this_->loginFlag & 0x20 )
      {
        if ( this_->loginFlag & 3 )
          result = REASON_TEMP_PASS_EXPIRED;
        else
          result = UserInfoTable::loadSession(this_);
      }
      else
      {
        result = REASON_SERVER_MAINTENANCE;
      }
    }
    else
    {
      result = REASON_USER_OR_PASS_WRONG;
    }
  }
  return result;
}

//----- (00401B99) --------------------------------------------------------
char __thiscall UserInfoTable::findUser_newCrypt(UserInfoTable *this, const char *accName, const char *realPass)
{
  SQLINTEGER accLength; // eax@1
  char result; // al@4
  SQLINTEGER acLength_; // eax@15
  char errorCode_; // ST2C_1@29
  UserInfoTable *this_; // [sp+0h] [bp-198h]@1
  char error; // [sp+2Ch] [bp-16Ch]@20
  SqlQuery sql; // [sp+30h] [bp-168h]@1
  SQLINTEGER pwdLength; // [sp+44h] [bp-154h]@1
  size_t realPassLength; // [sp+48h] [bp-150h]@11
  bool notFound[4]; // [sp+4Ch] [bp-14Ch]@2
  char sqlQuery[256]; // [sp+50h] [bp-148h]@1
  SQLINTEGER nl_1; // [sp+150h] [bp-48h]@1
  int i; // [sp+154h] [bp-44h]@11
  char passStoredInNewCrypt; // [sp+158h] [bp-40h]@1
  char realPassCopy[17]; // [sp+15Ch] [bp-3Ch]@1
  char storedPwd[17]; // [sp+170h] [bp-28h]@1
  SQLRETURN sqlResult; // [sp+184h] [bp-14h]@1
  SQLINTEGER null_2; // [sp+188h] [bp-10h]@1
  int unused_; // [sp+194h] [bp-4h]@1

  this_ = this;
  passStoredInNewCrypt = 0;
  SqlQuery::SqlQuery(&sql, &g_dbManager);
  unused_ = 0;
  strncpy(realPassCopy, realPass, 16u);
  realPassCopy[16] = 0;
  memset(storedPwd, 0, 17u);
  nl_1 = SQL_NTS;
  pwdLength = 16;
  null_2 = 0;
  accLength = strlen(accName);
  SqlQuery::bindParam(
    (SqlQuery *)sql.sqlHandler,
    1u,
    SQL_PARAM_INPUT,
    SQL_C_CHAR,
    SQL_VARCHAR,
    14u,
    0,
    (SQLPOINTER)accName,
    accLength,
    &nl_1);
  SqlQuery::bindParam((SqlQuery *)sql.sqlHandler, 2u, SQL_PARAM_OUTPUT, -2, -2, 16u, 0, storedPwd, 16, &pwdLength);// BINARY
  SqlQuery::bindParam((SqlQuery *)sql.sqlHandler, 3u, SQL_PARAM_OUTPUT, -6, -6, 0, 0, &passStoredInNewCrypt, 0, &null_2);// TINYINT
  sprintf(sqlQuery, aCallDbo_ap_g_0);
  sqlResult = SqlQuery::execRaw((SqlQuery *)sql.sqlHandler, sqlQuery, SQL_NTS);
  if ( sqlResult )
  {
    SqlQuery::printError(&sql, SQL_HANDLE_STMT, sql.sqlHandler, sqlQuery);
    SqlQuery::reset(&sql);
    unused_ = -1;
    SqlQuery::Destructor(&sql);
    return REASON_SYSTEM_ERROR_LOGIN_LATER;
  }
  if ( !SqlQuery::fetch(&sql, notFound) )
  {
    SqlQuery::reset(&sql);
    unused_ = -1;
    SqlQuery::Destructor(&sql);
    return REASON_PASS_WRONG;
  }
  if ( notFound[0] )
  {
    SqlQuery::reset(&sql);
    unused_ = -1;
    SqlQuery::Destructor(&sql);
    return REASON_PASS_WRONG;
  }
  memset(this_->account, 0, 15u);
  strcpy(this_->account, accName);
  SqlQuery::reset(&sql);
  *((_BYTE *)realPass + 16) = 0;
  if ( !passStoredInNewCrypt )
  {
    UserInfoTable::pwdHash((char *)realPass);
    if ( strcmp(storedPwd, realPass) )
    {
      unused_ = -1;
      SqlQuery::Destructor(&sql);
      return REASON_USER_OR_PASS_WRONG;
    }
  }
  realPassLength = strlen(realPassCopy);
  for ( i = realPassLength; i < 16; ++i )
    realPassCopy[i] = 0x10;
  DesFrontEnd2::Decrypt(&g_PwdCrypt, realPassCopy, 16);
  if ( passStoredInNewCrypt )
  {
    if ( memcmp(storedPwd, realPassCopy, 16u) ) // decrypted pwd missmatch
    {
      unused_ = -1;
      SqlQuery::Destructor(&sql);
      return REASON_USER_OR_PASS_WRONG;
    }
  }
  else                                          // force to change pwd
  {
    nl_1 = SQL_NTS;
    pwdLength = 16;
    acLength_ = strlen(accName);
    SqlQuery::bindParam(
      (SqlQuery *)sql.sqlHandler,
      1u,
      SQL_PARAM_INPUT,
      SQL_C_CHAR,
      SQL_VARCHAR,
      14u,
      0,
      (SQLPOINTER)accName,
      acLength_,
      &nl_1);
    SqlQuery::bindParam((SqlQuery *)sql.sqlHandler, 2u, SQL_PARAM_INPUT, -2, -2, 16u, 0, realPassCopy, 16, &pwdLength);
    sprintf(sqlQuery, aCallDbo_ap_sne);
    sqlResult = SqlQuery::execRaw((SqlQuery *)sql.sqlHandler, sqlQuery, SQL_NTS);
    if ( sqlResult )
    {
      SqlQuery::printError(&sql, SQL_HANDLE_STMT, sql.sqlHandler, sqlQuery);
      SqlQuery::reset(&sql);
      unused_ = -1;
      SqlQuery::Destructor(&sql);
      return REASON_SYSTEM_ERROR_LOGIN_LATER;
    }
    SqlQuery::reset(&sql);
  }
  error = UserInfoTable::loadInfo(this_, (char *)accName);
  if ( error )
  {
    unused_ = -1;
    SqlQuery::Destructor(&sql);
    result = error;
  }
  else if ( !g_Config.Gmcheckmode || this_->loginFlag & 0x10 || this_->loginFlag & 0x20 )
  {
    if ( this_->loginFlag & 3 )
    {
      unused_ = -1;
      SqlQuery::Destructor(&sql);
      result = REASON_TEMP_PASS_EXPIRED;
    }
    else
    {
      errorCode_ = UserInfoTable::loadSession(this_);
      unused_ = -1;
      SqlQuery::Destructor(&sql);
      result = errorCode_;
    }
  }
  else
  {
    unused_ = -1;
    SqlQuery::Destructor(&sql);
    result = REASON_SERVER_MAINTENANCE;
  }
  return result;
}

//----- (004020C5) --------------------------------------------------------
int SomeStaticInit2()
{
  SomeBitsInit();
  return sub_4020D4();
}

//----- (004020D4) --------------------------------------------------------
int sub_4020D4()
{
  return atexit(emptystub);
}

//----- (004020F0) --------------------------------------------------------
UserInfoTable *__thiscall UserInfoTable::DeletingDtor(UserInfoTable *this, char a2)
{
  UserInfoTable *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  UserInfoTable::Destructor(this);
  if ( a2 & 1 )
    _delete_table(v3);
  return v3;
}

//----- (00402120) --------------------------------------------------------
int SomeBitsInit()
{
  int result; // eax@1

  result = byte_481F40 & 1;
  if ( !(byte_481F40 & 1) )
    byte_481F40 |= 1u;
  return result;
}
// 481F40: using guessed type char byte_481F40;

//----- (00402150) --------------------------------------------------------
void __cdecl emptystub()
{
  ;
}

//----- (00402160) --------------------------------------------------------
char __cdecl UserManager::notifyUserLoggedOut(char *accName, int uid, int serverId)
{
  char result; // al@4
  time_t now; // [sp+4h] [bp-1Ch]@6
  char packet[24]; // [sp+8h] [bp-18h]@5

  if ( LOBYTE(g_Config.UseWantedSystem) && !CWantedSocket::isReconnecting && serverId > 0 )
  {
    memset(packet, 0, 24u);
    if ( g_Config.GameID == 8 )
    {
      packet[0] = 2;
      memcpy(&packet[1], &uid, 4u);
      strcpy(&packet[5], accName);
      packet[19] = serverId;
      now = time(0);
      memcpy(&packet[20], &now, 4u);
      if ( g_SocketWanted && LOBYTE(g_Config.UseWantedSystem) && !CWantedSocket::isReconnecting )
      {
        LogWindow::Add(&g_LogWindow, 2, aWantedUserLogo, accName);
        ReadWriteLock::readLock(&CWantedSocket::s_lock);
        MemoryObject::AddRef(&g_SocketWanted->base.base);
        CWantedSocket::send(g_SocketWanted, aCb, 1, 24, packet);
        MemoryObject::Release(&g_SocketWanted->base.base);
        ReadWriteLock::releaseReadLock(&CWantedSocket::s_lock);
      }
      result = true;
    }
    else
    {
      result = true;
    }
  }
  else
  {
    result = true;
  }
  return result;
}
// 4819B9: using guessed type char CWantedSocket::isReconnecting;

//----- (00402281) --------------------------------------------------------
UserManager *__thiscall UserManager::UserManager(UserManager *this)
{
  UserManager *this_; // ST08_4@1
  char v3; // [sp+4h] [bp-14h]@1
  char v4; // [sp+8h] [bp-10h]@1
  int v5; // [sp+14h] [bp-4h]@1

  this_ = this;
  std::map::map2(&this->m_accounts, &v3, &v4);
  v5 = 0;
  SpinLock::SpinLock(&this_->m_spinLock, LockType_CritSection, 0);
  this_->vftbl_off_45F390 = (int *)&UserManager_vtable_off_45F390;
  return this_;
}
// 45F390: using guessed type int (__stdcall *UserManager_vtable_off_45F390)(int);

//----- (004022E9) --------------------------------------------------------
void __thiscall UserManager::Destructor(UserManager *this)
{
  UserManager *v1; // ST00_4@1

  v1 = this;
  this->vftbl_off_45F390 = (int *)&UserManager_vtable_off_45F390;
  SpinLock::Destructor(&this->m_spinLock);
  std::map::destructor_2(&v1->m_accounts);
}
// 45F390: using guessed type int (__stdcall *UserManager_vtable_off_45F390)(int);

//----- (00402340) --------------------------------------------------------
char __thiscall UserManager::userAuthed(UserManager *this, int uid, char *accountName)
{
  std::_tree::iterator *end; // eax@1
  std::pair_AccountInfo *pair; // eax@2
  UserManager *this_; // [sp+0h] [bp-14h]@1
  std::_tree::iterator v7; // [sp+4h] [bp-10h]@1
  std::_tree::iterator it; // [sp+8h] [bp-Ch]@1
  HANDLE timer; // [sp+Ch] [bp-8h]@1
  char lastworld; // [sp+10h] [bp-4h]@1

  this_ = this;
  lastworld = 0;
  timer = 0;
  SpinLock::Enter(&this->m_spinLock);
  std::map::find(&this_->m_accounts, &it, &uid);
  end = std::map::end(&this_->m_accounts, &v7);
  if ( (unsigned __int8)std::_tree::iterator::not_equal(&it, end) )
  {
    pair = std::_tree::iterator::value(&it);
    strncpy(accountName, pair->value.accountName, 15u);
    timer = std::_tree::iterator::value(&it)->value.timerHandler;
    std::_tree::iterator::value(&it)->value.timerHandler = 0;
    lastworld = std::_tree::iterator::value(&it)->value.lastworld;
    SpinLock::Leave(&this_->m_spinLock);
  }
  else
  {
    SpinLock::Leave(&this_->m_spinLock);
    lastworld = -1;
  }
  if ( timer )
    DeleteTimerQueueTimer(0, timer, 0);
  return lastworld;
}

//----- (00402411) --------------------------------------------------------
char __thiscall UserManager::userReadyForGS(UserManager *this, int uid, char *accName, int *loginFlag, int *warnFlag, int *payStat, int *sessionKey)
{
  std::_tree::iterator *end; // eax@1
  std::pair_AccountInfo *v8; // eax@2
  std::pair_AccountInfo *v9; // eax@2
  std::pair_AccountInfo *v10; // eax@2
  std::pair_AccountInfo *v11; // eax@2
  std::pair_AccountInfo *v12; // eax@2
  UserManager *this_; // [sp+0h] [bp-14h]@1
  std::_tree::iterator v15; // [sp+4h] [bp-10h]@1
  std::_tree::iterator it; // [sp+8h] [bp-Ch]@1
  HANDLE Timer; // [sp+Ch] [bp-8h]@1
  char result_1; // [sp+10h] [bp-4h]@1

  this_ = this;
  result_1 = 0;
  Timer = 0;
  SpinLock::Enter(&this->m_spinLock);
  std::map::find(&this_->m_accounts, &it, &uid);
  end = std::map::end(&this_->m_accounts, &v15);
  if ( (unsigned __int8)std::_tree::iterator::not_equal(&it, end) )
  {
    v8 = std::_tree::iterator::value(&it);
    strncpy(accName, v8->value.accountName, 15u);
    v9 = std::_tree::iterator::value(&it);
    *loginFlag = v9->value.loginFlag;
    v10 = std::_tree::iterator::value(&it);
    *warnFlag = v10->value.warnFlag;
    v11 = std::_tree::iterator::value(&it);
    *payStat = v11->value.payStat;
    Timer = std::_tree::iterator::value(&it)->value.timerHandler;
    v12 = std::_tree::iterator::value(&it);
    *sessionKey = v12->value.sessionKey;
    std::_tree::iterator::value(&it)->value.timerHandler = 0;
    result_1 = true;
  }
  SpinLock::Leave(&this_->m_spinLock);
  if ( Timer )
    DeleteTimerQueueTimer(0, Timer, 0);
  return result_1;
}

//----- (00402507) --------------------------------------------------------
PlayFail __thiscall UserManager::bindUserWithGameServer(UserManager *this, int uid, SOCKET socket, int sessionKey, char serverId)
{
  std::_tree::iterator *end; // eax@1
  std::pair_AccountInfo *accInfo; // eax@2
  std::pair_AccountInfo *accInfo_; // eax@4
  std::pair_AccountInfo *accInfo_0; // eax@4
  PlayFail result; // eax@4
  UserManager *this_; // [sp+0h] [bp-Ch]@1
  std::_tree::iterator a2; // [sp+4h] [bp-8h]@1
  std::_tree::iterator it; // [sp+8h] [bp-4h]@1

  this_ = this;
  SpinLock::Enter(&this->m_spinLock);
  std::map::find(&this_->m_accounts, &it, &uid);
  end = std::map::end(&this_->m_accounts, &a2);
  if ( (unsigned __int8)std::_tree::iterator::not_equal(&it, end) )
  {
    accInfo = std::_tree::iterator::value(&it);
    if ( sessionKey == accInfo->value.sessionKey )
    {
      if ( std::_tree::iterator::value(&it)->value.loginState == LoginState_LoggedToGS )
      {
        SpinLock::Leave(&this_->m_spinLock);
        result = PLAY_FAIL_ALREADY_LOGGED;
      }
      else
      {
        accInfo_ = std::_tree::iterator::value(&it);
        accInfo_->value.gameSocket = socket;
        accInfo_0 = std::_tree::iterator::value(&it);
        accInfo_0->value.selectedGServerId = serverId;
        std::_tree::iterator::value(&it)->value.loggedGameServerId = 0;
        SpinLock::Leave(&this_->m_spinLock);
        result = PLAY_FAIL_NO_ERROR;
      }
    }
    else
    {
      SpinLock::Leave(&this_->m_spinLock);
      result = PLAY_FAIL_SYSTEM_ERROR;
    }
  }
  else
  {
    SpinLock::Leave(&this_->m_spinLock);
    result = PLAY_FAIL_WRONG_ACC_NAME;
  }
  return result;
}

//----- (004025DE) --------------------------------------------------------
char __thiscall UserManager::authenticateUser(UserManager *this, UserInfo *accInfo, int uid, CAuthSocket *gameClient, int totalTime, int zero)
{
  std::pair_AccountInfo *accInfo_1; // eax@1
  int v7; // ST2C_4@4
  int v8; // ST28_4@4
  int v9; // ST24_4@4
  int totalTime_; // ST20_4@4
  int uid_1; // ST18_4@4
  ServerInfo *serverInfo_1; // eax@4
  std::_tree::iterator *end; // eax@5
  int loginFlag; // ST2C_4@9
  int warnFlag; // ST28_4@9
  int zero_; // ST24_4@9
  int totalTime_1; // ST20_4@9
  int payStat; // ST1C_4@9
  int authCookie2; // ST18_4@9
  int authCookie1; // ST14_4@9
  int sessionKey; // eax@9
  UserManager *this_; // [sp+0h] [bp-C8h]@1
  std::_tree::iterator v24; // [sp+4h] [bp-C4h]@5
  std::_tree::iterator a2; // [sp+8h] [bp-C0h]@5
  ServerInfo serverInfo; // [sp+Ch] [bp-BCh]@4
  std::pair_AccountInfo accInfoCopy; // [sp+64h] [bp-64h]@1
  std::_tree::iterator it; // [sp+B8h] [bp-10h]@5
  std::pair_bool_acc pair; // [sp+BCh] [bp-Ch]@1
  char isOffline; // [sp+C4h] [bp-4h]@1

  this_ = this;
  isOffline = 0;
  SpinLock::Enter(&this->m_spinLock);
  accInfo_1 = std::pair_AccountInfo::pair_AccountInfo(&accInfoCopy, (int)&uid, accInfo);
  std::map::insert(&this_->m_accounts, &pair, accInfo_1);
  isOffline = pair.second;
  SpinLock::Leave(&this_->m_spinLock);
  if ( isOffline )                              // second == true, means was inserted, not changed
  {
    if ( accInfo->notifyGameServer & 0x10 )
    {
      v7 = accInfo->payStat;
      v8 = accInfo->warnFlag;
      v9 = accInfo->loginFlag;
      totalTime_ = totalTime;
      uid_1 = uid;
      serverInfo_1 = ServerList::getServerInfo(&g_ServerList, &serverInfo, 1);
      isOffline = WorldSrvServer::sendToWorldServer(
                    serverInfo_1->ipAddress,
                    aCdsdddd,
                    0,
                    uid_1,
                    accInfo->accountName,
                    totalTime_,
                    v9,
                    v8,
                    v7) != 0;
      if ( !isOffline )
      {
        unknown_libname_4(&it);
        SpinLock::Enter(&this_->m_spinLock);
        it._Ptr = std::map::find(&this_->m_accounts, &a2, &uid)->_Ptr;
        end = std::map::end(&this_->m_accounts, &v24);
        if ( (unsigned __int8)std::_tree::iterator::not_equal(&it, end) )
          std::map::erase2(&this_->m_accounts, &uid);
        SpinLock::Leave(&this_->m_spinLock);
        CAuthSocket::assembleAndSend(gameClient, aCc_0, LS_LoginFail, REASON_IP_SESSION_REJECTED);
      }
    }
    if ( isOffline )
    {
      gameClient->m_clientLoginState = LoginState_Connected;
      loginFlag = accInfo->loginFlag;
      warnFlag = accInfo->warnFlag;
      zero_ = zero;
      totalTime_1 = totalTime;
      payStat = accInfo->payStat;
      authCookie2 = UserManager::authCookie2;
      authCookie1 = UserManager::authCookie1;
      sessionKey = CAuthSocket::getSessionKey(gameClient);
      CAuthSocket::assembleAndSend(
        gameClient,
        aCddddddddd,
        LS_LoginOk,
        uid,
        sessionKey,
        authCookie1,
        authCookie2,
        payStat,
        totalTime_1,
        zero_,
        warnFlag,
        loginFlag);
    }
  }
  else
  {
    UserManager::kickUser(this_, uid, REASON_ACCOUNT_IN_USE, true);
    CAuthSocket::assembleAndSend(gameClient, aCc__1, LS_LoginFail, REASON_ACCOUNT_IN_USE);
  }
  return isOffline;
}
// 4816F8: using guessed type int UserManager::authCookie1;
// 4816FC: using guessed type int UserManager::authCookie2;

//----- (004027DF) --------------------------------------------------------
char __thiscall UserManager::kickUser(UserManager *this, int uid, char kickReason_, char sendToClient)
{
  std::_tree::iterator *end; // eax@1
  std::pair_AccountInfo *accInfo; // eax@2
  char result; // al@23
  int kickReason; // ST28_4@24
  int uid_; // ST24_4@24
  ServerInfo *serverInfo; // eax@24
  UserManager *this_; // [sp+0h] [bp-B8h]@1
  ServerInfo outServerInfo; // [sp+4h] [bp-B4h]@24
  int v12; // [sp+5Ch] [bp-5Ch]@2
  std::_tree::iterator a2; // [sp+60h] [bp-58h]@1
  int sessionKey_; // [sp+64h] [bp-54h]@32
  int sessionKey; // [sp+68h] [bp-50h]@26
  int sessionKey1; // [sp+6Ch] [bp-4Ch]@20
  std::_tree::iterator foundIt; // [sp+70h] [bp-48h]@1
  __int16 someClientCookie; // [sp+74h] [bp-44h]@1
  char gap30; // [sp+78h] [bp-40h]@1
  int clientIP; // [sp+7Ch] [bp-3Ch]@1
  int field_52; // [sp+80h] [bp-38h]@1
  int gameSocket; // [sp+84h] [bp-34h]@1
  char age; // [sp+88h] [bp-30h]@1
  LoginState loginState; // [sp+8Ch] [bp-2Ch]@1
  char accountName[15]; // [sp+90h] [bp-28h]@1
  int field_56; // [sp+A0h] [bp-18h]@1
  char loggedServerId; // [sp+A4h] [bp-14h]@1
  int payStat; // [sp+A8h] [bp-10h]@1
  time_t loginTime; // [sp+ACh] [bp-Ch]@1
  int found; // [sp+B0h] [bp-8h]@1
  int warnFlag; // [sp+B4h] [bp-4h]@1

  this_ = this;
  LOBYTE(found) = 0;
  loggedServerId = 0;
  gameSocket = -1;
  loginState = 0;
  gap30 = 0;
  accountName[0] = 0;
  field_52 = 0;
  field_56 = 0;
  payStat = 0;
  warnFlag = 0;
  age = 0;
  someClientCookie = 0;
  clientIP = 0;
  loginTime = 0;
  SpinLock::Enter(&this->m_spinLock);
  std::map::find(&this_->m_accounts, &foundIt, &uid);
  end = std::map::end(&this_->m_accounts, &a2);
  if ( (unsigned __int8)std::_tree::iterator::not_equal(&foundIt, end) )
  {
    gameSocket = std::_tree::iterator::value(&foundIt)->value.gameSocket;
    loginState = std::_tree::iterator::value(&foundIt)->value.loginState;
    loggedServerId = std::_tree::iterator::value(&foundIt)->value.loggedGameServerId;
    gap30 = std::_tree::iterator::value(&foundIt)->value.sexAndCentury;
    field_52 = std::_tree::iterator::value(&foundIt)->value.birthdayEncoded;
    field_56 = std::_tree::iterator::value(&foundIt)->value.restOfSsn;
    payStat = std::_tree::iterator::value(&foundIt)->value.payStat;
    clientIP = std::_tree::iterator::value(&foundIt)->value.connectedIP;
    loginTime = std::_tree::iterator::value(&foundIt)->value.loginTime;
    age = std::_tree::iterator::value(&foundIt)->value.age;
    someClientCookie = std::_tree::iterator::value(&foundIt)->value.clientCookie;
    warnFlag = std::_tree::iterator::value(&foundIt)->value.warnFlag;
    accInfo = std::_tree::iterator::value(&foundIt);
    strncpy(accountName, accInfo->value.accountName, 15u);
    std::map::erase(&this_->m_accounts, &v12, (std::_tree::iterator *)foundIt._Ptr);
    SpinLock::Leave(&this_->m_spinLock);
    LOBYTE(found) = true;
    accountName[14] = 0;
  }
  else
  {
    SpinLock::Leave(&this_->m_spinLock);
  }
  if ( (unsigned __int8)found != true )
    return found;
  if ( LOBYTE(g_Config.UseWantedSystem) && (warnFlag & 4) == 4 )
    UserManager::notifyUserLoggedOut(accountName, uid, loggedServerId);
  Utils::normalizeName(accountName);
  if ( strlen(accountName) >= 2 && gap30 < 7 )
    Utils::sendToLog(831, accountName, clientIP, payStat, age, gap30, 0, 0, uid);
  if ( loginState != LoginState_LoggedToGS && loginState != LoginState_AcceptedByGS )
  {
    if ( payStat < 1000 && payStat > 0 )
    {
      sessionKey_ = IPSessionDB::takeSessionKey(&g_IPSessionDB, uid);
      if ( sessionKey_ > 0 )
      {
        if ( g_Config.Useipserver )
          IPSessionDB::sendPayStats(&g_IPSessionDB, sessionKey_, clientIP, payStat);
      }
    }
    if ( gameSocket != INVALID_SOCKET && sendToClient )
      CAuthSocket::send(gameSocket, aCc_1, LS_KickedFromGS, kickReason_);
    return found;
  }
  if ( loginState == LoginState_LoggedToGS && loggedServerId > 0 )
    UserManager::updateUsedTime(
      uid,
      loginTime,
      loggedServerId,
      (in_addr)clientIP,
      g_Config.GameID,
      accountName,
      payStat,
      field_52,
      field_56,
      gap30,
      age,
      someClientCookie);
  if ( loggedServerId <= g_ServerList.m_serverNumber && loggedServerId >= 1 )
  {
    kickReason = kickReason_;
    uid_ = uid;
    serverInfo = ServerList::getServerInfo(&g_ServerList, &outServerInfo, loggedServerId);
    WorldSrvServer::sendToWorldServer(serverInfo->ipAddress, aCdcs, 1, uid_, kickReason, accountName);
    if ( payStat < 1000 && payStat > 0 )
    {
      sessionKey = IPSessionDB::takeSessionKey(&g_IPSessionDB, uid);
      if ( sessionKey > 0 )
      {
        if ( g_Config.Useipserver )
          IPSessionDB::sendPayStats(&g_IPSessionDB, sessionKey, clientIP, payStat);
      }
    }
    result = found;
  }
  else
  {
    if ( payStat < 1000 && payStat > 0 )
    {
      sessionKey1 = IPSessionDB::takeSessionKey(&g_IPSessionDB, uid);
      if ( sessionKey1 > 0 )
      {
        if ( g_Config.Useipserver )
          IPSessionDB::sendPayStats(&g_IPSessionDB, sessionKey1, clientIP, payStat);
      }
    }
    result = found;
  }
  return result;
}

//----- (00402BDA) --------------------------------------------------------
void __stdcall UserManager::TimerCallback(PVOID uid, BOOLEAN a2)
{
  UserManager::onTimeout(&g_userManager, (int)uid);
}

//----- (00402BF8) --------------------------------------------------------
char __thiscall UserManager::onTimeout(UserManager *this, int uid)
{
  std::_tree::iterator *endIt; // eax@1
  std::pair_AccountInfo *accInfo; // eax@2
  int result1; // eax@5
  int zero_1; // ST14_4@18
  int uid_; // ST10_4@18
  ServerInfo *serverInfo; // eax@18
  int zero; // ST14_4@22
  int uid_1; // ST10_4@22
  ServerInfo *serverInfo_; // eax@22
  UserManager *this_; // [sp+0h] [bp-F8h]@1
  ServerInfo v13; // [sp+4h] [bp-F4h]@22
  ServerInfo outServerInfo; // [sp+5Ch] [bp-9Ch]@18
  int v15; // [sp+B4h] [bp-44h]@3
  std::_tree::iterator a2; // [sp+B8h] [bp-40h]@1
  int sessionKey1; // [sp+BCh] [bp-3Ch]@11
  int end; // [sp+C0h] [bp-38h]@1
  std::_tree::iterator found; // [sp+C4h] [bp-34h]@1
  int clientIP; // [sp+C8h] [bp-30h]@3
  LoginState loginState; // [sp+CCh] [bp-2Ch]@2
  char accountName[15]; // [sp+D0h] [bp-28h]@2
  int zero_; // [sp+E0h] [bp-18h]@1
  int loggedGameServerId; // [sp+E4h] [bp-14h]@1
  int selectedGServerId; // [sp+E8h] [bp-10h]@1
  int payStat; // [sp+ECh] [bp-Ch]@1
  int removed; // [sp+F0h] [bp-8h]@1
  int warnFlag; // [sp+F4h] [bp-4h]@1

  this_ = this;
  end = 0;
  LOBYTE(removed) = false;
  loggedGameServerId = 0;
  selectedGServerId = 0;
  payStat = 0;
  LOBYTE(zero_) = 0;
  warnFlag = 0;
  SpinLock::Enter(&this->m_spinLock);
  std::map::find(&this_->m_accounts, &found, &uid);
  endIt = std::map::end(&this_->m_accounts, &a2);
  if ( (unsigned __int8)std::_tree::iterator::not_equal(&found, endIt) )
  {
    loginState = std::_tree::iterator::value(&found)->value.loginState;
    loggedGameServerId = std::_tree::iterator::value(&found)->value.loggedGameServerId;
    selectedGServerId = std::_tree::iterator::value(&found)->value.selectedGServerId;
    accInfo = std::_tree::iterator::value(&found);
    strncpy(accountName, accInfo->value.accountName, 0xFu);
    warnFlag = std::_tree::iterator::value(&found)->value.warnFlag;
    if ( loginState == LoginState_LoggedToGS )
    {
      std::_tree::iterator::value(&found)->value.timerHandler = 0;
    }
    else
    {
      payStat = std::_tree::iterator::value(&found)->value.payStat;
      clientIP = std::_tree::iterator::value(&found)->value.connectedIP;
      std::map::erase(&this_->m_accounts, &v15, (std::_tree::iterator *)found._Ptr);
      LOBYTE(removed) = true;
    }
  }
  SpinLock::Leave(&this_->m_spinLock);
  accountName[14] = 0;
  LOBYTE(result1) = removed;
  if ( (_BYTE)removed )
  {
    if ( LOBYTE(g_Config.UseWantedSystem) && (warnFlag & 4) == 4 )
      LOBYTE(result1) = UserManager::notifyUserLoggedOut(accountName, uid, loggedGameServerId);
    if ( payStat < 1000 && payStat > 0 )
    {
      result1 = IPSessionDB::takeSessionKey(&g_IPSessionDB, uid);
      sessionKey1 = result1;
      if ( result1 )
        LOBYTE(result1) = IPSessionDB::sendPayStats(&g_IPSessionDB, sessionKey1, clientIP, payStat);
    }
  }
  if ( loginState == LoginState_AcceptedByGS && (_BYTE)removed )// 5 min timeout
  {
    if ( selectedGServerId <= g_ServerList.m_serverNumber && selectedGServerId >= 1 )
    {
      zero_1 = (unsigned __int8)zero_;
      uid_ = uid;
      serverInfo = ServerList::getServerInfo(&g_ServerList, &outServerInfo, selectedGServerId);
      WorldSrvServer::sendToWorldServer(serverInfo->ipAddress, aCdcs_0, 1, uid_, zero_1, accountName);
    }
    LOBYTE(result1) = loggedGameServerId;
    if ( loggedGameServerId <= g_ServerList.m_serverNumber && loggedGameServerId >= 1 )
    {
      zero = (unsigned __int8)zero_;
      uid_1 = uid;
      serverInfo_ = ServerList::getServerInfo(&g_ServerList, &v13, loggedGameServerId);
      LOBYTE(result1) = WorldSrvServer::sendToWorldServer(serverInfo_->ipAddress, aCdcs_1, 1, uid_1, zero, accountName);
    }
  }
  return result1;
}

//----- (00402E5F) --------------------------------------------------------
void __thiscall UserManager::removeServer(UserManager *this, int serverId)
{
  std::_tree::iterator *end; // eax@2
  std::pair_AccountInfo *v3; // eax@6
  int v4; // ST08_4@7
  std::pair_AccountInfo *v5; // eax@7
  UserManager *this_; // [sp+0h] [bp-18h]@1
  int v7; // [sp+4h] [bp-14h]@9
  int v8; // [sp+8h] [bp-10h]@8
  std::_tree::iterator a2; // [sp+Ch] [bp-Ch]@2
  std::_tree::iterator begin; // [sp+10h] [bp-8h]@1
  int sessionKey1; // [sp+14h] [bp-4h]@1

  this_ = this;
  sessionKey1 = 0;
  SpinLock::Enter(&this->m_spinLock);
  std::map::begin(&this_->m_accounts, (int)&begin);
  while ( true )
  {
    end = std::map::end(&this_->m_accounts, &a2);
    if ( !(unsigned __int8)std::_tree::iterator::not_equal(&begin, end) )
      break;
    if ( std::_tree::iterator::value(&begin)->value.loggedGameServerId != serverId
      && std::_tree::iterator::value(&begin)->value.selectedGServerId != serverId )
    {
      std::_tree::iterator::post_increment(&begin, &v7, 0);
    }
    else
    {
      if ( std::_tree::iterator::value(&begin)->value.payStat < 1000 )
      {
        v3 = std::_tree::iterator::value(&begin);
        sessionKey1 = IPSessionDB::takeSessionKey(&g_IPSessionDB, v3->uid);
        if ( sessionKey1 )
        {
          v4 = std::_tree::iterator::value(&begin)->value.payStat;
          v5 = std::_tree::iterator::value(&begin);
          IPSessionDB::sendPayStats(&g_IPSessionDB, sessionKey1, v5->value.connectedIP, v4);
        }
      }
      begin._Ptr = std::map::erase(&this_->m_accounts, &v8, (std::_tree::iterator *)begin._Ptr)->_Ptr;
      InterlockedDecrement(&g_StatusLine.loggedUsers);
    }
  }
  SpinLock::Leave(&this_->m_spinLock);
}

//----- (00402F6E) --------------------------------------------------------
void __thiscall UserManager::clear(UserManager *this)
{
  std::_tree::iterator *end; // eax@2
  std::pair_AccountInfo *accInfo; // eax@4
  std::pair_AccountInfo *accInfo_1; // eax@7
  int payStat; // ST0C_4@8
  std::pair_AccountInfo *accInfo_2; // eax@8
  UserManager *this_; // [sp+0h] [bp-18h]@1
  int v7; // [sp+4h] [bp-14h]@9
  std::_tree::iterator v8; // [sp+8h] [bp-10h]@2
  int a2; // [sp+Ch] [bp-Ch]@1
  std::_tree::iterator it; // [sp+10h] [bp-8h]@1
  int sessionKey; // [sp+14h] [bp-4h]@1

  this_ = this;
  unknown_libname_4(&it);
  sessionKey = 0;
  SpinLock::Enter(&this_->m_spinLock);
  for ( it._Ptr = std::map::begin(&this_->m_accounts, (int)&a2)._Ptr->_Left;
        ;
        it._Ptr = std::map::erase(&this_->m_accounts, &v7, (std::_tree::iterator *)it._Ptr)->_Ptr )
  {
    end = std::map::end(&this_->m_accounts, &v8);
    if ( !(unsigned __int8)std::_tree::iterator::not_equal(&it, end) )
      break;
    if ( std::_tree::iterator::value(&it)->value.gameSocket != INVALID_SOCKET )
    {
      accInfo = std::_tree::iterator::value(&it);
      CAuthSocket::send(accInfo->value.gameSocket, aCc_2, LS_PlayFail, PLAY_FAIL_GS_ERROR);
    }
    if ( std::_tree::iterator::value(&it)->value.payStat < 1000 && std::_tree::iterator::value(&it)->value.payStat > 0 )
    {
      accInfo_1 = std::_tree::iterator::value(&it);
      sessionKey = IPSessionDB::takeSessionKey(&g_IPSessionDB, accInfo_1->uid);
      if ( sessionKey )
      {
        payStat = std::_tree::iterator::value(&it)->value.payStat;
        accInfo_2 = std::_tree::iterator::value(&it);
        IPSessionDB::sendPayStats(&g_IPSessionDB, sessionKey, accInfo_2->value.connectedIP, payStat);
      }
    }
  }
  SpinLock::Leave(&this_->m_spinLock);
  g_StatusLine.loggedUsers = 0;
}

//----- (0040308E) --------------------------------------------------------
SOCKET __thiscall UserManager::restartSomeTimer(UserManager *this, int uid, int recreate)
{
  std::_tree::iterator *endIt; // eax@3
  std::pair_AccountInfo *foundIt_; // eax@4
  UserManager *this_; // [sp+0h] [bp-18h]@1
  std::_tree::iterator end; // [sp+4h] [bp-14h]@3
  HANDLE timer; // [sp+8h] [bp-10h]@1
  std::_tree::iterator foundIt; // [sp+Ch] [bp-Ch]@3
  HANDLE phNewTimer; // [sp+10h] [bp-8h]@1
  SOCKET gameSocket; // [sp+14h] [bp-4h]@1

  this_ = this;
  gameSocket = 0;
  phNewTimer = 0;
  timer = 0;
  if ( (_BYTE)recreate )
    CreateTimerQueueTimer(&phNewTimer, 0, UserManager::TimerCallback, (PVOID)uid, 300000u, 0, 0);
  SpinLock::Enter(&this_->m_spinLock);
  std::map::find(&this_->m_accounts, &foundIt, &uid);
  endIt = std::map::end(&this_->m_accounts, &end);
  if ( (unsigned __int8)std::_tree::iterator::not_equal(&foundIt, endIt) )
  {
    gameSocket = std::_tree::iterator::value(&foundIt)->value.gameSocket;
    timer = std::_tree::iterator::value(&foundIt)->value.timerHandler;
    foundIt_ = std::_tree::iterator::value(&foundIt);
    foundIt_->value.timerHandler = phNewTimer;
  }
  SpinLock::Leave(&this_->m_spinLock);
  if ( timer )
    DeleteTimerQueueTimer(0, timer, 0);
  return gameSocket;
}

//----- (00403167) --------------------------------------------------------
SOCKET __thiscall UserManager::userAcceptedByGS(UserManager *this, int uid, int serverId, int restartTimer, char *selectedGServerId, char *accName)
{
  std::_tree::iterator *end; // eax@3
  std::pair_AccountInfo *accInfo_1; // eax@4
  std::pair_AccountInfo *accInfo_0; // eax@4
  std::pair_AccountInfo *accInfo_2; // eax@5
  std::pair_AccountInfo *accInfo_3; // eax@5
  std::pair_AccountInfo *accInfo; // eax@6
  std::pair_AccountInfo *accInfo_; // eax@6
  UserManager *this_; // [sp+0h] [bp-18h]@1
  int a2; // [sp+4h] [bp-14h]@3
  HANDLE timer; // [sp+8h] [bp-10h]@1
  std::_tree::iterator it; // [sp+Ch] [bp-Ch]@3
  HANDLE phNewTimer; // [sp+10h] [bp-8h]@1
  SOCKET gameSocket; // [sp+14h] [bp-4h]@1

  this_ = this;
  gameSocket = 0;
  phNewTimer = 0;
  timer = 0;
  if ( (_BYTE)restartTimer )
    CreateTimerQueueTimer(&phNewTimer, 0, UserManager::TimerCallback, (PVOID)uid, 300000u, 0, 0);
  *selectedGServerId = 0;
  SpinLock::Enter(&this_->m_spinLock);
  std::map::find(&this_->m_accounts, &it, &uid);
  end = std::map::end(&this_->m_accounts, (std::_tree::iterator *)&a2);
  if ( (unsigned __int8)std::_tree::iterator::not_equal(&it, end) )
  {
    gameSocket = std::_tree::iterator::value(&it)->value.gameSocket;
    timer = std::_tree::iterator::value(&it)->value.timerHandler;
    accInfo_1 = std::_tree::iterator::value(&it);
    accInfo_1->value.timerHandler = phNewTimer;
    accInfo_0 = std::_tree::iterator::value(&it);
    if ( serverId == accInfo_0->value.selectedGServerId )
    {
      accInfo = std::_tree::iterator::value(&it);
      accInfo->value.loggedGameServerId = serverId;
      std::_tree::iterator::value(&it)->value.loginState = LoginState_AcceptedByGS;
      accInfo_ = std::_tree::iterator::value(&it);
      strncpy(accName, accInfo_->value.accountName, 14u);
    }
    else
    {
      accInfo_2 = std::_tree::iterator::value(&it);
      *selectedGServerId = accInfo_2->value.selectedGServerId;
      accInfo_3 = std::_tree::iterator::value(&it);
      strncpy(accName, accInfo_3->value.accountName, 14u);
    }
    std::_tree::iterator::value(&it)->value.selectedGServerId = 0;
  }
  SpinLock::Leave(&this_->m_spinLock);
  if ( timer )
    DeleteTimerQueueTimer(0, timer, 0);
  return gameSocket;
}

//----- (004032CA) --------------------------------------------------------
char __thiscall UserManager::userDroppedFromGS(UserManager *this, int uid, char *accName)
{
  std::_tree::iterator *end; // eax@1
  std::pair_AccountInfo *pair; // eax@2
  UserManager *this_; // [sp+0h] [bp-28h]@1
  int a2a; // [sp+4h] [bp-24h]@2
  std::_tree::iterator v8; // [sp+8h] [bp-20h]@1
  int sessionKey1; // [sp+Ch] [bp-1Ch]@8
  std::_tree::iterator it; // [sp+10h] [bp-18h]@1
  int clientIP; // [sp+14h] [bp-14h]@2
  int serverId; // [sp+18h] [bp-10h]@1
  int payStat; // [sp+1Ch] [bp-Ch]@1
  int success; // [sp+20h] [bp-8h]@1
  int warnFlag; // [sp+24h] [bp-4h]@1

  this_ = this;
  LOBYTE(success) = 0;
  serverId = 0;
  payStat = 0;
  warnFlag = 0;
  SpinLock::Enter(&this->m_spinLock);
  std::map::find(&this_->m_accounts, &it, &uid);
  end = std::map::end(&this_->m_accounts, &v8);
  if ( (unsigned __int8)std::_tree::iterator::not_equal(&it, end) )
  {
    pair = std::_tree::iterator::value(&it);
    strncpy(accName, pair->value.accountName, 15u);
    warnFlag = std::_tree::iterator::value(&it)->value.warnFlag;
    payStat = std::_tree::iterator::value(&it)->value.payStat;
    clientIP = std::_tree::iterator::value(&it)->value.connectedIP;
    std::map::erase(&this_->m_accounts, &a2a, (std::_tree::iterator *)it._Ptr);
    LOBYTE(success) = true;
  }
  SpinLock::Leave(&this_->m_spinLock);
  accName[14] = 0;
  if ( (_BYTE)success )
  {
    if ( LOBYTE(g_Config.UseWantedSystem) && (warnFlag & 4) == 4 )
      UserManager::notifyUserLoggedOut(accName, uid, serverId);
    if ( payStat < 1000 )
    {
      sessionKey1 = IPSessionDB::takeSessionKey(&g_IPSessionDB, uid);
      if ( sessionKey1 )
        IPSessionDB::sendPayStats(&g_IPSessionDB, sessionKey1, clientIP, payStat);
    }
  }
  return success;
}

//----- (0040340F) --------------------------------------------------------
char __thiscall UserManager::loginAborted(UserManager *this, int uid, SOCKET socket)
{
  std::_tree::iterator *end; // eax@1
  std::pair_AccountInfo *v4; // eax@3
  std::pair_AccountInfo *v5; // eax@4
  UserManager *this_; // [sp+0h] [bp-40h]@1
  int v8; // [sp+4h] [bp-3Ch]@4
  int a2a; // [sp+8h] [bp-38h]@1
  int sessionKey1; // [sp+Ch] [bp-34h]@7
  std::_tree::iterator accInfo; // [sp+10h] [bp-30h]@1
  int gap30; // [sp+14h] [bp-2Ch]@1
  int clientIP; // [sp+18h] [bp-28h]@4
  int age; // [sp+1Ch] [bp-24h]@1
  CHAR accName[15]; // [sp+20h] [bp-20h]@4
  int payStat; // [sp+30h] [bp-10h]@4
  int serverId; // [sp+34h] [bp-Ch]@1
  int success; // [sp+38h] [bp-8h]@1
  int warnFlag; // [sp+3Ch] [bp-4h]@1

  this_ = this;
  LOBYTE(success) = 0;
  age = 0;
  gap30 = 0;
  serverId = 0;
  warnFlag = 0;
  SpinLock::Enter(&this->m_spinLock);
  std::map::find(&this_->m_accounts, &accInfo, &uid);
  end = std::map::end(&this_->m_accounts, (std::_tree::iterator *)&a2a);
  if ( (unsigned __int8)std::_tree::iterator::not_equal(&accInfo, end) )
  {
    if ( std::_tree::iterator::value(&accInfo)->value.loginState != LoginState_AcceptedByGS )
    {
      v4 = std::_tree::iterator::value(&accInfo);
      if ( v4->value.gameSocket == socket )
      {
        payStat = std::_tree::iterator::value(&accInfo)->value.payStat;
        clientIP = std::_tree::iterator::value(&accInfo)->value.connectedIP;
        v5 = std::_tree::iterator::value(&accInfo);
        strcpy(accName, v5->value.accountName);
        age = std::_tree::iterator::value(&accInfo)->value.age;
        gap30 = LOBYTE(std::_tree::iterator::value(&accInfo)->value.sexAndCentury);
        serverId = std::_tree::iterator::value(&accInfo)->value.loggedGameServerId;
        warnFlag = std::_tree::iterator::value(&accInfo)->value.warnFlag;
        std::map::erase(&this_->m_accounts, &v8, (std::_tree::iterator *)accInfo._Ptr);
        LOBYTE(success) = true;
      }
    }
  }
  SpinLock::Leave(&this_->m_spinLock);
  accName[14] = 0;
  if ( payStat < 1000 )
  {
    if ( (_BYTE)success )
    {
      sessionKey1 = IPSessionDB::takeSessionKey(&g_IPSessionDB, uid);
      if ( sessionKey1 )
        IPSessionDB::sendPayStats(&g_IPSessionDB, sessionKey1, clientIP, payStat);
    }
  }
  if ( (unsigned __int8)success == true )
  {
    if ( LOBYTE(g_Config.UseWantedSystem) && (warnFlag & 4) == 4 )
      UserManager::notifyUserLoggedOut(accName, uid, serverId);
    if ( strlen(accName) >= 2 && gap30 < 7 )
      Utils::sendToLog(831, accName, clientIP, payStat, age, gap30, 0, 0, uid);
  }
  return 1;
}

//----- (004035F9) --------------------------------------------------------
char __thiscall UserManager::loginCanceled(UserManager *this, int uid, int sessionKey)
{
  std::_tree::iterator *end; // eax@1
  std::pair_AccountInfo *accInfo; // eax@2
  std::pair_AccountInfo *accInfo_1; // eax@7
  UserManager *this_; // [sp+10h] [bp-5Ch]@1
  int a2; // [sp+14h] [bp-58h]@7
  std::_tree::iterator v9; // [sp+18h] [bp-54h]@1
  int sessionKey1; // [sp+1Ch] [bp-50h]@14
  std::_tree::iterator it; // [sp+20h] [bp-4Ch]@1
  char gap30; // [sp+24h] [bp-48h]@7
  int clientIP; // [sp+28h] [bp-44h]@7
  int unused; // [sp+2Ch] [bp-40h]@1
  int age; // [sp+30h] [bp-3Ch]@1
  char accountName[15]; // [sp+34h] [bp-38h]@7
  int payStat; // [sp+44h] [bp-28h]@1
  int serverId; // [sp+48h] [bp-24h]@1
  int warnFlag; // [sp+4Ch] [bp-20h]@1
  int success; // [sp+50h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+54h] [bp-18h]@1

  this_ = this;
  LOBYTE(success) = 0;
  ms_exc.registration.TryLevel = 0;
  payStat = 0;
  unused = 0;
  age = 0;
  serverId = 0;
  warnFlag = 0;
  SpinLock::Enter(&this->m_spinLock);
  std::map::find(&this_->m_accounts, &it, &uid);
  end = std::map::end(&this_->m_accounts, &v9);
  if ( (unsigned __int8)std::_tree::iterator::not_equal(&it, end) )
  {
    accInfo = std::_tree::iterator::value(&it);
    if ( accInfo->value.sessionKey == sessionKey )
    {
      if ( std::_tree::iterator::value(&it)->value.loginState == LoginState_LoggedToGS )
      {
        SpinLock::Leave(&this_->m_spinLock);
        LOBYTE(success) = UserManager::userQuitsFromGS(&g_userManager, uid, 0, 0);
        if ( (_BYTE)success )
          LOBYTE(success) = UserManager::removeUser(&g_userManager, uid);
        ms_exc.registration.TryLevel = -1;
        return success;
      }
      accInfo_1 = std::_tree::iterator::value(&it);
      strncpy(accountName, accInfo_1->value.accountName, 0xFu);
      clientIP = std::_tree::iterator::value(&it)->value.connectedIP;
      payStat = std::_tree::iterator::value(&it)->value.payStat;
      gap30 = std::_tree::iterator::value(&it)->value.sexAndCentury;
      unused = std::_tree::iterator::value(&it)->value.birthdayEncoded;
      age = std::_tree::iterator::value(&it)->value.age;
      serverId = std::_tree::iterator::value(&it)->value.loggedGameServerId;
      warnFlag = std::_tree::iterator::value(&it)->value.warnFlag;
      std::map::erase(&this_->m_accounts, &a2, (std::_tree::iterator *)it._Ptr);
      LOBYTE(success) = true;
    }
  }
  SpinLock::Leave(&this_->m_spinLock);
  accountName[14] = 0;
  if ( (_BYTE)success )
  {
    if ( LOBYTE(g_Config.UseWantedSystem) && (warnFlag & 4) == 4 )
      UserManager::notifyUserLoggedOut(accountName, uid, serverId);
    if ( payStat < 1000 && payStat > 0 )
    {
      sessionKey1 = IPSessionDB::takeSessionKey(&g_IPSessionDB, uid);
      if ( sessionKey1 )
        IPSessionDB::sendPayStats(&g_IPSessionDB, sessionKey1, clientIP, payStat);
    }
    if ( strlen(accountName) >= 2 && gap30 < 7 )
      Utils::sendToLog(831, accountName, clientIP, payStat, age, gap30, 0, 0, uid);
  }
  return success;
}

//----- (004038C3) --------------------------------------------------------
char __thiscall UserManager::removeUser(UserManager *this, int uid)
{
  std::_tree::iterator *end; // eax@1
  std::pair_AccountInfo *v3; // eax@2
  UserManager *this_; // [sp+0h] [bp-44h]@1
  int a2a; // [sp+4h] [bp-40h]@2
  std::_tree::iterator v7; // [sp+8h] [bp-3Ch]@1
  int sessionKey1; // [sp+Ch] [bp-38h]@10
  std::_tree::iterator it; // [sp+10h] [bp-34h]@1
  char gap30; // [sp+14h] [bp-30h]@1
  int clientIP; // [sp+18h] [bp-2Ch]@2
  int unused; // [sp+1Ch] [bp-28h]@1
  int age; // [sp+20h] [bp-24h]@1
  char accName[16]; // [sp+24h] [bp-20h]@2
  int payStat; // [sp+34h] [bp-10h]@1
  int serverId; // [sp+38h] [bp-Ch]@1
  int success; // [sp+3Ch] [bp-8h]@1
  int warnFlag; // [sp+40h] [bp-4h]@1

  this_ = this;
  LOBYTE(success) = 0;
  gap30 = 0;
  payStat = 0;
  unused = 0;
  age = 0;
  serverId = 0;
  warnFlag = 0;                                 // TODO: bug, get warnFlag
  SpinLock::Enter(&this->m_spinLock);
  std::map::find(&this_->m_accounts, &it, &uid);
  end = std::map::end(&this_->m_accounts, &v7);
  if ( (unsigned __int8)std::_tree::iterator::not_equal(&it, end) )
  {
    v3 = std::_tree::iterator::value(&it);
    strncpy(accName, v3->value.accountName, 15u);
    clientIP = std::_tree::iterator::value(&it)->value.connectedIP;
    gap30 = std::_tree::iterator::value(&it)->value.sexAndCentury;
    payStat = std::_tree::iterator::value(&it)->value.payStat;
    unused = std::_tree::iterator::value(&it)->value.birthdayEncoded;
    age = std::_tree::iterator::value(&it)->value.age;
    serverId = std::_tree::iterator::value(&it)->value.loggedGameServerId;
    std::map::erase(&this_->m_accounts, &a2a, (std::_tree::iterator *)it._Ptr);
    SpinLock::Leave(&this_->m_spinLock);
    LOBYTE(success) = true;
  }
  else
  {
    SpinLock::Leave(&this_->m_spinLock);
  }
  accName[14] = 0;
  if ( (_BYTE)success )
  {
    if ( LOBYTE(g_Config.UseWantedSystem) && (warnFlag & 4) == 4 )
      UserManager::notifyUserLoggedOut(accName, uid, serverId);
    if ( payStat < 1000 && payStat > 0 )
    {
      sessionKey1 = IPSessionDB::takeSessionKey(&g_IPSessionDB, uid);
      if ( sessionKey1 )
        IPSessionDB::sendPayStats(&g_IPSessionDB, sessionKey1, clientIP, payStat);
    }
    if ( strlen(accName) >= 2 && gap30 < 7 )
      Utils::sendToLog(831, accName, clientIP, payStat, age, gap30, 0, 0, uid);
  }
  return success;
}

//----- (00403AA1) --------------------------------------------------------
bool __thiscall UserManager::userLoggedToGS(UserManager *this, int uid, char serverId)
{
  std::_tree::iterator *end; // eax@1
  time_t now; // esi@2
  std::pair_AccountInfo *v5; // eax@2
  std::pair_AccountInfo *v6; // eax@2
  UserManager *this_; // [sp+Ch] [bp-74h]@1
  std::_tree::iterator v9; // [sp+10h] [bp-70h]@1
  time_t now_; // [sp+14h] [bp-6Ch]@17
  char buffer[28]; // [sp+18h] [bp-68h]@15
  std::_tree::iterator it; // [sp+34h] [bp-4Ch]@1
  char gap30; // [sp+38h] [bp-48h]@1
  int unused; // [sp+3Ch] [bp-44h]@1
  HANDLE timer; // [sp+40h] [bp-40h]@1
  int age; // [sp+44h] [bp-3Ch]@1
  int connectedIP; // [sp+48h] [bp-38h]@2
  CHAR accName[16]; // [sp+4Ch] [bp-34h]@1
  int payStat; // [sp+5Ch] [bp-24h]@1
  int warnFlag; // [sp+60h] [bp-20h]@1
  bool success; // [sp+64h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+68h] [bp-18h]@1

  this_ = this;
  success = 0;
  ms_exc.registration.TryLevel = 0;
  timer = 0;
  memset(accName, 0, 15u);
  gap30 = 0;
  unused = 0;
  payStat = 0;
  age = 0;
  warnFlag = 0;
  SpinLock::Enter(&this_->m_spinLock);
  std::map::find(&this_->m_accounts, &it, &uid);
  end = std::map::end(&this_->m_accounts, &v9);
  if ( (unsigned __int8)std::_tree::iterator::not_equal(&it, end) )
  {
    now = time(0);
    std::_tree::iterator::value(&it)->value.loginTime = now;
    v5 = std::_tree::iterator::value(&it);
    v5->value.loggedGameServerId = serverId;
    std::_tree::iterator::value(&it)->value.loginState = 4;
    timer = std::_tree::iterator::value(&it)->value.timerHandler;
    std::_tree::iterator::value(&it)->value.timerHandler = 0;
    std::_tree::iterator::value(&it)->value.selectedGServerId = 0;
    v6 = std::_tree::iterator::value(&it);
    strncpy(accName, v6->value.accountName, 15u);
    connectedIP = std::_tree::iterator::value(&it)->value.connectedIP;
    gap30 = std::_tree::iterator::value(&it)->value.sexAndCentury;
    payStat = std::_tree::iterator::value(&it)->value.payStat;
    unused = std::_tree::iterator::value(&it)->value.birthdayEncoded;
    age = std::_tree::iterator::value(&it)->value.age;
    warnFlag = std::_tree::iterator::value(&it)->value.warnFlag;
    success = 1;
  }
  SpinLock::Leave(&this_->m_spinLock);
  if ( payStat < 1000 && payStat > 0 && success )
    IPSessionDB::sendUserLoggedIn(&g_IPSessionDB, uid, connectedIP, payStat, serverId);
  if ( timer )
    DeleteTimerQueueTimer(0, timer, 0);
  if ( success )
  {
    InterlockedIncrement(&g_StatusLine.loggedUsers);
    Utils::sendToLog(802, accName, connectedIP, payStat, age, gap30, 0, g_StatusLine.loggedUsers, uid);
  }
  if ( g_SocketWanted && LOBYTE(g_Config.UseWantedSystem) && (warnFlag & 4) == 4 && success )
  {
    memset(buffer, 0, 28u);
    if ( g_Config.GameID == 8 )
      buffer[0] = 2;
    memcpy(&buffer[1], &uid, 4u);
    strncpy(&buffer[5], accName, 14u);
    buffer[19] = serverId;
    now_ = time(0);
    memcpy(&buffer[20], &now_, 4u);
    memcpy(&buffer[24], &connectedIP, 4u);
    if ( LOBYTE(g_Config.UseWantedSystem) && !CWantedSocket::isReconnecting )
    {
      ReadWriteLock::readLock(&CWantedSocket::s_lock);
      MemoryObject::AddRef(&g_SocketWanted->base.base);
      CWantedSocket::send(g_SocketWanted, aCb_0, 0, 28, buffer);
      MemoryObject::Release(&g_SocketWanted->base.base);
      ReadWriteLock::releaseReadLock(&CWantedSocket::s_lock);
    }
  }
  return success;
}
// 4819B9: using guessed type char CWantedSocket::isReconnecting;

//----- (00403E28) --------------------------------------------------------
char __thiscall UserManager::userQuitsFromGS(UserManager *this, int uid, int a3, int serverId)
{
  std::_tree::iterator *end; // eax@3
  std::pair_AccountInfo *accInfo; // eax@4
  std::pair_AccountInfo *accInfo_; // esi@6
  std::pair_AccountInfo *accInfo_0; // eax@6
  UserManager *this_; // [sp+Ch] [bp-80h]@1
  std::_tree::iterator v10; // [sp+10h] [bp-7Ch]@3
  std::_tree::iterator a2; // [sp+14h] [bp-78h]@3
  std::_tree::iterator it; // [sp+18h] [bp-74h]@1
  UserInfo userInfo; // [sp+1Ch] [bp-70h]@6
  HANDLE phNewTimer; // [sp+6Ch] [bp-20h]@1
  int success; // [sp+70h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+74h] [bp-18h]@1

  this_ = this;
  LOBYTE(success) = 0;
  ms_exc.registration.TryLevel = 0;
  unknown_libname_4(&it);
  phNewTimer = 0;
  if ( LOBYTE(g_Config.b_OneTimeLogOut) != true )
    CreateTimerQueueTimer(&phNewTimer, 0, UserManager::TimerCallback, (PVOID)uid, g_Config.SocketTimeOut, 0, 0);
  SpinLock::Enter(&this_->m_spinLock);
  it._Ptr = std::map::find(&this_->m_accounts, &a2, &uid)->_Ptr;
  end = std::map::end(&this_->m_accounts, &v10);
  if ( (unsigned __int8)std::_tree::iterator::not_equal(&it, end) )
  {
    accInfo = std::_tree::iterator::value(&it);
    if ( accInfo->value.loggedGameServerId == serverId || !serverId )
    {
      qmemcpy(&userInfo, &std::_tree::iterator::value(&it)->value, sizeof(userInfo));
      std::_tree::iterator::value(&it)->value.loginState = LoginState_Connected;
      accInfo_ = std::_tree::iterator::value(&it);
      std::_tree::iterator::value(&it)->value.lastworld = accInfo_->value.loggedGameServerId;
      std::_tree::iterator::value(&it)->value.loggedGameServerId = 0;
      accInfo_0 = std::_tree::iterator::value(&it);
      accInfo_0->value.timerHandler = phNewTimer;
      LOBYTE(success) = true;
    }
    SpinLock::Leave(&this_->m_spinLock);
  }
  else
  {
    SpinLock::Leave(&this_->m_spinLock);
  }
  if ( (_BYTE)success )
  {
    userInfo.accountName[14] = 0;
    if ( (userInfo.warnFlag & 4) == 4 )
      UserManager::notifyUserLoggedOut(userInfo.accountName, uid, userInfo.loggedGameServerId);
    if ( userInfo.loggedGameServerId > 0 )
      UserManager::updateUsedTime(
        uid,
        userInfo.loginTime,
        userInfo.loggedGameServerId,
        (in_addr)userInfo.connectedIP,
        g_Config.GameID,
        userInfo.accountName,
        userInfo.payStat,
        userInfo.birthdayEncoded,
        userInfo.restOfSsn,
        userInfo.sexAndCentury,
        (char)userInfo.age,
        userInfo.clientCookie);
  }
  return success;
}

//----- (0040403B) --------------------------------------------------------
signed int __thiscall UserManager::sub_40403B(UserManager *this, int uid, int sessionKey)
{
  std::_tree::iterator *end; // eax@1
  signed int result; // eax@3
  std::pair_AccountInfo *v5; // eax@4
  UserManager *this_; // [sp+18h] [bp-24h]@1
  std::_tree::iterator v7; // [sp+1Ch] [bp-20h]@1
  std::_tree::iterator a2; // [sp+20h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+24h] [bp-18h]@1

  this_ = this;
  ms_exc.registration.TryLevel = 0;
  SpinLock::Enter(&this->m_spinLock);
  std::map::find(&this_->m_accounts, &a2, &uid);
  end = std::map::end(&this_->m_accounts, &v7);
  if ( (unsigned __int8)std::_tree::iterator::not_equal(&a2, end) )
  {
    if ( std::_tree::iterator::value(&a2)->value.loginState == LoginState_LoggedToGS )
    {
      SpinLock::Leave(&this_->m_spinLock);
      ms_exc.registration.TryLevel = -1;
      result = REASON_ACCOUNT_IN_USE;
    }
    else
    {
      v5 = std::_tree::iterator::value(&a2);
      if ( v5->value.sessionKey == sessionKey )
      {
        SpinLock::Leave(&this_->m_spinLock);
        ms_exc.registration.TryLevel = -1;
        result = PLAY_FAIL_NO_ERROR;
      }
      else
      {
        SpinLock::Leave(&this_->m_spinLock);
        ms_exc.registration.TryLevel = -1;
        result = PLAY_FAIL_SYSTEM_ERROR;
      }
    }
  }
  else
  {
    SpinLock::Leave(&this_->m_spinLock);
    result = PLAY_FAIL_WRONG_ACC_NAME;
  }
  return result;
}

//----- (0040418D) --------------------------------------------------------
char __stdcall UserManager::updateUsedTime(int uid, time_t loginTime, char lastWorld, in_addr userIp, int gameType, char *accountName, int payStat, int a8, int a9, char a10, int age, int someClientCookie)
{
  SQLINTEGER ipLength; // eax@1
  SQLINTEGER accLength; // eax@13
  SqlQuery sql__; // [sp+Ch] [bp-408h]@13
  int unused; // [sp+20h] [bp-3F4h]@13
  SQLINTEGER null12; // [sp+24h] [bp-3F0h]@13
  SQLCHAR sqlQuery3[256]; // [sp+28h] [bp-3ECh]@13
  SQLINTEGER null11; // [sp+128h] [bp-2ECh]@13
  SQLINTEGER null10; // [sp+12Ch] [bp-2E8h]@13
  __int16 sqlResult3; // [sp+130h] [bp-2E4h]@13
  SqlQuery sql_; // [sp+134h] [bp-2E0h]@8
  SQLCHAR sqlQuery2[256]; // [sp+148h] [bp-2CCh]@8
  SQLINTEGER null7; // [sp+248h] [bp-1CCh]@8
  SQLINTEGER null6; // [sp+24Ch] [bp-1C8h]@8
  __int16 sqlResult2; // [sp+250h] [bp-1C4h]@8
  SqlQuery sql; // [sp+254h] [bp-1C0h]@1
  SQLINTEGER null2; // [sp+268h] [bp-1ACh]@1
  SQLINTEGER null5; // [sp+26Ch] [bp-1A8h]@1
  SQLINTEGER null4; // [sp+270h] [bp-1A4h]@1
  SQLCHAR sqlQuery[256]; // [sp+274h] [bp-1A0h]@1
  SQLINTEGER null3; // [sp+374h] [bp-A0h]@1
  SQLINTEGER null; // [sp+378h] [bp-9Ch]@1
  SQLINTEGER null1; // [sp+37Ch] [bp-98h]@1
  SQLRETURN sqlResult; // [sp+380h] [bp-94h]@1
  char lastIP[16]; // [sp+384h] [bp-90h]@1
  tm loginTime_; // [sp+394h] [bp-80h]@1
  tm now_; // [sp+3B8h] [bp-5Ch]@1
  TIMESTAMP_STRUCT lastLogin; // [sp+3DCh] [bp-38h]@1
  int usedTime; // [sp+3ECh] [bp-28h]@1
  int payFlag; // [sp+3F0h] [bp-24h]@4
  time_t now; // [sp+3F4h] [bp-20h]@1
  TIMESTAMP_STRUCT logoutTime; // [sp+3F8h] [bp-1Ch]@1
  int unused2; // [sp+410h] [bp-4h]@1

  sprintf(
    lastIP,
    aD_D_D_D,
    userIp.S_un.S_un_b.s_b1,
    userIp.S_un.S_un_b.s_b2,
    userIp.S_un.S_un_b.s_b3,
    userIp.S_un.S_un_b.s_b4);
  now = time(0);
  usedTime = now - loginTime;
  Utils::sendToLog(804, accountName, userIp.S_un.S_addr, payStat, age, a10, 0, now - loginTime, uid);
  qmemcpy(&now_, localtime(&now), sizeof(now_));
  qmemcpy(&loginTime_, localtime(&loginTime), sizeof(loginTime_));
  logoutTime.year = LOWORD(now_.tm_year) + 1900;
  logoutTime.month = LOWORD(now_.tm_mon) + 1;
  logoutTime.day = now_.tm_mday;
  logoutTime.hour = now_.tm_hour;
  logoutTime.minute = now_.tm_min;
  logoutTime.second = now_.tm_sec;
  logoutTime.fraction = 0;
  lastLogin.year = LOWORD(loginTime_.tm_year) + 1900;
  lastLogin.month = LOWORD(loginTime_.tm_mon) + 1;
  lastLogin.day = loginTime_.tm_mday;
  lastLogin.hour = loginTime_.tm_hour;
  lastLogin.minute = loginTime_.tm_min;
  lastLogin.second = loginTime_.tm_sec;
  lastLogin.fraction = 0;
  SqlQuery::SqlQuery(&sql, &g_dbManager);
  unused2 = 0;
  null = 0;
  SqlQuery::bindParam((SqlQuery *)sql.sqlHandler, 1u, SQL_PARAM_INPUT, -18, SQL_INTEGER, 0, 0, &uid, 0, &null);
  null1 = 0;
  SqlQuery::bindParam(
    (SqlQuery *)sql.sqlHandler,
    2u,
    SQL_PARAM_INPUT,
    SQL_C_TYPE_TIMESTAMP,
    SQL_TIMESTAMP,
    19u,
    0,
    &lastLogin,
    0,
    &null1);
  null2 = 0;
  SqlQuery::bindParam((SqlQuery *)sql.sqlHandler, 3u, SQL_PARAM_INPUT, 93, 11, 19u, 0, &logoutTime, 0, &null2);
  null3 = 0;
  SqlQuery::bindParam((SqlQuery *)sql.sqlHandler, 4u, SQL_PARAM_INPUT, -18, SQL_INTEGER, 0, 0, &gameType, 0, &null3);// SQL_C_ULONG
  null4 = 0;
  SqlQuery::bindParam((SqlQuery *)sql.sqlHandler, 5u, SQL_PARAM_INPUT, -28, -6, 0, 0, &lastWorld, 0, &null4);// SQL_C_UTINYINT, SQL_TINYINT
  null5 = SQL_NTS;
  ipLength = strlen(lastIP);
  SqlQuery::bindParam(
    (SqlQuery *)sql.sqlHandler,
    6u,
    SQL_PARAM_INPUT,
    SQL_C_CHAR,
    SQL_VARCHAR,
    15u,
    0,
    lastIP,
    ipLength,
    &null5);
  sprintf((char *)sqlQuery, aCallDbo_ap_slo);
  sqlResult = SqlQuery::execRaw((SqlQuery *)sql.sqlHandler, (const char *)sqlQuery, SQL_NTS);
  if ( sqlResult )
  {
    SqlQuery::printError(&sql, SQL_HANDLE_STMT, sql.sqlHandler, (char *)sqlQuery);
    SqlQuery::reset(&sql);
  }
  else
  {
    SqlQuery::reset(&sql);
  }
  unused2 = -1;
  SqlQuery::Destructor(&sql);
  FileLog::write(
    &g_userLog,
    0,
    aDDDDDDDDDDDDSD,
    now_.tm_year + 1900,
    now_.tm_mon + 1,
    now_.tm_mday,
    now_.tm_hour,
    now_.tm_min,
    now_.tm_sec,
    loginTime_.tm_year + 1900,
    loginTime_.tm_mon + 1,
    loginTime_.tm_mday,
    loginTime_.tm_hour,
    loginTime_.tm_min,
    loginTime_.tm_sec,
    accountName,
    (unsigned __int8)lastWorld,
    lastIP,
    payStat,
    usedTime,
    usedTime,
    a8,
    a9,
    a10,
    now_.tm_wday,
    age,
    someClientCookie);
  payFlag = payStat % 1000 / 100;
  if ( payStat >= 1000 || payStat <= 0 )
  {
    if ( payFlag == 2 )
    {
      SqlQuery::SqlQuery(&sql_, &g_dbManager);
      unused2 = 1;
      null6 = 0;
      SqlQuery::bindParam(
        (SqlQuery *)sql_.sqlHandler,
        1u,
        SQL_PARAM_INPUT,
        -18,
        SQL_INTEGER,
        0,
        0,
        &usedTime,
        0,
        &null6);                                // SQL_C_ULONG
      null7 = 0;
      SqlQuery::bindParam((SqlQuery *)sql_.sqlHandler, 2u, SQL_PARAM_INPUT, -18, SQL_INTEGER, 0, 0, &uid, 0, &null7);
      sprintf((char *)sqlQuery2, aCallDbo_ap_sus);
      sqlResult2 = SqlQuery::execRaw((SqlQuery *)sql_.sqlHandler, (const char *)sqlQuery2, SQL_NTS);
      if ( sqlResult2 )
      {
        SqlQuery::printError(&sql_, SQL_HANDLE_STMT, sql_.sqlHandler, (char *)sqlQuery2);
        SqlQuery::reset(&sql_);
      }
      else
      {
        SqlQuery::reset(&sql_);
      }
      unused2 = -1;
      SqlQuery::Destructor(&sql_);
    }
    else if ( payFlag == 3 )
    {
      SqlQuery::SqlQuery(&sql__, &g_dbManager);
      unused2 = 2;
      null11 = 0;
      unused = 0;
      accLength = strlen(accountName);
      SqlQuery::bindParam(
        (SqlQuery *)sql__.sqlHandler,
        1u,
        SQL_PARAM_INPUT,
        SQL_C_CHAR,
        SQL_VARCHAR,
        14u,
        0,
        accountName,
        accLength,
        &null11);
      null10 = 0;
      SqlQuery::bindParam(
        (SqlQuery *)sql__.sqlHandler,
        2u,
        SQL_PARAM_INPUT,
        SQL_C_TYPE_TIMESTAMP,
        SQL_TIMESTAMP,
        19u,
        0,
        &lastLogin,
        0,
        &null10);
      null12 = 0;
      SqlQuery::bindParam(
        (SqlQuery *)sql__.sqlHandler,
        3u,
        SQL_PARAM_INPUT,
        SQL_C_TYPE_TIMESTAMP,
        SQL_TIMESTAMP,
        19u,
        0,
        &logoutTime,
        0,
        &null12);
      sprintf((char *)sqlQuery3, aCallDbo_ap_log);
      sqlResult3 = SqlQuery::execRaw((SqlQuery *)sql__.sqlHandler, (const char *)sqlQuery3, SQL_NTS);
      if ( sqlResult3 )
      {
        SqlQuery::printError(&sql__, SQL_HANDLE_STMT, sql__.sqlHandler, (char *)sqlQuery3);
        SqlQuery::reset(&sql__);
      }
      else
      {
        SqlQuery::reset(&sql__);
      }
      unused2 = -1;
      SqlQuery::Destructor(&sql__);
    }
  }
  else
  {
    IPSessionDB::sendSomethingToIPSocket(
      &g_IPSessionDB,
      uid,
      userIp.S_un.S_addr,
      payStat,
      usedTime,
      loginTime,
      lastWorld,
      accountName);
  }
  InterlockedDecrement(&g_StatusLine.loggedUsers);
  return 1;
}

//----- (004047E1) --------------------------------------------------------
char __stdcall UserManager::getTotalTime(unsigned int uid, UserInfo *accountInfo, int *userTime)
{
  char errorCode; // [sp+4h] [bp-4h]@1

  errorCode = UserManager::getUserGameTime(uid, userTime);
  if ( errorCode )
    errorCode = REASON_NO_TIME_LEFT;
  return errorCode;
}

//----- (0040481A) --------------------------------------------------------
char __stdcall CAuthSocket::authenticateUser(CAuthSocket *this, UserInfo *accInfo, int uid)
{
  char result; // al@8
  SqlQuery sql; // [sp+4h] [bp-20h]@6
  int serverFlag; // [sp+18h] [bp-Ch]@1
  int totalTime; // [sp+1Ch] [bp-8h]@1
  char errorCode; // [sp+20h] [bp-4h]@1

  errorCode = 0;
  serverFlag = accInfo->payStat % 1000 / 100;
  totalTime = 0;
  if ( accInfo->payStat )
  {
    if ( serverFlag == 2 )                      // free server?
    {
      errorCode = UserManager::getTotalTime(uid, accInfo, &totalTime);
    }
    else if ( serverFlag == 3 )
    {
      SqlQuery::SqlQuery(&sql, &g_dbManager);
      SqlQuery::Destructor(&sql);
    }
  }
  else
  {
    errorCode = REASON_UNKNOWN1;
  }
  if ( errorCode )
  {
    CAuthSocket::assembleAndSend(this, aCc_3, LS_LoginFail, errorCode);
    result = errorCode;
  }
  else
  {
    if ( UserManager::authenticateUser(&g_userManager, accInfo, uid, this, totalTime, 0) )
    {
      this->m_lastPacketTime = GetTickCount();
      Utils::sendToLog(
        801,
        accInfo->accountName,
        accInfo->connectedIP,
        accInfo->payStat,
        accInfo->age,
        LOBYTE(accInfo->sexAndCentury),
        0,
        g_StatusLine.users,
        uid);
    }
    result = errorCode;
  }
  return result;
}

//----- (0040492F) --------------------------------------------------------
char __stdcall UserManager::getUserGameTime(unsigned int uid, int *userTime)
{
  char errorCode_; // ST2C_1@6
  SqlQuery sql; // [sp+8h] [bp-134h]@1
  SQLCHAR sqlQuery; // [sp+1Ch] [bp-120h]@1
  bool a2a; // [sp+11Ch] [bp-20h]@2
  char errorCode; // [sp+120h] [bp-1Ch]@1
  SQLINTEGER pcbValue; // [sp+124h] [bp-18h]@1
  __int16 sqlRes; // [sp+128h] [bp-14h]@1
  SQLINTEGER unused_2; // [sp+12Ch] [bp-10h]@1
  int unused_1; // [sp+138h] [bp-4h]@1

  errorCode = 0;
  SqlQuery::SqlQuery(&sql, &g_dbManager);
  unused_1 = 0;
  pcbValue = 0;
  SqlQuery::bindParam((SqlQuery *)sql.sqlHandler, 1u, SQL_PARAM_INPUT, -18, SQL_INTEGER, 0, 0, &uid, 0, &pcbValue);// SQL_C_ULONG
  unused_2 = 0;
  SqlQuery::bindParam((SqlQuery *)sql.sqlHandler, 2u, SQL_PARAM_OUTPUT, -18, SQL_INTEGER, 0, 0, userTime, 0, &unused_2);
  sprintf((char *)&sqlQuery, aCallDbo_ap_gus);
  sqlRes = SqlQuery::execRaw((SqlQuery *)sql.sqlHandler, (const char *)&sqlQuery, SQL_NTS);
  if ( sqlRes )
  {
    errorCode = REASON_SYSTEM_ERROR_LOGIN_LATER;
  }
  else
  {
    SqlQuery::fetch(&sql, &a2a);
    if ( *userTime <= 0 )
      errorCode = REASON_NO_TIME_LEFT;
  }
  SqlQuery::reset(&sql);
  errorCode_ = errorCode;
  unused_1 = -1;
  SqlQuery::Destructor(&sql);
  return errorCode_;
}

//----- (00404A52) --------------------------------------------------------
char __thiscall UserManager::forwardUserToGS(UserManager *this, int uid, char *accName, int totalTime, int loginFlag, int warnFlag, int sessionKey, CAuthSocket *gameClient, signed int serverId, int payStat)
{
  char result; // al@3
  int binSize; // ST24_4@8
  ServerInfo *serverInfo_; // eax@8
  ServerInfo *serverInfo__; // eax@13
  UserManager *this_; // [sp+0h] [bp-F4h]@1
  ServerInfo outServerInfo; // [sp+4h] [bp-F0h]@13
  ServerInfo serverInfo; // [sp+5Ch] [bp-98h]@8
  SQLINTEGER len; // [sp+B4h] [bp-40h]@5
  char userData[16]; // [sp+B8h] [bp-3Ch]@5
  int size; // [sp+C8h] [bp-2Ch]@5
  SqlQuery sql; // [sp+CCh] [bp-28h]@5
  char errorCode; // [sp+E0h] [bp-14h]@1
  int success; // [sp+E4h] [bp-10h]@1
  int unused; // [sp+F0h] [bp-4h]@5

  this_ = this;
  errorCode = 0;
  success = 0;
  if ( ServersProvider::isServerOn(serverId) || !gameClient )
  {
    if ( g_Config.UserData )
    {
      memset(userData, 0, 16u);
      SqlQuery::SqlQuery(&sql, &g_dbManager);
      unused = 0;
      len = 0;
      SQLBindCol(sql.sqlHandler, 1u, -2, userData, 16, &len);// SQL_C_BINARY
      SqlQuery::exec(&sql, aSelectUser_dat, uid);
      SqlQuery::fetch(&sql, 0);
      size = 16;
      if ( serverId <= g_ServerList.m_serverNumber && serverId >= 1 )
      {
        binSize = size;
        serverInfo_ = ServerList::getServerInfo(&g_ServerList, &serverInfo, serverId);
        success = WorldSrvServer::sendToWorldServer(
                    serverInfo_->ipAddress,
                    aCdsdddbd,
                    0,
                    uid,
                    accName,
                    totalTime,
                    loginFlag,
                    warnFlag,
                    binSize,
                    userData,
                    payStat);
      }
      unused = -1;
      SqlQuery::Destructor(&sql);
    }
    else if ( serverId <= g_ServerList.m_serverNumber && serverId >= 1 )
    {
      serverInfo__ = ServerList::getServerInfo(&g_ServerList, &outServerInfo, serverId);
      success = WorldSrvServer::sendToWorldServer(
                  serverInfo__->ipAddress,
                  aCdsdddd_0,
                  0,
                  uid,
                  accName,
                  totalTime,
                  loginFlag,
                  warnFlag,
                  payStat);
    }
    if ( gameClient )
    {
      if ( success )
      {
        errorCode = UserManager::bindUserWithGameServer(this_, uid, gameClient->base.m_hSocket, sessionKey, serverId);
        if ( errorCode )
          CAuthSocket::assembleAndSend(gameClient, aCc_6, LS_PlayFail, errorCode);
      }
      else
      {
        errorCode = PLAY_FAIL_GS_ERROR;
        CAuthSocket::assembleAndSend(gameClient, aCc_5, LS_PlayFail, PLAY_FAIL_GS_ERROR);
      }
    }
    result = errorCode;
  }
  else
  {
    CAuthSocket::assembleAndSend(gameClient, aCc_4, LS_PlayFail, PLAY_FAIL_GS_ERROR);
    result = PLAY_FAIL_GS_ERROR;
  }
  return result;
}

//----- (00404C7A) --------------------------------------------------------
char __thiscall UserManager::userReadyForGS_IP_Session(UserManager *this, int uid, char *accountName, int *loginFlag, int *warnFlag, int *sessionKey, SOCKET *socket)
{
  std::_tree::iterator *end; // eax@1
  std::pair_AccountInfo *v8; // eax@2
  std::pair_AccountInfo *v9; // eax@2
  std::pair_AccountInfo *v10; // eax@2
  std::pair_AccountInfo *accInfo; // eax@2
  std::pair_AccountInfo *accInfo_; // eax@2
  UserManager *this_; // [sp+0h] [bp-14h]@1
  std::_tree::iterator a2; // [sp+4h] [bp-10h]@1
  std::_tree::iterator it; // [sp+8h] [bp-Ch]@1
  HANDLE timer; // [sp+Ch] [bp-8h]@1
  char success; // [sp+10h] [bp-4h]@1

  this_ = this;
  success = false;
  timer = 0;
  SpinLock::Enter(&this->m_spinLock);
  std::map::find(&this_->m_accounts, &it, &uid);
  end = std::map::end(&this_->m_accounts, &a2);
  if ( (unsigned __int8)std::_tree::iterator::not_equal(&it, end) )
  {
    v8 = std::_tree::iterator::value(&it);
    strncpy(accountName, v8->value.accountName, 15u);
    v9 = std::_tree::iterator::value(&it);
    *loginFlag = v9->value.loginFlag;
    v10 = std::_tree::iterator::value(&it);
    *warnFlag = v10->value.warnFlag;
    accInfo = std::_tree::iterator::value(&it);
    *socket = accInfo->value.gameSocket;
    accInfo_ = std::_tree::iterator::value(&it);
    *sessionKey = accInfo_->value.sessionKey;
    timer = std::_tree::iterator::value(&it)->value.timerHandler;
    std::_tree::iterator::value(&it)->value.timerHandler = 0;
    success = true;
  }
  SpinLock::Leave(&this_->m_spinLock);
  if ( timer )
    DeleteTimerQueueTimer(0, timer, 0);
  return success;
}

//----- (00404D70) --------------------------------------------------------
char __thiscall UserManager::getAccInfo(UserManager *this, int uid, char *accName, int *payStat, int *connectedIP, time_t *loginTime)
{
  std::_tree::iterator *end; // eax@1
  std::pair_AccountInfo *accInfo; // eax@2
  std::pair_AccountInfo *accInfo_; // eax@2
  std::pair_AccountInfo *accInfo_0; // eax@2
  std::pair_AccountInfo *accInfo_1; // eax@2
  UserManager *this_; // [sp+0h] [bp-10h]@1
  std::_tree::iterator a2; // [sp+4h] [bp-Ch]@1
  std::_tree::iterator it; // [sp+8h] [bp-8h]@1
  char success; // [sp+Ch] [bp-4h]@1

  this_ = this;
  success = false;
  SpinLock::Enter(&this->m_spinLock);
  std::map::find(&this_->m_accounts, &it, &uid);
  end = std::map::end(&this_->m_accounts, &a2);
  if ( (unsigned __int8)std::_tree::iterator::not_equal(&it, end) )
  {
    accInfo = std::_tree::iterator::value(&it);
    strncpy(accName, accInfo->value.accountName, 15u);
    accInfo_ = std::_tree::iterator::value(&it);
    *payStat = accInfo_->value.payStat;
    accInfo_0 = std::_tree::iterator::value(&it);
    *connectedIP = accInfo_0->value.connectedIP;
    accInfo_1 = std::_tree::iterator::value(&it);
    *loginTime = accInfo_1->value.loginTime;
    SpinLock::Leave(&this_->m_spinLock);
    success = true;
  }
  else
  {
    SpinLock::Leave(&this_->m_spinLock);
  }
  return success;
}

//----- (00404E2B) --------------------------------------------------------
char __thiscall UserManager::addUser(UserManager *this, UserInfo *accInfo, int uid, WorldSrvSocket *serverSocket, int unused1, int unused)
{
  std::pair_AccountInfo *pair; // eax@1
  UserManager *this_; // [sp+0h] [bp-64h]@1
  std::pair_AccountInfo accPair; // [sp+4h] [bp-60h]@1
  std::pair_bool_acc insertResult; // [sp+58h] [bp-Ch]@1
  char newUser; // [sp+60h] [bp-4h]@1

  this_ = this;
  newUser = 0;
  SpinLock::Enter(&this->m_spinLock);
  pair = std::pair_AccountInfo::pair_AccountInfo(&accPair, (int)&uid, accInfo);
  std::map::insert(&this_->m_accounts, &insertResult, pair);
  newUser = insertResult.second;
  SpinLock::Leave(&this_->m_spinLock);
  if ( !newUser )
    UserManager::kickUser(this_, uid, REASON_ACCOUNT_IN_USE, true);
  return newUser;
}

//----- (00404E9A) --------------------------------------------------------
int __stdcall UserManager::getUserCharNumber(int uid)
{
  int userCharNumber1; // ST10_4@4
  bool notFound; // [sp+8h] [bp-28h]@2
  SqlQuery sql; // [sp+Ch] [bp-24h]@1
  int userCharNumber; // [sp+20h] [bp-10h]@1
  int unused1; // [sp+2Ch] [bp-4h]@1

  userCharNumber = 0;
  SqlQuery::SqlQuery(&sql, &g_dbManager);
  unused1 = 0;
  SqlQuery::bindInt(&sql, &userCharNumber);
  if ( SqlQuery::exec(&sql, aSelectUser_cha, uid) )
  {
    notFound = false;
    SqlQuery::fetch(&sql, &notFound);
  }
  else
  {
    userCharNumber = -1;
  }
  userCharNumber1 = userCharNumber;
  unused1 = -1;
  SqlQuery::Destructor(&sql);
  return userCharNumber1;
}

//----- (00404F3E) --------------------------------------------------------
char __stdcall UserManager::addCharacterToServer(int uid, int charId, char serverId)
{
  char result_2; // ST18_1@3
  SqlQuery sql; // [sp+8h] [bp-24h]@1
  char result_1; // [sp+1Ch] [bp-10h]@1
  int unused1; // [sp+28h] [bp-4h]@1

  result_1 = false;
  SqlQuery::SqlQuery(&sql, &g_dbManager);
  unused1 = 0;
  if ( SqlQuery::exec(&sql, aInsertIntoUser, uid, serverId, charId) )
  {
    SqlQuery::exec(&sql, aUpdateUser_dat, uid);
    result_1 = true;
  }
  result_2 = result_1;
  unused1 = -1;
  SqlQuery::Destructor(&sql);
  return result_2;
}

//----- (00404FDC) --------------------------------------------------------
char __stdcall UserManager::delCharacter(int uid, int charId, char serverId)
{
  char result_2; // ST2C_1@4
  SqlQuery sql; // [sp+8h] [bp-128h]@1
  SQLCHAR StatementText; // [sp+1Ch] [bp-114h]@1
  char result_1; // [sp+11Ch] [bp-14h]@1
  SQLINTEGER null11; // [sp+120h] [bp-10h]@1
  SQLINTEGER null12; // [sp+124h] [bp-Ch]@1
  SQLINTEGER pcbValue; // [sp+128h] [bp-8h]@1
  __int16 sqlResult; // [sp+12Ch] [bp-4h]@1

  result_1 = false;
  SqlQuery::SqlQuery(&sql, &g_dbManager);
  pcbValue = 0;
  null12 = 0;
  null11 = 0;
  SqlQuery::bindParam((SqlQuery *)sql.sqlHandler, 1u, SQL_PARAM_INPUT, -18, SQL_INTEGER, 0, 0, &uid, 0, &pcbValue);// SQL_C_ULONG
  SqlQuery::bindParam((SqlQuery *)sql.sqlHandler, 2u, SQL_PARAM_INPUT, -18, SQL_INTEGER, 0, 0, &charId, 0, &null12);
  SqlQuery::bindParam((SqlQuery *)sql.sqlHandler, 3u, SQL_PARAM_INPUT, -6, -6, 0, 0, &serverId, 0, &null11);// SQL_C_TINYINT, SQL_TINYINT
  sprintf((char *)&StatementText, aCallDbo_ap_del);
  sqlResult = SqlQuery::execRaw((SqlQuery *)sql.sqlHandler, (const char *)&StatementText, SQL_NTS);
  if ( !sqlResult || sqlResult == SQL_SUCCESS_WITH_INFO )
    result_1 = true;
  result_2 = result_1;
  SqlQuery::Destructor(&sql);
  return result_2;
}

//----- (004050DC) --------------------------------------------------------
char __stdcall UserManager::moveCharacterToServer(int uid, int oldCharId, char oldServerId, int newCharId, int newServerId)
{
  char result1; // ST20_1@3
  SqlQuery sql; // [sp+8h] [bp-24h]@1
  char result2; // [sp+1Ch] [bp-10h]@1
  int unused1; // [sp+28h] [bp-4h]@1

  result2 = false;                              // UPDATE user_char set char_id=%d, world_id=%d WHERE uid =%d and char_id = %d and world_id = %d
  SqlQuery::SqlQuery(&sql, &g_dbManager);
  unused1 = 0;
  if ( SqlQuery::exec(&sql, aUpdateUser_cha, newCharId, newServerId, uid, oldCharId, oldServerId) )
    result2 = true;
  result1 = result2;
  unused1 = -1;
  SqlQuery::Destructor(&sql);
  return result1;
}

//----- (0040516D) --------------------------------------------------------
int SomeStaticInit3()
{
  SomeBitsInit();
  return sub_40517C();
}

//----- (0040517C) --------------------------------------------------------
int sub_40517C()
{
  return atexit(emptystub);
}

//----- (00405190) --------------------------------------------------------
UserManager *__thiscall UserManager::DeletingDtor(UserManager *this, char a2)
{
  UserManager *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  UserManager::Destructor(this);
  if ( a2 & 1 )
    _delete_table(v3);
  return v3;
}

//----- (00405200) --------------------------------------------------------
std::map *__thiscall std::map::map2(std::map *this, _BYTE *a2, _BYTE *a3)
{
  std::map *v3; // ST08_4@1

  v3 = this;
  std::map::map(this, a2, a3);
  return v3;
}

//----- (00405220) --------------------------------------------------------
std::_tree::iterator __thiscall std::map::begin(std::map *this, int a2)
{
  std::_tree::begin(this, a2);
  return (std::_tree::iterator)a2;
}

//----- (00405240) --------------------------------------------------------
std::_tree::iterator *__thiscall std::map::end(std::map *this, std::_tree::iterator *a2)
{
  std::_tree::end(&this->_Tr, a2);
  return a2;
}

//----- (00405260) --------------------------------------------------------
std::pair_bool_acc *__thiscall std::map::insert(std::map *this, std::pair_bool_acc *a2, std::pair_AccountInfo *a3)
{
  int a2a; // [sp+4h] [bp-8h]@1
  char a3a; // [sp+8h] [bp-4h]@1

  std::_tree::insert3(&this->_Tr, (int)&a2a, (struct Concurrency::IExecutionContext *)a3);
  std::pair::pair_iterator_bool((int)a2, &a2a, &a3a);
  return a2;
}

//----- (004052A0) --------------------------------------------------------
std::_tree::iterator *__thiscall std::map::erase(std::map *this, _DWORD *a2, std::_tree::iterator *a3)
{
  std::_tree::erase_2(&this->_Tr, a2, (int)a3);
  return (std::_tree::iterator *)a2;
}

//----- (004052E0) --------------------------------------------------------
std::_tree::iterator *__thiscall std::map::find(std::map *this, std::_tree::iterator *a2, _DWORD *a3)
{
  std::_tree::find(&this->_Tr, a2, a3);
  return a2;
}

//----- (00405300) --------------------------------------------------------
void __thiscall std::_tree::destructor(std::_tree *this)
{
  std::_tree *v1; // ST0C_4@1
  std::_tree::_Node *v2; // ST08_4@1
  int *v3; // eax@1
  char v4; // [sp+4h] [bp-14h]@1
  char v5; // [sp+8h] [bp-10h]@1
  char v6; // [sp+Ch] [bp-Ch]@1
  char v7; // [sp+10h] [bp-8h]@1
  void *v8; // [sp+14h] [bp-4h]@1

  v1 = this;
  v2 = std::_tree::end(this, (std::_tree::iterator *)&v6)->_Ptr;
  v3 = (int *)std::_tree::begin(v1, (int)&v5);
  std::_tree::erase(v1, &v4, *v3, (char)v2);
  std::_tree::_Freenode(v1->_Head);
  v1->_Head = 0;
  v1->_Size = 0;
  v8 = 0;
  std::_Lockit::_Lockit((std::_Lockit *)&v7);
  if ( !--std::_tree::_Nilrefs )
  {
    v8 = std::_tree::_Nil;
    std::_tree::_Nil = 0;
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v7);
  if ( v8 )
    std::_tree::_Freenode(v8);
}
// 472464: using guessed type int std::_tree::_Nilrefs;

//----- (004053B0) --------------------------------------------------------
std::pair_AccountInfo *__thiscall std::pair_AccountInfo::pair_AccountInfo(std::pair_AccountInfo *this, int uid, UserInfo *a3)
{
  this->uid = *(_DWORD *)uid;
  qmemcpy(&this->value, a3, sizeof(this->value));
  return this;
}

//----- (00405420) --------------------------------------------------------
_DWORD *__thiscall std::_tree::iterator::post_increment(std::_tree::iterator *this, _DWORD *a2, int a3)
{
  std::_tree::iterator v3; // ST04_4@1

  v3._Ptr = this->_Ptr;
  std::_tree::iterator::pre_increment(this);
  *a2 = v3._Ptr;
  return a2;
}

//----- (00405450) --------------------------------------------------------
BOOL __thiscall std::_tree::iterator::not_equal(std::_tree::iterator *this, std::_tree::iterator *a2)
{
  return (unsigned __int8)std::_tree::iterator_operator_eq((int)this, a2) == 0;
}

//----- (00405480) --------------------------------------------------------
std::map *__thiscall std::map::map(std::map *this, _BYTE *a2, _BYTE *a4)
{
  std::map *v3; // ST0C_4@1

  v3 = this;
  std::_tree::_tree(&this->_Tr, a2, 0, a4);
  return v3;
}

//----- (004054B0) --------------------------------------------------------
int __thiscall std::_tree::begin(void *this, int a2)
{
  int *v2; // eax@1

  v2 = (int *)std::_tree::_Lmost((std::_tree *)this);
  std::_tree::iterator::iterator((std::_tree::iterator *)a2, *v2);
  return a2;
}

//----- (004054E0) --------------------------------------------------------
std::_tree::iterator *__thiscall std::_tree::end(std::_tree *this, std::_tree::iterator *a2)
{
  std::_tree::iterator::iterator(a2, (int)this->_Head);
  return a2;
}

//----- (00405500) --------------------------------------------------------
int __thiscall std::_tree::insert3(std::_tree *this, int a2, struct Concurrency::IExecutionContext *a3)
{
  _DWORD *v3; // ST10_4@3
  std::_tree::_Node *v4; // eax@3
  _DWORD *v5; // eax@8
  int result; // eax@8
  _DWORD *v7; // eax@10
  _DWORD *v8; // eax@11
  std::_tree::_Node *v9; // ST10_4@13
  std::_tree::_Node *v10; // eax@13
  _DWORD *v11; // eax@13
  _DWORD *v12; // eax@14
  std::_tree::_Node *v13; // [sp+0h] [bp-40h]@4
  std::_tree *v14; // [sp+4h] [bp-3Ch]@1
  char v15; // [sp+8h] [bp-38h]@15
  int v16; // [sp+Ch] [bp-34h]@14
  char v17; // [sp+10h] [bp-30h]@14
  int v18; // [sp+18h] [bp-28h]@11
  char v19; // [sp+1Ch] [bp-24h]@11
  char v20; // [sp+20h] [bp-20h]@10
  int v21; // [sp+24h] [bp-1Ch]@8
  char v22; // [sp+28h] [bp-18h]@8
  std::_tree::_Node *_Y; // [sp+30h] [bp-10h]@1
  std::_tree::_Node *_X; // [sp+34h] [bp-Ch]@1
  int v25; // [sp+38h] [bp-8h]@1
  int v26; // [sp+3Ch] [bp-4h]@9

  v14 = this;
  _X = std::_tree::_Root_const(this)->_Left;
  _Y = v14->_Head;
  LOBYTE(v25) = 1;
  while ( _X != std::_tree::_Nil )
  {
    _Y = _X;
    v3 = std::_tree::_Key(_X);
    v4 = std::_tree::_Kfn((void *)a3);
    LOBYTE(v25) = std::_tree::key_compare(v4, v3);
    if ( (_BYTE)v25 )
      v13 = std::_tree::_Left((int)_X)->_Left;
    else
      v13 = std::_tree::_Right((int)_X)->_Left;
    _X = v13;
  }
  if ( v14->_Multi )
  {
    v22 = 1;
    v5 = (_DWORD *)std::_tree::_Insert(v14, (int)&v21, _X, _Y, a3);
    std::pair::pair_iterator_bool(a2, v5, &v22);
    return a2;
  }
  std::_tree::iterator::iterator((std::_tree::iterator *)&v26, (int)_Y);
  if ( (_BYTE)v25 )
  {
    v7 = (_DWORD *)std::_tree::begin(v14, (int)&v20);
    if ( (unsigned __int8)std::_tree::iterator_operator_eq((int)&v26, v7) )
    {
      v19 = 1;
      v8 = (_DWORD *)std::_tree::_Insert(v14, (int)&v18, _X, _Y, a3);
      std::pair::pair_iterator_bool(a2, v8, &v19);
      return a2;
    }
    unknown_libname_14(&v26);
  }
  v9 = std::_tree::_Kfn((void *)a3);
  v10 = (std::_tree::_Node *)unknown_libname_12(&v26);
  v11 = std::_tree::_Key(v10);
  if ( (unsigned __int8)std::_tree::key_compare(v11, v9) )
  {
    v17 = 1;
    v12 = (_DWORD *)std::_tree::_Insert(v14, (int)&v16, _X, _Y, a3);
    std::pair::pair_iterator_bool(a2, v12, &v17);
    result = a2;
  }
  else
  {
    v15 = 0;
    std::pair::pair_iterator_bool(a2, &v26, &v15);
    result = a2;
  }
  return result;
}
// 406CD0: using guessed type int __thiscall unknown_libname_14(_DWORD);

//----- (004056D0) --------------------------------------------------------
int __thiscall CAuthSocket::getSessionKey(CAuthSocket *this)
{
  return this->m_sessionKey;
}

//----- (004056F0) --------------------------------------------------------
_DWORD *__thiscall std::_tree::erase_2(std::_tree *this, _DWORD *a2, int a3)
{
  _DWORD *v3; // eax@1
  int *v4; // eax@5
  std::_tree::_Node *v5; // eax@7
  std::_tree::_Node **v6; // eax@7
  std::_tree::_Node *v7; // esi@7
  std::_tree::_Node *v8; // eax@7
  std::_tree::_Node **v9; // eax@8
  std::_tree::_Node **v10; // esi@9
  int *v11; // eax@9
  std::_tree::_Node *v12; // eax@9
  std::_tree::_Node *v13; // esi@9
  std::_tree::_Node *v14; // eax@9
  std::_tree::_Node **v15; // eax@9
  std::_tree::_Node *v16; // eax@10
  std::_tree::_Node *v17; // eax@11
  int *v18; // eax@12
  std::_tree::_Node *v19; // eax@12
  int *v20; // eax@13
  std::_tree::_Node *v21; // eax@13
  int *v22; // eax@14
  std::_tree::_Node *v23; // eax@14
  std::_tree::_Node **v24; // esi@15
  int *v25; // ST04_4@15
  int *v26; // eax@15
  std::_tree::_Node **v27; // esi@16
  std::_tree::_Node *v28; // eax@16
  std::_tree::_Node *v29; // eax@17
  int *v30; // eax@18
  std::_tree::_Node *v31; // eax@18
  int *v32; // eax@19
  std::_tree::_Node *v33; // eax@19
  int *v34; // eax@20
  std::_tree::_Node *v35; // eax@20
  std::_tree::_Node *v36; // eax@21
  std::_tree::_Node **v37; // esi@23
  std::_tree::_Node *v38; // esi@24
  std::_tree::_Node *v39; // eax@25
  std::_tree::_Node **v40; // esi@27
  std::_tree::_Node *v41; // esi@28
  std::_tree::_Node *v42; // eax@30
  int *v43; // eax@32
  std::_tree::_Node *v44; // eax@32
  int *v45; // eax@33
  int *v46; // eax@34
  int *v47; // eax@34
  int *v48; // eax@34
  int *v49; // eax@35
  int *v50; // eax@36
  int *v51; // eax@38
  int *v52; // eax@39
  int *v53; // eax@39
  int *v54; // eax@40
  _DWORD *v55; // esi@40
  int *v56; // eax@40
  int *v57; // eax@40
  int *v58; // eax@40
  int *v59; // eax@41
  int *v60; // eax@42
  int *v61; // eax@42
  int *v62; // eax@42
  int *v63; // eax@43
  int *v64; // eax@44
  int *v65; // eax@46
  int *v66; // eax@47
  int *v67; // eax@47
  int *v68; // eax@48
  _DWORD *v69; // esi@48
  int *v70; // eax@48
  int *v71; // eax@48
  int *v72; // eax@48
  void *v73; // eax@51
  std::_tree *this_; // [sp+4h] [bp-2Ch]@1
  char v76; // [sp+8h] [bp-28h]@1
  int v77; // [sp+Ch] [bp-24h]@41
  int v78; // [sp+10h] [bp-20h]@33
  char v79; // [sp+14h] [bp-1Ch]@6
  int v80; // [sp+18h] [bp-18h]@1
  std::_tree::_Node *a1; // [sp+1Ch] [bp-14h]@1
  std::_tree::_Node *v82; // [sp+20h] [bp-10h]@2
  int v83; // [sp+2Ch] [bp-4h]@6

  this_ = this;
  v3 = std::_tree::iterator::post_increment((std::_tree::iterator *)&a3, &v76, 0);
  a1 = (std::_tree::_Node *)unknown_libname_12(v3);
  v80 = (int)a1;
  if ( std::_tree::_Left((int)a1)->_Left == std::_tree::_Nil )
  {
    v82 = std::_tree::_Right((int)a1)->_Left;
  }
  else if ( std::_tree::_Right((int)a1)->_Left == std::_tree::_Nil )
  {
    v82 = std::_tree::_Left((int)a1)->_Left;
  }
  else
  {
    v4 = (int *)std::_tree::_Right((int)a1);
    a1 = (std::_tree::_Node *)sub_406A30(*v4);
    v82 = std::_tree::_Right((int)a1)->_Left;
  }
  std::_Lockit::_Lockit((std::_Lockit *)&v79);
  v83 = 0;
  if ( a1 == (std::_tree::_Node *)v80 )
  {
    v27 = std::_tree::_Parent(a1);
    *std::_tree::_Parent(v82) = *v27;
    v28 = std::_tree::_Root_const(this_);
    if ( v28->_Left == (std::_tree::_Node *)v80 )
    {
      v29 = std::_tree::_Root_const(this_);
      v29->_Left = v82;
    }
    else
    {
      v30 = (int *)std::_tree::_Parent((std::_tree::_Node *)v80);
      v31 = std::_tree::_Left(*v30);
      if ( v31->_Left == (std::_tree::_Node *)v80 )
      {
        v32 = (int *)std::_tree::_Parent((std::_tree::_Node *)v80);
        v33 = std::_tree::_Left(*v32);
        v33->_Left = v82;
      }
      else
      {
        v34 = (int *)std::_tree::_Parent((std::_tree::_Node *)v80);
        v35 = std::_tree::_Right(*v34);
        v35->_Left = v82;
      }
    }
    v36 = std::_tree::_Lmost(this_);
    if ( v36->_Left == (std::_tree::_Node *)v80 )
    {
      if ( std::_tree::_Right(v80)->_Left == std::_tree::_Nil )
      {
        v37 = std::_tree::_Parent((std::_tree::_Node *)v80);
        std::_tree::_Lmost(this_)->_Left = *v37;
      }
      else
      {
        v38 = (std::_tree::_Node *)sub_406A30((int)v82);
        std::_tree::_Lmost(this_)->_Left = v38;
      }
    }
    v39 = std::_tree::_Rmost((int)this_);
    if ( v39->_Left == (std::_tree::_Node *)v80 )
    {
      if ( std::_tree::_Left(v80)->_Left == std::_tree::_Nil )
      {
        v40 = std::_tree::_Parent((std::_tree::_Node *)v80);
        std::_tree::_Rmost((int)this_)->_Left = *v40;
      }
      else
      {
        v41 = (std::_tree::_Node *)sub_4069F0((int)v82);
        std::_tree::_Rmost((int)this_)->_Left = v41;
      }
    }
  }
  else
  {
    v5 = std::_tree::_Left(v80);
    v6 = std::_tree::_Parent(v5->_Left);
    *v6 = a1;
    v7 = std::_tree::_Left(v80);
    std::_tree::_Left((int)a1)->_Left = v7->_Left;
    v8 = std::_tree::_Right(v80);
    if ( a1 == v8->_Left )
    {
      v9 = std::_tree::_Parent(v82);
      *v9 = a1;
    }
    else
    {
      v10 = std::_tree::_Parent(a1);
      *std::_tree::_Parent(v82) = *v10;
      v11 = (int *)std::_tree::_Parent(a1);
      v12 = std::_tree::_Left(*v11);
      v12->_Left = v82;
      v13 = std::_tree::_Right(v80);
      std::_tree::_Right((int)a1)->_Left = v13->_Left;
      v14 = std::_tree::_Right(v80);
      v15 = std::_tree::_Parent(v14->_Left);
      *v15 = a1;
    }
    v16 = std::_tree::_Root_const(this_);
    if ( v16->_Left == (std::_tree::_Node *)v80 )
    {
      v17 = std::_tree::_Root_const(this_);
      v17->_Left = a1;
    }
    else
    {
      v18 = (int *)std::_tree::_Parent((std::_tree::_Node *)v80);
      v19 = std::_tree::_Left(*v18);
      if ( v19->_Left == (std::_tree::_Node *)v80 )
      {
        v20 = (int *)std::_tree::_Parent((std::_tree::_Node *)v80);
        v21 = std::_tree::_Left(*v20);
        v21->_Left = a1;
      }
      else
      {
        v22 = (int *)std::_tree::_Parent((std::_tree::_Node *)v80);
        v23 = std::_tree::_Right(*v22);
        v23->_Left = a1;
      }
    }
    v24 = std::_tree::_Parent((std::_tree::_Node *)v80);
    *std::_tree::_Parent(a1) = *v24;
    v25 = (int *)sub_406270(v80);
    v26 = (int *)sub_406270((int)a1);
    sub_407110(v26, v25);
    a1 = (std::_tree::_Node *)v80;
  }
  if ( *(_DWORD *)sub_406270((int)a1) == 1 )
  {
    while ( 1 )
    {
      v42 = std::_tree::_Root_const(this_);
      if ( v82 == v42->_Left || *(_DWORD *)sub_406270((int)v82) != 1 )
        break;
      v43 = (int *)std::_tree::_Parent(v82);
      v44 = std::_tree::_Left(*v43);
      if ( v82 == v44->_Left )
      {
        v45 = (int *)std::_tree::_Parent(v82);
        v78 = (int)std::_tree::_Right(*v45)->_Left;
        if ( !*(_DWORD *)sub_406270(v78) )
        {
          *(_DWORD *)sub_406270(v78) = 1;
          v46 = (int *)std::_tree::_Parent(v82);
          *(_DWORD *)sub_406270(*v46) = 0;
          v47 = (int *)std::_tree::_Parent(v82);
          sub_4068C0(this_, *v47);
          v48 = (int *)std::_tree::_Parent(v82);
          v78 = (int)std::_tree::_Right(*v48)->_Left;
        }
        v49 = (int *)std::_tree::_Left(v78);
        if ( *(_DWORD *)sub_406270(*v49) != 1
          || (v50 = (int *)std::_tree::_Right(v78), *(_DWORD *)sub_406270(*v50) != 1) )
        {
          v51 = (int *)std::_tree::_Right(v78);
          if ( *(_DWORD *)sub_406270(*v51) == 1 )
          {
            v52 = (int *)std::_tree::_Left(v78);
            *(_DWORD *)sub_406270(*v52) = 1;
            *(_DWORD *)sub_406270(v78) = 0;
            sub_406AB0(this_, v78);
            v53 = (int *)std::_tree::_Parent(v82);
            v78 = (int)std::_tree::_Right(*v53)->_Left;
          }
          v54 = (int *)std::_tree::_Parent(v82);
          v55 = (_DWORD *)sub_406270(*v54);
          *(_DWORD *)sub_406270(v78) = *v55;
          v56 = (int *)std::_tree::_Parent(v82);
          *(_DWORD *)sub_406270(*v56) = 1;
          v57 = (int *)std::_tree::_Right(v78);
          *(_DWORD *)sub_406270(*v57) = 1;
          v58 = (int *)std::_tree::_Parent(v82);
          sub_4068C0(this_, *v58);
          break;
        }
        *(_DWORD *)sub_406270(v78) = 0;
        v82 = *std::_tree::_Parent(v82);
      }
      else
      {
        v59 = (int *)std::_tree::_Parent(v82);
        v77 = (int)std::_tree::_Left(*v59)->_Left;
        if ( !*(_DWORD *)sub_406270(v77) )
        {
          *(_DWORD *)sub_406270(v77) = 1;
          v60 = (int *)std::_tree::_Parent(v82);
          *(_DWORD *)sub_406270(*v60) = 0;
          v61 = (int *)std::_tree::_Parent(v82);
          sub_406AB0(this_, *v61);
          v62 = (int *)std::_tree::_Parent(v82);
          v77 = (int)std::_tree::_Left(*v62)->_Left;
        }
        v63 = (int *)std::_tree::_Right(v77);
        if ( *(_DWORD *)sub_406270(*v63) != 1 || (v64 = (int *)std::_tree::_Left(v77), *(_DWORD *)sub_406270(*v64) != 1) )
        {
          v65 = (int *)std::_tree::_Left(v77);
          if ( *(_DWORD *)sub_406270(*v65) == 1 )
          {
            v66 = (int *)std::_tree::_Right(v77);
            *(_DWORD *)sub_406270(*v66) = 1;
            *(_DWORD *)sub_406270(v77) = 0;
            sub_4068C0(this_, v77);
            v67 = (int *)std::_tree::_Parent(v82);
            v77 = (int)std::_tree::_Left(*v67)->_Left;
          }
          v68 = (int *)std::_tree::_Parent(v82);
          v69 = (_DWORD *)sub_406270(*v68);
          *(_DWORD *)sub_406270(v77) = *v69;
          v70 = (int *)std::_tree::_Parent(v82);
          *(_DWORD *)sub_406270(*v70) = 1;
          v71 = (int *)std::_tree::_Left(v77);
          *(_DWORD *)sub_406270(*v71) = 1;
          v72 = (int *)std::_tree::_Parent(v82);
          sub_406AB0(this_, *v72);
          break;
        }
        *(_DWORD *)sub_406270(v77) = 0;
        v82 = *std::_tree::_Parent(v82);
      }
    }
    *(_DWORD *)sub_406270((int)v82) = 1;
  }
  v83 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v79);
  v73 = std::_tree::_Node::_Value2(a1);
  sub_406BE0((int)v73);
  std::_tree::_Freenode(a1);
  --this_->_Size;
  *a2 = a3;
  return a2;
}

//----- (00405F40) --------------------------------------------------------
_DWORD *__thiscall std::_tree::erase(void *this, _DWORD *a2, int a3, char a4)
{
  std::_tree::iterator *v4; // eax@2
  std::_tree::iterator *v5; // eax@3
  int *v6; // eax@5
  _DWORD *result; // eax@6
  std::_tree::_Node *v8; // eax@7
  std::_tree *v9; // [sp+0h] [bp-14h]@1
  char v10; // [sp+4h] [bp-10h]@5
  char v11; // [sp+8h] [bp-Ch]@5
  char v12; // [sp+Ch] [bp-8h]@3
  char v13; // [sp+10h] [bp-4h]@2

  v9 = (std::_tree *)this;
  if ( !std::_tree::size((int)this)
    || (v4 = (std::_tree::iterator *)std::_tree::begin(v9, (int)&v13),
        (unsigned __int8)std::_tree::iterator::not_equal((std::_tree::iterator *)&a3, v4))
    || (v5 = std::_tree::end(v9, (std::_tree::iterator *)&v12),
        (unsigned __int8)std::_tree::iterator::not_equal((std::_tree::iterator *)&a4, v5)) )
  {
    while ( (unsigned __int8)std::_tree::iterator::not_equal((std::_tree::iterator *)&a3, (std::_tree::iterator *)&a4) )
    {
      v6 = std::_tree::iterator::post_increment((std::_tree::iterator *)&a3, &v11, 0);
      std::_tree::erase_2(v9, &v10, *v6);
    }
    *a2 = a3;
    result = a2;
  }
  else
  {
    v8 = std::_tree::_Root_const(v9);
    sub_406390(v9, v8->_Left);
    std::_tree::_Root_const(v9)->_Left = std::_tree::_Nil;
    v9->_Size = 0;
    std::_tree::_Lmost(v9)->_Left = v9->_Head;
    std::_tree::_Rmost((int)v9)->_Left = v9->_Head;
    std::_tree::begin(v9, (int)a2);
    result = a2;
  }
  return result;
}

//----- (00406060) --------------------------------------------------------
int __thiscall sub_406060(std::_tree *this, _DWORD *a2)
{
  std::_tree *v2; // ST0C_4@1
  char v4; // [sp+4h] [bp-10h]@1
  int v5; // [sp+8h] [bp-Ch]@1
  int v6; // [sp+Ch] [bp-8h]@1
  int v7; // [sp+10h] [bp-4h]@1

  v2 = this;
  sub_406350(this, (int)&v6, a2);
  v5 = 0;
  sub_407140(v6, v7, &v5);
  std::_tree::erase(v2, &v4, v6, v7);
  return v5;
}

//----- (004060C0) --------------------------------------------------------
std::_tree::iterator *__thiscall std::_tree::find(std::_tree *this, std::_tree::iterator *a2, _DWORD *a3)
{
  std::_tree::iterator *v3; // eax@1
  std::_tree::_Node *v4; // eax@2
  _DWORD *v5; // eax@2
  std::_tree::_Node **v7; // [sp+0h] [bp-18h]@3
  std::_tree *v8; // [sp+4h] [bp-14h]@1
  int v9; // [sp+8h] [bp-10h]@4
  int a2a; // [sp+Ch] [bp-Ch]@1
  std::_tree::_Node **v11; // [sp+10h] [bp-8h]@5
  int v12; // [sp+14h] [bp-4h]@1

  v8 = this;
  std::_tree::lower_bound(this, (int)&v12, a3);
  v3 = std::_tree::end(v8, (std::_tree::iterator *)&a2a);
  if ( (unsigned __int8)std::_tree::iterator_operator_eq((int)&v12, v3)
    || (v4 = (std::_tree::_Node *)unknown_libname_12(&v12),
        v5 = std::_tree::_Key(v4),
        (unsigned __int8)std::_tree::key_compare(a3, v5)) )
  {
    v7 = (std::_tree::_Node **)std::_tree::end(v8, (std::_tree::iterator *)&v9);
  }
  else
  {
    v7 = (std::_tree::_Node **)&v12;
  }
  v11 = v7;
  a2->_Ptr = *v7;
  return a2;
}

//----- (00406190) --------------------------------------------------------
void *__thiscall std::_tree::iterator::_Mynode(std::_tree::iterator *this)
{
  return std::_tree::_Node::_Value2(this->_Ptr);
}

//----- (004061D0) --------------------------------------------------------
BOOL __thiscall std::_tree::iterator_operator_eq(int this, _DWORD *a2)
{
  return *(_DWORD *)this == *a2;
}

//----- (004061F0) --------------------------------------------------------
std::_tree::_Node *__thiscall std::pair::pair_iterator_bool(int this, _DWORD *a2, _BYTE *a3)
{
  *(_DWORD *)this = *a2;
  *(_BYTE *)(this + 4) = *a3;
  return (std::_tree::_Node *)this;
}

//----- (00406220) --------------------------------------------------------
BOOL __stdcall std::_tree::key_compare(_DWORD *a1, _DWORD *a2)
{
  return *a1 < *a2;
}

//----- (00406270) --------------------------------------------------------
int __cdecl sub_406270(int a1)
{
  return a1 + 96;
}

//----- (00406280) --------------------------------------------------------
void *__cdecl std::_tree::_Key(std::_tree::_Node *a1)
{
  void *v1; // eax@1

  v1 = std::_tree::_Node::_Value2(a1);
  return std::_tree::_Kfn(v1);
}

//----- (004062B0) --------------------------------------------------------
std::_tree::_Node **__cdecl std::_tree::_Parent(std::_tree::_Node *a1)
{
  return &a1->_Parent;
}

//----- (004062C0) --------------------------------------------------------
std::_tree::_Node *__cdecl std::_tree::_Right(int a1)
{
  return (std::_tree::_Node *)(a1 + 8);
}

//----- (004062D0) --------------------------------------------------------
void *__cdecl std::_tree::_Node::_Value2(std::_tree::_Node *a1)
{
  return &a1->_Value;
}

//----- (004062E0) --------------------------------------------------------
std::_tree *__thiscall std::_tree::_tree(std::_tree *this, _BYTE *a2, char a3, _BYTE *a4)
{
  std::_tree *v4; // ST00_4@1

  v4 = this;
  this->allocator = *a4;
  this->keyComparer = *a2;
  this->_Multi = a3;
  std::_tree::_Init(this);
  return v4;
}

//----- (00406320) --------------------------------------------------------
int __thiscall std::_tree::lower_bound(std::_tree *this, int a2, _DWORD *a3)
{
  std::_tree::_Node *v3; // eax@1

  v3 = std::_tree::_Lbound(this, a3);
  std::_tree::iterator::iterator((std::_tree::iterator *)a2, (int)v3);
  return a2;
}

//----- (00406350) --------------------------------------------------------
int __thiscall sub_406350(std::_tree *this, int a2, _DWORD *a3)
{
  std::_tree *v3; // ST0C_4@1
  _DWORD *v4; // ST08_4@1
  _DWORD *v5; // eax@1
  int a2a; // [sp+4h] [bp-8h]@1
  char v8; // [sp+8h] [bp-4h]@1

  v3 = this;
  v4 = (_DWORD *)sub_406CF0(this, (int)&v8, a3);
  v5 = (_DWORD *)std::_tree::lower_bound(v3, (int)&a2a, a3);
  sub_407010(a2, v5, v4);
  return a2;
}

//----- (00406390) --------------------------------------------------------
void *__thiscall sub_406390(std::_tree *this, void *a2)
{
  void *result; // eax@1
  std::_tree::_Node *v3; // eax@3
  void *v4; // eax@3
  std::_tree *v5; // [sp+0h] [bp-8h]@1
  std::_tree::_Node *i; // [sp+4h] [bp-4h]@1

  v5 = this;
  result = a2;
  for ( i = (std::_tree::_Node *)a2; i != std::_tree::_Nil; a2 = i )
  {
    v3 = std::_tree::_Right((int)i);
    sub_406390(v5, v3->_Left);
    i = std::_tree::_Left((int)i)->_Left;
    v4 = std::_tree::_Node::_Value2((std::_tree::_Node *)a2);
    sub_406BE0((int)v4);
    std::_tree::_Freenode(a2);
  }
  return result;
}

//----- (00406410) --------------------------------------------------------
int __thiscall std::_tree::_Insert(std::_tree *this, int a2, std::_tree::_Node *_X, std::_tree::_Node *_Y, struct Concurrency::IExecutionContext *a5)
{
  void *v5; // eax@1
  _DWORD *v6; // ST04_4@3
  std::_tree::_Node *v7; // eax@3
  int *v8; // eax@13
  std::_tree::_Node **v9; // esi@14
  std::_tree::_Node **v10; // eax@14
  int *v11; // eax@14
  std::_tree::_Node **v12; // eax@15
  int *v13; // eax@15
  int *v14; // eax@15
  int *v15; // eax@16
  std::_tree::_Node **v16; // eax@16
  int *v17; // eax@16
  std::_tree::_Node **v18; // eax@16
  int *v19; // eax@17
  int *v20; // eax@19
  std::_tree::_Node **v21; // eax@19
  int *v22; // eax@19
  std::_tree::_Node **v23; // eax@19
  int *v24; // eax@19
  std::_tree::_Node **v25; // eax@21
  int *v26; // eax@21
  int *v27; // eax@21
  int *v28; // eax@22
  std::_tree::_Node **v29; // eax@22
  int *v30; // eax@22
  std::_tree::_Node **v31; // eax@22
  int *v32; // eax@23
  int *v33; // eax@25
  std::_tree::_Node **v34; // eax@25
  int *v35; // eax@25
  std::_tree::_Node **v36; // eax@25
  int *v37; // eax@25
  int *v38; // eax@27
  std::_tree *this_; // [sp+4h] [bp-Ch]@1
  std::_tree::_Node *a1; // [sp+Ch] [bp-4h]@1
  std::_tree::_Node *_Xa; // [sp+1Ch] [bp+Ch]@11
  std::_tree::_Node *_Ya; // [sp+20h] [bp+10h]@15
  std::_tree::_Node *_Yb; // [sp+20h] [bp+10h]@21

  this_ = this;
  a1 = std::_tree::_Buynode((int)_Y, 0);
  std::_tree::_Left((int)a1)->_Left = std::_tree::_Nil;
  std::_tree::_Right((int)a1)->_Left = std::_tree::_Nil;
  v5 = std::_tree::_Node::_Value2(a1);
  std::_tree::_Consval(v5, (int)a5);
  ++this_->_Size;
  if ( _Y == this_->_Head
    || _X != std::_tree::_Nil
    || (v6 = std::_tree::_Key(_Y), v7 = std::_tree::_Kfn((void *)a5), (unsigned __int8)std::_tree::key_compare(v7, v6)) )
  {
    std::_tree::_Left((int)_Y)->_Left = a1;
    if ( _Y == this_->_Head )
    {
      std::_tree::_Root_const(this_)->_Left = a1;
      std::_tree::_Rmost((int)this_)->_Left = a1;
    }
    else if ( _Y == std::_tree::_Lmost(this_)->_Left )
    {
      std::_tree::_Lmost(this_)->_Left = a1;
    }
  }
  else
  {
    std::_tree::_Right((int)_Y)->_Left = a1;
    if ( _Y == std::_tree::_Rmost((int)this_)->_Left )
      std::_tree::_Rmost((int)this_)->_Left = a1;
  }
  _Xa = a1;
  while ( _Xa != std::_tree::_Root_const(this_)->_Left )
  {
    v8 = (int *)std::_tree::_Parent(_Xa);
    if ( *(_DWORD *)sub_406270(*v8) )
      break;
    v9 = std::_tree::_Parent(_Xa);
    v10 = std::_tree::_Parent(_Xa);
    v11 = (int *)std::_tree::_Parent(*v10);
    if ( *v9 == std::_tree::_Left(*v11)->_Left )
    {
      v12 = std::_tree::_Parent(_Xa);
      v13 = (int *)std::_tree::_Parent(*v12);
      v14 = (int *)std::_tree::_Right(*v13);
      _Ya = (std::_tree::_Node *)*v14;
      if ( *(_DWORD *)sub_406270(*v14) )
      {
        v19 = (int *)std::_tree::_Parent(_Xa);
        if ( _Xa == std::_tree::_Right(*v19)->_Left )
        {
          _Xa = *std::_tree::_Parent(_Xa);
          sub_4068C0(this_, (int)_Xa);
        }
        v20 = (int *)std::_tree::_Parent(_Xa);
        *(_DWORD *)sub_406270(*v20) = 1;
        v21 = std::_tree::_Parent(_Xa);
        v22 = (int *)std::_tree::_Parent(*v21);
        *(_DWORD *)sub_406270(*v22) = 0;
        v23 = std::_tree::_Parent(_Xa);
        v24 = (int *)std::_tree::_Parent(*v23);
        sub_406AB0(this_, *v24);
      }
      else
      {
        v15 = (int *)std::_tree::_Parent(_Xa);
        *(_DWORD *)sub_406270(*v15) = 1;
        *(_DWORD *)sub_406270((int)_Ya) = 1;
        v16 = std::_tree::_Parent(_Xa);
        v17 = (int *)std::_tree::_Parent(*v16);
        *(_DWORD *)sub_406270(*v17) = 0;
        v18 = std::_tree::_Parent(_Xa);
        _Xa = *std::_tree::_Parent(*v18);
      }
    }
    else
    {
      v25 = std::_tree::_Parent(_Xa);
      v26 = (int *)std::_tree::_Parent(*v25);
      v27 = (int *)std::_tree::_Left(*v26);
      _Yb = (std::_tree::_Node *)*v27;
      if ( *(_DWORD *)sub_406270(*v27) )
      {
        v32 = (int *)std::_tree::_Parent(_Xa);
        if ( _Xa == std::_tree::_Left(*v32)->_Left )
        {
          _Xa = *std::_tree::_Parent(_Xa);
          sub_406AB0(this_, (int)_Xa);
        }
        v33 = (int *)std::_tree::_Parent(_Xa);
        *(_DWORD *)sub_406270(*v33) = 1;
        v34 = std::_tree::_Parent(_Xa);
        v35 = (int *)std::_tree::_Parent(*v34);
        *(_DWORD *)sub_406270(*v35) = 0;
        v36 = std::_tree::_Parent(_Xa);
        v37 = (int *)std::_tree::_Parent(*v36);
        sub_4068C0(this_, *v37);
      }
      else
      {
        v28 = (int *)std::_tree::_Parent(_Xa);
        *(_DWORD *)sub_406270(*v28) = 1;
        *(_DWORD *)sub_406270((int)_Yb) = 1;
        v29 = std::_tree::_Parent(_Xa);
        v30 = (int *)std::_tree::_Parent(*v29);
        *(_DWORD *)sub_406270(*v30) = 0;
        v31 = std::_tree::_Parent(_Xa);
        _Xa = *std::_tree::_Parent(*v31);
      }
    }
  }
  v38 = (int *)std::_tree::_Root_const(this_);
  *(_DWORD *)sub_406270(*v38) = 1;
  std::_tree::iterator::iterator((std::_tree::iterator *)a2, (int)a1);
  return a2;
}

//----- (004068A0) --------------------------------------------------------
std::_tree::_Node *__thiscall std::_tree::_Lmost(std::_tree *this)
{
  return std::_tree::_Left((int)this->_Head);
}

//----- (004068C0) --------------------------------------------------------
std::_tree::_Node **__thiscall sub_4068C0(void *this, int a2)
{
  std::_tree::_Node *v2; // esi@1
  std::_tree::_Node *v3; // eax@2
  std::_tree::_Node **v4; // esi@3
  int *v5; // eax@5
  int *v6; // eax@6
  int *v7; // eax@7
  std::_tree::_Node **result; // eax@8
  std::_tree *v9; // [sp+4h] [bp-8h]@1
  std::_tree::_Node *a1; // [sp+8h] [bp-4h]@1

  v9 = (std::_tree *)this;
  a1 = std::_tree::_Right(a2)->_Left;
  v2 = std::_tree::_Left((int)a1);
  std::_tree::_Right(a2)->_Left = v2->_Left;
  if ( std::_tree::_Left((int)a1)->_Left != std::_tree::_Nil )
  {
    v3 = std::_tree::_Left((int)a1);
    *std::_tree::_Parent(v3->_Left) = (std::_tree::_Node *)a2;
  }
  v4 = std::_tree::_Parent((std::_tree::_Node *)a2);
  *std::_tree::_Parent(a1) = *v4;
  if ( (std::_tree::_Node *)a2 == std::_tree::_Root_const(v9)->_Left )
  {
    std::_tree::_Root_const(v9)->_Left = a1;
  }
  else
  {
    v5 = (int *)std::_tree::_Parent((std::_tree::_Node *)a2);
    if ( (std::_tree::_Node *)a2 == std::_tree::_Left(*v5)->_Left )
    {
      v6 = (int *)std::_tree::_Parent((std::_tree::_Node *)a2);
      std::_tree::_Left(*v6)->_Left = a1;
    }
    else
    {
      v7 = (int *)std::_tree::_Parent((std::_tree::_Node *)a2);
      std::_tree::_Right(*v7)->_Left = a1;
    }
  }
  std::_tree::_Left((int)a1)->_Left = (std::_tree::_Node *)a2;
  result = std::_tree::_Parent((std::_tree::_Node *)a2);
  *result = a1;
  return result;
}

//----- (004069F0) --------------------------------------------------------
int __cdecl sub_4069F0(int a1)
{
  while ( std::_tree::_Right(a1)->_Left != std::_tree::_Nil )
    a1 = (int)std::_tree::_Right(a1)->_Left;
  return a1;
}

//----- (00406A30) --------------------------------------------------------
int __cdecl sub_406A30(int a1)
{
  while ( std::_tree::_Left(a1)->_Left != std::_tree::_Nil )
    a1 = (int)std::_tree::_Left(a1)->_Left;
  return a1;
}

//----- (00406A70) --------------------------------------------------------
std::_tree::_Node *__thiscall std::_tree::_Rmost(int this)
{
  return std::_tree::_Right(*(_DWORD *)(this + 4));
}

//----- (00406A90) --------------------------------------------------------
std::_tree::_Node *__thiscall std::_tree::_Root_const(std::_tree *this)
{
  return (std::_tree::_Node *)std::_tree::_Parent(this->_Head);
}

//----- (00406AB0) --------------------------------------------------------
std::_tree::_Node **__thiscall sub_406AB0(void *this, int a2)
{
  std::_tree::_Node *v2; // esi@1
  std::_tree::_Node *v3; // eax@2
  std::_tree::_Node **v4; // esi@3
  int *v5; // eax@5
  int *v6; // eax@6
  int *v7; // eax@7
  std::_tree::_Node **result; // eax@8
  std::_tree *v9; // [sp+4h] [bp-8h]@1
  std::_tree::_Node *v10; // [sp+8h] [bp-4h]@1

  v9 = (std::_tree *)this;
  v10 = std::_tree::_Left(a2)->_Left;
  v2 = std::_tree::_Right((int)v10);
  std::_tree::_Left(a2)->_Left = v2->_Left;
  if ( std::_tree::_Right((int)v10)->_Left != std::_tree::_Nil )
  {
    v3 = std::_tree::_Right((int)v10);
    *std::_tree::_Parent(v3->_Left) = (std::_tree::_Node *)a2;
  }
  v4 = std::_tree::_Parent((std::_tree::_Node *)a2);
  *std::_tree::_Parent(v10) = *v4;
  if ( (std::_tree::_Node *)a2 == std::_tree::_Root_const(v9)->_Left )
  {
    std::_tree::_Root_const(v9)->_Left = v10;
  }
  else
  {
    v5 = (int *)std::_tree::_Parent((std::_tree::_Node *)a2);
    if ( (std::_tree::_Node *)a2 == std::_tree::_Right(*v5)->_Left )
    {
      v6 = (int *)std::_tree::_Parent((std::_tree::_Node *)a2);
      std::_tree::_Right(*v6)->_Left = v10;
    }
    else
    {
      v7 = (int *)std::_tree::_Parent((std::_tree::_Node *)a2);
      std::_tree::_Left(*v7)->_Left = v10;
    }
  }
  std::_tree::_Right((int)v10)->_Left = (std::_tree::_Node *)a2;
  result = std::_tree::_Parent((std::_tree::_Node *)a2);
  *result = v10;
  return result;
}

//----- (00406BE0) --------------------------------------------------------
void __stdcall sub_406BE0(int a1)
{
  sub_407170();
}

//----- (00406C00) --------------------------------------------------------
std::_tree::_Node *__thiscall std::_tree::iterator::_Inc(std::_tree::iterator *this)
{
  int *v1; // eax@2
  std::_tree::_Node *result; // eax@2
  int *v3; // eax@3
  std::_tree::iterator *v4; // [sp+0h] [bp-8h]@1
  std::_tree::_Node *a1; // [sp+4h] [bp-4h]@3

  v4 = this;
  if ( std::_tree::_Right((int)this->_Ptr)->_Left == std::_tree::_Nil )
  {
    while ( 1 )
    {
      v3 = (int *)std::_tree::_Parent(v4->_Ptr);
      a1 = (std::_tree::_Node *)*v3;
      if ( v4->_Ptr != std::_tree::_Right(*v3)->_Left )
        break;
      v4->_Ptr = a1;
    }
    result = std::_tree::_Right((int)v4->_Ptr);
    if ( result->_Left != a1 )
    {
      result = a1;
      v4->_Ptr = a1;
    }
  }
  else
  {
    v1 = (int *)std::_tree::_Right((int)v4->_Ptr);
    result = (std::_tree::_Node *)sub_406A30(*v1);
    v4->_Ptr = result;
  }
  return result;
}

//----- (00406CF0) --------------------------------------------------------
int __thiscall sub_406CF0(void *this, int a2, _DWORD *a3)
{
  std::_tree::_Node *v3; // eax@1

  v3 = sub_407080(this, a3);
  std::_tree::iterator::iterator((std::_tree::iterator *)a2, (int)v3);
  return a2;
}

//----- (00406D20) --------------------------------------------------------
std::_tree::_Node *__thiscall std::_tree::_Init(std::_tree *this)
{
  std::_tree::_Node *result; // eax@5
  std::_tree *v2; // [sp+0h] [bp-18h]@1
  char v3; // [sp+4h] [bp-14h]@1
  void *v4; // [sp+8h] [bp-10h]@1
  int v5; // [sp+14h] [bp-4h]@1

  v2 = this;
  v4 = std::_tree::_Buynode(0, 1);
  std::_Lockit::_Lockit((std::_Lockit *)&v3);
  v5 = 0;
  if ( !std::_tree::_Nil )
  {
    std::_tree::_Nil = (std::_tree::_Node *)v4;
    v4 = 0;
    std::_tree::_Left((int)std::_tree::_Nil)->_Left = 0;
    std::_tree::_Right((int)std::_tree::_Nil)->_Left = 0;
  }
  ++std::_tree::_Nilrefs;
  v5 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v3);
  if ( v4 )
    std::_tree::_Freenode(v4);
  v2->_Head = std::_tree::_Buynode((int)std::_tree::_Nil, 0);
  v2->_Size = 0;
  std::_tree::_Lmost(v2)->_Left = v2->_Head;
  result = std::_tree::_Rmost((int)v2);
  result->_Left = v2->_Head;
  return result;
}
// 472464: using guessed type int std::_tree::_Nilrefs;

//----- (00406E20) --------------------------------------------------------
std::_tree::_Node *__thiscall std::_tree::_Lbound(std::_tree *this, _DWORD *a2)
{
  std::_tree *v2; // ST08_4@1
  _DWORD *v3; // eax@3
  std::_tree::_Node *v5; // [sp+4h] [bp-8h]@1
  std::_tree::_Node *a1; // [sp+8h] [bp-4h]@1

  v2 = this;
  a1 = *std::_tree::_Root(this);
  v5 = v2->_Head;
  while ( a1 != std::_tree::_Nil )
  {
    v3 = std::_tree::_Key(a1);
    if ( (unsigned __int8)std::_tree::key_compare(v3, a2) )
    {
      a1 = std::_tree::_Right((int)a1)->_Left;
    }
    else
    {
      v5 = a1;
      a1 = std::_tree::_Left((int)a1)->_Left;
    }
  }
  return v5;
}

//----- (00406EB0) --------------------------------------------------------
std::_tree::_Node *__stdcall std::_tree::_Buynode(int a1, int a2)
{
  std::_tree::_Node *result; // eax@1

  result = (std::_tree::_Node *)std::_Allocate_2(0x64u);
  *std::_tree::_Parent(result) = (std::_tree::_Node *)a1;
  *(_DWORD *)sub_406270((int)result) = a2;
  return result;
}

//----- (00406F00) --------------------------------------------------------
void *__stdcall std::_tree::_Consval(void *a1, int a2)
{
  return sub_407180(a1, a2);
}

//----- (00406F40) --------------------------------------------------------
std::_tree::_Node *__thiscall sub_406F40(int *this)
{
  std::_tree::_Node **v1; // eax@2
  std::_tree::_Node *result; // eax@3
  int *v3; // eax@5
  int *v4; // eax@6
  int *v5; // [sp+0h] [bp-8h]@1
  std::_tree::_Node *a1; // [sp+4h] [bp-4h]@6

  v5 = this;
  if ( *(_DWORD *)sub_406270(*this)
    || (v1 = std::_tree::_Parent((std::_tree::_Node *)*v5), *std::_tree::_Parent(*v1) != (std::_tree::_Node *)*v5) )
  {
    if ( std::_tree::_Left(*v5)->_Left == std::_tree::_Nil )
    {
      while ( 1 )
      {
        v4 = (int *)std::_tree::_Parent((std::_tree::_Node *)*v5);
        a1 = (std::_tree::_Node *)*v4;
        if ( (std::_tree::_Node *)*v5 != std::_tree::_Left(*v4)->_Left )
          break;
        *v5 = (int)a1;
      }
      result = a1;
      *v5 = (int)a1;
    }
    else
    {
      v3 = (int *)std::_tree::_Left(*v5);
      result = (std::_tree::_Node *)sub_4069F0(*v3);
      *v5 = (int)result;
    }
  }
  else
  {
    result = std::_tree::_Right(*v5);
    *v5 = (int)result->_Left;
  }
  return result;
}

//----- (00407010) --------------------------------------------------------
int __thiscall sub_407010(int this, _DWORD *a2, _DWORD *a3)
{
  *(_DWORD *)this = *a2;
  *(_DWORD *)(this + 4) = *a3;
  return this;
}

//----- (00407040) --------------------------------------------------------
char *__stdcall std::_Allocate_2(size_t a1)
{
  return std::_Allocate(a1);
}

//----- (00407060) --------------------------------------------------------
std::_tree::_Node **__thiscall std::_tree::_Root(std::_tree *this)
{
  return std::_tree::_Parent(this->_Head);
}

//----- (00407080) --------------------------------------------------------
std::_tree::_Node *__thiscall sub_407080(void *this, _DWORD *a2)
{
  _DWORD *v2; // ST08_4@1
  _DWORD *v3; // eax@3
  std::_tree::_Node *v5; // [sp+4h] [bp-8h]@1
  std::_tree::_Node *a1; // [sp+8h] [bp-4h]@1

  v2 = this;
  a1 = *std::_tree::_Root((std::_tree *)this);
  v5 = (std::_tree::_Node *)v2[1];
  while ( a1 != std::_tree::_Nil )
  {
    v3 = std::_tree::_Key(a1);
    if ( (unsigned __int8)std::_tree::key_compare(a2, v3) )
    {
      v5 = a1;
      a1 = std::_tree::_Left((int)a1)->_Left;
    }
    else
    {
      a1 = std::_tree::_Right((int)a1)->_Left;
    }
  }
  return v5;
}

//----- (00407110) --------------------------------------------------------
int __cdecl sub_407110(int *a1, int *a2)
{
  int v2; // ST00_4@1
  int result; // eax@1

  v2 = *a1;
  *a1 = *a2;
  result = v2;
  *a2 = v2;
  return result;
}

//----- (00407140) --------------------------------------------------------
int __cdecl sub_407140(char a1, char a2, _DWORD *a3)
{
  int v3; // ecx@0
  char v4; // dl@1
  int v6; // [sp+0h] [bp-4h]@1

  v6 = v3;
  v4 = *sub_407200(&v6);
  return sub_407220(a1, a2, a3);
}

//----- (00407170) --------------------------------------------------------
void sub_407170()
{
  ;
}

//----- (00407180) --------------------------------------------------------
void *__cdecl sub_407180(void *a1, int a2)
{
  void *result; // eax@1

  result = operator new(0x54u, a1);
  if ( result )
    qmemcpy(result, (const void *)a2, 0x54u);
  return result;
}

//----- (00407200) --------------------------------------------------------
_BYTE *__cdecl sub_407200(_BYTE *a1)
{
  char v2; // [sp+4h] [bp-4h]@1

  *a1 = v2;
  return a1;
}

//----- (00407220) --------------------------------------------------------
int __cdecl sub_407220(char a1, char a2, _DWORD *a3)
{
  int result; // eax@1

  while ( 1 )
  {
    result = (unsigned __int8)std::_tree::iterator::not_equal((std::_tree::iterator *)&a1, (std::_tree::iterator *)&a2);
    if ( !result )
      break;
    ++*a3;
    std::_tree::iterator::pre_increment((std::_tree::iterator *)&a1);
  }
  return result;
}

//----- (00407260) --------------------------------------------------------
unsigned __int8 *__cdecl Blowfish::encipher(unsigned __int8 *left, unsigned __int8 *right)
{
  unsigned int v2; // ST04_4@1
  unsigned int v3; // ST00_4@1
  unsigned int v4; // ST04_4@1
  unsigned int v5; // ST00_4@1
  unsigned int v6; // ST04_4@1
  unsigned int v7; // ST00_4@1
  unsigned int v8; // ST04_4@1
  unsigned int v9; // ST00_4@1
  unsigned int v10; // ST04_4@1
  unsigned int v11; // ST00_4@1
  unsigned int v12; // ST04_4@1
  unsigned int v13; // ST00_4@1
  unsigned int v14; // ST04_4@1
  unsigned int v15; // ST00_4@1
  unsigned int v16; // ST04_4@1
  unsigned int v17; // ST00_4@1
  unsigned int v18; // ST04_4@1
  unsigned int v19; // ST00_4@1
  unsigned __int8 *result; // eax@1

  v2 = BF::pary[0] ^ *(_DWORD *)left;
  v3 = BF::pary[1] ^ (BF::sbox[3][(unsigned __int8)v2]
                    + (BF::sbox[2][(unsigned __int16)v2 >> 8] ^ (BF::sbox[1][(v2 >> 16) & 0xFF] + BF::sbox[0][v2 >> 24]))) ^ *(_DWORD *)right;
  v4 = BF::pary[2] ^ (BF::sbox[3][(unsigned __int8)v3]
                    + (BF::sbox[2][(unsigned __int16)v3 >> 8] ^ (BF::sbox[1][(v3 >> 16) & 0xFF] + BF::sbox[0][v3 >> 24]))) ^ v2;
  v5 = BF::pary[3] ^ (BF::sbox[3][(unsigned __int8)v4]
                    + (BF::sbox[2][(unsigned __int16)v4 >> 8] ^ (BF::sbox[1][(v4 >> 16) & 0xFF] + BF::sbox[0][v4 >> 24]))) ^ v3;
  v6 = BF::pary[4] ^ (BF::sbox[3][(unsigned __int8)v5]
                    + (BF::sbox[2][(unsigned __int16)v5 >> 8] ^ (BF::sbox[1][(v5 >> 16) & 0xFF] + BF::sbox[0][v5 >> 24]))) ^ v4;
  v7 = BF::pary[5] ^ (BF::sbox[3][(unsigned __int8)v6]
                    + (BF::sbox[2][(unsigned __int16)v6 >> 8] ^ (BF::sbox[1][(v6 >> 16) & 0xFF] + BF::sbox[0][v6 >> 24]))) ^ v5;
  v8 = BF::pary[6] ^ (BF::sbox[3][(unsigned __int8)v7]
                    + (BF::sbox[2][(unsigned __int16)v7 >> 8] ^ (BF::sbox[1][(v7 >> 16) & 0xFF] + BF::sbox[0][v7 >> 24]))) ^ v6;
  v9 = BF::pary[7] ^ (BF::sbox[3][(unsigned __int8)v8]
                    + (BF::sbox[2][(unsigned __int16)v8 >> 8] ^ (BF::sbox[1][(v8 >> 16) & 0xFF] + BF::sbox[0][v8 >> 24]))) ^ v7;
  v10 = BF::pary[8] ^ (BF::sbox[3][(unsigned __int8)v9]
                     + (BF::sbox[2][(unsigned __int16)v9 >> 8] ^ (BF::sbox[1][(v9 >> 16) & 0xFF] + BF::sbox[0][v9 >> 24]))) ^ v8;
  v11 = BF::pary[9] ^ (BF::sbox[3][(unsigned __int8)v10]
                     + (BF::sbox[2][(unsigned __int16)v10 >> 8] ^ (BF::sbox[1][(v10 >> 16) & 0xFF]
                                                                 + BF::sbox[0][v10 >> 24]))) ^ v9;
  v12 = BF::pary[10] ^ (BF::sbox[3][(unsigned __int8)v11]
                      + (BF::sbox[2][(unsigned __int16)v11 >> 8] ^ (BF::sbox[1][(v11 >> 16) & 0xFF]
                                                                  + BF::sbox[0][v11 >> 24]))) ^ v10;
  v13 = BF::pary[11] ^ (BF::sbox[3][(unsigned __int8)v12]
                      + (BF::sbox[2][(unsigned __int16)v12 >> 8] ^ (BF::sbox[1][(v12 >> 16) & 0xFF]
                                                                  + BF::sbox[0][v12 >> 24]))) ^ v11;
  v14 = BF::pary[12] ^ (BF::sbox[3][(unsigned __int8)v13]
                      + (BF::sbox[2][(unsigned __int16)v13 >> 8] ^ (BF::sbox[1][(v13 >> 16) & 0xFF]
                                                                  + BF::sbox[0][v13 >> 24]))) ^ v12;
  v15 = BF::pary[13] ^ (BF::sbox[3][(unsigned __int8)v14]
                      + (BF::sbox[2][(unsigned __int16)v14 >> 8] ^ (BF::sbox[1][(v14 >> 16) & 0xFF]
                                                                  + BF::sbox[0][v14 >> 24]))) ^ v13;
  v16 = BF::pary[14] ^ (BF::sbox[3][(unsigned __int8)v15]
                      + (BF::sbox[2][(unsigned __int16)v15 >> 8] ^ (BF::sbox[1][(v15 >> 16) & 0xFF]
                                                                  + BF::sbox[0][v15 >> 24]))) ^ v14;
  v17 = BF::pary[15] ^ (BF::sbox[3][(unsigned __int8)v16]
                      + (BF::sbox[2][(unsigned __int16)v16 >> 8] ^ (BF::sbox[1][(v16 >> 16) & 0xFF]
                                                                  + BF::sbox[0][v16 >> 24]))) ^ v15;
  v18 = BF::pary[16] ^ (BF::sbox[3][(unsigned __int8)v17]
                      + (BF::sbox[2][(unsigned __int16)v17 >> 8] ^ (BF::sbox[1][(v17 >> 16) & 0xFF]
                                                                  + BF::sbox[0][v17 >> 24]))) ^ v16;
  v19 = BF::pary[17] ^ v17;
  *(_DWORD *)right = v18;
  result = left;
  *(_DWORD *)left = v19;
  return result;
}

//----- (004077FC) --------------------------------------------------------
unsigned int *__cdecl Blowfish::decipher(unsigned __int8 *left, unsigned __int8 *right)
{
  unsigned int v18; // ST04_4@1 MAPDST
  unsigned int *result; // eax@1

  v18 = BF::pary[17] ^ *(_DWORD *)left;
  v18 = BF::pary[16] ^ (BF::sbox[3][(unsigned __int8)v18]
                      + (BF::sbox[2][(unsigned __int16)v18 >> 8] ^ (BF::sbox[1][(v18 >> 16) & 0xFF]
                                                                  + BF::sbox[0][v18 >> 24]))) ^ *(_DWORD *)right;
  v18 ^= BF::pary[15] ^ (BF::sbox[3][(unsigned __int8)v18]
                       + (BF::sbox[2][(unsigned __int16)v18 >> 8] ^ (BF::sbox[1][(v18 >> 16) & 0xFF]
                                                                   + BF::sbox[0][v18 >> 24])));
  v18 ^= BF::pary[14] ^ (BF::sbox[3][(unsigned __int8)v18]
                       + (BF::sbox[2][(unsigned __int16)v18 >> 8] ^ (BF::sbox[1][(v18 >> 16) & 0xFF]
                                                                   + BF::sbox[0][v18 >> 24])));
  v18 ^= BF::pary[13] ^ (BF::sbox[3][(unsigned __int8)v18]
                       + (BF::sbox[2][(unsigned __int16)v18 >> 8] ^ (BF::sbox[1][(v18 >> 16) & 0xFF]
                                                                   + BF::sbox[0][v18 >> 24])));
  v18 ^= BF::pary[12] ^ (BF::sbox[3][(unsigned __int8)v18]
                       + (BF::sbox[2][(unsigned __int16)v18 >> 8] ^ (BF::sbox[1][(v18 >> 16) & 0xFF]
                                                                   + BF::sbox[0][v18 >> 24])));
  v18 ^= BF::pary[11] ^ (BF::sbox[3][(unsigned __int8)v18]
                       + (BF::sbox[2][(unsigned __int16)v18 >> 8] ^ (BF::sbox[1][(v18 >> 16) & 0xFF]
                                                                   + BF::sbox[0][v18 >> 24])));
  v18 ^= BF::pary[10] ^ (BF::sbox[3][(unsigned __int8)v18]
                       + (BF::sbox[2][(unsigned __int16)v18 >> 8] ^ (BF::sbox[1][(v18 >> 16) & 0xFF]
                                                                   + BF::sbox[0][v18 >> 24])));
  v18 ^= BF::pary[9] ^ (BF::sbox[3][(unsigned __int8)v18]
                      + (BF::sbox[2][(unsigned __int16)v18 >> 8] ^ (BF::sbox[1][(v18 >> 16) & 0xFF]
                                                                  + BF::sbox[0][v18 >> 24])));
  v18 ^= BF::pary[8] ^ (BF::sbox[3][(unsigned __int8)v18]
                      + (BF::sbox[2][(unsigned __int16)v18 >> 8] ^ (BF::sbox[1][(v18 >> 16) & 0xFF]
                                                                  + BF::sbox[0][v18 >> 24])));
  v18 ^= BF::pary[7] ^ (BF::sbox[3][(unsigned __int8)v18]
                      + (BF::sbox[2][(unsigned __int16)v18 >> 8] ^ (BF::sbox[1][(v18 >> 16) & 0xFF]
                                                                  + BF::sbox[0][v18 >> 24])));
  v18 ^= BF::pary[6] ^ (BF::sbox[3][(unsigned __int8)v18]
                      + (BF::sbox[2][(unsigned __int16)v18 >> 8] ^ (BF::sbox[1][(v18 >> 16) & 0xFF]
                                                                  + BF::sbox[0][v18 >> 24])));
  v18 ^= BF::pary[5] ^ (BF::sbox[3][(unsigned __int8)v18]
                      + (BF::sbox[2][(unsigned __int16)v18 >> 8] ^ (BF::sbox[1][(v18 >> 16) & 0xFF]
                                                                  + BF::sbox[0][v18 >> 24])));
  v18 ^= BF::pary[4] ^ (BF::sbox[3][(unsigned __int8)v18]
                      + (BF::sbox[2][(unsigned __int16)v18 >> 8] ^ (BF::sbox[1][(v18 >> 16) & 0xFF]
                                                                  + BF::sbox[0][v18 >> 24])));
  v18 ^= BF::pary[3] ^ (BF::sbox[3][(unsigned __int8)v18]
                      + (BF::sbox[2][(unsigned __int16)v18 >> 8] ^ (BF::sbox[1][(v18 >> 16) & 0xFF]
                                                                  + BF::sbox[0][v18 >> 24])));
  v18 ^= BF::pary[2] ^ (BF::sbox[3][(unsigned __int8)v18]
                      + (BF::sbox[2][(unsigned __int16)v18 >> 8] ^ (BF::sbox[1][(v18 >> 16) & 0xFF]
                                                                  + BF::sbox[0][v18 >> 24])));
  v18 ^= BF::pary[1] ^ (BF::sbox[3][(unsigned __int8)v18]
                      + (BF::sbox[2][(unsigned __int16)v18 >> 8] ^ (BF::sbox[1][(v18 >> 16) & 0xFF]
                                                                  + BF::sbox[0][v18 >> 24])));
  *(_DWORD *)left = BF::pary[0] ^ v18;
  result = (unsigned int *)right;
  *(_DWORD *)right = v18;
  return result;
}

//----- (00407D98) --------------------------------------------------------
unsigned int *__cdecl Blowfish::Decrypt(unsigned __int8 *src, signed int size)
{
  unsigned int *result; // eax@1
  signed int i; // [sp+0h] [bp-8h]@1

  result = (unsigned int *)(size >> 3);
  for ( i = 0; i < size >> 3; ++i )
  {
    result = Blowfish::decipher(src, src + 4);
    src += 8;
  }
  return result;
}

//----- (00407DE3) --------------------------------------------------------
unsigned __int8 *__cdecl Blowfish::Encrypt(unsigned __int8 *src, signed int size)
{
  unsigned __int8 *result; // eax@1
  signed int i; // [sp+0h] [bp-8h]@1

  result = (unsigned __int8 *)(size >> 3);
  for ( i = 0; i < size >> 3; ++i )
  {
    result = Blowfish::encipher(src, src + 4);
    src += 8;
  }
  return result;
}

//----- (00407E2E) --------------------------------------------------------
__int16 __cdecl Blowfish::Initialize(const unsigned __int8 *key, int size)
{
  int v11_; // edx@3
  int _v11; // edx@3
  __int16 x; // [sp+0h] [bp-18h]@1
  __int16 idx2; // [sp+0h] [bp-18h]@9
  __int16 i; // [sp+4h] [bp-14h]@1
  __int16 j; // [sp+4h] [bp-14h]@4
  __int16 idx; // [sp+4h] [bp-14h]@7
  unsigned int right; // [sp+8h] [bp-10h]@4
  int v11; // [sp+Ch] [bp-Ch]@3
  int unused; // [sp+10h] [bp-8h]@3
  unsigned int left; // [sp+14h] [bp-4h]@4 Copy over the constant init array vals (so the originals aren't destroyed).

  memcpy(BF::pary, BF::initial_pary, 0x48u);    // 18*4
  memcpy(BF::sbox, BF::initial_sbox, 0x1000u);  // 4*4*256
  x = 0;                                        // Combine the key with the P box. Assume key is standard 448 bits (56 bytes) or less.
  for ( i = 0; i < 18; ++i )
  {
    v11 = 0;
    v11 = (key[(x + 1) % (signed __int16)size] << 16) | (key[x] << 24) & 0xFF00FFFF;
    v11_ = v11;
    BYTE1(v11_) = 0;
    v11 = (key[(x + 2) % (signed __int16)size] << 8) | v11_;
    _v11 = v11;
    LOBYTE(_v11) = 0;
    v11 = key[(x + 3) % (signed __int16)size] | _v11;
    unused = v11;
    BF::pary[i] ^= v11;
    x = (x + 4) % (signed __int16)size;
  }
  left = 0;
  right = 0;
  for ( j = 0; j < 18; j += 2 )                 // Re-calculate the P box.
  {
    Blowfish::encipher((unsigned __int8 *)&left, (unsigned __int8 *)&right);
    BF::pary[j] = left;
    BF::pary[j + 1] = right;
  }
  for ( idx = 0; idx < 4; ++idx )               // Recalculate the S-boxes.
  {
    for ( idx2 = 0; idx2 < 256; idx2 += 2 )
    {
      Blowfish::encipher((unsigned __int8 *)&left, (unsigned __int8 *)&right);
      BF::sbox[idx][idx2] = left;
      BF::sbox[idx][idx2 + 1] = right;
    }
  }
  return 0;
}

//----- (0040803F) --------------------------------------------------------
__int16 __cdecl BlowFishLocal::Initialize(void *a1, int a2, __int16 a3)
{
  int v3; // edx@3
  int v4; // edx@3
  __int16 v6; // [sp+0h] [bp-18h]@1
  __int16 l; // [sp+0h] [bp-18h]@9
  __int16 i; // [sp+4h] [bp-14h]@1
  __int16 j; // [sp+4h] [bp-14h]@4
  __int16 k; // [sp+4h] [bp-14h]@7
  int v11; // [sp+8h] [bp-10h]@4
  int v12; // [sp+Ch] [bp-Ch]@3
  int v13; // [sp+10h] [bp-8h]@3
  int v14; // [sp+14h] [bp-4h]@4

  memcpy((char *)a1 + 0x1000, BF::initial_pary, 0x48u);
  memcpy(a1, BF::initial_sbox, 0x1000u);
  v6 = 0;
  for ( i = 0; i < 18; ++i )
  {
    v12 = 0;
    v12 = (*(_BYTE *)(a2 + (v6 + 1) % a3) << 16) | (*(_BYTE *)(a2 + v6) << 24) & 0xFF00FFFF;
    v3 = v12;
    BYTE1(v3) = 0;
    v12 = (*(_BYTE *)(a2 + (v6 + 2) % a3) << 8) | v3;
    v4 = v12;
    LOBYTE(v4) = 0;
    v12 = *(_BYTE *)(a2 + (v6 + 3) % a3) | v4;
    v13 = v12;
    *((_DWORD *)a1 + i + 1024) ^= v12;
    v6 = (v6 + 4) % a3;
  }
  v14 = 0;
  v11 = 0;
  for ( j = 0; j < 18; j += 2 )
  {
    BlowFishLocal::encipher((int)a1, &v14, &v11);
    *((_DWORD *)a1 + j + 0x400) = v14;
    *((_DWORD *)a1 + j + 0x401) = v11;
  }
  for ( k = 0; k < 4; ++k )
  {
    for ( l = 0; l < 256; l += 2 )
    {
      BlowFishLocal::encipher((int)a1, &v14, &v11);
      *((_DWORD *)a1 + 256 * k + l) = v14;
      *((_DWORD *)a1 + 256 * k + l + 1) = v11;
    }
  }
  return 0;
}

//----- (00408269) --------------------------------------------------------
int __cdecl BlowFishLocal::encipher(int a1, int *a2, int *a3)
{
  unsigned int v3; // ST04_4@1
  unsigned int v4; // ST00_4@1
  unsigned int v5; // ST04_4@1
  unsigned int v6; // ST00_4@1
  unsigned int v7; // ST04_4@1
  unsigned int v8; // ST00_4@1
  unsigned int v9; // ST04_4@1
  unsigned int v10; // ST00_4@1
  unsigned int v11; // ST04_4@1
  unsigned int v12; // ST00_4@1
  unsigned int v13; // ST04_4@1
  unsigned int v14; // ST00_4@1
  unsigned int v15; // ST04_4@1
  unsigned int v16; // ST00_4@1
  unsigned int v17; // ST04_4@1
  unsigned int v18; // ST00_4@1
  int v19; // ST04_4@1
  int v20; // ST00_4@1
  int result; // eax@1

  v3 = *(_DWORD *)(a1 + 4096) ^ *a2;
  v4 = *(_DWORD *)(a1 + 4100) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v3 + 3072)
                               + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v3 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v3 >> 16) & 0xFF) + 1024)
                                                                                            + *(_DWORD *)(a1 + 4 * (v3 >> 24))))) ^ *a3;
  v5 = *(_DWORD *)(a1 + 4104) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v4 + 3072)
                               + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v4 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v4 >> 16) & 0xFF) + 1024)
                                                                                            + *(_DWORD *)(a1 + 4 * (v4 >> 24))))) ^ v3;
  v6 = *(_DWORD *)(a1 + 4108) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v5 + 3072)
                               + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v5 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v5 >> 16) & 0xFF) + 1024)
                                                                                            + *(_DWORD *)(a1 + 4 * (v5 >> 24))))) ^ v4;
  v7 = *(_DWORD *)(a1 + 4112) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v6 + 3072)
                               + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v6 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v6 >> 16) & 0xFF) + 1024)
                                                                                            + *(_DWORD *)(a1 + 4 * (v6 >> 24))))) ^ v5;
  v8 = *(_DWORD *)(a1 + 4116) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v7 + 3072)
                               + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v7 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v7 >> 16) & 0xFF) + 1024)
                                                                                            + *(_DWORD *)(a1 + 4 * (v7 >> 24))))) ^ v6;
  v9 = *(_DWORD *)(a1 + 4120) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v8 + 3072)
                               + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v8 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v8 >> 16) & 0xFF) + 1024)
                                                                                            + *(_DWORD *)(a1 + 4 * (v8 >> 24))))) ^ v7;
  v10 = *(_DWORD *)(a1 + 4124) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v9 + 3072)
                                + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v9 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v9 >> 16) & 0xFF) + 1024)
                                                                                             + *(_DWORD *)(a1 + 4 * (v9 >> 24))))) ^ v8;
  v11 = *(_DWORD *)(a1 + 4128) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v10 + 3072)
                                + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v10 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v10 >> 16) & 0xFF) + 1024)
                                                                                              + *(_DWORD *)(a1 + 4 * (v10 >> 24))))) ^ v9;
  v12 = *(_DWORD *)(a1 + 4132) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v11 + 3072)
                                + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v11 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v11 >> 16) & 0xFF) + 1024)
                                                                                              + *(_DWORD *)(a1 + 4 * (v11 >> 24))))) ^ v10;
  v13 = *(_DWORD *)(a1 + 4136) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v12 + 3072)
                                + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v12 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v12 >> 16) & 0xFF) + 1024)
                                                                                              + *(_DWORD *)(a1 + 4 * (v12 >> 24))))) ^ v11;
  v14 = *(_DWORD *)(a1 + 4140) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v13 + 3072)
                                + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v13 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v13 >> 16) & 0xFF) + 1024)
                                                                                              + *(_DWORD *)(a1 + 4 * (v13 >> 24))))) ^ v12;
  v15 = *(_DWORD *)(a1 + 4144) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v14 + 3072)
                                + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v14 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v14 >> 16) & 0xFF) + 1024)
                                                                                              + *(_DWORD *)(a1 + 4 * (v14 >> 24))))) ^ v13;
  v16 = *(_DWORD *)(a1 + 4148) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v15 + 3072)
                                + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v15 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v15 >> 16) & 0xFF) + 1024)
                                                                                              + *(_DWORD *)(a1 + 4 * (v15 >> 24))))) ^ v14;
  v17 = *(_DWORD *)(a1 + 4152) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v16 + 3072)
                                + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v16 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v16 >> 16) & 0xFF) + 1024)
                                                                                              + *(_DWORD *)(a1 + 4 * (v16 >> 24))))) ^ v15;
  v18 = *(_DWORD *)(a1 + 4156) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v17 + 3072)
                                + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v17 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v17 >> 16) & 0xFF) + 1024)
                                                                                              + *(_DWORD *)(a1 + 4 * (v17 >> 24))))) ^ v16;
  v19 = *(_DWORD *)(a1 + 4160) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v18 + 3072)
                                + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v18 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v18 >> 16) & 0xFF) + 1024)
                                                                                              + *(_DWORD *)(a1 + 4 * (v18 >> 24))))) ^ v17;
  v20 = *(_DWORD *)(a1 + 4164) ^ v18;
  result = v19;
  *a3 = v19;
  *a2 = v20;
  return result;
}

//----- (004088C1) --------------------------------------------------------
int __cdecl BlowFishLocal::decipher(int a1, int *a2, int *a3)
{
  unsigned int v3; // ST04_4@1
  unsigned int v4; // ST00_4@1
  unsigned int v5; // ST04_4@1
  unsigned int v6; // ST00_4@1
  unsigned int v7; // ST04_4@1
  unsigned int v8; // ST00_4@1
  unsigned int v9; // ST04_4@1
  unsigned int v10; // ST00_4@1
  unsigned int v11; // ST04_4@1
  unsigned int v12; // ST00_4@1
  unsigned int v13; // ST04_4@1
  unsigned int v14; // ST00_4@1
  unsigned int v15; // ST04_4@1
  unsigned int v16; // ST00_4@1
  unsigned int v17; // ST04_4@1
  unsigned int v18; // ST00_4@1
  int v19; // ST04_4@1
  int result; // eax@1

  v3 = *(_DWORD *)(a1 + 4164) ^ *a2;
  v4 = *(_DWORD *)(a1 + 4160) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v3 + 3072)
                               + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v3 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v3 >> 16) & 0xFF) + 1024)
                                                                                            + *(_DWORD *)(a1 + 4 * (v3 >> 24))))) ^ *a3;
  v5 = *(_DWORD *)(a1 + 4156) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v4 + 3072)
                               + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v4 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v4 >> 16) & 0xFF) + 1024)
                                                                                            + *(_DWORD *)(a1 + 4 * (v4 >> 24))))) ^ v3;
  v6 = *(_DWORD *)(a1 + 4152) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v5 + 3072)
                               + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v5 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v5 >> 16) & 0xFF) + 1024)
                                                                                            + *(_DWORD *)(a1 + 4 * (v5 >> 24))))) ^ v4;
  v7 = *(_DWORD *)(a1 + 4148) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v6 + 3072)
                               + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v6 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v6 >> 16) & 0xFF) + 1024)
                                                                                            + *(_DWORD *)(a1 + 4 * (v6 >> 24))))) ^ v5;
  v8 = *(_DWORD *)(a1 + 4144) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v7 + 3072)
                               + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v7 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v7 >> 16) & 0xFF) + 1024)
                                                                                            + *(_DWORD *)(a1 + 4 * (v7 >> 24))))) ^ v6;
  v9 = *(_DWORD *)(a1 + 4140) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v8 + 3072)
                               + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v8 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v8 >> 16) & 0xFF) + 1024)
                                                                                            + *(_DWORD *)(a1 + 4 * (v8 >> 24))))) ^ v7;
  v10 = *(_DWORD *)(a1 + 4136) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v9 + 3072)
                                + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v9 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v9 >> 16) & 0xFF) + 1024)
                                                                                             + *(_DWORD *)(a1 + 4 * (v9 >> 24))))) ^ v8;
  v11 = *(_DWORD *)(a1 + 4132) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v10 + 3072)
                                + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v10 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v10 >> 16) & 0xFF) + 1024)
                                                                                              + *(_DWORD *)(a1 + 4 * (v10 >> 24))))) ^ v9;
  v12 = *(_DWORD *)(a1 + 4128) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v11 + 3072)
                                + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v11 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v11 >> 16) & 0xFF) + 1024)
                                                                                              + *(_DWORD *)(a1 + 4 * (v11 >> 24))))) ^ v10;
  v13 = *(_DWORD *)(a1 + 4124) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v12 + 3072)
                                + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v12 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v12 >> 16) & 0xFF) + 1024)
                                                                                              + *(_DWORD *)(a1 + 4 * (v12 >> 24))))) ^ v11;
  v14 = *(_DWORD *)(a1 + 4120) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v13 + 3072)
                                + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v13 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v13 >> 16) & 0xFF) + 1024)
                                                                                              + *(_DWORD *)(a1 + 4 * (v13 >> 24))))) ^ v12;
  v15 = *(_DWORD *)(a1 + 4116) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v14 + 3072)
                                + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v14 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v14 >> 16) & 0xFF) + 1024)
                                                                                              + *(_DWORD *)(a1 + 4 * (v14 >> 24))))) ^ v13;
  v16 = *(_DWORD *)(a1 + 4112) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v15 + 3072)
                                + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v15 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v15 >> 16) & 0xFF) + 1024)
                                                                                              + *(_DWORD *)(a1 + 4 * (v15 >> 24))))) ^ v14;
  v17 = *(_DWORD *)(a1 + 4108) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v16 + 3072)
                                + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v16 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v16 >> 16) & 0xFF) + 1024)
                                                                                              + *(_DWORD *)(a1 + 4 * (v16 >> 24))))) ^ v15;
  v18 = *(_DWORD *)(a1 + 4104) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v17 + 3072)
                                + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v17 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v17 >> 16) & 0xFF) + 1024)
                                                                                              + *(_DWORD *)(a1 + 4 * (v17 >> 24))))) ^ v16;
  v19 = *(_DWORD *)(a1 + 4100) ^ (*(_DWORD *)(a1 + 4 * (unsigned __int8)v18 + 3072)
                                + (*(_DWORD *)(a1 + 4 * ((unsigned __int16)v18 >> 8) + 2048) ^ (*(_DWORD *)(a1 + 4 * ((v18 >> 16) & 0xFF) + 1024)
                                                                                              + *(_DWORD *)(a1 + 4 * (v18 >> 24))))) ^ v17;
  result = *(_DWORD *)(a1 + 4096) ^ v18;
  *a2 = result;
  *a3 = v19;
  return result;
}

//----- (00408F19) --------------------------------------------------------
int __cdecl BlowFishLocal::Decrypt(int a1, int a2, signed int a3)
{
  int result; // eax@1
  signed int i; // [sp+0h] [bp-8h]@1

  result = a3 >> 3;
  for ( i = 0; i < a3 >> 3; ++i )
  {
    BlowFishLocal::decipher(a1, (int *)a2, (int *)(a2 + 4));
    result = a2 + 8;
    a2 += 8;
  }
  return result;
}

//----- (00408F68) --------------------------------------------------------
int __cdecl BlowFishLocal::Encrypt(int a1, int a2, signed int a3)
{
  int result; // eax@1
  signed int i; // [sp+0h] [bp-8h]@1

  result = a3 >> 3;
  for ( i = 0; i < a3 >> 3; ++i )
  {
    BlowFishLocal::encipher(a1, (int *)a2, (int *)(a2 + 4));
    result = a2 + 8;
    a2 += 8;
  }
  return result;
}

//----- (00408FC0) --------------------------------------------------------
int StaticInitFor_PwdCrypt()
{
  CallStaticCtorPwdCrypt();
  return RegisterStaticDtorPwdCrypt();
}

//----- (00408FCF) --------------------------------------------------------
PwdCrypt *CallStaticCtorPwdCrypt()
{
  return PwdCrypt::PwdCrypt(&g_PwdCrypt);
}

//----- (00408FDE) --------------------------------------------------------
int RegisterStaticDtorPwdCrypt()
{
  return atexit(CallStaticDtorPwdCrypt);
}

//----- (00408FF0) --------------------------------------------------------
void __cdecl CallStaticDtorPwdCrypt()
{
  PwdCrypt::Destructor();
}

//----- (00409018) --------------------------------------------------------
_BYTE *__stdcall PwdCrypt::Decrypt_2(_BYTE *in, PwdCrypt_small *a2, _BYTE *out)
{
  _BYTE *result; // eax@1
  char *v4; // [sp+4h] [bp-18h]@4
  signed int v5; // [sp+8h] [bp-14h]@4
  signed int v6; // [sp+Ch] [bp-10h]@1
  signed int i; // [sp+Ch] [bp-10h]@6
  _BYTE *v8; // [sp+10h] [bp-Ch]@1
  _BYTE *v9; // [sp+10h] [bp-Ch]@6
  char *v10; // [sp+14h] [bp-8h]@6
  char *v11; // [sp+18h] [bp-4h]@6

  v6 = 0;
  result = out;
  v8 = out;
  while ( v6 < 8 )
  {
    *v8 = 0;
    result = v8++ + 1;
    ++v6;
  }
  v4 = in;
  v5 = 0;
  while ( v5 < 16 )
  {
    v9 = out;
    v11 = (char *)&a2[v5] + 8 * ((*v4 >> 4) & 0xF);
    v10 = (char *)&a2[v5 + 1] + 8 * (*v4 & 0xF);
    for ( i = 0; i < 8; ++i )
      *v9++ |= *v10++ | *v11++;
    v5 += 2;
    result = v4++ + 1;
  }
  return result;
}

//----- (00409115) --------------------------------------------------------
_BYTE *__thiscall PwdCrypt::Decrypt_7(PwdCrypt *this, _BYTE *a2, char *a3)
{
  _BYTE *result; // eax@1
  char *v4; // ST10_4@3
  _BYTE *v5; // [sp+4h] [bp-10h]@1
  signed int v6; // [sp+8h] [bp-Ch]@1

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  a3[3] = 0;
  result = a2;
  v5 = a2;
  v6 = 0;
  while ( v6 < 4 )
  {
    v4 = (char *)&this->big[v6] + 4 * *v5;
    *a3 |= *v4++;
    a3[1] |= *v4++;
    a3[2] |= *v4;
    a3[3] |= v4[1];
    result = a3 + 4;
    ++v6;
    ++v5;
  }
  return result;
}

//----- (00409242) --------------------------------------------------------
char *__stdcall PwdCrypt::Decrypt_5(char *a1, char *a2)
{
  char v2; // ST04_1@1
  char v3; // ST18_1@1
  char v4; // ST10_1@1
  char v5; // ST0C_1@1

  v2 = *a1;
  v3 = a1[1];
  v4 = a1[2];
  v5 = a1[3];
  *a2 = ((v2 & 0x18) >> 3) | ((v2 & 0xF8) >> 1) | ((v5 & 1) << 7);
  a2[1] = ((v3 & 0xE0) >> 5) | 8 * (v2 & 1) | ((v3 & 0x80) >> 3) | 32 * (v2 & 7);
  a2[2] = ((v4 & 0x80) >> 7) | 2 * (v3 & 0x1F) | 8 * (v3 & 0x18);
  a2[3] = ((v4 & 0x18) >> 3) | ((v4 & 0xF8) >> 1) | ((v3 & 1) << 7);
  a2[4] = ((v5 & 0xE0) >> 5) | 8 * (v4 & 1) | ((v5 & 0x80) >> 3) | 32 * (v4 & 7);
  a2[5] = ((v2 & 0x80) >> 7) | 2 * (v5 & 0x1F) | 8 * (v5 & 0x18);
  return a2 + 6;
}

//----- (004093E9) --------------------------------------------------------
char *__thiscall PwdCrypt::Decrypt_6(PwdCrypt *this, char *a2, char *a3)
{
  int v3; // ST14_4@1
  char v4; // ST10_1@1
  __int16 v5; // ST0C_2@1
  signed int v6; // ST08_4@1
  char v7; // ST04_1@1

  v3 = a2[1];
  v4 = a2[2];
  v5 = a2[3];
  v6 = a2[4];
  v7 = a2[5];
  *a3 = this->reallyBig[0].data[((v3 >> 4) & 0xF | (unsigned __int16)(16 * *a2)) & 0xFFF];
  a3[1] = this->reallyBig[1].data[((unsigned __int8)v4 | (unsigned __int16)((_WORD)v3 << 8)) & 0xFFF];
  a3[2] = this->reallyBig[2].data[((v6 >> 4) & 0xF | (unsigned __int16)(16 * v5)) & 0xFFF];
  a3[3] = this->reallyBig[3].data[((unsigned __int8)v7 | (unsigned __int16)((_WORD)v6 << 8)) & 0xFFF];
  return a3 + 4;
}

//----- (0040952A) --------------------------------------------------------
_BYTE *__thiscall PwdCrypt::Decrypt_4(PwdCrypt *this, char *a2, int a3, char *a4)
{
  PwdCrypt *v4; // ST08_4@1
  char a3a; // [sp+4h] [bp-20h]@1
  char v7; // [sp+8h] [bp-1Ch]@1
  PwdCrypt_nested *v8; // [sp+10h] [bp-14h]@1
  char *v9; // [sp+14h] [bp-10h]@1
  char *v10; // [sp+18h] [bp-Ch]@1
  char a2a; // [sp+1Ch] [bp-8h]@1

  v4 = this;
  v8 = &this->lastGap[a3];
  v10 = &v7;
  v9 = &a2a;
  PwdCrypt::Decrypt_5(a2, &v7);
  *v9++ = v8->data[0] ^ *v10;
  v8 = (PwdCrypt_nested *)((char *)v8 + 1);
  *v9++ = v8->data[0] ^ *++v10;
  v8 = (PwdCrypt_nested *)((char *)v8 + 1);
  *v9++ = v8->data[0] ^ *++v10;
  v8 = (PwdCrypt_nested *)((char *)v8 + 1);
  *v9++ = v8->data[0] ^ *++v10;
  v8 = (PwdCrypt_nested *)((char *)v8 + 1);
  *v9++ = v8->data[0] ^ *++v10;
  v8 = (PwdCrypt_nested *)((char *)v8 + 1);
  *v9++ = v8->data[0] ^ *++v10;
  v8 = (PwdCrypt_nested *)((char *)v8 + 1);
  ++v10;
  PwdCrypt::Decrypt_6(v4, &a2a, &a3a);
  return PwdCrypt::Decrypt_7(v4, &a3a, a4);
}

//----- (0040969C) --------------------------------------------------------
_BYTE *__thiscall PwdCrypt::Decrypt_3(PwdCrypt *this, int a2, char *a3, _BYTE *a4)
{
  int a4a[2]; // [sp+8h] [bp-Ch]@1
  int *v6; // [sp+10h] [bp-4h]@1

  a4a[1] = (int)a4;
  PwdCrypt::Decrypt_4(this, a3 + 4, a2, (char *)a4a);
  *(_BYTE *)a4a[1] = a3[4];
  ++a4a[1];
  *(_BYTE *)a4a[1] = a3[5];
  ++a4a[1];
  *(_BYTE *)a4a[1] = a3[6];
  ++a4a[1];
  *(_BYTE *)a4a[1] = a3[7];
  ++a4a[1];
  v6 = a4a;
  *(_BYTE *)a4a[1] = LOBYTE(a4a[0]) ^ *a3;
  ++a4a[1];
  v6 = (int *)((char *)v6 + 1);
  *(_BYTE *)a4a[1] = *(_BYTE *)v6 ^ a3[1];
  ++a4a[1];
  v6 = (int *)((char *)v6 + 1);
  *(_BYTE *)a4a[1] = *(_BYTE *)v6 ^ a3[2];
  ++a4a[1];
  *(_BYTE *)a4a[1] = *((_BYTE *)v6 + 1) ^ a3[3];
  return (_BYTE *)(a4a[1] + 1);
}

//----- (00409802) --------------------------------------------------------
int __stdcall PwdCrypt::init_4(int a1, char a2)
{
  return *(&PwdCrypt::SBoxes[a1][16 * (a2 & 1 | ((a2 & 0x20) >> 4))] + ((a2 & 0x1F) >> 1));
}

//----- (00409847) --------------------------------------------------------
void __thiscall PwdCrypt::init_3(PwdCrypt *this)
{
  int v1; // ebx@5
  PwdCrypt *v2; // [sp+4h] [bp-Ch]@1
  signed int j; // [sp+8h] [bp-8h]@3
  signed int i; // [sp+Ch] [bp-4h]@1

  v2 = this;
  for ( i = 0; i < 4; ++i )
  {
    for ( j = 0; j < 0x1000; ++j )
    {
      v1 = 16 * PwdCrypt::init_4(2 * i, j >> 6);
      v2->reallyBig[i].data[j] = PwdCrypt::init_4(2 * i + 1, j & 63) & 0xF | v1;
    }
  }
}

//----- (004098D8) --------------------------------------------------------
int __thiscall PwdCrypt::init_keys(PwdCrypt *this, char *key)
{
  int result; // eax@3
  int v3; // [sp+4h] [bp-18h]@15
  signed int v4; // [sp+10h] [bp-Ch]@14
  signed int i; // [sp+14h] [bp-8h]@1
  signed int k; // [sp+14h] [bp-8h]@6
  signed int m; // [sp+14h] [bp-8h]@12
  signed int n; // [sp+14h] [bp-8h]@18
  signed int j; // [sp+18h] [bp-4h]@4
  signed int l; // [sp+18h] [bp-4h]@10

  for ( i = 0; i < 56; ++i )
  {
    this->permutedKey[i] = (PwdCrypt::BoolMask[(PwdCrypt::PC_1[i] - 1) & 7] & key[(PwdCrypt::PC_1[i] - 1) >> 3]) != 0;
    result = i + 1;
  }
  for ( j = 0; j < 16; ++j )
  {
    for ( k = 0; k < 6; ++k )
      this->lastGap[j].data[k] = 0;
    result = j + 1;
  }
  for ( l = 0; l < 16; ++l )
  {
    for ( m = 0; m < 56; ++m )
    {                                           // 1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27
      v4 = g_PwdCrypt_key4[l] + m;
      if ( v4 >= (m >= 28 ? 56 : 28) )
        v3 = v4 - 28;
      else
        v3 = g_PwdCrypt_key4[l] + m;
      this->field_2[m] = this->permutedKey[v3];
      result = m + 1;
    }
    for ( n = 0; n < 48; ++n )
    {
      result = PwdCrypt::PC_2[n];
      if ( this->permutedKey[result + 55] )
      {
        result = (int)&this->lastGap[l];
        LOBYTE(result) = LOBYTE(PwdCrypt::BoolMask[n & 7]) | *(_BYTE *)(result + (n >> 3));
        this->lastGap[l].data[n >> 3] = result;
      }
    }
  }
  return result;
}

//----- (00409A84) --------------------------------------------------------
int __thiscall PwdCrypt::init_5(PwdCrypt *this)
{
  int result; // eax@9
  signed int v2; // [sp+Ch] [bp-10h]@17
  signed int k; // [sp+10h] [bp-Ch]@5
  signed int n; // [sp+10h] [bp-Ch]@14
  signed int j; // [sp+14h] [bp-8h]@3
  signed int m; // [sp+14h] [bp-8h]@12
  signed int i; // [sp+18h] [bp-4h]@1
  signed int l; // [sp+18h] [bp-4h]@10

  for ( i = 0; i < 4; ++i )
  {
    for ( j = 0; j < 256; ++j )
    {
      for ( k = 0; k < 4; ++k )
        this->big[i].data[j][k] = 0;
    }
    result = i + 1;
  }
  for ( l = 0; l < 4; ++l )
  {
    for ( m = 0; m < 256; ++m )
    {
      for ( n = 0; n < 32; ++n )
      {
        v2 = PwdCrypt::P[n] - 1;
        if ( v2 >> 3 == l && PwdCrypt::BoolMask[v2 & 7] & m )
          this->big[l].data[m][n >> 3] |= LOBYTE(PwdCrypt::BoolMask[n & 7]);
        result = n + 1;
      }
    }
  }
  return result;
}

//----- (00409BE8) --------------------------------------------------------
int __stdcall PwdCrypt::init_1(PwdCrypt_small *arr_size_16, unsigned __int8 *initKey)
{
  int result; // eax@9
  signed int v3; // [sp+Ch] [bp-10h]@17
  signed int k; // [sp+10h] [bp-Ch]@5
  signed int n; // [sp+10h] [bp-Ch]@14
  signed int j; // [sp+14h] [bp-8h]@3
  signed int m; // [sp+14h] [bp-8h]@12
  signed int i; // [sp+18h] [bp-4h]@1
  signed int l; // [sp+18h] [bp-4h]@10

  for ( i = 0; i < 16; ++i )
  {
    for ( j = 0; j < 16; ++j )
    {
      for ( k = 0; k < 8; ++k )
        arr_size_16[i].data[j][k] = 0;
    }
    result = i + 1;
  }
  for ( l = 0; l < 16; ++l )
  {
    for ( m = 0; m < 16; ++m )
    {
      for ( n = 0; n < 64; ++n )
      {
        v3 = (char)initKey[n] - 1;
        if ( v3 >> 2 == l && PwdCrypt::BoolMaskSmall[v3 & 3] & m )
          arr_size_16[l].data[m][n >> 3] |= LOBYTE(PwdCrypt::BoolMask[n & 7]);
        result = n + 1;
      }
    }
  }
  return result;
}

//----- (00409D36) --------------------------------------------------------
_BYTE *__thiscall PwdCrypt::Decrypt_1(PwdCrypt *this, _BYTE *in, _BYTE *out)
{
  PwdCrypt *v4; // [sp+0h] [bp-A0h]@1
  char v5[8]; // [sp+4h] [bp-9Ch]@4
  int i; // [sp+Ch] [bp-94h]@1
  char v7[8]; // [sp+10h] [bp-90h]@1
  char v8[120]; // [sp+18h] [bp-88h]@3
  char v9[8]; // [sp+90h] [bp-10h]@4
  char *v10; // [sp+98h] [bp-8h]@4
  int *v11; // [sp+9Ch] [bp-4h]@4

  v4 = this;
  PwdCrypt::Decrypt_2(in, this->fieldKey1, v7);
  for ( i = 0; i < 16; ++i )
    PwdCrypt::Decrypt_3(v4, i, &v7[8 * i], &v8[8 * i]);
  v5[0] = v9[4];
  v5[1] = v9[5];
  v5[2] = v9[6];
  v5[3] = v9[7];
  v5[4] = v9[0];
  v5[5] = v9[1];
  v5[6] = v9[2];
  v5[7] = v9[3];
  v11 = &i;
  v10 = &v9[4];
  return PwdCrypt::Decrypt_2(v5, v4->fieldKey2, out);
}
// 409D36: using guessed type char var_90[8];
// 409D36: using guessed type char var_88[120];

//----- (00409ED7) --------------------------------------------------------
_BYTE *__thiscall PwdCrypt::f10_INVALID_CALL_FROM_NOWHERE(PwdCrypt *this, _BYTE *in, _BYTE *out)
{
  PwdCrypt *v4; // [sp+0h] [bp-A0h]@1
  char v5[8]; // [sp+4h] [bp-9Ch]@4
  int i; // [sp+Ch] [bp-94h]@1
  char v7[8]; // [sp+10h] [bp-90h]@1
  char v8[120]; // [sp+18h] [bp-88h]@3
  char v9[8]; // [sp+90h] [bp-10h]@4
  char *v10; // [sp+98h] [bp-8h]@4
  int *v11; // [sp+9Ch] [bp-4h]@4

  v4 = this;
  PwdCrypt::Decrypt_2(in, this->fieldKey1, v7);
  for ( i = 0; i < 16; ++i )
    PwdCrypt::Decrypt_3(v4, 15 - i, &v7[8 * i], &v8[8 * i]);
  v5[0] = v9[4];
  v5[1] = v9[5];
  v5[2] = v9[6];
  v5[3] = v9[7];
  v5[4] = v9[0];
  v5[5] = v9[1];
  v5[6] = v9[2];
  v5[7] = v9[3];
  v11 = &i;
  v10 = &v9[4];
  return PwdCrypt::Decrypt_2(v5, v4->fieldKey2, out);
}
// 409ED7: using guessed type char var_90[8];
// 409ED7: using guessed type char var_88[120];

//----- (0040A07D) --------------------------------------------------------
char __thiscall DesFrontEnd2::Decrypt(PwdCrypt *this, _BYTE *pass, int size)
{
  int size_; // eax@1
  PwdCrypt *this_; // [sp+0h] [bp-Ch]@1
  int size__; // [sp+4h] [bp-8h]@1
  _BYTE *pass_; // [sp+8h] [bp-4h]@1

  this_ = this;
  size_ = size;
  LOBYTE(size_) = size & 248;
  size__ = size_;
  pass_ = pass;
  while ( size__ > 0 )
  {
    PwdCrypt::Decrypt_1(this_, pass_, pass_);
    size__ -= 8;
    LOBYTE(size_) = (_BYTE)pass_ + 8;
    pass_ += 8;
  }
  return size_;
}

//----- (0040A10F) --------------------------------------------------------
int __thiscall DesFrontEnd2::initDesKey(PwdCrypt *this, _BYTE *seed)
{
  PwdCrypt *this_; // [sp+0h] [bp-14h]@1
  signed int i; // [sp+4h] [bp-10h]@1
  unsigned __int8 key[8]; // [sp+Ch] [bp-8h]@1

  this_ = this;
  memset(key, 0, 8u);
  for ( i = 0; *seed && i < 40; ++i )
    key[i % 8] ^= *seed++;
  PwdCrypt::init_1(this_->fieldKey1, PwdCrypt::IP);
  PwdCrypt::init_1(this_->fieldKey2, PwdCrypt::FP);
  PwdCrypt::init_keys(this_, (char *)key);
  PwdCrypt::init_3(this_);
  return PwdCrypt::init_5(this_);
}

//----- (0040A1D8) --------------------------------------------------------
int SomeStaticInit5()
{
  SomeBitsInit();
  return RegisterStatic_EmptyDestructor();
}

//----- (0040A1E7) --------------------------------------------------------
int RegisterStatic_EmptyDestructor()
{
  return atexit(emptystub);
}

//----- (0040A200) --------------------------------------------------------
int StaticInitFor_Config()
{
  CallStaticCtorForConfig();
  return RegisterStatic_destructorForConfig();
}

//----- (0040A20F) --------------------------------------------------------
Config *CallStaticCtorForConfig()
{
  return Config::Config(&g_Config);
}

//----- (0040A21E) --------------------------------------------------------
int RegisterStatic_destructorForConfig()
{
  return atexit(CallConfigDestructor);
}

//----- (0040A230) --------------------------------------------------------
void __cdecl CallConfigDestructor()
{
  Config::Destructor(&g_Config);
}

//----- (0040A23F) --------------------------------------------------------
char *__cdecl Config::readFile(char *fileName, int *outSize, int a3)
{
  char *result; // eax@2
  _off_t fileSize; // [sp+4h] [bp-30h]@3
  struct _stat fileInfo; // [sp+8h] [bp-2Ch]@3
  char *buffer; // [sp+2Ch] [bp-8h]@5
  int file; // [sp+30h] [bp-4h]@1

  file = _open(fileName, 0x8000, 0);
  if ( file >= 0 )
  {
    _stat(fileName, &fileInfo);
    fileSize = fileInfo.st_size;
    if ( (_BYTE)a3 )
      fileSize = fileInfo.st_size + 1;
    buffer = (char *)operator new(fileSize);
    if ( buffer )
    {
      _read(file, buffer, fileInfo.st_size);
      _close(file);
      if ( outSize )
        *outSize = fileInfo.st_size;
      if ( (_BYTE)a3 )
        buffer[fileInfo.st_size] = 0;
      result = buffer;
    }
    else
    {
      _close(file);
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (0040A309) --------------------------------------------------------
Config *__thiscall Config::Config(Config *this)
{
  Config *this_; // ST08_4@1
  char v3; // [sp+4h] [bp-8h]@1
  char v4; // [sp+8h] [bp-4h]@1

  this_ = this;
  std::map_str_str::map_str_str(&this->values, &v3, &v4);
  return this_;
}

//----- (0040A32F) --------------------------------------------------------
void __thiscall Config::Destructor(Config *this)
{
  std::map_str_str::Destructor(&this->values);
}

//----- (0040A348) --------------------------------------------------------
int __thiscall Config::Load(Config *this, char *fileName)
{
  std::pair_str_str *pair; // ST18_4@17
  std::pair_int_bool *inserResult; // eax@17
  std::string *value; // edx@17
  int exists; // eax@17
  int result; // eax@28
  Config *this_; // [sp+14h] [bp-1ACh]@1
  int v8; // [sp+18h] [bp-1A8h]@28
  int v9; // [sp+1Ch] [bp-1A4h]@28
  int v10; // [sp+20h] [bp-1A0h]@28
  int removeMe; // [sp+24h] [bp-19Ch]@28
  char *buffer_; // [sp+28h] [bp-198h]@26
  int a2; // [sp+2Ch] [bp-194h]@17
  int v14; // [sp+34h] [bp-18Ch]@17
  std::string configKey; // [sp+38h] [bp-188h]@17
  int v16; // [sp+48h] [bp-178h]@17
  std::string configValue; // [sp+4Ch] [bp-174h]@17
  std::pair_str_str pair_; // [sp+5Ch] [bp-164h]@17
  char paramName[72]; // [sp+7Ch] [bp-144h]@16
  ParserState state; // [sp+C4h] [bp-FCh]@5
  Symbol read_result; // [sp+C8h] [bp-F8h]@6
  void *reader; // [sp+CCh] [bp-F4h]@2
  char token[72]; // [sp+158h] [bp-68h]@6
  int lineNumber; // [sp+1A0h] [bp-20h]@5
  std::string *value_; // [sp+1A4h] [bp-1Ch]@5
  int exists_; // [sp+1A8h] [bp-18h]@17
  char *buffer; // [sp+1ACh] [bp-14h]@1
  int outSize; // [sp+1B0h] [bp-10h]@1
  int unused_state; // [sp+1BCh] [bp-4h]@2

  this_ = this;
  buffer = Config::readFile(fileName, &outSize, 0);
  if ( buffer )
  {
    std::istrstream::istrstream(&reader, buffer, outSize, 1);
    unused_state = 0;
    if ( &reader )
      sub_40AF20((char *)&reader + *((_DWORD *)reader + 1));
    else
      sub_40AF20(0);
    lineNumber = 1;
    state = ParserState_NewLine;
    sub_40BB10((std::string *)&value_);
    while ( 1 )
    {
      read_result = Config::readToken(&reader, token, 1);
      if ( read_result == Sym_EoF )             // end of file?
        break;
      if ( state == ParserState_Comment )
      {
        if ( read_result == Sym_NewLine )
          state = ParserState_NewLine;
      }
      else
      {
        switch ( read_result )
        {
          case Sym_Word:
            if ( state )
            {
              if ( state == ParserState_ParameterFound )
              {
                std::string::string_2(&configValue, token, (int)&v16);
                LOBYTE(unused_state) = 1;
                std::string::string_2(&configKey, paramName, (int)&v14);
                LOBYTE(unused_state) = 2;
                pair = std::pair_str_str::pair_str_str(&pair_, &configKey, &configValue);
                LOBYTE(unused_state) = 3;
                inserResult = std::map_str_str::insert(&this_->values, (std::_tree_str_str::iterator *)&a2, pair);
                value = (std::string *)inserResult->first;
                exists = *(_DWORD *)&inserResult->second;
                value_ = value;
                exists_ = exists;
                LOBYTE(unused_state) = 2;
                std::pair_str_str::destructor(&pair_);
                LOBYTE(unused_state) = 1;
                std::string::destructor(&configKey);
                LOBYTE(unused_state) = 0;
                std::string::destructor(&configValue);
                if ( !(_BYTE)exists_ )
                  LogWindow::Add(&g_LogWindow, 3, aInsertTwiceSAt, paramName, lineNumber, fileName);
              }
              else if ( state != ParserState_Comment )
              {
                LogWindow::Add(&g_LogWindow, 3, aInvalidStateAt, lineNumber, fileName);
              }
            }
            else
            {
              strcpy(paramName, token);
            }
            break;
          case Sym_Eqaul:
            state = ParserState_ParameterFound;
            break;
          case Sym_SemiColon:
            state = ParserState_Comment;
            break;
          case Sym_NewLine:
            state = ParserState_NewLine;
            ++lineNumber;
            break;
          default:
            if ( state != ParserState_Comment )
              LogWindow::Add(&g_LogWindow, 3, aInvalidTokenSA, token, lineNumber, fileName);
            break;
        }
      }
    }
    buffer_ = buffer;
    _delete_table(buffer);
    unused_state = -1;
    FileStream_dtor((int)&reader);
  }
  else
  {
    LogWindow::Add(&g_LogWindow, 3, aCanTLoadS, fileName);
  }
  this_->serverPort = Config::getInt(this_, aServerPort, 0);
  this_->serverExPort = Config::getInt(this_, aServerExPort, 0);
  this_->serverIntPort = Config::getInt(this_, aServerintport, 0);
  this_->worldPort = Config::getInt(this_, aWorldport, 0);
  this_->DBConnectionNum = Config::getInt(this_, aDbconnectionnu, 0);
  this_->numServerThread = Config::getInt(this_, aNumserverthrea, 0);
  this_->numServerIntThread = Config::getInt(this_, aNumserverintth, 0);
  this_->GameID = Config::getInt(this_, aGameid, 0);
  this_->SocketTimeOut = 1000 * Config::getInt(this_, aSockettimeout, 0);
  this_->SocketLimit = Config::getInt(this_, aSocketlimit, 0);
  this_->AcceptCallNum = Config::getInt(this_, aAcceptcallnum, 0);
  this_->WaitingUserLimit = Config::getInt(this_, aWaitinguserlim, 0);
  this_->PacketSizeType = Config::getInt(this_, aPacketsizetype, 0);
  LOBYTE(this_->b_encrypt) = Config::getBool(this_, aEncrypt, 0);
  this_->logDirectory = Config::getString(this_, aLogDirectory);
  this_->ProtocolVersion = Config::getInt(this_, aProtocolversio, 0);
  LOBYTE(this_->b_DesApply) = Config::getBool(this_, aDesapply, 0);
  this_->DesKey = Config::getString(this_, aDeskey);
  this_->ReadLocalServerList = Config::getBool(this_, aReadlocalserve, 0);
  LOBYTE(this_->b_OneTimeLogOut) = Config::getBool(this_, aOnetimelogout, 0);
  this_->Gmcheckmode = Config::getBool(this_, aGmcheckmode, 0);
  this_->CountryCode = Config::getInt(this_, aCountrycode, 0);
  this_->UserData = Config::getBool(this_, aUserdata, 0);
  this_->DevConnectOuter = Config::getBool(this_, aDevconnectoute, 0);
  this_->DevServerIP = Config::getString(this_, aDevserverip);
  this_->DumpPacket = Config::getBool(this_, aDumppacket, 0);
  this_->PcCafeFirst = Config::getBool(this_, aPccafefirst, 0);
  this_->Useipserver = Config::getBool(this_, aUseipserver, 0);
  this_->IpServer = *Config::getIP(this_, &removeMe, aIPServer);
  this_->IpPort = Config::getInt(this_, aIpport, 0);
  this_->IpInterval = 1000 * Config::getInt(this_, aIpinterval, 0);
  LOBYTE(this_->UseLogD) = Config::getBool(this_, aUselogd, 0);
  this_->logdip = *Config::getIP(this_, &v10, aLogDIp);
  this_->logdport = Config::getInt(this_, aLogdport, 0);
  this_->logdconnectinterval = 1000 * Config::getInt(this_, aLogdconnectint, 60);
  LOBYTE(this_->b_Restrictgmip) = Config::getBool(this_, aRestrictgmip, 0);
  this_->gmIP = *Config::getIP(this_, &v9, aGmip);
  LOBYTE(this_->UseWantedSystem) = Config::getBool(this_, aUsewantedsyste, 0);
  this_->WantedIP = *Config::getIP(this_, &v8, aWantedip);
  this_->WantedPort = Config::getInt(this_, aWantedport, 2122);
  this_->WantedReconnectInterval = 1000 * Config::getInt(this_, aWantedreconnec, 1800);
  this_->IpAccessLimit = Config::getInt(this_, aIpaccesslimit, 0);
  this_->Freeserver = Config::getBool(this_, aFreeserver, 0);
  this_->Useforbiddenip = Config::getBool(this_, aUseforbiddenip, 0);
  this_->Supportreconne = Config::getBool(this_, aSupportreconne, 0);
  this_->Mailserver = Config::getString(this_, aMailserver);
  this_->Mailfrom = Config::getString(this_, aMailfrom);
  this_->Mailto = Config::getString(this_, aMailto);
  this_->Newserverlist = Config::getBool(this_, aNewserverlist, 0);
  this_->Autokickaccoun = Config::getBool(this_, aAutokickaccoun, 0);
  LOBYTE(result) = Config::getBool(this_, aNewencrypt, 0);
  this_->Newencrypt = result;
  return result;
}

//----- (0040AC55) --------------------------------------------------------
char *__thiscall Config::getString(Config *this, char *paramName)
{
  Config *this_; // ST08_4@1
  std::_tree_str_str::iterator *end; // eax@1
  std::pair_str_str *pair; // eax@2
  char *result; // eax@2
  int a2; // [sp+4h] [bp-8h]@1
  std::_tree_str_str::iterator it; // [sp+8h] [bp-4h]@1

  this_ = this;
  std::map_str_str::find(&this->values, &it, paramName);
  end = std::map_str_str::end(&this_->values, (int)&a2);
  if ( (unsigned __int8)std::_tree_str_str::iterator::not_equal(&it, end) )
  {
    pair = std::_tree_str_str::iterator::value(&it);
    result = std::string::c_str(&pair->second);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (0040ACB4) --------------------------------------------------------
bool __thiscall Config::getBool(Config *this, char *paramName, bool defaultValue)
{
  bool result; // al@7
  bool v4; // [sp+0h] [bp-Ch]@5
  const char *value; // [sp+8h] [bp-4h]@1

  value = Config::getString(this, paramName);
  if ( value )
  {
    v4 = !_strcmpi(value, aYes) || !_strcmpi(value, aTrue) || !_strcmpi(value, a1);
    result = v4;
  }
  else
  {
    result = defaultValue;
  }
  return result;
}

//----- (0040AD2F) --------------------------------------------------------
int __thiscall Config::getInt(Config *this, char *paramName, int defaultValue)
{
  int result; // eax@2
  const char *value; // [sp+4h] [bp-4h]@1

  value = Config::getString(this, paramName);
  if ( value )
    result = atoi(value);
  else
    result = defaultValue;
  return result;
}

//----- (0040AD64) --------------------------------------------------------
unsigned int *__thiscall Config::getIP(Config *this, int *removeMe, char *paramName)
{
  const char *value; // [sp+4h] [bp-8h]@1
  int ipAddress; // [sp+8h] [bp-4h]@2

  value = Config::getString(this, paramName);
  if ( value )
    ipAddress = inet_addr(value);
  else
    ipAddress = 0;
  *removeMe = ipAddress;
  return (unsigned int *)removeMe;
}

//----- (0040ADA9) --------------------------------------------------------
char *__thiscall Config::EditMode(Config *this, char *a2)
{
  Config *this_; // ST10_4@1

  this_ = this;
  Config::changeInt(a2, aServerport_1, aServerport_0, &this->serverPort);
  Config::changeInt(a2, aServerexport_1, aServerexport_0, &this_->serverExPort);
  Config::changeInt(a2, aServerintpor_1, aServerintpor_0, &this_->serverIntPort);
  return Config::changeInt(a2, aWorldport_1, aWorldport_0, &this_->worldPort);
}

//----- (0040AE2F) --------------------------------------------------------
char *__stdcall Config::changeInt(char *fullCommand, char *subCommand, char *paramName, int *valueToChange)
{
  char *result; // eax@1
  char *newValue; // [sp+4h] [bp-4h]@2

  result = strstr(fullCommand, subCommand);
  if ( result )
  {
    newValue = &result[strlen(subCommand)];
    result = (char *)*newValue;
    if ( (signed int)result >= '0' && *newValue <= '9' )
    {
      *valueToChange = atoi(newValue);
      result = (char *)LogWindow::Add(&g_LogWindow, 2, aEditorModeSD, paramName, *valueToChange);
    }
  }
  return result;
}

//----- (0040AEB0) --------------------------------------------------------
int SomeStaticInit7()
{
  SomeBitsInit();
  return sub_40AEBF();
}

//----- (0040AEBF) --------------------------------------------------------
int sub_40AEBF()
{
  return atexit(emptystub);
}

//----- (0040AF20) --------------------------------------------------------
void *__cdecl sub_40AF20(void *a1)
{
  sub_40AF40((int)a1, 1);
  return a1;
}

//----- (0040AF40) --------------------------------------------------------
int __thiscall sub_40AF40(int this, int a2)
{
  int result; // eax@1

  result = this;
  *(_DWORD *)(this + 12) &= ~a2;
  return result;
}

//----- (0040AF60) --------------------------------------------------------
char *__thiscall std::istrstream::istrstream(void *this, char *buffer, int size, int a4)
{
  void *this_; // [sp+0h] [bp-14h]@1

  this_ = this;
  if ( a4 )
  {
    *(_DWORD *)this = &unk_45F3D4;
    std::basic_ios::basic_ios((std::ios_base *)((char *)this + 88));
  }
  sub_40B240((int *)this_, (int)this_ + 8, (int)this_ + 8, 0, 0);
  sub_40B010((std::strstreambuf *)((char *)this_ + 8), buffer, size);
  *(_DWORD *)((char *)this_ + *(_DWORD *)(*(_DWORD *)this_ + 4)) = &std::istrstream::`vftable'{for `std::basic_ios<char,std::char_traits<char>>'};
  return (char *)this_;
}
// 45FA4C: using guessed type int (__stdcall *std::istrstream::`vftable'{for `std::basic_ios<char,std::char_traits<char>>'})(int);

//----- (0040B010) --------------------------------------------------------
std::strstreambuf *__thiscall sub_40B010(std::strstreambuf *this, char *a2, int a3)
{
  std::strstreambuf *v3; // ST10_4@1

  v3 = this;
  sub_40B300((int)this);
  *(_DWORD *)v3 = &std::strstreambuf::`vftable';
  std::strstreambuf::_Init(v3, a3, a2, 0, 2);
  return v3;
}
// 45FA5C: using guessed type int (__stdcall *std::strstreambuf::`vftable')(int);

//----- (0040B0F0) --------------------------------------------------------
int __thiscall FileStream_dtor(int this)
{
  int v1; // ST00_4@1

  v1 = this;
  std::istrstream::~istrstream((std::istrstream *)(this + 88));
  return sub_40B190((std::ios_base *)(v1 + 88));
}

//----- (0040B140) --------------------------------------------------------
int __thiscall std::pair_str_str::destructor(std::pair_str_str *this)
{
  std::pair_str_str *v1; // ST00_4@1

  v1 = this;
  std::string::destructor(&this->second);
  return std::string::destructor(v1);
}

//----- (0040B190) --------------------------------------------------------
int __thiscall sub_40B190(std::ios_base *this)
{
  this->vtable = (int)&std::basic_ios<char,std::char_traits<char>>::`vftable';
  return std::ios_base::~ios_base(this);
}
// 45FACC: using guessed type int (__stdcall *std::basic_ios<char,std::char_traits<char>>::`vftable')(int);

//----- (0040B1B0) --------------------------------------------------------
std::ios_base *__thiscall std::basic_ios::basic_ios(std::ios_base *this)
{
  std::ios_base *this_; // ST00_4@1

  this_ = this;
  std::ios_base::ios_base(this);
  this_->vtable = (int)&std::basic_ios<char,std::char_traits<char>>::`vftable';
  return this_;
}
// 45FACC: using guessed type int (__stdcall *std::basic_ios<char,std::char_traits<char>>::`vftable')(int);

//----- (0040B240) --------------------------------------------------------
int *__fastcall sub_40B240(int *a1, int a2, int a3, char a4, int a5)
{
  int v5; // ecx@3
  unsigned __int8 v6; // cf@3
  int *v8; // [sp+0h] [bp-14h]@1

  v8 = a1;
  if ( a5 )
  {
    *a1 = (int)&unk_45F3DC;
    std::basic_ios::basic_ios((std::ios_base *)(a1 + 2));
  }
  v8[1] = 0;
  v5 = *v8;
  *(int *)((char *)v8 + *(_DWORD *)(*v8 + 4)) = (int)&std::basic_istream<char,std::char_traits<char>>::`vftable'{for `std::basic_ios<char,std::char_traits<char>>'};
  LOBYTE(v5) = a4;
  v6 = __CFADD__(*(_DWORD *)(*v8 + 4), v8);
  std::basic_ios<char,std::char_traits<char>>::init(a3, v5);
  return v8;
}
// 40BC20: using guessed type _DWORD __stdcall std::basic_ios<char,std::char_traits<char>>::init(_DWORD, _DWORD);
// 45FA44: using guessed type int (__stdcall *std::basic_istream<char,std::char_traits<char>>::`vftable'{for `std::basic_ios<char,std::char_traits<char>>'})(int);

//----- (0040B2E0) --------------------------------------------------------
char *__thiscall sub_40B2E0(char *this)
{
  char *result; // eax@1

  result = this;
  *(_DWORD *)&this[*(_DWORD *)(*((_DWORD *)this - 2) + 4) - 8] = &std::basic_istream<char,std::char_traits<char>>::`vftable'{for `std::basic_ios<char,std::char_traits<char>>'};
  return result;
}
// 45FA44: using guessed type int (__stdcall *std::basic_istream<char,std::char_traits<char>>::`vftable'{for `std::basic_ios<char,std::char_traits<char>>'})(int);

//----- (0040B300) --------------------------------------------------------
_DWORD *__thiscall sub_40B300(int this)
{
  _DWORD *v1; // ST00_4@1

  v1 = (_DWORD *)this;
  std::locale::locale((std::locale *)(this + 52));
  *v1 = std::basic_streambuf<char,std::char_traits<char>>::`vftable';
  std::basic_streambuf<char,std::char_traits<char>>::_Init(v1);
  return v1;
}
// 40BE70: using guessed type int __thiscall std::basic_streambuf<char,std::char_traits<char>>::_Init(_DWORD);
// 45FA94: using guessed type int (__stdcall *std::basic_streambuf<char,std::char_traits<char>>::`vftable'[3])(int);

//----- (0040B490) --------------------------------------------------------
int __thiscall sub_40B490(int this)
{
  *(_DWORD *)this = std::basic_streambuf<char,std::char_traits<char>>::`vftable';
  return std::locale::~locale((std::locale *)(this + 52));
}
// 45FA94: using guessed type int (__stdcall *std::basic_streambuf<char,std::char_traits<char>>::`vftable'[3])(int);

//----- (0040B890) --------------------------------------------------------
std::string *__thiscall std::string::string_2(std::string *this, char *a2, int a3)
{
  std::string *v3; // ST08_4@1

  v3 = this;
  std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(
    a2,
    a3);
  return v3;
}
// 40BF20: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *, _DWORD);

//----- (0040B8D0) --------------------------------------------------------
char *__thiscall std::string::c_str(std::string *this)
{
  char *v2; // [sp+0h] [bp-8h]@2

  if ( this->_Ptr )
    v2 = this->_Ptr;
  else
    v2 = (char *)sub_40BF50();
  return v2;
}

//----- (0040B900) --------------------------------------------------------
std::map_str_str *__thiscall std::map_str_str::map_str_str(std::map_str_str *this, _BYTE *a2, _BYTE *a3)
{
  std::map_str_str *v3; // ST08_4@1

  v3 = this;
  std::map_str_str::map_str_str_2(this, a2, a3);
  return v3;
}

//----- (0040B920) --------------------------------------------------------
std::_tree_str_str::iterator *__thiscall std::map_str_str::find(std::map_str_str *this, std::_tree_str_str::iterator *a2, char *a3)
{
  std::_tree_str_str::_Node *v3; // eax@1
  int a2a; // [sp+4h] [bp-4h]@1

  v3 = (std::_tree_str_str::_Node *)std::_tree_str_str::find(&this->_Tr, (int)&a2a, a3);
  unknown_libname_32(a2, v3);
  return a2;
}

//----- (0040B950) --------------------------------------------------------
std::_tree_str_str::iterator *__thiscall std::map_str_str::end(std::map_str_str *this, int a2)
{
  std::_tree_str_str::end(&this->_Tr, (std::_tree_str_str::iterator *)a2);
  return (std::_tree_str_str::iterator *)a2;
}

//----- (0040B970) --------------------------------------------------------
std::pair_int_bool *__thiscall std::map_str_str::insert(std::map_str_str *this, std::_tree_str_str::iterator *a2, std::pair_str_str *a3)
{
  int a2a; // [sp+4h] [bp-8h]@1
  char a3a; // [sp+8h] [bp-4h]@1

  std::_tree_str_str::insert(&this->_Tr, (int)&a2a, (struct Concurrency::IExecutionContext *)a3);
  sub_40C460((std::_tree_str_str::_Node *)&a2->_Ptr, &a2a, &a3a);
  return (std::pair_int_bool *)a2;
}

//----- (0040B9B0) --------------------------------------------------------
void __thiscall std::_tree_str_str::Destructor(std::_tree_str_str *this)
{
  std::_tree *v1; // ST0C_4@1
  int v2; // ST08_4@1
  int *v3; // eax@1
  char v4; // [sp+4h] [bp-14h]@1
  char v5; // [sp+8h] [bp-10h]@1
  char v6; // [sp+Ch] [bp-Ch]@1
  char v7; // [sp+10h] [bp-8h]@1
  std::_tree_str_str *a2; // [sp+14h] [bp-4h]@1

  v1 = (std::_tree *)this;
  v2 = *(_DWORD *)sub_40C080((int)this, (int)&v6);
  v3 = (int *)sub_40C050(v1, (int)&v5);
  sub_40C2C0(v1, &v4, *v3, v2);
  std::_tree_str_str::_Freenode((std::_tree_str_str *)v1->_Head);
  v1->_Head = 0;
  v1->_Size = 0;
  a2 = 0;
  std::_Lockit::_Lockit((std::_Lockit *)&v7);
  if ( !--std::_tree_str_str::_Nilrefs )
  {
    a2 = (std::_tree_str_str *)std::_tree_str_str::_Nil;
    std::_tree_str_str::_Nil = 0;
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v7);
  if ( a2 )
    std::_tree_str_str::_Freenode(a2);
}
// 4785F8: using guessed type int std::_tree_str_str::_Nilrefs;

//----- (0040BA60) --------------------------------------------------------
std::pair_str_str *__thiscall std::pair_str_str::pair_str_str(std::pair_str_str *this, std::string *first, std::string *second)
{
  std::pair_str_str *v3; // ST04_4@1

  v3 = this;
  std::string::string(&this->first, first);
  std::string::string(&v3->second, second);
  return v3;
}

//----- (0040BAE0) --------------------------------------------------------
BOOL __thiscall std::_tree_str_str::iterator::not_equal(std::_tree_str_str::iterator *this, std::_tree_str_str::iterator *a2)
{
  return (unsigned __int8)sub_40C420(this, a2) == 0;
}

//----- (0040BB10) --------------------------------------------------------
std::string *__thiscall sub_40BB10(std::string *this)
{
  std::string *v1; // ST00_4@1

  v1 = this;
  unknown_libname_33(this);
  LOBYTE(v1->_Ptr) = 0;
  return v1;
}

//----- (0040BB30) --------------------------------------------------------
std::ios_base *__thiscall sub_40BB30(std::ios_base *this, char a2)
{
  std::ios_base *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  sub_40B190(this);
  if ( a2 & 1 )
    _delete_table(v3);
  return v3;
}

//----- (0040BB60) --------------------------------------------------------
char *__thiscall sub_40BB60(char *this, char a2)
{
  char *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  sub_40BBF0((int)(this - 8));
  if ( a2 & 1 )
    _delete_table(v3 - 8);
  return v3 - 8;
}

//----- (0040BBA0) --------------------------------------------------------
void *__thiscall sub_40BBA0(void *this, char a2)
{
  void *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  sub_40B490((int)this);
  if ( a2 & 1 )
    _delete_table(v3);
  return v3;
}

//----- (0040BBF0) --------------------------------------------------------
int __thiscall sub_40BBF0(int this)
{
  int v1; // ST00_4@1

  v1 = this;
  sub_40B2E0((char *)(this + 8));
  return sub_40B190((std::ios_base *)(v1 + 8));
}

//----- (0040BC90) --------------------------------------------------------
void __thiscall I_setstate(void *this, int a2, char a3)
{
  int v3; // eax@2

  if ( a2 )
  {
    v3 = unknown_libname_29((int)this);
    sub_40BCE0(a2 | v3, a3);
  }
}
// 40BCE0: using guessed type _DWORD __stdcall sub_40BCE0(_DWORD, char);

//----- (0040BF50) --------------------------------------------------------
void *sub_40BF50()
{
  return &unk_45F3E8;
}

//----- (0040C020) --------------------------------------------------------
std::map_str_str *__thiscall std::map_str_str::map_str_str_2(std::map_str_str *this, _BYTE *a2, _BYTE *a3)
{
  std::map_str_str *v3; // ST0C_4@1

  v3 = this;
  std::_tree_str_str::_tree_str_str(&this->_Tr, a2, 0, a3);
  return v3;
}

//----- (0040C050) --------------------------------------------------------
int __thiscall sub_40C050(void *this, int a2)
{
  int *v2; // eax@1

  v2 = (int *)std::_tree_str_str::_Lmost((std::_tree_str_str *)this);
  unknown_libname_42((void *)a2, *v2);
  return a2;
}

//----- (0040C080) --------------------------------------------------------
int __thiscall sub_40C080(int this, int a2)
{
  unknown_libname_42((void *)a2, *(_DWORD *)(this + 4));
  return a2;
}

//----- (0040C0A0) --------------------------------------------------------
std::_tree_str_str::iterator *__thiscall std::_tree_str_str::end(std::_tree_str_str *this, std::_tree_str_str::iterator *a2)
{
  std::_tree_str_str::iterator::iterator(a2, (int)this->_Head);
  return a2;
}

//----- (0040C0C0) --------------------------------------------------------
int __thiscall std::_tree_str_str::insert(std::_tree_str_str *this, int a2, struct Concurrency::IExecutionContext *a3)
{
  struct Concurrency::details::InternalContextBase *v3; // ST10_4@3
  struct Concurrency::details::InternalContextBase *v4; // eax@3
  _DWORD *v5; // eax@8
  int result; // eax@8
  _DWORD *v7; // eax@10
  _DWORD *v8; // eax@11
  struct Concurrency::details::InternalContextBase *v9; // ST10_4@13
  int v10; // eax@13
  struct Concurrency::details::InternalContextBase *v11; // eax@13
  _DWORD *v12; // eax@14
  std::_tree_str_str::_Node *v13; // [sp+0h] [bp-40h]@4
  std::_tree_str_str *v14; // [sp+4h] [bp-3Ch]@1
  char v15; // [sp+8h] [bp-38h]@15
  int v16; // [sp+Ch] [bp-34h]@14
  char v17; // [sp+10h] [bp-30h]@14
  int v18; // [sp+18h] [bp-28h]@11
  char v19; // [sp+1Ch] [bp-24h]@11
  char v20; // [sp+20h] [bp-20h]@10
  int v21; // [sp+24h] [bp-1Ch]@8
  char a3a; // [sp+28h] [bp-18h]@8
  int v23; // [sp+30h] [bp-10h]@1
  std::_tree_str_str::_Node *a1; // [sp+34h] [bp-Ch]@1
  int v25; // [sp+38h] [bp-8h]@1
  int a2a; // [sp+3Ch] [bp-4h]@9

  v14 = this;
  a1 = *(std::_tree_str_str::_Node **)sub_40D650((int)this);
  v23 = (int)v14->_Head;
  LOBYTE(v25) = 1;
  while ( a1 != std::_tree_str_str::_Nil )
  {
    v23 = (int)a1;
    v3 = getInternalContext((int)a1);
    v4 = some_cast(a3);
    LOBYTE(v25) = sub_40C290((int)v4, (int)v3);
    if ( (_BYTE)v25 )
      v13 = *std::_tree_str_str::_Left(a1);
    else
      v13 = *std::_tree_str_str::_Right(a1);
    a1 = v13;
  }
  if ( v14->_Multi )
  {
    a3a = 1;
    v5 = (_DWORD *)sub_40D180(v14, (int)&v21, (int)a1, v23, a3);
    sub_40C460((std::_tree_str_str::_Node *)a2, v5, &a3a);
    return a2;
  }
  unknown_libname_42(&a2a, v23);
  if ( (_BYTE)v25 )
  {
    v7 = (_DWORD *)sub_40C050(v14, (int)&v20);
    if ( (unsigned __int8)sub_40D720(&a2a, v7) )
    {
      v19 = 1;
      v8 = (_DWORD *)sub_40D180(v14, (int)&v18, (int)a1, v23, a3);
      sub_40C460((std::_tree_str_str::_Node *)a2, v8, &v19);
      return a2;
    }
    unknown_libname_43(&a2a);
  }
  v9 = some_cast(a3);
  v10 = unknown_libname_41(&a2a);
  v11 = getInternalContext(v10);
  if ( sub_40C290((int)v11, (int)v9) )
  {
    v17 = 1;
    v12 = (_DWORD *)sub_40D180(v14, (int)&v16, (int)a1, v23, a3);
    sub_40C460((std::_tree_str_str::_Node *)a2, v12, &v17);
    result = a2;
  }
  else
  {
    v15 = 0;
    sub_40C460((std::_tree_str_str::_Node *)a2, &a2a, &v15);
    result = a2;
  }
  return result;
}
// 40D700: using guessed type int __thiscall unknown_libname_43(_DWORD);

//----- (0040C290) --------------------------------------------------------
bool __stdcall sub_40C290(int a1, int a2)
{
  char *v2; // ST04_4@1
  char *v3; // eax@1

  v2 = std::string::c_str((std::string *)a2);
  v3 = std::string::c_str((std::string *)a1);
  return _strcmpi(v3, v2) < 0;
}

//----- (0040C2C0) --------------------------------------------------------
_DWORD *__thiscall sub_40C2C0(void *this, _DWORD *a2, int a3, char a4)
{
  _DWORD *v4; // eax@2
  _DWORD *v5; // eax@3
  int *v6; // eax@5
  _DWORD *result; // eax@6
  void **v8; // eax@7
  std::_tree *v9; // [sp+0h] [bp-14h]@1
  char v10; // [sp+4h] [bp-10h]@5
  char v11; // [sp+8h] [bp-Ch]@5
  char v12; // [sp+Ch] [bp-8h]@3
  char v13; // [sp+10h] [bp-4h]@2

  v9 = (std::_tree *)this;
  if ( !unknown_libname_38()
    || (v4 = (_DWORD *)sub_40C050(v9, (int)&v13), (unsigned __int8)sub_40D740(&a3, v4))
    || (v5 = (_DWORD *)sub_40C080((int)v9, (int)&v12), (unsigned __int8)sub_40D740(&a4, v5)) )
  {
    while ( (unsigned __int8)sub_40D740(&a3, &a4) )
    {
      v6 = sub_40D6D0(&a3, &v11, 0);
      sub_40C8B0(v9, &v10, *v6);
    }
    *a2 = a3;
    result = a2;
  }
  else
  {
    v8 = (void **)sub_40D650((int)v9);
    sub_40D100(v9, *v8);
    *(_DWORD *)sub_40D650((int)v9) = std::_tree_str_str::_Nil;
    v9->_Size = 0;
    *std::_tree_str_str::_Lmost((std::_tree_str_str *)v9) = (std::_tree_str_str::_Node *)v9->_Head;
    *std::_tree_str_str::_Rmost((std::_tree_str_str *)v9) = (std::_tree_str_str::_Node *)v9->_Head;
    sub_40C050(v9, (int)a2);
    result = a2;
  }
  return result;
}
// 40C890: using guessed type int unknown_libname_38(void);

//----- (0040C400) --------------------------------------------------------
int __thiscall sub_40C400(int *this)
{
  return sub_40C840(*this);
}

//----- (0040C420) --------------------------------------------------------
BOOL __thiscall sub_40C420(void *this, _DWORD *a2)
{
  return *(_DWORD *)this == *a2;
}

//----- (0040C460) --------------------------------------------------------
std::_tree_str_str::_Node *__thiscall sub_40C460(std::_tree_str_str::_Node *this, _DWORD *a2, _BYTE *a3)
{
  this->_Left = (std::_tree_str_str::_Node *)*a2;
  LOBYTE(this->_Parent) = *a3;
  return this;
}

//----- (0040C490) --------------------------------------------------------
int __thiscall std::_tree_str_str::find(std::_tree_str_str *this, int a2, char *a3)
{
  _DWORD *v3; // eax@1
  int v4; // eax@2
  struct Concurrency::details::InternalContextBase *v5; // eax@2
  int *v7; // [sp+0h] [bp-18h]@3
  std::_tree_str_str *v8; // [sp+4h] [bp-14h]@1
  char v9; // [sp+8h] [bp-10h]@4
  char v10; // [sp+Ch] [bp-Ch]@1
  int *v11; // [sp+10h] [bp-8h]@5
  int v12; // [sp+14h] [bp-4h]@1

  v8 = this;
  sub_40D770(this, (int)&v12, a3);
  v3 = (_DWORD *)sub_40C080((int)v8, (int)&v10);
  if ( (unsigned __int8)sub_40D720(&v12, v3)
    || (v4 = unknown_libname_41(&v12), v5 = getInternalContext(v4), sub_40C530(a3, (int)v5)) )
  {
    v7 = (int *)sub_40C080((int)v8, (int)&v9);
  }
  else
  {
    v7 = &v12;
  }
  v11 = v7;
  *(_DWORD *)a2 = *v7;
  return a2;
}

//----- (0040C530) --------------------------------------------------------
bool __stdcall sub_40C530(char *a1, int a2)
{
  char *v2; // eax@1

  v2 = std::string::c_str((std::string *)a2);
  return _strcmpi(a1, v2) < 0;
}

//----- (0040C740) --------------------------------------------------------
_DWORD *__thiscall sub_40C740(_DWORD *this, char *a2)
{
  _DWORD *v2; // ST08_4@1
  size_t v3; // eax@1

  v2 = this;
  v3 = unknown_libname_34(a2);
  return sub_40D7A0(v2, a2, v3);
}

//----- (0040C800) --------------------------------------------------------
struct Concurrency::details::InternalContextBase *__cdecl getInternalContext(int a1)
{
  struct Concurrency::IExecutionContext *v1; // eax@1

  v1 = (struct Concurrency::IExecutionContext *)sub_40C840(a1);
  return some_cast(v1);
}

//----- (0040C830) --------------------------------------------------------
std::_tree_str_str::_Node **__cdecl std::_tree_str_str::_Right(std::_tree_str_str::_Node *a1)
{
  return &a1->_Right;
}

//----- (0040C840) --------------------------------------------------------
int __cdecl sub_40C840(int a1)
{
  return a1 + 12;
}

//----- (0040C850) --------------------------------------------------------
std::_tree_str_str *__thiscall std::_tree_str_str::_tree_str_str(std::_tree_str_str *this, _BYTE *a2, char a3, _BYTE *a4)
{
  std::_tree_str_str *v4; // ST00_4@1

  v4 = this;
  this->allocator = *a4;
  this->keyComparer = *a2;
  this->_Multi = a3;
  std::_tree_str_str::_Init(this);
  return v4;
}

//----- (0040C8B0) --------------------------------------------------------
_DWORD *__thiscall sub_40C8B0(std::_tree *this, _DWORD *a2, int a3)
{
  _DWORD *v3; // eax@1
  int *v4; // eax@5
  int *v5; // eax@7
  std::_tree_str_str::_Node **v6; // eax@7
  std::_tree_str_str::_Node **v7; // esi@7
  std::_tree_str_str::_Node **v8; // eax@7
  std::_tree_str_str::_Node **v9; // eax@8
  _DWORD *v10; // esi@9
  std::_tree_str_str::_Node **v11; // eax@9
  std::_tree_str_str::_Node **v12; // eax@9
  std::_tree_str_str::_Node **v13; // esi@9
  int *v14; // eax@9
  std::_tree_str_str::_Node **v15; // eax@9
  std::_tree_str_str::_Node **v16; // eax@10
  std::_tree_str_str::_Node **v17; // eax@11
  std::_tree_str_str::_Node **v18; // eax@12
  std::_tree_str_str::_Node **v19; // eax@12
  std::_tree_str_str::_Node **v20; // eax@13
  std::_tree_str_str::_Node **v21; // eax@13
  std::_tree_str_str::_Node **v22; // eax@14
  std::_tree_str_str::_Node **v23; // eax@14
  _DWORD *v24; // esi@15
  int *v25; // ST04_4@15
  int *v26; // eax@15
  _DWORD *v27; // esi@16
  std::_tree_str_str::_Node **v28; // eax@16
  std::_tree_str_str::_Node **v29; // eax@17
  std::_tree_str_str::_Node **v30; // eax@18
  std::_tree_str_str::_Node **v31; // eax@18
  std::_tree_str_str::_Node **v32; // eax@19
  std::_tree_str_str::_Node **v33; // eax@19
  std::_tree_str_str::_Node **v34; // eax@20
  std::_tree_str_str::_Node **v35; // eax@20
  std::_tree_str_str::_Node **v36; // eax@21
  std::_tree_str_str::_Node **v37; // esi@23
  std::_tree_str_str::_Node *v38; // esi@24
  std::_tree_str_str::_Node **v39; // eax@25
  std::_tree_str_str::_Node **v40; // esi@27
  std::_tree_str_str::_Node *v41; // esi@28
  std::_tree_str_str::_Node **v42; // eax@30
  std::_tree_str_str::_Node **v43; // eax@32
  std::_tree_str_str::_Node **v44; // eax@32
  std::_tree_str_str::_Node **v45; // eax@33
  int *v46; // eax@34
  int *v47; // eax@34
  std::_tree_str_str::_Node **v48; // eax@34
  int *v49; // eax@35
  int *v50; // eax@36
  int *v51; // eax@38
  int *v52; // eax@39
  std::_tree_str_str::_Node **v53; // eax@39
  int *v54; // eax@40
  _DWORD *v55; // esi@40
  int *v56; // eax@40
  int *v57; // eax@40
  int *v58; // eax@40
  std::_tree_str_str::_Node **v59; // eax@41
  int *v60; // eax@42
  int *v61; // eax@42
  std::_tree_str_str::_Node **v62; // eax@42
  int *v63; // eax@43
  int *v64; // eax@44
  int *v65; // eax@46
  int *v66; // eax@47
  std::_tree_str_str::_Node **v67; // eax@47
  int *v68; // eax@48
  _DWORD *v69; // esi@48
  int *v70; // eax@48
  int *v71; // eax@48
  int *v72; // eax@48
  void *v73; // eax@51
  std::_tree *v75; // [sp+4h] [bp-2Ch]@1
  char v76; // [sp+8h] [bp-28h]@1
  std::_tree_str_str::_Node *v77; // [sp+Ch] [bp-24h]@41
  std::_tree_str_str::_Node *v78; // [sp+10h] [bp-20h]@33
  char v79; // [sp+14h] [bp-1Ch]@6
  std::_tree_str_str::_Node *v80; // [sp+18h] [bp-18h]@1
  std::_tree_str_str::_Node *a1; // [sp+1Ch] [bp-14h]@1
  std::_tree_str_str::_Node *v82; // [sp+20h] [bp-10h]@2
  int v83; // [sp+2Ch] [bp-4h]@6

  v75 = this;
  v3 = sub_40D6D0(&a3, &v76, 0);
  a1 = (std::_tree_str_str::_Node *)unknown_libname_41(v3);
  v80 = a1;
  if ( *std::_tree_str_str::_Left(a1) == std::_tree_str_str::_Nil )
  {
    v82 = *std::_tree_str_str::_Right(a1);
  }
  else if ( *std::_tree_str_str::_Right(a1) == std::_tree_str_str::_Nil )
  {
    v82 = *std::_tree_str_str::_Left(a1);
  }
  else
  {
    v4 = (int *)std::_tree_str_str::_Right(a1);
    a1 = (std::_tree_str_str::_Node *)sub_40DD20(*v4);
    v82 = *std::_tree_str_str::_Right(a1);
  }
  std::_Lockit::_Lockit((std::_Lockit *)&v79);
  v83 = 0;
  if ( a1 == v80 )
  {
    v27 = (_DWORD *)sub_40DAA0((int)a1);
    *(_DWORD *)sub_40DAA0((int)v82) = *v27;
    v28 = (std::_tree_str_str::_Node **)sub_40D650((int)v75);
    if ( *v28 == v80 )
    {
      v29 = (std::_tree_str_str::_Node **)sub_40D650((int)v75);
      *v29 = v82;
    }
    else
    {
      v30 = (std::_tree_str_str::_Node **)sub_40DAA0((int)v80);
      v31 = std::_tree_str_str::_Left(*v30);
      if ( *v31 == v80 )
      {
        v32 = (std::_tree_str_str::_Node **)sub_40DAA0((int)v80);
        v33 = std::_tree_str_str::_Left(*v32);
        *v33 = v82;
      }
      else
      {
        v34 = (std::_tree_str_str::_Node **)sub_40DAA0((int)v80);
        v35 = std::_tree_str_str::_Right(*v34);
        *v35 = v82;
      }
    }
    v36 = std::_tree_str_str::_Lmost((std::_tree_str_str *)v75);
    if ( *v36 == v80 )
    {
      if ( *std::_tree_str_str::_Right(v80) == std::_tree_str_str::_Nil )
      {
        v37 = (std::_tree_str_str::_Node **)sub_40DAA0((int)v80);
        *std::_tree_str_str::_Lmost((std::_tree_str_str *)v75) = *v37;
      }
      else
      {
        v38 = (std::_tree_str_str::_Node *)sub_40DD20((int)v82);
        *std::_tree_str_str::_Lmost((std::_tree_str_str *)v75) = v38;
      }
    }
    v39 = std::_tree_str_str::_Rmost((std::_tree_str_str *)v75);
    if ( *v39 == v80 )
    {
      if ( *std::_tree_str_str::_Left(v80) == std::_tree_str_str::_Nil )
      {
        v40 = (std::_tree_str_str::_Node **)sub_40DAA0((int)v80);
        *std::_tree_str_str::_Rmost((std::_tree_str_str *)v75) = *v40;
      }
      else
      {
        v41 = (std::_tree_str_str::_Node *)sub_40DCE0((int)v82);
        *std::_tree_str_str::_Rmost((std::_tree_str_str *)v75) = v41;
      }
    }
  }
  else
  {
    v5 = (int *)std::_tree_str_str::_Left(v80);
    v6 = (std::_tree_str_str::_Node **)sub_40DAA0(*v5);
    *v6 = a1;
    v7 = std::_tree_str_str::_Left(v80);
    *std::_tree_str_str::_Left(a1) = *v7;
    v8 = std::_tree_str_str::_Right(v80);
    if ( a1 == *v8 )
    {
      v9 = (std::_tree_str_str::_Node **)sub_40DAA0((int)v82);
      *v9 = a1;
    }
    else
    {
      v10 = (_DWORD *)sub_40DAA0((int)a1);
      *(_DWORD *)sub_40DAA0((int)v82) = *v10;
      v11 = (std::_tree_str_str::_Node **)sub_40DAA0((int)a1);
      v12 = std::_tree_str_str::_Left(*v11);
      *v12 = v82;
      v13 = std::_tree_str_str::_Right(v80);
      *std::_tree_str_str::_Right(a1) = *v13;
      v14 = (int *)std::_tree_str_str::_Right(v80);
      v15 = (std::_tree_str_str::_Node **)sub_40DAA0(*v14);
      *v15 = a1;
    }
    v16 = (std::_tree_str_str::_Node **)sub_40D650((int)v75);
    if ( *v16 == v80 )
    {
      v17 = (std::_tree_str_str::_Node **)sub_40D650((int)v75);
      *v17 = a1;
    }
    else
    {
      v18 = (std::_tree_str_str::_Node **)sub_40DAA0((int)v80);
      v19 = std::_tree_str_str::_Left(*v18);
      if ( *v19 == v80 )
      {
        v20 = (std::_tree_str_str::_Node **)sub_40DAA0((int)v80);
        v21 = std::_tree_str_str::_Left(*v20);
        *v21 = a1;
      }
      else
      {
        v22 = (std::_tree_str_str::_Node **)sub_40DAA0((int)v80);
        v23 = std::_tree_str_str::_Right(*v22);
        *v23 = a1;
      }
    }
    v24 = (_DWORD *)sub_40DAA0((int)v80);
    *(_DWORD *)sub_40DAA0((int)a1) = *v24;
    v25 = (int *)sub_40DA90((int)v80);
    v26 = (int *)sub_40DA90((int)a1);
    sub_40E410(v26, v25);
    a1 = v80;
  }
  if ( *(_DWORD *)sub_40DA90((int)a1) == 1 )
  {
    while ( 1 )
    {
      v42 = (std::_tree_str_str::_Node **)sub_40D650((int)v75);
      if ( v82 == *v42 || *(_DWORD *)sub_40DA90((int)v82) != 1 )
        break;
      v43 = (std::_tree_str_str::_Node **)sub_40DAA0((int)v82);
      v44 = std::_tree_str_str::_Left(*v43);
      if ( v82 == *v44 )
      {
        v45 = (std::_tree_str_str::_Node **)sub_40DAA0((int)v82);
        v78 = *std::_tree_str_str::_Right(*v45);
        if ( !*(_DWORD *)sub_40DA90((int)v78) )
        {
          *(_DWORD *)sub_40DA90((int)v78) = 1;
          v46 = (int *)sub_40DAA0((int)v82);
          *(_DWORD *)sub_40DA90(*v46) = 0;
          v47 = (int *)sub_40DAA0((int)v82);
          sub_40DBB0(v75, *v47);
          v48 = (std::_tree_str_str::_Node **)sub_40DAA0((int)v82);
          v78 = *std::_tree_str_str::_Right(*v48);
        }
        v49 = (int *)std::_tree_str_str::_Left(v78);
        if ( *(_DWORD *)sub_40DA90(*v49) != 1
          || (v50 = (int *)std::_tree_str_str::_Right(v78), *(_DWORD *)sub_40DA90(*v50) != 1) )
        {
          v51 = (int *)std::_tree_str_str::_Right(v78);
          if ( *(_DWORD *)sub_40DA90(*v51) == 1 )
          {
            v52 = (int *)std::_tree_str_str::_Left(v78);
            *(_DWORD *)sub_40DA90(*v52) = 1;
            *(_DWORD *)sub_40DA90((int)v78) = 0;
            sub_40DD60(v75, (int)v78);
            v53 = (std::_tree_str_str::_Node **)sub_40DAA0((int)v82);
            v78 = *std::_tree_str_str::_Right(*v53);
          }
          v54 = (int *)sub_40DAA0((int)v82);
          v55 = (_DWORD *)sub_40DA90(*v54);
          *(_DWORD *)sub_40DA90((int)v78) = *v55;
          v56 = (int *)sub_40DAA0((int)v82);
          *(_DWORD *)sub_40DA90(*v56) = 1;
          v57 = (int *)std::_tree_str_str::_Right(v78);
          *(_DWORD *)sub_40DA90(*v57) = 1;
          v58 = (int *)sub_40DAA0((int)v82);
          sub_40DBB0(v75, *v58);
          break;
        }
        *(_DWORD *)sub_40DA90((int)v78) = 0;
        v82 = *(std::_tree_str_str::_Node **)sub_40DAA0((int)v82);
      }
      else
      {
        v59 = (std::_tree_str_str::_Node **)sub_40DAA0((int)v82);
        v77 = *std::_tree_str_str::_Left(*v59);
        if ( !*(_DWORD *)sub_40DA90((int)v77) )
        {
          *(_DWORD *)sub_40DA90((int)v77) = 1;
          v60 = (int *)sub_40DAA0((int)v82);
          *(_DWORD *)sub_40DA90(*v60) = 0;
          v61 = (int *)sub_40DAA0((int)v82);
          sub_40DD60(v75, *v61);
          v62 = (std::_tree_str_str::_Node **)sub_40DAA0((int)v82);
          v77 = *std::_tree_str_str::_Left(*v62);
        }
        v63 = (int *)std::_tree_str_str::_Right(v77);
        if ( *(_DWORD *)sub_40DA90(*v63) != 1
          || (v64 = (int *)std::_tree_str_str::_Left(v77), *(_DWORD *)sub_40DA90(*v64) != 1) )
        {
          v65 = (int *)std::_tree_str_str::_Left(v77);
          if ( *(_DWORD *)sub_40DA90(*v65) == 1 )
          {
            v66 = (int *)std::_tree_str_str::_Right(v77);
            *(_DWORD *)sub_40DA90(*v66) = 1;
            *(_DWORD *)sub_40DA90((int)v77) = 0;
            sub_40DBB0(v75, (int)v77);
            v67 = (std::_tree_str_str::_Node **)sub_40DAA0((int)v82);
            v77 = *std::_tree_str_str::_Left(*v67);
          }
          v68 = (int *)sub_40DAA0((int)v82);
          v69 = (_DWORD *)sub_40DA90(*v68);
          *(_DWORD *)sub_40DA90((int)v77) = *v69;
          v70 = (int *)sub_40DAA0((int)v82);
          *(_DWORD *)sub_40DA90(*v70) = 1;
          v71 = (int *)std::_tree_str_str::_Left(v77);
          *(_DWORD *)sub_40DA90(*v71) = 1;
          v72 = (int *)sub_40DAA0((int)v82);
          sub_40DD60(v75, *v72);
          break;
        }
        *(_DWORD *)sub_40DA90((int)v77) = 0;
        v82 = *(std::_tree_str_str::_Node **)sub_40DAA0((int)v82);
      }
    }
    *(_DWORD *)sub_40DA90((int)v82) = 1;
  }
  v83 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v79);
  v73 = (void *)sub_40C840((int)a1);
  sub_40DF00(v73);
  std::_tree_str_str::_Freenode((std::_tree_str_str *)a1);
  --v75->_Size;
  *a2 = a3;
  return a2;
}

//----- (0040D100) --------------------------------------------------------
void *__thiscall sub_40D100(std::_tree *this, void *a2)
{
  void *result; // eax@1
  void **v3; // eax@3
  void *v4; // eax@3
  std::_tree *v5; // [sp+0h] [bp-8h]@1
  std::_tree_str_str::_Node *a1; // [sp+4h] [bp-4h]@1

  v5 = this;
  result = a2;
  for ( a1 = (std::_tree_str_str::_Node *)a2; a1 != std::_tree_str_str::_Nil; a2 = a1 )
  {
    v3 = (void **)std::_tree_str_str::_Right(a1);
    sub_40D100(v5, *v3);
    a1 = *std::_tree_str_str::_Left(a1);
    v4 = (void *)sub_40C840((int)a2);
    sub_40DF00(v4);
    std::_tree_str_str::_Freenode((std::_tree_str_str *)a2);
  }
  return result;
}

//----- (0040D180) --------------------------------------------------------
int __thiscall sub_40D180(void *this, int a2, int a3, int a4, struct Concurrency::IExecutionContext *a5)
{
  void *v5; // eax@1
  struct Concurrency::details::InternalContextBase *v6; // ST04_4@3
  struct Concurrency::details::InternalContextBase *v7; // eax@3
  int *v8; // eax@13
  std::_tree_str_str::_Node **v9; // esi@14
  int *v10; // eax@14
  std::_tree_str_str::_Node **v11; // eax@14
  int *v12; // eax@15
  std::_tree_str_str::_Node **v13; // eax@15
  int *v14; // eax@15
  int *v15; // eax@16
  int *v16; // eax@16
  int *v17; // eax@16
  int *v18; // eax@16
  std::_tree_str_str::_Node **v19; // eax@17
  int *v20; // eax@19
  int *v21; // eax@19
  int *v22; // eax@19
  int *v23; // eax@19
  int *v24; // eax@19
  int *v25; // eax@21
  std::_tree_str_str::_Node **v26; // eax@21
  int *v27; // eax@21
  int *v28; // eax@22
  int *v29; // eax@22
  int *v30; // eax@22
  int *v31; // eax@22
  std::_tree_str_str::_Node **v32; // eax@23
  int *v33; // eax@25
  int *v34; // eax@25
  int *v35; // eax@25
  int *v36; // eax@25
  int *v37; // eax@25
  int *v38; // eax@27
  std::_tree_str_str *v40; // [sp+4h] [bp-Ch]@1
  std::_tree_str_str::_Node *a1; // [sp+Ch] [bp-4h]@1
  std::_tree_str_str::_Node *v42; // [sp+1Ch] [bp+Ch]@11
  std::_tree_str_str::_Node *v43; // [sp+20h] [bp+10h]@15
  std::_tree_str_str::_Node *v44; // [sp+20h] [bp+10h]@21

  v40 = (std::_tree_str_str *)this;
  a1 = std::_tree_str_str::_Buynode((std::_tree_str_str *)a4, 0);
  *std::_tree_str_str::_Left(a1) = std::_tree_str_str::_Nil;
  *std::_tree_str_str::_Right(a1) = std::_tree_str_str::_Nil;
  v5 = (void *)sub_40C840((int)a1);
  sub_40DEE0(v5, (int)a5);
  ++v40->_Size;
  if ( (std::_tree_str_str::_Node *)a4 == v40->_Head
    || (std::_tree_str_str::_Node *)a3 != std::_tree_str_str::_Nil
    || (v6 = getInternalContext(a4), v7 = some_cast(a5), sub_40C290((int)v7, (int)v6)) )
  {
    *std::_tree_str_str::_Left((std::_tree_str_str::_Node *)a4) = a1;
    if ( (std::_tree_str_str::_Node *)a4 == v40->_Head )
    {
      *(_DWORD *)sub_40D650((int)v40) = a1;
      *std::_tree_str_str::_Rmost(v40) = a1;
    }
    else if ( (std::_tree_str_str::_Node *)a4 == *std::_tree_str_str::_Lmost(v40) )
    {
      *std::_tree_str_str::_Lmost(v40) = a1;
    }
  }
  else
  {
    *std::_tree_str_str::_Right((std::_tree_str_str::_Node *)a4) = a1;
    if ( (std::_tree_str_str::_Node *)a4 == *std::_tree_str_str::_Rmost(v40) )
      *std::_tree_str_str::_Rmost(v40) = a1;
  }
  v42 = a1;
  while ( v42 != *(std::_tree_str_str::_Node **)sub_40D650((int)v40) )
  {
    v8 = (int *)sub_40DAA0((int)v42);
    if ( *(_DWORD *)sub_40DA90(*v8) )
      break;
    v9 = (std::_tree_str_str::_Node **)sub_40DAA0((int)v42);
    v10 = (int *)sub_40DAA0((int)v42);
    v11 = (std::_tree_str_str::_Node **)sub_40DAA0(*v10);
    if ( *v9 == *std::_tree_str_str::_Left(*v11) )
    {
      v12 = (int *)sub_40DAA0((int)v42);
      v13 = (std::_tree_str_str::_Node **)sub_40DAA0(*v12);
      v14 = (int *)std::_tree_str_str::_Right(*v13);
      v43 = (std::_tree_str_str::_Node *)*v14;
      if ( *(_DWORD *)sub_40DA90(*v14) )
      {
        v19 = (std::_tree_str_str::_Node **)sub_40DAA0((int)v42);
        if ( v42 == *std::_tree_str_str::_Right(*v19) )
        {
          v42 = *(std::_tree_str_str::_Node **)sub_40DAA0((int)v42);
          sub_40DBB0(v40, (int)v42);
        }
        v20 = (int *)sub_40DAA0((int)v42);
        *(_DWORD *)sub_40DA90(*v20) = 1;
        v21 = (int *)sub_40DAA0((int)v42);
        v22 = (int *)sub_40DAA0(*v21);
        *(_DWORD *)sub_40DA90(*v22) = 0;
        v23 = (int *)sub_40DAA0((int)v42);
        v24 = (int *)sub_40DAA0(*v23);
        sub_40DD60(v40, *v24);
      }
      else
      {
        v15 = (int *)sub_40DAA0((int)v42);
        *(_DWORD *)sub_40DA90(*v15) = 1;
        *(_DWORD *)sub_40DA90((int)v43) = 1;
        v16 = (int *)sub_40DAA0((int)v42);
        v17 = (int *)sub_40DAA0(*v16);
        *(_DWORD *)sub_40DA90(*v17) = 0;
        v18 = (int *)sub_40DAA0((int)v42);
        v42 = *(std::_tree_str_str::_Node **)sub_40DAA0(*v18);
      }
    }
    else
    {
      v25 = (int *)sub_40DAA0((int)v42);
      v26 = (std::_tree_str_str::_Node **)sub_40DAA0(*v25);
      v27 = (int *)std::_tree_str_str::_Left(*v26);
      v44 = (std::_tree_str_str::_Node *)*v27;
      if ( *(_DWORD *)sub_40DA90(*v27) )
      {
        v32 = (std::_tree_str_str::_Node **)sub_40DAA0((int)v42);
        if ( v42 == *std::_tree_str_str::_Left(*v32) )
        {
          v42 = *(std::_tree_str_str::_Node **)sub_40DAA0((int)v42);
          sub_40DD60(v40, (int)v42);
        }
        v33 = (int *)sub_40DAA0((int)v42);
        *(_DWORD *)sub_40DA90(*v33) = 1;
        v34 = (int *)sub_40DAA0((int)v42);
        v35 = (int *)sub_40DAA0(*v34);
        *(_DWORD *)sub_40DA90(*v35) = 0;
        v36 = (int *)sub_40DAA0((int)v42);
        v37 = (int *)sub_40DAA0(*v36);
        sub_40DBB0(v40, *v37);
      }
      else
      {
        v28 = (int *)sub_40DAA0((int)v42);
        *(_DWORD *)sub_40DA90(*v28) = 1;
        *(_DWORD *)sub_40DA90((int)v44) = 1;
        v29 = (int *)sub_40DAA0((int)v42);
        v30 = (int *)sub_40DAA0(*v29);
        *(_DWORD *)sub_40DA90(*v30) = 0;
        v31 = (int *)sub_40DAA0((int)v42);
        v42 = *(std::_tree_str_str::_Node **)sub_40DAA0(*v31);
      }
    }
  }
  v38 = (int *)sub_40D650((int)v40);
  *(_DWORD *)sub_40DA90(*v38) = 1;
  unknown_libname_42((void *)a2, (int)a1);
  return a2;
}

//----- (0040D610) --------------------------------------------------------
std::_tree_str_str::_Node **__thiscall std::_tree_str_str::_Lmost(std::_tree_str_str *this)
{
  return std::_tree_str_str::_Left(this->_Head);
}

//----- (0040D630) --------------------------------------------------------
std::_tree_str_str::_Node **__thiscall std::_tree_str_str::_Rmost(std::_tree_str_str *this)
{
  return std::_tree_str_str::_Right(this->_Head);
}

//----- (0040D650) --------------------------------------------------------
int __thiscall sub_40D650(int this)
{
  return sub_40DAA0(*(_DWORD *)(this + 4));
}

//----- (0040D6D0) --------------------------------------------------------
_DWORD *__thiscall sub_40D6D0(void *this, _DWORD *a2, int a3)
{
  int v3; // ST04_4@1

  v3 = *(_DWORD *)this;
  unknown_libname_46(this);
  *a2 = v3;
  return a2;
}
// 40DFF0: using guessed type int __cdecl unknown_libname_46(_DWORD);

//----- (0040D720) --------------------------------------------------------
BOOL __thiscall sub_40D720(void *this, _DWORD *a2)
{
  return *(_DWORD *)this == *a2;
}

//----- (0040D740) --------------------------------------------------------
BOOL __thiscall sub_40D740(void *this, _DWORD *a2)
{
  return (unsigned __int8)sub_40D720(this, a2) == 0;
}

//----- (0040D770) --------------------------------------------------------
int __thiscall sub_40D770(void *this, int a2, char *a3)
{
  std::_tree_str_str::_Node *v3; // eax@1

  v3 = sub_40E010(this, a3);
  unknown_libname_42((void *)a2, (int)v3);
  return a2;
}

//----- (0040D7A0) --------------------------------------------------------
_DWORD *__thiscall sub_40D7A0(_DWORD *this, void *a2, size_t a3)
{
  _DWORD *v4; // [sp+0h] [bp-4h]@1

  v4 = this;
  if ( sub_40D950(this, a3, 1) )
  {
    std::char_traits<char>::copy((void *)v4[1], a2, a3);
    std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(a3);
  }
  return v4;
}
// 40D900: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(_DWORD);

//----- (0040D8A0) --------------------------------------------------------
void *__cdecl sub_40D8A0(void *a1, void *a2, size_t a3)
{
  return memmove(a1, a2, a3);
}

//----- (0040D950) --------------------------------------------------------
char __thiscall sub_40D950(_DWORD *this, unsigned int a2, char a3)
{
  _BYTE *v3; // eax@7
  char result; // al@7
  _DWORD *v5; // [sp+4h] [bp-4h]@1

  v5 = this;
  if ( std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size() < a2 )
    sub_43DF65();
  if ( v5[1] && *(_BYTE *)sub_40C790(v5[1]) && *(_BYTE *)sub_40C790(v5[1]) != 255 )
  {
    if ( a2 )
    {
      std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(a2);
      result = 1;
    }
    else
    {
      v3 = (_BYTE *)sub_40C790(v5[1]);
      --*v3;
      std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(0);
      result = 0;
    }
  }
  else if ( a2 )
  {
    if ( a3 && (v5[3] > 0x1Fu || v5[3] < a2) )
    {
      std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(1);
      std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(a2);
    }
    else if ( !a3 && v5[3] < a2 )
    {
      std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(a2);
    }
    result = 1;
  }
  else
  {
    if ( a3 )
    {
      std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(1);
    }
    else if ( v5[1] )
    {
      std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(0);
    }
    result = 0;
  }
  return result;
}
// 40BF60: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(_DWORD);
// 40C790: using guessed type _DWORD __stdcall sub_40C790(_DWORD);
// 40D900: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(_DWORD);
// 40E0D0: using guessed type int std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void);
// 40E140: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(_DWORD);

//----- (0040DA90) --------------------------------------------------------
int __cdecl sub_40DA90(int a1)
{
  return a1 + 44;
}

//----- (0040DAA0) --------------------------------------------------------
int __cdecl sub_40DAA0(int a1)
{
  return a1 + 4;
}

//----- (0040DAB0) --------------------------------------------------------
std::_tree_str_str::_Node *__thiscall std::_tree_str_str::_Init(std::_tree_str_str *this)
{
  std::_tree_str_str::_Node *result; // eax@5
  std::_tree_str_str *this_; // [sp+0h] [bp-18h]@1
  char v3; // [sp+4h] [bp-14h]@1
  std::_tree_str_str::_Node *v4; // [sp+8h] [bp-10h]@1
  int v5; // [sp+14h] [bp-4h]@1

  this_ = this;
  v4 = std::_tree_str_str::_Buynode(0, 1);
  std::_Lockit::_Lockit((std::_Lockit *)&v3);
  v5 = 0;
  if ( !std::_tree_str_str::_Nil )
  {
    std::_tree_str_str::_Nil = v4;
    v4 = 0;
    *std::_tree_str_str::_Left(std::_tree_str_str::_Nil) = 0;
    *std::_tree_str_str::_Right(std::_tree_str_str::_Nil) = 0;
  }
  ++std::_tree_str_str::_Nilrefs;
  v5 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v3);
  if ( v4 )
    std::_tree_str_str::_Freenode((std::_tree_str_str *)v4);
  this_->_Head = std::_tree_str_str::_Buynode((std::_tree_str_str *)std::_tree_str_str::_Nil, 0);
  this_->_Size = 0;
  *std::_tree_str_str::_Lmost(this_) = this_->_Head;
  result = (std::_tree_str_str::_Node *)std::_tree_str_str::_Rmost(this_);
  result->_Left = this_->_Head;
  return result;
}
// 4785F8: using guessed type int std::_tree_str_str::_Nilrefs;

//----- (0040DBB0) --------------------------------------------------------
std::_tree_str_str::_Node **__thiscall sub_40DBB0(void *this, int a2)
{
  std::_tree_str_str::_Node **v2; // esi@1
  int *v3; // eax@2
  _DWORD *v4; // esi@3
  std::_tree_str_str::_Node **v5; // eax@5
  std::_tree_str_str::_Node **v6; // eax@6
  std::_tree_str_str::_Node **v7; // eax@7
  std::_tree_str_str::_Node **result; // eax@8
  void *v9; // [sp+4h] [bp-8h]@1
  std::_tree_str_str::_Node *v10; // [sp+8h] [bp-4h]@1

  v9 = this;
  v10 = *std::_tree_str_str::_Right((std::_tree_str_str::_Node *)a2);
  v2 = std::_tree_str_str::_Left(v10);
  *std::_tree_str_str::_Right((std::_tree_str_str::_Node *)a2) = *v2;
  if ( *std::_tree_str_str::_Left(v10) != std::_tree_str_str::_Nil )
  {
    v3 = (int *)std::_tree_str_str::_Left(v10);
    *(_DWORD *)sub_40DAA0(*v3) = a2;
  }
  v4 = (_DWORD *)sub_40DAA0(a2);
  *(_DWORD *)sub_40DAA0((int)v10) = *v4;
  if ( a2 == *(_DWORD *)sub_40D650((int)v9) )
  {
    *(_DWORD *)sub_40D650((int)v9) = v10;
  }
  else
  {
    v5 = (std::_tree_str_str::_Node **)sub_40DAA0(a2);
    if ( (std::_tree_str_str::_Node *)a2 == *std::_tree_str_str::_Left(*v5) )
    {
      v6 = (std::_tree_str_str::_Node **)sub_40DAA0(a2);
      *std::_tree_str_str::_Left(*v6) = v10;
    }
    else
    {
      v7 = (std::_tree_str_str::_Node **)sub_40DAA0(a2);
      *std::_tree_str_str::_Right(*v7) = v10;
    }
  }
  *std::_tree_str_str::_Left(v10) = (std::_tree_str_str::_Node *)a2;
  result = (std::_tree_str_str::_Node **)sub_40DAA0(a2);
  *result = v10;
  return result;
}

//----- (0040DCE0) --------------------------------------------------------
int __cdecl sub_40DCE0(int a1)
{
  while ( *std::_tree_str_str::_Right((std::_tree_str_str::_Node *)a1) != std::_tree_str_str::_Nil )
    a1 = (int)*std::_tree_str_str::_Right((std::_tree_str_str::_Node *)a1);
  return a1;
}

//----- (0040DD20) --------------------------------------------------------
int __cdecl sub_40DD20(int a1)
{
  while ( *std::_tree_str_str::_Left((std::_tree_str_str::_Node *)a1) != std::_tree_str_str::_Nil )
    a1 = (int)*std::_tree_str_str::_Left((std::_tree_str_str::_Node *)a1);
  return a1;
}

//----- (0040DD60) --------------------------------------------------------
std::_tree_str_str::_Node **__thiscall sub_40DD60(void *this, int a2)
{
  std::_tree_str_str::_Node **v2; // esi@1
  int *v3; // eax@2
  _DWORD *v4; // esi@3
  std::_tree_str_str::_Node **v5; // eax@5
  std::_tree_str_str::_Node **v6; // eax@6
  std::_tree_str_str::_Node **v7; // eax@7
  std::_tree_str_str::_Node **result; // eax@8
  void *v9; // [sp+4h] [bp-8h]@1
  std::_tree_str_str::_Node *a1; // [sp+8h] [bp-4h]@1

  v9 = this;
  a1 = *std::_tree_str_str::_Left((std::_tree_str_str::_Node *)a2);
  v2 = std::_tree_str_str::_Right(a1);
  *std::_tree_str_str::_Left((std::_tree_str_str::_Node *)a2) = *v2;
  if ( *std::_tree_str_str::_Right(a1) != std::_tree_str_str::_Nil )
  {
    v3 = (int *)std::_tree_str_str::_Right(a1);
    *(_DWORD *)sub_40DAA0(*v3) = a2;
  }
  v4 = (_DWORD *)sub_40DAA0(a2);
  *(_DWORD *)sub_40DAA0((int)a1) = *v4;
  if ( a2 == *(_DWORD *)sub_40D650((int)v9) )
  {
    *(_DWORD *)sub_40D650((int)v9) = a1;
  }
  else
  {
    v5 = (std::_tree_str_str::_Node **)sub_40DAA0(a2);
    if ( (std::_tree_str_str::_Node *)a2 == *std::_tree_str_str::_Right(*v5) )
    {
      v6 = (std::_tree_str_str::_Node **)sub_40DAA0(a2);
      *std::_tree_str_str::_Right(*v6) = a1;
    }
    else
    {
      v7 = (std::_tree_str_str::_Node **)sub_40DAA0(a2);
      *std::_tree_str_str::_Left(*v7) = a1;
    }
  }
  *std::_tree_str_str::_Right(a1) = (std::_tree_str_str::_Node *)a2;
  result = (std::_tree_str_str::_Node **)sub_40DAA0(a2);
  *result = a1;
  return result;
}

//----- (0040DE90) --------------------------------------------------------
std::_tree_str_str::_Node *__stdcall std::_tree_str_str::_Buynode(std::_tree_str_str *a1, int a2)
{
  std::_tree_str_str::_Node *result; // eax@1

  result = (std::_tree_str_str::_Node *)sub_40E2F0(0x30u);
  *(_DWORD *)sub_40DAA0((int)result) = a1;
  *(_DWORD *)sub_40DA90((int)result) = a2;
  return result;
}

//----- (0040DEE0) --------------------------------------------------------
void *__stdcall sub_40DEE0(void *a1, int a2)
{
  return sub_40E440(a1, a2);
}

//----- (0040DF00) --------------------------------------------------------
void __stdcall sub_40DF00(void *a1)
{
  __ExceptionPtrDestroy(a1);
}

//----- (0040DF20) --------------------------------------------------------
std::_tree_str_str::_Node **__thiscall sub_40DF20(int *this)
{
  int *v1; // eax@2
  std::_tree_str_str::_Node **result; // eax@3
  int *v3; // eax@5
  std::_tree_str_str::_Node **v4; // eax@6
  int *v5; // [sp+0h] [bp-8h]@1
  std::_tree_str_str::_Node *a1; // [sp+4h] [bp-4h]@6

  v5 = this;
  if ( *(_DWORD *)sub_40DA90(*this) || (v1 = (int *)sub_40DAA0(*v5), *(_DWORD *)sub_40DAA0(*v1) != *v5) )
  {
    if ( *std::_tree_str_str::_Left((std::_tree_str_str::_Node *)*v5) == std::_tree_str_str::_Nil )
    {
      while ( 1 )
      {
        v4 = (std::_tree_str_str::_Node **)sub_40DAA0(*v5);
        a1 = *v4;
        if ( (std::_tree_str_str::_Node *)*v5 != *std::_tree_str_str::_Left(*v4) )
          break;
        *v5 = (int)a1;
      }
      result = (std::_tree_str_str::_Node **)a1;
      *v5 = (int)a1;
    }
    else
    {
      v3 = (int *)std::_tree_str_str::_Left((std::_tree_str_str::_Node *)*v5);
      result = (std::_tree_str_str::_Node **)sub_40DCE0(*v3);
      *v5 = (int)result;
    }
  }
  else
  {
    result = std::_tree_str_str::_Right((std::_tree_str_str::_Node *)*v5);
    *v5 = (int)*result;
  }
  return result;
}

//----- (0040E010) --------------------------------------------------------
std::_tree_str_str::_Node *__thiscall sub_40E010(void *this, char *a2)
{
  _DWORD *v2; // ST08_4@1
  struct Concurrency::details::InternalContextBase *v3; // eax@3
  std::_tree_str_str::_Node *v5; // [sp+4h] [bp-8h]@1
  std::_tree_str_str::_Node *a1; // [sp+8h] [bp-4h]@1

  v2 = this;
  a1 = *(std::_tree_str_str::_Node **)sub_40E310((int)this);
  v5 = (std::_tree_str_str::_Node *)v2[1];
  while ( a1 != std::_tree_str_str::_Nil )
  {
    v3 = getInternalContext((int)a1);
    if ( readNextToken((int)v3, a2) )
    {
      a1 = *std::_tree_str_str::_Right(a1);
    }
    else
    {
      v5 = a1;
      a1 = *std::_tree_str_str::_Left(a1);
    }
  }
  return v5;
}

//----- (0040E0A0) --------------------------------------------------------
bool __stdcall readNextToken(int a1, char *a2)
{
  char *v2; // eax@1

  v2 = std::string::c_str((std::string *)a1);
  return _strcmpi(v2, a2) < 0;
}

//----- (0040E280) --------------------------------------------------------
_DWORD *__thiscall sub_40E280(int this)
{
  _DWORD *result; // eax@1
  char *v2; // ST08_4@4
  int v3; // [sp+0h] [bp-8h]@1

  v3 = this;
  result = (_DWORD *)this;
  if ( *(_DWORD *)(this + 4) )
  {
    result = (_DWORD *)sub_40C790(*(_DWORD *)(this + 4));
    if ( *(_BYTE *)result )
    {
      result = (_DWORD *)sub_40C790(*(_DWORD *)(v3 + 4));
      if ( *(_BYTE *)result != 255 )
      {
        v2 = *(char **)(v3 + 4);
        std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(1);
        result = sub_40C740((_DWORD *)v3, v2);
      }
    }
  }
  return result;
}
// 40BF60: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(_DWORD);
// 40C790: using guessed type _DWORD __stdcall sub_40C790(_DWORD);

//----- (0040E2F0) --------------------------------------------------------
char *__stdcall sub_40E2F0(size_t a1)
{
  return std::_Allocate(a1);
}

//----- (0040E310) --------------------------------------------------------
int __thiscall sub_40E310(int this)
{
  return sub_40DAA0(*(_DWORD *)(this + 4));
}

//----- (0040E330) --------------------------------------------------------
std::_tree_str_str::_Node **__thiscall sub_40E330(int *this)
{
  int *v1; // eax@2
  std::_tree_str_str::_Node **result; // eax@2
  std::_tree_str_str::_Node **v3; // eax@3
  int *v4; // [sp+0h] [bp-8h]@1
  std::_tree_str_str::_Node *a1; // [sp+4h] [bp-4h]@3

  v4 = this;
  if ( *std::_tree_str_str::_Right((std::_tree_str_str::_Node *)*this) == std::_tree_str_str::_Nil )
  {
    while ( 1 )
    {
      v3 = (std::_tree_str_str::_Node **)sub_40DAA0(*v4);
      a1 = *v3;
      if ( (std::_tree_str_str::_Node *)*v4 != *std::_tree_str_str::_Right(*v3) )
        break;
      *v4 = (int)a1;
    }
    result = std::_tree_str_str::_Right((std::_tree_str_str::_Node *)*v4);
    if ( *result != a1 )
    {
      result = (std::_tree_str_str::_Node **)a1;
      *v4 = (int)a1;
    }
  }
  else
  {
    v1 = (int *)std::_tree_str_str::_Right((std::_tree_str_str::_Node *)*v4);
    result = (std::_tree_str_str::_Node **)sub_40DD20(*v1);
    *v4 = (int)result;
  }
  return result;
}

//----- (0040E3F0) --------------------------------------------------------
char sub_40E3F0()
{
  return 1;
}

//----- (0040E410) --------------------------------------------------------
int __cdecl sub_40E410(int *a1, int *a2)
{
  int v2; // ST00_4@1
  int result; // eax@1

  v2 = *a1;
  *a1 = *a2;
  result = v2;
  *a2 = v2;
  return result;
}

//----- (0040E440) --------------------------------------------------------
void *__cdecl sub_40E440(void *a1, int a2)
{
  void *result; // eax@1

  result = operator new(0x20u, a1);
  if ( result )
    result = sub_40E4D0(result, a2);
  return result;
}

//----- (0040E4B0) --------------------------------------------------------
void sub_40E4B0()
{
  ;
}

//----- (0040E4D0) --------------------------------------------------------
void *__thiscall sub_40E4D0(void *this, int a2)
{
  void *v2; // ST04_4@1

  v2 = this;
  std::string::string((std::string *)this, (std::string *)a2);
  std::string::string((std::string *)v2 + 1, (std::string *)(a2 + 16));
  return v2;
}

//----- (0040E530) --------------------------------------------------------
char *__thiscall sub_40E530(char *this, char a2)
{
  char *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  std::pair_str_str::destructor((std::pair_str_str *)this);
  if ( a2 & 1 )
    _delete_table(v3);
  return v3;
}

//----- (0040E560) --------------------------------------------------------
void __cdecl CSocketInt::packet00_kickByUid(CSocketInt *this, char *command)
{
  char uidStr[256]; // [sp+0h] [bp-10Ch]@1
  int uidLen; // [sp+100h] [bp-Ch]@3
  int i; // [sp+104h] [bp-8h]@3
  int uid; // [sp+108h] [bp-4h]@1
  char *buffera; // [sp+118h] [bp+Ch]@1

  uid = 0;
  buffera = CSocketInt::subcommand(uidStr, command);
  if ( buffera )
  {
    CSocketInt::subcommand(uidStr, buffera);
    uidLen = strlen(uidStr);
    for ( i = 0; i < uidLen; ++i )
    {
      if ( !isdigit(uidStr[i]) )
      {
        CSocketInt::send(this, a0_3);
        return;
      }
    }
    uid = atoi(uidStr);
    UserManager::kickUser(&g_userManager, uid, 11, true);
    CSocketInt::send(this, a1_7);
  }
  else
  {
    CSocketInt::send(this, arg4);
  }
}
// 40E560: using guessed type char uidStr[256];

//----- (0040E64A) --------------------------------------------------------
char *__cdecl CSocketInt::subcommand(char *out, char *in)
{
  signed int i; // [sp+0h] [bp-4h]@1

  for ( i = 0; i < 255; ++i )
  {
    *out = *in++;
    if ( !*out )
      return NULL;
    if ( *out == '\t' || *out == '\r' )
    {
      *out = '\0';
      return in;
    }
    ++out;
  }
  *out = '\0';
  return NULL;
}

//----- (0040E6C2) --------------------------------------------------------
void __cdecl CSocketInt::packet02_getUserNumber(CSocketInt *this)
{
  int users; // eax@1

  users = UserManager::getUsersNumber(&g_userManager);
  CSocketInt::send(this, aD_12, users);
}

//----- (0040E6E3) --------------------------------------------------------
void __cdecl CSocketInt::packet03_kickByAccNameFromAuthServer(CSocketInt *this, char *command)
{
  char accountName[256]; // [sp+0h] [bp-128h]@1
  bool notFound[4]; // [sp+100h] [bp-28h]@3
  int uid; // [sp+104h] [bp-24h]@1
  SqlQuery sql; // [sp+108h] [bp-20h]@3
  int unused; // [sp+124h] [bp-4h]@3
  char *token; // [sp+134h] [bp+Ch]@1

  uid = 0;
  memset(accountName, 0, 32u);
  token = CSocketInt::subcommand(accountName, command);
  if ( token )
  {
    CSocketInt::subcommand(accountName, token);
    accountName[14] = 0;
    SqlQuery::SqlQuery(&sql, &g_dbManager);
    unused = 0;
    SqlQuery::bindInt(&sql, &uid);
    SqlQuery::exec(&sql, aSelectUidFromU, accountName);
    notFound[0] = true;
    if ( SqlQuery::fetch(&sql, notFound) )
    {
      if ( notFound[0] )
      {
        CSocketInt::send(this, a0Invalidaccoun);
        unused = -1;
        SqlQuery::Destructor(&sql);
      }
      else
      {
        UserManager::kickUser(&g_userManager, uid, 11, true);
        CSocketInt::send(this, a1_0);
        unused = -1;
        SqlQuery::Destructor(&sql);
      }
    }
    else
    {
      CSocketInt::send(this, a0Invalidacco_0);
      unused = -1;
      SqlQuery::Destructor(&sql);
    }
  }
  else
  {
    CSocketInt::sendString(this, aIncorrectFormat, 19u);
  }
}

//----- (0040E849) --------------------------------------------------------
void __cdecl CSocketInt::packet04_changeGmMode(CSocketInt *this, char *command)
{
  char a1[256]; // [sp+0h] [bp-100h]@1
  char *token; // [sp+10Ch] [bp+Ch]@1

  token = CSocketInt::subcommand(a1, command);
  if ( token )
  {
    memset(a1, 0, 32u);
    CSocketInt::subcommand(a1, token);
    if ( a1[0] == '0' )
    {
      g_Config.Gmcheckmode = false;
      LogWindow::Add(&g_LogWindow, 2, aGmOnlyModeOff);
      CSocketInt::send(this, a1_1);
    }
    else
    {
      g_Config.Gmcheckmode = true;
      LogWindow::Add(&g_LogWindow, 2, aGmOnlyModeOn);
      CSocketInt::send(this, a1_2);
    }
  }
  else
  {
    CSocketInt::send(this, a0IncorrectFo_0);
  }
}

//----- (0040E917) --------------------------------------------------------
void __cdecl CSocketInt::packet01_changeSocketLimit(CSocketInt *this, char *command)
{
  signed int socketLimit; // [sp+0h] [bp-104h]@2
  char buffer[268]; // [sp+4h] [bp-100h]@1
  char *token; // [sp+110h] [bp+Ch]@1

  token = CSocketInt::subcommand(buffer, command);
  if ( token )
  {
    CSocketInt::subcommand(buffer, token);
    socketLimit = atoi(buffer);
    if ( socketLimit > 0 && socketLimit < 12000 )
    {
      g_Config.SocketLimit = socketLimit;
      LogWindow::Add(&g_LogWindow, 2, aChangeSocketli, socketLimit);
      CSocketInt::send(this, a1_3);
    }
  }
}

//----- (0040E9BE) --------------------------------------------------------
void CSocketInt::packet05_stub()
{
  ;
}

//----- (0040E9C3) --------------------------------------------------------
void __cdecl CSocketInt::packet06_changeGmIp(CSocketInt *this, char *command)
{
  char buffer[256]; // [sp+0h] [bp-104h]@1
  in_addr ipAddr; // [sp+100h] [bp-4h]@3
  char *token; // [sp+110h] [bp+Ch]@1

  token = CSocketInt::subcommand(buffer, command);
  if ( token )
  {
    CSocketInt::subcommand(buffer, token);
    buffer[16] = 0;
    ipAddr = (in_addr)inet_addr(buffer);
    if ( ipAddr == -1 )
    {
      CSocketInt::send(this, a0_0);
    }
    else
    {
      g_Config.gmIP = ipAddr.S_un.S_addr;
      LogWindow::Add(
        &g_LogWindow,
        2,
        aChangeGmipD_D_,
        ipAddr.S_un.S_un_b.s_b1,
        ipAddr.S_un.S_un_b.s_b2,
        ipAddr.S_un.S_un_b.s_b3,
        ipAddr.S_un.S_un_b.s_b4);
      CSocketInt::send(this, a1_4);
    }
  }
  else
  {
    CSocketInt::send(this, a0);
  }
}

//----- (0040EA99) --------------------------------------------------------
void CSocketInt::packet07_stub()
{
  ;
}

//----- (0040EA9E) --------------------------------------------------------
void __cdecl CSocketInt::packet08_changeServerMode(CSocketInt *this, char *command)
{
  char buffer[256]; // [sp+0h] [bp-100h]@1
  char *token; // [sp+10Ch] [bp+Ch]@1

  token = CSocketInt::subcommand(buffer, command);
  if ( !token )
    goto LABEL_9;
  CSocketInt::subcommand(buffer, token);
  if ( buffer[0] == '0' )
  {
    g_Config.Freeserver = false;
    LogWindow::Add(&g_LogWindow, 2, aConfigFreeserv);
    CSocketInt::send(this, a1_5);
    return;
  }
  if ( buffer[0] == '1' )
  {
    g_Config.Freeserver = true;
    LogWindow::Add(&g_LogWindow, 2, aConfigFreese_0);
    CSocketInt::send(this, a1_6);
  }
  else
  {
LABEL_9:
    CSocketInt::send(this, a0_1);
  }
}

//----- (0040EB66) --------------------------------------------------------
void __cdecl CSocketInt::packet09_getLoginFlag(CSocketInt *this, char *command)
{
  UserInfoTable userInfoTable; // [sp+0h] [bp-1D4h]@4
  char password[20]; // [sp+60h] [bp-174h]@1
  char buffer[256]; // [sp+74h] [bp-160h]@1
  char v5[64]; // [sp+174h] [bp-60h]@1
  char accName[16]; // [sp+1B4h] [bp-20h]@3
  char findUserResult; // [sp+1C4h] [bp-10h]@5
  int unused; // [sp+1D0h] [bp-4h]@4
  char *token; // [sp+1E0h] [bp+Ch]@1
  char *token1; // [sp+1E0h] [bp+Ch]@2
  char *token2; // [sp+1E0h] [bp+Ch]@3

  memset(v5, 0, 64u);
  memset(password, 0, 20u);
  token = CSocketInt::subcommand(buffer, command);
  if ( token )
  {
    token1 = CSocketInt::subcommand(buffer, token);
    if ( token1 )
    {
      strncpy(accName, buffer, 16u);
      token2 = CSocketInt::subcommand(buffer, token1);
      if ( token2 )
      {
        strncpy(password, buffer, 20u);
        CSocketInt::subcommand(buffer, token2);
        strncpy(v5, buffer, 63u);
        UserInfoTable::UserInfoTable(&userInfoTable);
        unused = 0;
        if ( g_Config.Newencrypt )
          findUserResult = UserInfoTable::findUser_newCrypt(&userInfoTable, accName, password);
        else
          findUserResult = UserInfoTable::findUser(&userInfoTable, accName, password);
        if ( findUserResult == REASON_ACCESS_FAILED_TRY_AGAIN_LATER )
        {
          CSocketInt::send(this, aOchk201ErrorS, v5);
          unused = -1;
          UserInfoTable::Destructor(&userInfoTable);
        }
        else if ( findUserResult == REASON_USER_OR_PASS_WRONG )
        {
          CSocketInt::send(this, aOchk202ErrorS, v5);
          unused = -1;
          UserInfoTable::Destructor(&userInfoTable);
        }
        else
        {
          if ( userInfoTable.blockFlag_custom || userInfoTable.blockFlag_standard )
            CSocketInt::send(this, aOchkDSD_0, userInfoTable.loginFlag | 0x80000000, v5, userInfoTable.uid);
          else
            CSocketInt::send(this, aOchkDSD, userInfoTable.loginFlag, v5, userInfoTable.uid);
          unused = -1;
          UserInfoTable::Destructor(&userInfoTable);
        }
      }
      else
      {
        CSocketInt::send(this, aOchk003Error);
      }
    }
    else
    {
      CSocketInt::send(this, aOchk003Error_0);
    }
  }
  else
  {
    CSocketInt::send(this, aOchk004);
  }
}

//----- (0040EDD3) --------------------------------------------------------
void __cdecl CSocketInt::packet10_checkUser(CSocketInt *this, char *command)
{
  UserInfoTable userInfoTable; // [sp+0h] [bp-194h]@5
  char password[18]; // [sp+60h] [bp-134h]@1
  char buffer[256]; // [sp+74h] [bp-120h]@1
  char accName[16]; // [sp+174h] [bp-20h]@1
  char findUserResult; // [sp+184h] [bp-10h]@6
  int unused; // [sp+190h] [bp-4h]@5
  char *token; // [sp+1A0h] [bp+Ch]@1
  char *token1; // [sp+1A0h] [bp+Ch]@2

  memset(accName, 0, 15u);
  memset(password, 0, 17u);
  token = CSocketInt::subcommand(buffer, command);
  if ( token )
  {
    buffer[0] = 0;
    token1 = CSocketInt::subcommand(buffer, token);
    if ( token1 )
    {
      strncpy(accName, buffer, 14u);
      accName[14] = 0;
      if ( Utils::validateAccName(accName) )
      {
        buffer[0] = 0;
        if ( CSocketInt::subcommand(buffer, token1) )
        {
          buffer[16] = 0;
          strncpy(password, buffer, 16u);
          UserInfoTable::UserInfoTable(&userInfoTable);
          unused = 0;
          if ( g_Config.Newencrypt )
            findUserResult = UserInfoTable::findUser_newCrypt(&userInfoTable, accName, password);
          else
            findUserResult = UserInfoTable::findUser(&userInfoTable, accName, password);
          if ( findUserResult )
            CSocketInt::send(this, aD_0, 3);
          else
            CSocketInt::send(this, aD, 0);
          unused = -1;
          UserInfoTable::Destructor(&userInfoTable);
        }
        else
        {
          CSocketInt::send(this, aD_1, 1);
        }
      }
      else
      {
        CSocketInt::send(this, aD_2, 2);
      }
    }
    else
    {
      CSocketInt::send(this, aD_3, 1);
    }
  }
  else
  {
    CSocketInt::send(this, aD_4, 1);
  }
}

//----- (0040EFC9) --------------------------------------------------------
UserInfoTable *__cdecl CSocketInt::packet11_kickUserFromWorldServer(CSocketInt *this, char *command)
{
  int parameterLen; // eax@5
  ServerInfo outServerInfo; // [sp+0h] [bp-1E0h]@8
  char error; // [sp+58h] [bp-188h]@3
  ServerInfo *serverInfo_; // [sp+5Ch] [bp-184h]@8
  char accName[15]; // [sp+60h] [bp-180h]@1
  char buffer[256]; // [sp+70h] [bp-170h]@1
  UserInfoTable userInfoTable; // [sp+170h] [bp-70h]@1
  int serverId; // [sp+1D0h] [bp-10h]@1
  int v11; // [sp+1DCh] [bp-4h]@1
  char *token; // [sp+1ECh] [bp+Ch]@1
  char *token1; // [sp+1ECh] [bp+Ch]@2
  char *token2; // [sp+1ECh] [bp+Ch]@5

  serverId = 0;
  UserInfoTable::UserInfoTable(&userInfoTable);
  v11 = 0;
  LogWindow::Add(&g_LogWindow, 1, aS_0, command);
  memset(accName, 0, 15u);
  token = CSocketInt::subcommand(buffer, command);
  if ( token )
  {
    buffer[0] = 0;
    token1 = CSocketInt::subcommand(buffer, token);
    strncpy(accName, buffer, 14u);
    accName[14] = 0;
    if ( Utils::validateAccName(accName) )
    {
      error = UserInfoTable::loadInfo(&userInfoTable, accName);
      if ( error )
      {
        CSocketInt::send(this, aC, 2);
      }
      else
      {
        buffer[0] = 0;
        token2 = CSocketInt::subcommand(buffer, token1);
        LOBYTE(userInfoTable.vftable) = 0;      // wtf??
        parameterLen = strlen(buffer);
        if ( Utils::isNumber(buffer, parameterLen) )
        {
          serverId = atoi(buffer);
          CSocketInt::subcommand(buffer, token2);
          if ( serverId <= 0 || serverId > g_ServerList.m_serverNumber )
          {
            CSocketInt::send(this, aD_7, 4);
          }
          else
          {
            serverInfo_ = (ServerInfo *)ServerList::getServerInfo(&g_ServerList, &outServerInfo, serverId)->ipAddress;
            if ( WorldSrvServer::socketExists(&g_worldServServer, (int)serverInfo_) )
            {
              WorldSrvServer::sendToWorldServer((int)serverInfo_, aCdcs_2, 1, userInfoTable.uid, 7, accName);
              CSocketInt::send(this, aD_5, 0);
            }
            else
            {
              CSocketInt::send(this, aD_6, 5);
            }
          }
        }
        else
        {
          CSocketInt::send(this, aD_8, 4);
        }
      }
    }
    else
    {
      CSocketInt::send(this, aD_9, 2);
    }
  }
  else
  {
    CSocketInt::send(this, aD_10, 1);
  }
  v11 = -1;
  return UserInfoTable::Destructor(&userInfoTable);
}

//----- (0040F25A) --------------------------------------------------------
CSocketInt *__thiscall CSocketInt::CSocketInt(CSocketInt *this, SOCKET socket)
{
  CSocketInt *this_; // ST04_4@1

  this_ = this;
  CIOSocket::CIOSocket(&this->base, socket);
  this_->base.base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&CSocketInt_vptr_off_45F3EC;
  this_->m_socket = socket;
  this_->m_ipAddress.S_un.S_addr = 0;
  this_->m_field_20 = 0;
  this_->m_status = SocketStatus_Init;
  this_->m_packetHandlers = (bool (__cdecl **)(CSocketInt *, char *))CSocketInt_handlers;
  return this_;
}
// 45F3EC: using guessed type int (__stdcall *CSocketInt_vptr_off_45F3EC)(int);

//----- (0040F2B0) --------------------------------------------------------
MemoryObject *__thiscall CSocketInt::Dtor(CSocketInt *this)
{
  this->base.base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&CSocketInt_vptr_off_45F3EC;
  return CIOSocket::Destructor(&this->base);
}
// 45F3EC: using guessed type int (__stdcall *CSocketInt_vptr_off_45F3EC)(int);

//----- (0040F2CC) --------------------------------------------------------
CSocketInt *__cdecl CSocketInt::Create(SOCKET socket)
{
  CSocketInt *v2; // [sp+0h] [bp-18h]@2
  CSocketInt *v3; // [sp+4h] [bp-14h]@1

  v3 = (CSocketInt *)operator_new(0x78u);
  if ( v3 )
    v2 = CSocketInt::CSocketInt(v3, socket);
  else
    v2 = 0;
  return v2;
}

//----- (0040F337) --------------------------------------------------------
LogWindow *__thiscall CSocketInt::OnClose(CSocketInt *this)
{
  CSocketInt *this_; // ST14_4@1
  SOCKET v2; // ST10_4@1
  char *v3; // eax@1

  this->m_status = SocketStatus_Closed;
  this_ = this;
  v2 = this->m_socket;
  v3 = CSocketInt::addrToStr(this);
  return LogWindow::Add(&g_LogWindow, 0, aCloseConnectio, v3, v2, this_);
}

//----- (0040F374) --------------------------------------------------------
LONG __thiscall CSocketInt::OnRead(CSocketInt *this)
{
  signed __int32 bytesLeft; // edx@2
  CSocketInt *this_; // [sp+0h] [bp-10h]@1
  DWORD buffSize; // [sp+4h] [bp-Ch]@1
  signed int bufferEnd; // [sp+8h] [bp-8h]@1
  char *buffer; // [sp+Ch] [bp-4h]@1

  this_ = this;
  buffer = (char *)this->base.m_pReadBuf->m_Buffer;
  bufferEnd = 0;
  buffSize = this->base.m_pReadBuf->m_dwSize;
  while ( 1 )
  {
    bytesLeft = buffSize--;
    if ( bytesLeft <= 0 )
      break;
    if ( bufferEnd < 255 && buffer[bufferEnd] != '\n' )
    {
      ++bufferEnd;
    }
    else
    {
      buffer[bufferEnd] = 0;
      this_->m_unused = 60;
      CSocketInt::handleCommand(this_, buffer);
      buffer += bufferEnd + 1;
      bufferEnd = 0;
    }
  }
  return CIOSocket::Read(&this_->base, bufferEnd);
}

//----- (0040F416) --------------------------------------------------------
int __thiscall CSocketInt::handleCommand(CSocketInt *this, char *command)
{
  int result; // eax@1
  CSocketInt *this_; // [sp+0h] [bp-8h]@1
  int commandId; // [sp+4h] [bp-4h]@1

  this_ = this;
  result = sscanf(command, aD_11, &commandId);
  if ( commandId >= 0 && (unsigned int)commandId < 12 )
    result = this_->m_packetHandlers[commandId](this_, command);
  return result;
}

//----- (0040F45D) --------------------------------------------------------
char *__thiscall CSocketInt::addrToStr(CSocketInt *this)
{
  return inet_ntoa(this->m_ipAddress);
}

//----- (0040F475) --------------------------------------------------------
int __thiscall CSocketInt::OnCreate(CSocketInt *this)
{
  CSocketInt *this_; // ST00_4@1

  this_ = this;
  MemoryObject::AddRef(&this->base.base);
  return this_->base.base.vftbl_0_45F520->derived_func_9((CIOSocket *)this_);// onRead
}

//----- (0040F493) --------------------------------------------------------
CSocketInt *__thiscall CSocketInt::setIPAddress(CSocketInt *this, int ipAddress)
{
  CSocketInt *result; // eax@1

  result = this;
  this->m_ipAddress.S_un.S_addr = ipAddress;
  return result;
}

//----- (0040F4A9) --------------------------------------------------------
void CSocketInt::send(CSocketInt *this, char *format, ...)
{
  int size; // [sp+0h] [bp-Ch]@3
  CIOBuffer *buff; // [sp+8h] [bp-4h]@2
  va_list va; // [sp+1Ch] [bp+10h]@1

  va_start(va, format);
  if ( this->m_status != SocketStatus_Closed )
  {
    buff = CIOBuffer::Alloc();
    if ( vsprintf((char *)buff->m_Buffer, format, va) <= 0 )
      size = 0;
    else
      size = vsprintf((char *)buff->m_Buffer, format, va);
    buff->m_dwSize = size;
    CIOSocket::Write(&this->base, buff);
  }
}

//----- (0040F529) --------------------------------------------------------
void __thiscall CSocketInt::sendString(CSocketInt *this, char *message, size_t size)
{
  CIOBuffer *buff; // ST10_4@4
  CSocketInt *this_; // [sp+0h] [bp-8h]@1

  this_ = this;
  if ( this->m_status != SocketStatus_Closed && (signed int)size > 0 && (signed int)size <= 0x2000 )
  {
    buff = CIOBuffer::Alloc();
    memcpy(buff->m_Buffer, message, size);
    buff->m_dwSize = size;
    CIOSocket::Write(&this_->base, buff);
  }
}

//----- (0040F58B) --------------------------------------------------------
int SomeStaticInit8()
{
  SomeBitsInit();
  return sub_40F59A();
}

//----- (0040F59A) --------------------------------------------------------
int sub_40F59A()
{
  return atexit(emptystub);
}

//----- (0040F5B0) --------------------------------------------------------
int __thiscall UserManager::getUsersNumber(UserManager *this)
{
  UserManager *this_; // ST00_4@1
  int size; // ST04_4@1

  this_ = this;
  SpinLock::Enter(&this->m_spinLock);
  size = std::vector::size(&this_->m_accounts);
  SpinLock::Leave(&this_->m_spinLock);
  return size;
}

//----- (0040F5F0) --------------------------------------------------------
CSocketInt *__thiscall CSocketInt::CallDtor(CSocketInt *this, char a2)
{
  CSocketInt *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  CSocketInt::Dtor(this);
  if ( a2 & 1 )
    operator_delete(v3);
  return v3;
}

//----- (0040F680) --------------------------------------------------------
char __cdecl WorldSrvSocket::packet00_playOk(WorldSrvSocket *this, char *buffer)
{
  int uid_; // ST10_4@6
  ServerInfo *serverInfo; // eax@6
  char result; // al@7
  ServerInfo serverInfo_; // [sp+0h] [bp-78h]@6
  int sessionKey; // [sp+58h] [bp-20h]@1
  int uid; // [sp+5Ch] [bp-1Ch]@1
  char accountName[15]; // [sp+60h] [bp-18h]@1
  int socket; // [sp+70h] [bp-8h]@1
  char otherServer; // [sp+74h] [bp-4h]@1

  uid = BufferReader::ReadInt(&buffer);
  sessionKey = BufferReader::ReadInt(&buffer);
  otherServer = 0;
  memset(accountName, 0, 14u);
  socket = UserManager::userAcceptedByGS(&g_userManager, uid, this->m_serverID, true, &otherServer, accountName);
  accountName[14] = 0;
  if ( socket && uid && otherServer )
  {
    UserManager::kickUser(&g_userManager, uid, 14, true);
    if ( otherServer > 0 && otherServer <= g_ServerList.m_serverNumber )
    {
      uid_ = uid;
      serverInfo = ServerList::getServerInfo(&g_ServerList, &serverInfo_, otherServer);
      WorldSrvServer::sendToWorldServer(serverInfo->ipAddress, aCdcs_3, 1, uid_, 14, accountName);
    }
    WorldSrvSocket::send(this, aCdcs_4, 1, uid, 14, accountName);
    result = 0;
  }
  else
  {
    if ( socket && uid )
      CAuthSocket::send(socket, aCddc, LS_PlayOk, sessionKey, uid, this->m_serverID);
    result = 0;
  }
  return result;
}

//----- (0040F7B1) --------------------------------------------------------
char __cdecl WorldSrvSocket::packet01_playFail(WorldSrvSocket *this, char *buffer)
{
  int loginTime; // [sp+0h] [bp-2Ch]@1
  int uid; // [sp+4h] [bp-28h]@1
  int connectedIP; // [sp+8h] [bp-24h]@1
  char accName[15]; // [sp+Ch] [bp-20h]@1
  char errorCode; // [sp+1Ch] [bp-10h]@1
  int socket; // [sp+20h] [bp-Ch]@1
  int payStat; // [sp+24h] [bp-8h]@1
  bool success; // [sp+28h] [bp-4h]@1

  errorCode = BufferReader::ReadByte(&buffer);
  uid = BufferReader::ReadInt(&buffer);
  socket = UserManager::restartSomeTimer(&g_userManager, uid, false);
  payStat = 0;
  success = UserManager::getAccInfo(&g_userManager, uid, accName, &payStat, &connectedIP, (time_t *)&loginTime);
  if ( success && payStat < 1000 && payStat > 0 )
    IPSessionDB::sendSomethingToIPSocket(
      &g_IPSessionDB,
      uid,
      connectedIP,
      payStat,
      0,
      loginTime,
      this->m_serverID,
      accName);
  if ( g_Config.Autokickaccoun && errorCode == PLAY_FAIL_ALREADY_LOGGED )
    WorldSrvSocket::send(this, aCdcs_5, 1, uid, errorCode, accName);
  if ( socket && uid )
    CAuthSocket::send(socket, aCc_7, LS_PlayFail, errorCode);
  return 0;
}

//----- (0040F8B2) --------------------------------------------------------
char __cdecl WorldSrvSocket::packet02_userLoggedToGs(WorldSrvSocket *this, char *buffer)
{
  char result; // al@2
  int uid; // [sp+0h] [bp-4h]@1

  uid = BufferReader::ReadInt(&buffer);
  if ( UserManager::userLoggedToGS(&g_userManager, uid, this->m_serverID) )
  {
    result = 0;
  }
  else
  {
    UserManager::kickUser(&g_userManager, uid, PLAY_FAIL_WRONG_ACC_NAME, true);
    result = 0;
  }
  return result;
}

//----- (0040F900) --------------------------------------------------------
char __cdecl WorldSrvSocket::packet03_userQuitsWithError(WorldSrvSocket *this, char *buffer)
{
  int uid; // [sp+Ch] [bp-24h]@1
  int usetime; // [sp+10h] [bp-20h]@1
  __int16 reason; // [sp+14h] [bp-1Ch]@1

  uid = BufferReader::ReadInt(&buffer);
  reason = BufferReader::ReadShort(&buffer);
  usetime = BufferReader::ReadInt(&buffer);
  if ( !UserManager::userQuitsFromGS(&g_userManager, uid, 0, this->m_serverID) )
    FileLog::write(&g_errLog, 3, aQuitGameErrorU, uid, reason, usetime);
  if ( LOBYTE(g_Config.b_OneTimeLogOut) )
    UserManager::removeUser(&g_userManager, uid);
  return 0;
}

//----- (0040FA11) --------------------------------------------------------
char __cdecl WorldSrvSocket::packet04_userDropped(WorldSrvSocket *this, char *buffer)
{
  char accountName[15]; // [sp+Ch] [bp-30h]@1
  int uid; // [sp+1Ch] [bp-20h]@1
  __int16 reason; // [sp+20h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+24h] [bp-18h]@1

  ms_exc.registration.TryLevel = 0;
  uid = BufferReader::ReadInt(&buffer);
  reason = BufferReader::ReadShort(&buffer);
  UserManager::userQuitsFromGS(&g_userManager, uid, 0, this->m_serverID);
  memset(accountName, 0, 15u);
  UserManager::userDroppedFromGS(&g_userManager, uid, accountName);
  return 0;
}

//----- (0040FAF4) --------------------------------------------------------
char __cdecl WorldSrvSocket::packet05_setUserLimit(WorldSrvSocket *this, char *buffer)
{
  int pair; // eax@1
  int serverId_; // edx@1
  int serverId; // ST08_4@1
  int v5; // ST04_4@1
  int worldSrvIp; // eax@1
  int a2a; // [sp+0h] [bp-8h]@1
  __int16 pair_[2]; // [sp+4h] [bp-4h]@1

  pair = BufferReader::ReadInt(&buffer);
  *(_DWORD *)pair_ = pair;
  LOBYTE(serverId_) = this->m_serverID;
  serverId = serverId_;
  v5 = pair;
  worldSrvIp = WorldSrvSocket::getWorldServerIp(this, &a2a);
  ServersProvider::setUserNumber(*(_DWORD *)worldSrvIp, v5, serverId);
  UserCountTable::setUsers(&g_UserTable, this->m_serverID, pair_[0], pair_[1]);
  return false;
}

//----- (0040FB53) --------------------------------------------------------
char __cdecl WorldSrvSocket::packet06_stub(WorldSrvSocket *this, char *buffer)
{
  BufferReader::ReadInt(&buffer);
  BufferReader::ReadShort(&buffer);
  return false;
}

//----- (0040FB7E) --------------------------------------------------------
char __cdecl WorldSrvSocket::packet07_stub(WorldSrvSocket *this, char *buffer)
{
  BufferReader::ReadInt(&buffer);
  return false;
}

//----- (0040FB97) --------------------------------------------------------
char __cdecl WorldSrvSocket::packet08_pingAck(WorldSrvSocket *this, char *buffer)
{
  int ping; // eax@1

  ping = BufferReader::ReadInt(&buffer);
  WorldSrvSocket::send(this, aCd_2, 4, ping);
  return 0;
}

//----- (0040FBBE) --------------------------------------------------------
char __cdecl WorldSrvSocket::packet09_updateUserData(WorldSrvSocket *this, char *buffer)
{
  char userData[17]; // [sp+4h] [bp-3Ch]@1
  SQLINTEGER len; // [sp+18h] [bp-28h]@1
  int uid; // [sp+1Ch] [bp-24h]@1
  SqlQuery sql; // [sp+20h] [bp-20h]@1
  int v7; // [sp+3Ch] [bp-4h]@1

  uid = BufferReader::ReadInt(&buffer);
  memcpy(userData, buffer, 16u);
  buffer += 16;
  userData[16] = 0;
  SqlQuery::SqlQuery(&sql, &g_dbManager);
  v7 = 0;
  len = 16;
  SqlQuery::bindParam((SqlQuery *)sql.sqlHandler, 1u, SQL_PARAM_INPUT, -2, -2, 16u, 0, userData, 16, &len);// SQL_C_BINARY, SQL_BINARY
  SqlQuery::exec(&sql, aUpdateUser_d_0, uid);
  v7 = -1;
  SqlQuery::Destructor(&sql);
  return 0;
}

//----- (0040FC7A) --------------------------------------------------------
char __cdecl WorldSrvSocket::packet10_updateWorldStatus(WorldSrvSocket *this)
{
  SqlQuery sql; // [sp+4h] [bp-20h]@1
  int v3; // [sp+20h] [bp-4h]@1

  ThreadSafeMap::dumpKickedUsers(&this->m_accsInUseMap, this);
  SqlQuery::SqlQuery(&sql, &g_dbManager);
  v3 = 0;
  SqlQuery::exec(&sql, aUpdateWorldsta, this->m_serverID);
  ServersProvider::setServerStatus(this->m_serverID, true);
  LOBYTE(this->m_gsStatus_unused) = 1;
  v3 = -1;
  SqlQuery::Destructor(&sql);
  return 0;
}

//----- (0040FD0D) --------------------------------------------------------
char __cdecl WorldSrvSocket::packet11_gsReconnected(WorldSrvSocket *this, char *buffer)
{
  SqlQuery sql; // [sp+10h] [bp-90h]@5
  int dayMonthNowEncoded; // [sp+24h] [bp-7Ch]@21
  int dayAndMonthEncoded; // [sp+28h] [bp-78h]@21
  UserInfo *accInfo; // [sp+2Ch] [bp-74h]@27
  int unused1; // [sp+30h] [bp-70h]@1
  int userNumber; // [sp+34h] [bp-6Ch]@1
  struct tm *now; // [sp+38h] [bp-68h]@1
  int warnFlag; // [sp+3Ch] [bp-64h]@1
  bool notFound[4]; // [sp+40h] [bp-60h]@1
  SexAndCentury sexAndCentury; // [sp+44h] [bp-5Ch]@1
  int payStat; // [sp+48h] [bp-58h]@1
  int connectedIp; // [sp+4Ch] [bp-54h]@4
  char sessionKey[14]; // [sp+50h] [bp-50h]@5
  int birthdayEncoded; // [sp+60h] [bp-40h]@25
  int uid; // [sp+64h] [bp-3Ch]@1
  int age; // [sp+68h] [bp-38h]@1
  char accName[16]; // [sp+6Ch] [bp-34h]@4
  char devidedByTen; // [sp+7Ch] [bp-24h]@1
  char moduloTen; // [sp+7Dh] [bp-23h]@1
  int success; // [sp+80h] [bp-20h]@1
  int restOfSsn; // [sp+84h] [bp-1Ch]@25
  time_t timeNow; // [sp+88h] [bp-18h]@1
  int userIndex; // [sp+8Ch] [bp-14h]@1
  int loginFlag; // [sp+90h] [bp-10h]@1
  int unused; // [sp+9Ch] [bp-4h]@5

  userNumber = BufferReader::ReadInt(&buffer);
  userIndex = 0;
  loginFlag = 0;
  warnFlag = 0;
  payStat = 0;
  uid = 0;
  unused1 = 0;
  notFound[0] = false;
  LOBYTE(success) = false;
  sexAndCentury = FemaleBorn_1800_to_1899;
  age = 0;
  timeNow = time(0);
  now = localtime(&timeNow);
  devidedByTen = now->tm_year / 10 + '0';
  moduloTen = now->tm_year % 10 + '0';
  for ( userIndex = 0; userIndex < userNumber; ++userIndex )
  {
    memset(accName, 0, 15u);
    BufferReader::ReadString(&buffer, 14, accName);
    uid = BufferReader::ReadInt(&buffer);
    payStat = BufferReader::ReadInt(&buffer);
    connectedIp = BufferReader::ReadUInt(&buffer);
    loginFlag = BufferReader::ReadInt(&buffer);
    warnFlag = BufferReader::ReadInt(&buffer);
    if ( g_Config.CountryCode )
    {
      birthdayEncoded = 0;
      restOfSsn = 0;
      sexAndCentury = FemaleBorn_1800_to_1899;
      age = 0;
    }
    else
    {
      SqlQuery::SqlQuery(&sql, &g_dbManager);
      unused = 0;
      SqlQuery::reset(&sql);
      SqlQuery::bindStr(&sql, sessionKey, 14);
      LOBYTE(success) = true;
      if ( SqlQuery::exec(&sql, aSelectSsnFro_0, accName) )
      {
        if ( SqlQuery::fetch(&sql, notFound) )
        {
          if ( notFound[0] )
            LOBYTE(success) = false;
        }
        else
        {
          LOBYTE(success) = false;
        }
      }
      else
      {
        LOBYTE(success) = false;
      }
      if ( !(_BYTE)success )
      {
        unused = -1;
        SqlQuery::Destructor(&sql);
        continue;
      }
      sexAndCentury = sessionKey[6] - '0';
      if ( sessionKey[6] != '1' && sessionKey[6] != '2' && sessionKey[6] != '5' && sessionKey[6] != '6' )
        age = 10 * (sessionKey[0] - '0') + sessionKey[1] - '0';// // 2000-2099 year
      else
        age = moduloTen - sessionKey[1] + 10 * (devidedByTen - sessionKey[0]);// // 1900-1999 year
      dayMonthNowEncoded = now->tm_mday + 100 * (now->tm_mon + 1);
      dayAndMonthEncoded = 10 * (sessionKey[4] - '0')
                         + 100 * (sessionKey[3] - '0')
                         + 1000 * (sessionKey[2] - '0')
                         + sessionKey[5]
                         - '0';
      if ( dayMonthNowEncoded < dayAndMonthEncoded )
        --age;
      if ( age < 0 )
        age = 0;
      birthdayEncoded = 10000 * (10 * (sessionKey[0] - '0') + sessionKey[1] - '0') + dayAndMonthEncoded;
      restOfSsn = atoi(&sessionKey[6]);
      SqlQuery::reset(&sql);
      unused = -1;
      SqlQuery::Destructor(&sql);
    }
    accInfo = (UserInfo *)operator new(0x50u);
    strncpy(accInfo->accountName, accName, 14u);
    accInfo->accountName[14] = 0;
    accInfo->clientCookie = 0;
    accInfo->lastworld = this->m_serverID;
    accInfo->loginFlag = loginFlag;
    accInfo->warnFlag = warnFlag;
    accInfo->loginState = LoginState_LoggedToGS;
    accInfo->connectedIP = connectedIp;
    accInfo->loginTime = timeNow;
    accInfo->loggedGameServerId = this->m_serverID;
    accInfo->selectedGServerId = 0;
    accInfo->gameSocket = INVALID_SOCKET;
    accInfo->sessionKey = 0;
    accInfo->timerHandler = 0;
    accInfo->payStat = payStat;
    LOBYTE(accInfo->sexAndCentury) = sexAndCentury;
    accInfo->birthdayEncoded = birthdayEncoded;
    accInfo->restOfSsn = restOfSsn;
    accInfo->age = age;
    if ( UserManager::addUser(&g_userManager, accInfo, uid, this, 0, 0) )
    {
      _delete_table(accInfo);
    }
    else
    {
      _delete_table(accInfo);
      ThreadSafeMap::insert(&this->m_accsInUseMap, uid, accName);// acc in use, add to map
    }
  }
  WorldSrvSocket::send(this, aCd, 5, userIndex);
  return 0;
}

//----- (004101AC) --------------------------------------------------------
char __cdecl WorldSrvSocket::packet12_newCharCreated(WorldSrvSocket *this, char *buffer)
{
  char v2; // ST38_1@1
  int uid; // ST30_4@1
  int charId; // ST2C_4@1
  int binarySize; // ST28_4@1
  int socket; // ST34_4@1

  v2 = BufferReader::ReadInt(&buffer);
  uid = BufferReader::ReadInt(&buffer);
  charId = BufferReader::ReadInt(&buffer);
  binarySize = BufferReader::ReadShort(&buffer);
  UserManager::addCharacterToServer(uid, charId, this->m_serverID);
  socket = UserManager::restartSomeTimer(&g_userManager, uid, false);
  CAuthSocket::send(
    socket,
    aCcddchb,
    LS_CharSelection,
    v2,
    uid,
    charId,
    this->m_serverID,
    binarySize,
    binarySize,
    buffer);
  return 0;
}

//----- (0041026C) --------------------------------------------------------
char __cdecl WorldSrvSocket::packet13_charDeleted(WorldSrvSocket *this, char *buffer)
{
  char v2; // ST28_1@1
  int uid; // ST20_4@1
  int charId; // ST1C_4@1
  SOCKET socket; // eax@1

  v2 = BufferReader::ReadByte(&buffer);
  uid = BufferReader::ReadInt(&buffer);
  charId = BufferReader::ReadInt(&buffer);
  UserManager::delCharacter(uid, charId, this->m_serverID);
  socket = UserManager::restartSomeTimer(&g_userManager, uid, false);
  CAuthSocket::send(socket, aCcddc, LS_CharDeleted, v2, uid, charId, this->m_serverID);
  return 0;
}

//----- (00410307) --------------------------------------------------------
char __cdecl WorldSrvSocket::packet14_charManipulation(WorldSrvSocket *this, char *buffer)
{
  char result; // al@2
  SOCKET authSocket; // eax@3
  int binarySize; // [sp+4h] [bp-10h]@1
  int uid; // [sp+8h] [bp-Ch]@1
  char v6; // [sp+Ch] [bp-8h]@1

  uid = BufferReader::ReadInt(&buffer);
  v6 = BufferReader::ReadByte(&buffer);
  binarySize = BufferReader::ReadShort(&buffer);
  if ( v6 > 0 )
  {
    authSocket = UserManager::restartSomeTimer(&g_userManager, uid, false);
    CAuthSocket::send(
      authSocket,
      aCdccchb,
      LS_CharManipulation,
      uid,
      11,
      v6,
      this->m_serverID,
      binarySize,
      binarySize,
      buffer);
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (004103AD) --------------------------------------------------------
char __cdecl WorldSrvSocket::packet21_moveCharToGS(WorldSrvSocket *this, char *buffer)
{
  int uid; // ST14_4@1
  int oldCharId; // ST28_4@1
  char oldServerId; // ST18_1@1
  int newCharId; // ST24_4@1
  int newServerId; // ST20_4@1

  uid = BufferReader::ReadInt(&buffer);
  oldCharId = BufferReader::ReadInt(&buffer);
  oldServerId = BufferReader::ReadInt(&buffer);
  newCharId = BufferReader::ReadInt(&buffer);
  newServerId = BufferReader::ReadInt(&buffer);
  UserManager::moveCharacterToServer(uid, oldCharId, oldServerId, newCharId, newServerId);
  return 0;
}

//----- (00410448) --------------------------------------------------------
char __cdecl WorldSrvSocket::packet15_serverSelected(WorldSrvSocket *this, char *buffer)
{
  ServerInfo serverInfo_0; // [sp+Ch] [bp-130h]@4
  ServerInfo serverInfo_; // [sp+64h] [bp-D8h]@4
  ServerInfo serverInfo; // [sp+BCh] [bp-80h]@4
  int uid; // [sp+114h] [bp-28h]@1
  int v7; // [sp+118h] [bp-24h]@1
  SOCKET authSocket; // [sp+11Ch] [bp-20h]@1
  char serverId; // [sp+120h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+124h] [bp-18h]@1

  ms_exc.registration.TryLevel = 0;
  uid = BufferReader::ReadInt(&buffer);
  v7 = BufferReader::ReadInt(&buffer);
  serverId = BufferReader::ReadByte(&buffer);
  authSocket = UserManager::restartSomeTimer(&g_userManager, uid, true);
  if ( serverId >= 1 || serverId <= ServerList::getServerCount(&g_ServerList) )// TODO: && instead of ||
  {
    qmemcpy(&serverInfo_, ServersProvider::getServerInfo(&serverInfo_0, serverId), sizeof(serverInfo_));
    qmemcpy(&serverInfo, &serverInfo_, sizeof(serverInfo));
    if ( serverInfo.serverId <= 0 || serverInfo.kind & 0x80000000 )
      CAuthSocket::send(authSocket, aCc_9, LS_PlayFail, PLAY_FAIL_SOME_ERROR);
    else
      CAuthSocket::send(authSocket, aCddd, LS_ServerSelection, v7, serverInfo.outerIP, serverInfo.serverPort);
  }
  else
  {
    CAuthSocket::send(authSocket, aCc_8, LS_PlayFail, PLAY_FAIL_SOME_ERROR);
  }
  return 0;
}

//----- (004105CD) --------------------------------------------------------
char WorldSrvSocket::packet16_handler()
{
  return 0;
}

//----- (00410653) --------------------------------------------------------
char __cdecl WorldSrvSocket::packet17_userDropped(WorldSrvSocket *this, char *buffer)
{
  int uid; // ST1C_4@1

  uid = BufferReader::ReadInt(&buffer);
  BufferReader::ReadByte(&buffer);
  UserManager::removeUser(&g_userManager, uid);
  return 0;
}

//----- (0041070C) --------------------------------------------------------
char __cdecl WorldSrvSocket::packet18_updateGSStatus(WorldSrvSocket *this, char *buffer)
{
  ServerInfo v3; // [sp+8h] [bp-130h]@3
  ServerInfo serverInfo_; // [sp+60h] [bp-D8h]@3
  SqlQuery sql; // [sp+B8h] [bp-80h]@10
  ServerInfo serverInfo; // [sp+CCh] [bp-6Ch]@3
  char status; // [sp+124h] [bp-14h]@1
  char serverId; // [sp+128h] [bp-10h]@1
  int unused; // [sp+134h] [bp-4h]@10

  serverId = BufferReader::ReadByte(&buffer);
  status = BufferReader::ReadByte(&buffer);
  if ( serverId > 0 && serverId <= g_ServerList.m_serverNumber )
  {
    qmemcpy(&serverInfo_, ServersProvider::getServerInfo(&v3, serverId), sizeof(serverInfo_));
    qmemcpy(&serverInfo, &serverInfo_, sizeof(serverInfo));
    if ( serverInfo.serverId > 0 && serverInfo.serverId <= g_ServerList.m_serverNumber )
    {
      if ( !(serverInfo.kind & 0x80000000) || status )
      {
        if ( !status )
          UserManager::removeServer(&g_userManager, serverInfo.serverId);
        SqlQuery::SqlQuery(&sql, &g_dbManager);
        unused = 0;
        SqlQuery::exec(&sql, aUpdateWorlds_0, serverInfo.serverId, status);// serverID and status parameters missmatch in query?
        ServersProvider::setServerStatus(serverInfo.serverId, status);
        unused = -1;
        SqlQuery::Destructor(&sql);
      }
      else
      {
        LogWindow::Add(&g_LogWindow, 3, aDServeridIsMan, serverInfo.serverId);
      }
    }
  }
  return 0;
}

//----- (0041085B) --------------------------------------------------------
char __cdecl WorldSrvSocket::packet19_updateUsersNumber(WorldSrvSocket *this, char *buffer)
{
  int serverId_; // edx@1
  ServerInfo v4; // [sp+Ch] [bp-128h]@3
  ServerInfo serverInfo_; // [sp+64h] [bp-D0h]@3
  ServerInfo serverInfo; // [sp+BCh] [bp-78h]@3
  int usersNumber; // [sp+114h] [bp-20h]@1
  char serverId; // [sp+118h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+11Ch] [bp-18h]@1

  ms_exc.registration.TryLevel = 0;
  usersNumber = BufferReader::ReadInt(&buffer);
  serverId = BufferReader::ReadByte(&buffer);
  serverId_ = serverId;
  if ( serverId > 0 && serverId <= g_ServerList.m_serverNumber )
  {
    qmemcpy(&serverInfo_, ServersProvider::getServerInfo(&v4, serverId), sizeof(serverInfo_));
    qmemcpy(&serverInfo, &serverInfo_, sizeof(serverInfo));
    if ( serverInfo.serverId > 0 && serverInfo.serverId <= g_ServerList.m_serverNumber )
    {
      LOBYTE(serverId_) = serverInfo.serverId;
      ServersProvider::setUserNumber(serverInfo.outerIP, usersNumber, serverId_);
    }
  }
  return 0;
}

//----- (00410970) --------------------------------------------------------
char __cdecl WorldSrvSocket::packet20_getServerList(WorldSrvSocket *this)
{
  char packetBuffer[2048]; // [sp+Ch] [bp-824h]@2
  int unused2; // [sp+80Ch] [bp-24h]@1
  size_t size; // [sp+810h] [bp-20h]@1
  char *buffer; // [sp+814h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+818h] [bp-18h]@1

  size = 0;
  unused2 = 0;
  buffer = 0;
  ms_exc.registration.TryLevel = 0;
  if ( g_Config.Newserverlist )
  {
    size = ServerTable::getServerList(&g_serverTable, FrameType_DefaultOrCompressed, 0, &buffer);
    memcpy(packetBuffer, buffer, size);
  }
  else
  {
    size = g_ServerList.m_frameSizes[FrameType_DefaultOrCompressed];
    memcpy(packetBuffer, g_ServerList.m_frameLists[0], g_ServerList.m_frameSizes[0]);
  }
  packetBuffer[size] = 0;
  WorldSrvSocket::send(this, aCb_1, 9, size, packetBuffer);
  return 0;
}
// 410970: using guessed type char packetBuffer[2048];

//----- (00410A93) --------------------------------------------------------
signed int CAuthSocket::send(SOCKET socket, const char *format, ...)
{
  signed int result; // eax@2
  int size_1; // ST18_4@8
  CAuthSocket *gameClient; // [sp+0h] [bp-1Ch]@1
  char *packetBuffer; // [sp+8h] [bp-14h]@3
  int size; // [sp+Ch] [bp-10h]@3
  int size_; // [sp+10h] [bp-Ch]@8
  va_list ap; // [sp+14h] [bp-8h]@3
  CIOBuffer *buff; // [sp+18h] [bp-4h]@3
  va_list va; // [sp+2Ch] [bp+10h]@1

  va_start(va, format);
  gameClient = CAuthServer::getIOSocket(&g_authServer, socket);
  if ( gameClient )
  {
    buff = CIOBuffer::Alloc();
    packetBuffer = (char *)buff->m_Buffer;
    size = PacketUtils::VAssemble((char *)&buff->m_Buffer[2], 8190, format, va);
    ap = 0;
    if ( size )
      --size;
    else
      LogWindow::Add(&g_LogWindow, 3, aDAssembleTooLa, socket, format);
    if ( buff->m_Buffer[2] == LS_PlayOk )
      gameClient->m_clientLoginState = LoginState_AcceptedByGS;
    size_ = size + 1;
    gameClient->m_encrypt_handler(packetBuffer + 2, gameClient->m_xorKeySend, (int)&size_);
    size_1 = size_ + g_Config.PacketSizeType - 1;
    *packetBuffer = size_ + LOBYTE(g_Config.PacketSizeType) - 1;
    packetBuffer[1] = BYTE1(size_1);
    buff->m_dwSize = size_ + 2;
    CIOSocket::Write(&gameClient->base, buff);
    MemoryObject::Release(&gameClient->base.base);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00410BAB) --------------------------------------------------------
WorldSrvSocket *__thiscall WorldSrvSocket::WorldSrvSocket(WorldSrvSocket *this, SOCKET socket)
{
  WorldSrvSocket *this_; // ST04_4@1

  this_ = this;
  CIOSocket::CIOSocket(&this->m_base, socket);
  ThreadSafeMap::ThreadSafeMap(&this_->m_accsInUseMap);
  this_->m_base.base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&GameServSocket_vtable_off_45F484;
  this_->m_socket = socket;
  this_->m_worldSrvIP.S_un.S_addr = 0;
  this_->m_field_80 = 0;
  this_->m_socketStatus = SocketStatus_Init;
  this_->m_packetHandlers = WorldSrvSocket_handlers;
  this_->m_status = 0;
  return this_;
}
// 45F484: using guessed type int (__stdcall *GameServSocket_vtable_off_45F484)(int);

//----- (00410C4F) --------------------------------------------------------
MemoryObject *__thiscall WorldSrvSocket::Destructor(WorldSrvSocket *this)
{
  WorldSrvSocket *this_; // ST00_4@1

  this_ = this;
  this->m_base.base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&GameServSocket_vtable_off_45F484;
  ThreadSafeMap::Destructor(&this->m_accsInUseMap);
  return CIOSocket::Destructor(&this_->m_base);
}
// 45F484: using guessed type int (__stdcall *GameServSocket_vtable_off_45F484)(int);

//----- (00410CA3) --------------------------------------------------------
WorldSrvSocket *__cdecl WorldSrvSocket::Create(SOCKET socket)
{
  WorldSrvSocket *v2; // [sp+0h] [bp-18h]@2
  WorldSrvSocket *v3; // [sp+4h] [bp-14h]@1

  v3 = (WorldSrvSocket *)operator_new(0xB0u);
  if ( v3 )
    v2 = WorldSrvSocket::WorldSrvSocket(v3, socket);
  else
    v2 = 0;
  return v2;
}

//----- (00410D11) --------------------------------------------------------
void __thiscall WorldSrvSocket::OnClose(WorldSrvSocket *this)
{
  SOCKET v1; // ST24_4@1
  char *v2; // eax@1
  SOCKET v3; // ST28_4@1
  char *v4; // eax@1
  WorldSrvSocket *this_; // [sp+8h] [bp-4Ch]@1
  SqlQuery sql; // [sp+Ch] [bp-48h]@5
  tm now; // [sp+20h] [bp-34h]@1
  time_t time; // [sp+44h] [bp-10h]@1
  int unused; // [sp+50h] [bp-4h]@5

  this_ = this;
  this->m_socketStatus = SocketStatus_Closed;
  time = ::time(0);
  qmemcpy(&now, localtime(&time), sizeof(now));
  v1 = this_->m_socket;
  v2 = WorldSrvSocket::addrToStr(this_);
  LogWindow::Add(&g_LogWindow, 3, aCloseConnect_0, v2, v1, this_);
  v3 = this_->m_socket;
  v4 = WorldSrvSocket::addrToStr(this_);
  FileLog::write(
    &g_errLog,
    0,
    aDDDDDDMainServ,
    now.tm_year + 1900,
    now.tm_mon + 1,
    now.tm_mday,
    now.tm_hour,
    now.tm_min,
    now.tm_sec,
    v4,
    v3);
  if ( this_->m_serverID > 0 )
    UserManager::removeServer(&g_userManager, this_->m_serverID);
  if ( ServersProvider::updateServerAndGetServerID(this_->m_worldSrvIP.S_un.S_addr, this_->m_socket) > 0 )
    WorldSrvServer::removeServer(&g_worldServServer, this_->m_worldSrvIP.S_un.S_addr);
  SqlQuery::SqlQuery(&sql, &g_dbManager);
  unused = 0;
  SqlQuery::exec(&sql, aUpdateWorlds_1, this_->m_serverID);
  ServersProvider::setServerStatus(this_->m_serverID, 0);
  unused = -1;
  SqlQuery::Destructor(&sql);
}

//----- (00410E7A) --------------------------------------------------------
LONG __thiscall WorldSrvSocket::OnRead(WorldSrvSocket *this)
{
  LONG result; // eax@2
  WorldSrvPacket *packet; // ST20_4@16
  int errorNum; // ST10_4@20
  char *v4; // eax@20
  WorldSrvSocket *this_; // [sp+8h] [bp-40h]@1
  tm unused; // [sp+10h] [bp-38h]@20
  unsigned __int8 *buffer; // [sp+34h] [bp-14h]@1
  time_t unused2; // [sp+38h] [bp-10h]@20
  signed __int32 buffSize; // [sp+3Ch] [bp-Ch]@1
  int status; // [sp+40h] [bp-8h]@1
  DWORD packetSize; // [sp+44h] [bp-4h]@1

  this_ = this;
  packetSize = 0;
  buffSize = this->m_base.m_pReadBuf->m_dwSize;
  status = SocketStatus_Init;
  buffer = this->m_base.m_pReadBuf->m_Buffer;
  if ( this->m_socketStatus == SocketStatus_Closed )
  {
    result = CIOSocket::Close(&this->m_base);
  }
  else
  {
    while ( true )
    {
      while ( true )
      {
        if ( (signed int)packetSize >= buffSize )
        {
          packetSize = 0;
          return CIOSocket::Read(&this_->m_base, 0);
        }
        if ( this_->m_socketStatus )
          break;
        if ( (signed int)(packetSize + 3) > buffSize )
          return CIOSocket::Read(&this_->m_base, buffSize - packetSize);
        this_->m_codedPacketSize = buffer[packetSize] + (buffer[packetSize + 1] << 8) + 1 - g_Config.PacketSizeType;
        if ( this_->m_codedPacketSize <= 0 || this_->m_codedPacketSize > 0x2000 )
        {
          status = SocketStatus_BytesRead;
          LogWindow::Add(&g_LogWindow, 3, aDBadPacketSize, this_->m_socket, this_->m_codedPacketSize);
          goto LABEL_20;
        }
        packetSize += 2;
        this_->m_socketStatus = SocketStatus_BytesRead;
      }
      if ( this_->m_socketStatus != SocketStatus_BytesRead )
        break;
      if ( (signed int)(this_->m_codedPacketSize + packetSize) > buffSize )
        return CIOSocket::Read(&this_->m_base, buffSize - packetSize);
      if ( (signed int)buffer[packetSize] >= 22 )
      {
        LogWindow::Add(&g_LogWindow, 3, aUnknownProtoco, buffer[packetSize]);
        status = SocketStatus_Closed;
        goto LABEL_20;
      }
      packet = WorldSrvPacket::Alloc();
      packet->m_pSocket = (CIOSocket *)this_;
      packet->m_pBuf = this_->m_base.m_pReadBuf;
      packet->m_pFunc = (void (__cdecl *)(CAuthSocket *, char *))this_->m_packetHandlers[buffer[packetSize]];
      MemoryObject::AddRef(&this_->m_base.base);
      CIOBuffer::AddRef(this_->m_base.m_pReadBuf);
      InterlockedIncrement(&WorldSrvPacket::g_nPendingPacket);
      CPacket::PostObject(packet, packetSize, Threading::g_hCompletionPort);
      packetSize += this_->m_codedPacketSize;
      this_->m_socketStatus = SocketStatus_Init;
    }
    status = 3;
LABEL_20:
    unused2 = time(0);
    qmemcpy(&unused, localtime(&unused2), sizeof(unused));
    errorNum = status;
    v4 = WorldSrvSocket::addrToStr(this_);
    FileLog::write(&g_errLog, 0, aMainServerConn, v4, errorNum);
    result = CIOSocket::Close(&this_->m_base);
  }
  return result;
}

//----- (00411108) --------------------------------------------------------
char *__thiscall WorldSrvSocket::addrToStr(WorldSrvSocket *this)
{
  return inet_ntoa(this->m_worldSrvIP);
}

//----- (00411123) --------------------------------------------------------
void __thiscall WorldSrvSocket::OnCreate(WorldSrvSocket *this)
{
  WorldSrvSocket *this_; // ST14_4@1

  this_ = this;
  MemoryObject::AddRef(&this->m_base.base);
  this_->m_base.base.vftbl_0_45F520->derived_func_9((CIOSocket *)this_);
  WorldSrvSocket::send(this_, aCdd, 3, g_buildNumber, 1);
}

//----- (0041115C) --------------------------------------------------------
void __thiscall WorldSrvSocket::setIPAddress(WorldSrvSocket *this, in_addr ipAddress)
{
  WorldSrvSocket *this_; // [sp+0h] [bp-24h]@1
  SqlQuery sql; // [sp+4h] [bp-20h]@2
  int v4; // [sp+20h] [bp-4h]@2

  this_ = this;
  this->m_worldSrvIP = ipAddress;
  if ( !g_Config.Supportreconne )
  {
    SqlQuery::SqlQuery(&sql, &g_dbManager);
    v4 = 0;
    SqlQuery::exec(&sql, aUpdateWorlds_2, this_->m_serverID);
    ServersProvider::setServerStatus(this_->m_serverID, true);
    LOBYTE(this_->m_gsStatus_unused) = 1;
    v4 = -1;
    SqlQuery::Destructor(&sql);
  }
}

//----- (004111F6) --------------------------------------------------------
void WorldSrvSocket::send(WorldSrvSocket *this, char *format, ...)
{
  int size; // [sp+4h] [bp-Ch]@2
  CIOBuffer *buff; // [sp+Ch] [bp-4h]@2
  va_list va; // [sp+20h] [bp+10h]@1

  va_start(va, format);
  if ( this->m_socketStatus != SocketStatus_Closed )
  {
    buff = CIOBuffer::Alloc();
    size = PacketUtils::VAssemble((char *)&buff->m_Buffer[2], 8190, format, va);
    if ( size )
    {
      size = g_Config.PacketSizeType + size - 1;
      buff->m_Buffer[0] = size;
      buff->m_Buffer[1] = BYTE1(size);
    }
    else
    {
      LogWindow::Add(&g_LogWindow, 3, aDAssembleToo_0, this->m_socket, format);
    }
    buff->m_dwSize = size + 3 - g_Config.PacketSizeType;
    CIOSocket::Write(&this->m_base, buff);
  }
}

//----- (004112BF) --------------------------------------------------------
char __thiscall ThreadSafeMap::insert(ThreadSafeMap *this, int uid, char *accName)
{
  ThreadSafeMap *this_; // ST10_4@1
  struct Concurrency::IExecutionContext *pair; // eax@1
  char v6; // [sp+Ch] [bp-40h]@1
  char v7; // [sp+10h] [bp-3Ch]@1
  char v8; // [sp+20h] [bp-2Ch]@1
  int a2; // [sp+34h] [bp-18h]@1
  char v10; // [sp+38h] [bp-14h]@1
  char v11; // [sp+3Ch] [bp-10h]@1
  int v12; // [sp+48h] [bp-4h]@1

  this_ = this;
  v11 = 0;
  SpinLock::Enter(&this->lock);
  std::string::string_2((std::string *)&v7, accName, (int)&v6);
  v12 = 0;
  pair = (struct Concurrency::IExecutionContext *)unknown_libname_55((int)&v8, &uid, (int)&v7);
  LOBYTE(v12) = 1;
  std::map_uid_acc::insert(&this_->map, (int)&a2, pair);
  LOBYTE(v12) = 0;
  unknown_libname_53((int)&v8);
  v12 = -1;
  std::string::destructor(&v7);
  SpinLock::Leave(&this_->lock);
  return v10;
}

//----- (0041136F) --------------------------------------------------------
char __thiscall ThreadSafeMap::dumpKickedUsers(ThreadSafeMap *this, WorldSrvSocket *socket)
{
  std::_tree_uid_acc::iterator *end; // eax@2
  int string; // eax@3
  char *accName_temp; // eax@3
  ThreadSafeMap *this_; // [sp+0h] [bp-2Ch]@1
  std::_tree_uid_acc::iterator v7; // [sp+4h] [bp-28h]@2
  int v8; // [sp+8h] [bp-24h]@5
  std::_tree_uid_acc::iterator *a2; // [sp+Ch] [bp-20h]@1
  std::_tree_uid_acc::iterator it; // [sp+10h] [bp-1Ch]@1
  int uid; // [sp+14h] [bp-18h]@1
  char accName[15]; // [sp+18h] [bp-14h]@3
  char v13; // [sp+28h] [bp-4h]@1

  this_ = this;
  v13 = 0;
  unknown_libname_56(&it);
  uid = 0;
  SpinLock::Enter(&this_->lock);
  for ( it._Ptr = std::map_uid_acc::begin(&this_->map, (std::_tree_uid_acc::iterator *)&a2)->_Ptr;
        ;
        std::_tree_uid_acc::iterator::post_increment(&it, &v8, 0) )
  {
    end = std::map_uid_acc::end(&this_->map, &v7);
    if ( !(unsigned __int8)std::_tree_uid_acc::iterator::not_equal(&it, end) )
      break;
    uid = 0;
    uid = *(_DWORD *)std::_tree_uid_acc::iterator::value(&it);
    memset(accName, 0, 15u);
    string = std::_tree_uid_acc::iterator::value(&it);
    accName_temp = std::string::c_str((std::string *)(string + 4));
    strncpy(accName, accName_temp, 14u);
    if ( uid > 0 )
      WorldSrvSocket::send(socket, aCdcs_6, 1, uid, 14, accName);
  }
  std::map_uid_acc::clear(&this_->map);
  SpinLock::Leave(&this_->lock);
  return v13;
}

//----- (0041145E) --------------------------------------------------------
int SomeStaticInit9()
{
  SomeBitsInit();
  return sub_41146D();
}

//----- (0041146D) --------------------------------------------------------
int sub_41146D()
{
  return atexit(emptystub);
}

//----- (00411480) --------------------------------------------------------
int __cdecl BufferReader::ReadInt(char **buffer)
{
  int result_1; // ST00_4@1

  result_1 = *(_DWORD *)*buffer;
  *buffer += 4;
  return result_1;
}

//----- (004114B0) --------------------------------------------------------
char __cdecl BufferReader::ReadByte(char **buffer)
{
  return *(*buffer)++;
}

//----- (004114E0) --------------------------------------------------------
__int16 __cdecl BufferReader::ReadShort(char **buffer)
{
  __int16 result_1; // ST00_2@1

  result_1 = *(_WORD *)*buffer;
  *buffer += 2;
  return result_1;
}

//----- (00411510) --------------------------------------------------------
int __thiscall WorldSrvSocket::getWorldServerIp(WorldSrvSocket *this, _DWORD *a2)
{
  *a2 = this->m_worldSrvIP.S_un.S_addr;
  return (int)a2;
}

//----- (00411530) --------------------------------------------------------
int __cdecl BufferReader::ReadUInt(char **buffer)
{
  int result_1; // ST00_4@1

  result_1 = *(_DWORD *)*buffer;
  *buffer += 4;
  return result_1;
}

//----- (00411560) --------------------------------------------------------
char **__cdecl BufferReader::ReadString(char **buffer, signed int size, char *out)
{
  char *end; // edx@1
  char **result; // eax@1

  end = &(*buffer)[BufferReader::copyStrBuffer(out, *buffer, size)];
  result = buffer;
  *buffer = end;
  return result;
}

//----- (00411590) --------------------------------------------------------
int __thiscall ServerList::getServerCount(ServerList *this)
{
  return this->m_serverNumber;
}

//----- (004115B0) --------------------------------------------------------
ThreadSafeMap *__thiscall ThreadSafeMap::ThreadSafeMap(ThreadSafeMap *this)
{
  ThreadSafeMap *this_; // ST08_4@1
  char v3; // [sp+4h] [bp-14h]@1
  char v4; // [sp+8h] [bp-10h]@1
  int v5; // [sp+14h] [bp-4h]@1

  this_ = this;
  sub_411710(&this->map, &v3, &v4);
  v5 = 0;
  SpinLock::SpinLock(&this_->lock, LockType_CritSection, 0);
  return this_;
}

//----- (00411650) --------------------------------------------------------
WorldSrvSocket *__thiscall WorldSrvSocket::CallDtor(WorldSrvSocket *this, char a2)
{
  WorldSrvSocket *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  WorldSrvSocket::Destructor(this);
  if ( a2 & 1 )
    operator_delete(v3);
  return v3;
}

//----- (00411680) --------------------------------------------------------
void __thiscall ThreadSafeMap::Destructor(ThreadSafeMap *this)
{
  ThreadSafeMap *v1; // ST00_4@1

  v1 = this;
  SpinLock::Destructor(&this->lock);
  std::map_uid_acc::destructor(&v1->map);
}

//----- (004116D0) --------------------------------------------------------
LONG __thiscall CIOBuffer::AddRef(CIOBuffer *this)
{
  return InterlockedIncrement(&this->m_nRefCount);
}

//----- (00411710) --------------------------------------------------------
std::map_uid_acc *__thiscall sub_411710(std::map_uid_acc *this, _BYTE *a2, _BYTE *a3)
{
  std::map_uid_acc *v3; // ST08_4@1

  v3 = this;
  std::map_uid_acc::map_uid_acc(this, a2, a3);
  return v3;
}

//----- (00411730) --------------------------------------------------------
std::_tree_uid_acc::iterator *__thiscall std::map_uid_acc::begin(std::map_uid_acc *this, std::_tree_uid_acc::iterator *a2)
{
  std::_tree_uid_acc1::begin(&this->_Tr, a2);
  return a2;
}

//----- (00411750) --------------------------------------------------------
std::_tree_uid_acc::iterator *__thiscall std::map_uid_acc::end(std::map_uid_acc *this, std::_tree_uid_acc::iterator *a2)
{
  std::_tree_uid_acc1::end(&this->_Tr, a2);
  return a2;
}

//----- (00411770) --------------------------------------------------------
int __thiscall std::map_uid_acc::insert(std::map_uid_acc *this, int a2, struct Concurrency::IExecutionContext *a3)
{
  int v4; // [sp+4h] [bp-8h]@1
  char v5; // [sp+8h] [bp-4h]@1

  std::_tree_uid_acc1::insert3(&this->_Tr, (int)&v4, a3);
  sub_411D70(a2, &v4, &v5);
  return a2;
}

//----- (004117D0) --------------------------------------------------------
void __thiscall sub_4117D0(std::_tree *this)
{
  std::_tree_uid_acc1 *v1; // ST0C_4@1
  std::_tree_uid_acc::_Node *v2; // ST08_4@1
  int *v3; // eax@1
  char v4; // [sp+4h] [bp-14h]@1
  char a2; // [sp+8h] [bp-10h]@1
  char v6; // [sp+Ch] [bp-Ch]@1
  char v7; // [sp+10h] [bp-8h]@1
  void *v8; // [sp+14h] [bp-4h]@1

  v1 = (std::_tree_uid_acc1 *)this;
  v2 = std::_tree_uid_acc1::end((std::_tree_uid_acc1 *)this, (std::_tree_uid_acc::iterator *)&v6)->_Ptr;
  v3 = (int *)std::_tree_uid_acc1::begin(v1, (std::_tree_uid_acc::iterator *)&a2);
  std::_tree_uid_acc1::erase(v1, &v4, *v3, (char)v2);
  std::_tree_uid_acc1::_Freenode(v1->_Head);
  v1->_Head = 0;
  v1->_Size = 0;
  v8 = 0;
  std::_Lockit::_Lockit((std::_Lockit *)&v7);
  if ( !--std::_tree_uid_acc1::_Nilrefs )
  {
    v8 = std::_tree_uid_acc1::_Nil;
    std::_tree_uid_acc1::_Nil = 0;
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v7);
  if ( v8 )
    std::_tree_uid_acc1::_Freenode((std::_tree_uid_acc::_Node *)v8);
}
// 478600: using guessed type int std::_tree_uid_acc1::_Nilrefs;

//----- (004118F0) --------------------------------------------------------
_DWORD *__thiscall std::_tree_uid_acc::iterator::post_increment(std::_tree_uid_acc::iterator *this, _DWORD *a2, int a3)
{
  std::_tree_uid_acc::_Node *v3; // ST04_4@1

  v3 = this->_Ptr;
  unknown_libname_59(this);
  *a2 = v3;
  return a2;
}

//----- (00411920) --------------------------------------------------------
BOOL __thiscall std::_tree_uid_acc::iterator::not_equal(void *this, _DWORD *a2)
{
  return (unsigned __int8)std::_tree_uid_acc::iterator::iterator_operator_eq(this, a2) == 0;
}

//----- (00411950) --------------------------------------------------------
std::map_uid_acc *__thiscall std::map_uid_acc::map_uid_acc(std::map_uid_acc *this, _BYTE *a2, _BYTE *a3)
{
  std::map_uid_acc *v3; // ST0C_4@1

  v3 = this;
  std::_tree_uid_acc1::_tree_uid_acc1(&this->_Tr, a2, 0, a3);
  return v3;
}

//----- (00411980) --------------------------------------------------------
std::_tree_uid_acc::iterator *__thiscall std::_tree_uid_acc1::begin(std::_tree_uid_acc1 *this, std::_tree_uid_acc::iterator *a2)
{
  std::_tree_uid_acc::_Node *v2; // eax@1

  v2 = std::_tree_uid_acc1::_Lmost(this);
  std::_tree_uid_acc::iterator::iterator(a2, v2->_Left);
  return a2;
}

//----- (004119B0) --------------------------------------------------------
std::_tree_uid_acc::iterator *__thiscall std::_tree_uid_acc1::end(std::_tree_uid_acc1 *this, std::_tree_uid_acc::iterator *a2)
{
  std::_tree_uid_acc::iterator::iterator(a2, this->_Head);
  return a2;
}

//----- (004119D0) --------------------------------------------------------
int __thiscall std::_tree_uid_acc1::insert3(std::_tree_uid_acc1 *this, int a2, struct Concurrency::IExecutionContext *a3)
{
  struct Concurrency::details::InternalContextBase *v3; // ST10_4@3
  struct Concurrency::details::InternalContextBase *v4; // eax@3
  _DWORD *v5; // eax@8
  int result; // eax@8
  std::_tree_uid_acc::iterator *v7; // eax@10
  _DWORD *v8; // eax@11
  struct Concurrency::details::InternalContextBase *v9; // ST10_4@13
  int v10; // eax@13
  struct Concurrency::details::InternalContextBase *v11; // eax@13
  _DWORD *v12; // eax@14
  std::_tree_uid_acc::_Node *v13; // [sp+0h] [bp-40h]@4
  std::_tree_uid_acc1 *this_; // [sp+4h] [bp-3Ch]@1
  char v15; // [sp+8h] [bp-38h]@15
  int v16; // [sp+Ch] [bp-34h]@14
  char v17; // [sp+10h] [bp-30h]@14
  int v18; // [sp+18h] [bp-28h]@11
  char v19; // [sp+1Ch] [bp-24h]@11
  int a2a; // [sp+20h] [bp-20h]@10
  int v21; // [sp+24h] [bp-1Ch]@8
  char v22; // [sp+28h] [bp-18h]@8
  std::_tree_uid_acc::_Node *_Y; // [sp+30h] [bp-10h]@1
  std::_tree_uid_acc::_Node *_X; // [sp+34h] [bp-Ch]@1
  int v25; // [sp+38h] [bp-8h]@1
  std::_tree_uid_acc::iterator v26; // [sp+3Ch] [bp-4h]@9

  this_ = this;
  _X = std::_tree_uid_acc1::_Root_const(this)->_Left;
  _Y = this_->_Head;
  LOBYTE(v25) = 1;
  while ( _X != std::_tree_uid_acc1::_Nil )
  {
    _Y = _X;
    v3 = std::_tree_uid_acc1::_Key((int)_X);
    v4 = std::_tree_uid_acc1::_Kfn(a3);
    LOBYTE(v25) = std::_tree::key_compare(v4, v3);
    if ( (_BYTE)v25 )
      v13 = std::_tree_uid_acc::_Left(_X)->_Left;
    else
      v13 = std::_tree_uid_acc::_Right(_X)->_Left;
    _X = v13;
  }
  if ( this_->_Multi )
  {
    v22 = 1;
    v5 = (_DWORD *)std::_tree_uid_acc1::_Insert(this_, (int)&v21, (int)_X, (int)_Y, a3);
    sub_411D70(a2, v5, &v22);
    return a2;
  }
  std::_tree_uid_acc::iterator::iterator(&v26, _Y);
  if ( (_BYTE)v25 )
  {
    v7 = std::_tree_uid_acc1::begin(this_, (std::_tree_uid_acc::iterator *)&a2a);
    if ( (unsigned __int8)std::_tree_uid_acc::iterator::iterator_operator_eq(&v26, v7) )
    {
      v19 = 1;
      v8 = (_DWORD *)std::_tree_uid_acc1::_Insert(this_, (int)&v18, (int)_X, (int)_Y, a3);
      sub_411D70(a2, v8, &v19);
      return a2;
    }
    unknown_libname_64(&v26);
  }
  v9 = std::_tree_uid_acc1::_Kfn(a3);
  v10 = unknown_libname_62(&v26);
  v11 = std::_tree_uid_acc1::_Key(v10);
  if ( (unsigned __int8)std::_tree::key_compare(v11, v9) )
  {
    v17 = 1;
    v12 = (_DWORD *)std::_tree_uid_acc1::_Insert(this_, (int)&v16, (int)_X, (int)_Y, a3);
    sub_411D70(a2, v12, &v17);
    result = a2;
  }
  else
  {
    v15 = 0;
    sub_411D70(a2, &v26, &v15);
    result = a2;
  }
  return result;
}
// 412CC0: using guessed type int __thiscall unknown_libname_62(_DWORD);
// 412CF0: using guessed type int __thiscall unknown_libname_64(_DWORD);

//----- (00411BA0) --------------------------------------------------------
_DWORD *__thiscall std::_tree_uid_acc1::erase(std::_tree_uid_acc1 *this, _DWORD *a2, int a3, char a4)
{
  std::_tree_uid_acc::iterator *v4; // eax@2
  std::_tree_uid_acc::iterator *v5; // eax@3
  int *v6; // eax@5
  _DWORD *result; // eax@6
  std::_tree_uid_acc::_Node *v8; // eax@7
  std::_tree_uid_acc1 *v9; // [sp+0h] [bp-14h]@1
  char v10; // [sp+4h] [bp-10h]@5
  int v11; // [sp+8h] [bp-Ch]@5
  std::_tree_uid_acc::iterator v12; // [sp+Ch] [bp-8h]@3
  char a2a; // [sp+10h] [bp-4h]@2

  v9 = this;
  if ( !std::_tree_uid_acc1::size((int)this)
    || (v4 = std::_tree_uid_acc1::begin(v9, (std::_tree_uid_acc::iterator *)&a2a),
        (unsigned __int8)std::_tree_uid_acc::iterator::not_equal(&a3, v4))
    || (v5 = std::_tree_uid_acc1::end(v9, &v12), (unsigned __int8)std::_tree_uid_acc::iterator::not_equal(&a4, v5)) )
  {
    while ( (unsigned __int8)std::_tree_uid_acc::iterator::not_equal(&a3, &a4) )
    {
      v6 = std::_tree_uid_acc::iterator::post_increment((std::_tree_uid_acc::iterator *)&a3, &v11, 0);
      std::_tree_uid_acc1::erase2((std::_tree *)v9, &v10, *v6);
    }
    *a2 = a3;
    result = a2;
  }
  else
  {
    v8 = std::_tree_uid_acc1::_Root_const(v9);
    sub_4126B0((std::_tree *)v9, v8->_Left);
    std::_tree_uid_acc1::_Root_const(v9)->_Left = std::_tree_uid_acc1::_Nil;
    v9->_Size = 0;
    std::_tree_uid_acc1::_Lmost(v9)->_Left = v9->_Head;
    std::_tree_uid_acc1::_Rmost(v9)->_Left = v9->_Head;
    std::_tree_uid_acc1::begin(v9, (std::_tree_uid_acc::iterator *)a2);
    result = a2;
  }
  return result;
}

//----- (00411CA0) --------------------------------------------------------
_DWORD *__thiscall std::_tree_uid_acc1::clear(std::_tree_uid_acc1 *this)
{
  std::_tree_uid_acc1 *v1; // ST0C_4@1
  std::_tree_uid_acc::_Node *v2; // ST08_4@1
  int *v3; // eax@1
  char v5; // [sp+4h] [bp-Ch]@1
  char a2; // [sp+8h] [bp-8h]@1
  std::_tree_uid_acc::iterator v7; // [sp+Ch] [bp-4h]@1

  v1 = this;
  v2 = std::_tree_uid_acc1::end(this, &v7)->_Ptr;
  v3 = (int *)std::_tree_uid_acc1::begin(v1, (std::_tree_uid_acc::iterator *)&a2);
  return std::_tree_uid_acc1::erase(v1, &v5, *v3, (char)v2);
}

//----- (00411D10) --------------------------------------------------------
void **__thiscall sub_411D10(std::_tree_uid_acc::iterator *this)
{
  return sub_411DF0(this->_Ptr);
}

//----- (00411D50) --------------------------------------------------------
BOOL __thiscall std::_tree_uid_acc::iterator::iterator_operator_eq(void *this, _DWORD *a2)
{
  return *(_DWORD *)this == *a2;
}

//----- (00411D70) --------------------------------------------------------
int __thiscall sub_411D70(int this, _DWORD *a2, _BYTE *a3)
{
  *(_DWORD *)this = *a2;
  *(_BYTE *)(this + 4) = *a3;
  return this;
}

//----- (00411DB0) --------------------------------------------------------
struct Concurrency::details::InternalContextBase *__cdecl std::_tree_uid_acc1::_Key(int a1)
{
  void **v1; // eax@1

  v1 = sub_411DF0((std::_tree_uid_acc::_Node *)a1);
  return std::_tree_uid_acc1::_Kfn((struct Concurrency::IExecutionContext *)v1);
}

//----- (00411DE0) --------------------------------------------------------
std::_tree_uid_acc::_Node *__cdecl std::_tree_uid_acc::_Right(std::_tree_uid_acc::_Node *a1)
{
  return (std::_tree_uid_acc::_Node *)((char *)a1 + 8);
}

//----- (00411DF0) --------------------------------------------------------
void **__cdecl sub_411DF0(std::_tree_uid_acc::_Node *a1)
{
  return &a1->_Value;
}

//----- (00411E00) --------------------------------------------------------
std::_tree_uid_acc1 *__thiscall std::_tree_uid_acc1::_tree_uid_acc1(std::_tree_uid_acc1 *this, _BYTE *a2, char a3, _BYTE *a4)
{
  std::_tree_uid_acc1 *v4; // ST00_4@1

  v4 = this;
  this->allocator = *a4;
  this->keyComparer = *a2;
  this->_Multi = a3;
  std::_tree_uid_acc1::_Init(this);
  return v4;
}

//----- (00411E60) --------------------------------------------------------
_DWORD *__thiscall std::_tree_uid_acc1::erase2(std::_tree *this, _DWORD *a2, int a3)
{
  _DWORD *v3; // eax@1
  int *v4; // eax@5
  std::_tree_uid_acc1 **v5; // eax@7
  std::_tree_uid_acc::_Node *v6; // eax@7
  std::_tree_uid_acc::_Node *v7; // esi@7
  std::_tree_uid_acc::_Node *v8; // eax@7
  std::_tree_uid_acc::_Node *v9; // eax@8
  std::_tree_uid_acc::_Node *v10; // esi@9
  std::_tree_uid_acc::_Node *v11; // eax@9
  std::_tree_uid_acc::_Node *v12; // eax@9
  std::_tree_uid_acc::_Node *v13; // esi@9
  std::_tree_uid_acc1 **v14; // eax@9
  std::_tree_uid_acc::_Node *v15; // eax@9
  std::_tree_uid_acc::_Node *v16; // eax@10
  std::_tree_uid_acc::_Node *v17; // eax@11
  std::_tree_uid_acc::_Node *v18; // eax@12
  std::_tree_uid_acc::_Node *v19; // eax@12
  std::_tree_uid_acc::_Node *v20; // eax@13
  std::_tree_uid_acc::_Node *v21; // eax@13
  std::_tree_uid_acc::_Node *v22; // eax@14
  std::_tree_uid_acc::_Node *v23; // eax@14
  std::_tree_uid_acc::_Node *v24; // esi@15
  int *v25; // ST04_4@15
  int *v26; // eax@15
  std::_tree_uid_acc::_Node *v27; // esi@16
  std::_tree_uid_acc::_Node *v28; // eax@16
  std::_tree_uid_acc::_Node *v29; // eax@17
  std::_tree_uid_acc::_Node *v30; // eax@18
  std::_tree_uid_acc::_Node *v31; // eax@18
  std::_tree_uid_acc::_Node *v32; // eax@19
  std::_tree_uid_acc::_Node *v33; // eax@19
  std::_tree_uid_acc::_Node *v34; // eax@20
  std::_tree_uid_acc::_Node *v35; // eax@20
  std::_tree_uid_acc::_Node *v36; // eax@21
  std::_tree_uid_acc::_Node *v37; // esi@23
  std::_tree_uid_acc::_Node *v38; // esi@24
  std::_tree_uid_acc::_Node *v39; // eax@25
  std::_tree_uid_acc::_Node *v40; // esi@27
  std::_tree_uid_acc::_Node *v41; // esi@28
  std::_tree_uid_acc::_Node *v42; // eax@30
  std::_tree_uid_acc::_Node *v43; // eax@32
  std::_tree_uid_acc::_Node *v44; // eax@32
  std::_tree_uid_acc::_Node *v45; // eax@33
  int *v46; // eax@34
  int *v47; // eax@34
  std::_tree_uid_acc::_Node *v48; // eax@34
  int *v49; // eax@35
  int *v50; // eax@36
  int *v51; // eax@38
  int *v52; // eax@39
  std::_tree_uid_acc::_Node *v53; // eax@39
  int *v54; // eax@40
  _DWORD *v55; // esi@40
  int *v56; // eax@40
  int *v57; // eax@40
  int *v58; // eax@40
  std::_tree_uid_acc::_Node *v59; // eax@41
  int *v60; // eax@42
  int *v61; // eax@42
  std::_tree_uid_acc::_Node *v62; // eax@42
  int *v63; // eax@43
  int *v64; // eax@44
  int *v65; // eax@46
  int *v66; // eax@47
  std::_tree_uid_acc::_Node *v67; // eax@47
  int *v68; // eax@48
  _DWORD *v69; // esi@48
  int *v70; // eax@48
  int *v71; // eax@48
  int *v72; // eax@48
  void **v73; // eax@51
  std::_tree *v75; // [sp+4h] [bp-2Ch]@1
  char v76; // [sp+8h] [bp-28h]@1
  std::_tree_uid_acc::_Node *v77; // [sp+Ch] [bp-24h]@41
  std::_tree_uid_acc::_Node *v78; // [sp+10h] [bp-20h]@33
  char v79; // [sp+14h] [bp-1Ch]@6
  std::_tree_uid_acc::_Node *v80; // [sp+18h] [bp-18h]@1
  std::_tree_uid_acc::_Node *a1; // [sp+1Ch] [bp-14h]@1
  std::_tree_uid_acc::_Node *v82; // [sp+20h] [bp-10h]@2
  int v83; // [sp+2Ch] [bp-4h]@6

  v75 = this;
  v3 = std::_tree_uid_acc::iterator::post_increment((std::_tree_uid_acc::iterator *)&a3, &v76, 0);
  a1 = (std::_tree_uid_acc::_Node *)unknown_libname_62(v3);
  v80 = a1;
  if ( std::_tree_uid_acc::_Left(a1)->_Left == std::_tree_uid_acc1::_Nil )
  {
    v82 = std::_tree_uid_acc::_Right(a1)->_Left;
  }
  else if ( std::_tree_uid_acc::_Right(a1)->_Left == std::_tree_uid_acc1::_Nil )
  {
    v82 = std::_tree_uid_acc::_Left(a1)->_Left;
  }
  else
  {
    v4 = (int *)std::_tree_uid_acc::_Right(a1);
    a1 = (std::_tree_uid_acc::_Node *)sub_412FA0(*v4);
    v82 = std::_tree_uid_acc::_Right(a1)->_Left;
  }
  std::_Lockit::_Lockit((std::_Lockit *)&v79);
  v83 = 0;
  if ( a1 == v80 )
  {
    v27 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)a1);
    std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v82)->_Left = v27->_Left;
    v28 = std::_tree_uid_acc1::_Root_const((std::_tree_uid_acc1 *)v75);
    if ( v28->_Left == v80 )
    {
      v29 = std::_tree_uid_acc1::_Root_const((std::_tree_uid_acc1 *)v75);
      v29->_Left = v82;
    }
    else
    {
      v30 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v80);
      v31 = std::_tree_uid_acc::_Left(v30->_Left);
      if ( v31->_Left == v80 )
      {
        v32 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v80);
        v33 = std::_tree_uid_acc::_Left(v32->_Left);
        v33->_Left = v82;
      }
      else
      {
        v34 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v80);
        v35 = std::_tree_uid_acc::_Right(v34->_Left);
        v35->_Left = v82;
      }
    }
    v36 = std::_tree_uid_acc1::_Lmost((std::_tree_uid_acc1 *)v75);
    if ( v36->_Left == v80 )
    {
      if ( std::_tree_uid_acc::_Right(v80)->_Left == std::_tree_uid_acc1::_Nil )
      {
        v37 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v80);
        std::_tree_uid_acc1::_Lmost((std::_tree_uid_acc1 *)v75)->_Left = v37->_Left;
      }
      else
      {
        v38 = (std::_tree_uid_acc::_Node *)sub_412FA0((int)v82);
        std::_tree_uid_acc1::_Lmost((std::_tree_uid_acc1 *)v75)->_Left = v38;
      }
    }
    v39 = std::_tree_uid_acc1::_Rmost((std::_tree_uid_acc1 *)v75);
    if ( v39->_Left == v80 )
    {
      if ( std::_tree_uid_acc::_Left(v80)->_Left == std::_tree_uid_acc1::_Nil )
      {
        v40 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v80);
        std::_tree_uid_acc1::_Rmost((std::_tree_uid_acc1 *)v75)->_Left = v40->_Left;
      }
      else
      {
        v41 = (std::_tree_uid_acc::_Node *)sub_412F60((int)v82);
        std::_tree_uid_acc1::_Rmost((std::_tree_uid_acc1 *)v75)->_Left = v41;
      }
    }
  }
  else
  {
    v5 = (std::_tree_uid_acc1 **)std::_tree_uid_acc::_Left(v80);
    v6 = std::_tree_uid_acc1::_Parent(*v5);
    v6->_Left = a1;
    v7 = std::_tree_uid_acc::_Left(v80);
    std::_tree_uid_acc::_Left(a1)->_Left = v7->_Left;
    v8 = std::_tree_uid_acc::_Right(v80);
    if ( a1 == v8->_Left )
    {
      v9 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v82);
      v9->_Left = a1;
    }
    else
    {
      v10 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)a1);
      std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v82)->_Left = v10->_Left;
      v11 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)a1);
      v12 = std::_tree_uid_acc::_Left(v11->_Left);
      v12->_Left = v82;
      v13 = std::_tree_uid_acc::_Right(v80);
      std::_tree_uid_acc::_Right(a1)->_Left = v13->_Left;
      v14 = (std::_tree_uid_acc1 **)std::_tree_uid_acc::_Right(v80);
      v15 = std::_tree_uid_acc1::_Parent(*v14);
      v15->_Left = a1;
    }
    v16 = std::_tree_uid_acc1::_Root_const((std::_tree_uid_acc1 *)v75);
    if ( v16->_Left == v80 )
    {
      v17 = std::_tree_uid_acc1::_Root_const((std::_tree_uid_acc1 *)v75);
      v17->_Left = a1;
    }
    else
    {
      v18 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v80);
      v19 = std::_tree_uid_acc::_Left(v18->_Left);
      if ( v19->_Left == v80 )
      {
        v20 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v80);
        v21 = std::_tree_uid_acc::_Left(v20->_Left);
        v21->_Left = a1;
      }
      else
      {
        v22 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v80);
        v23 = std::_tree_uid_acc::_Right(v22->_Left);
        v23->_Left = a1;
      }
    }
    v24 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v80);
    std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)a1)->_Left = v24->_Left;
    v25 = (int *)_tolower((int)v80);
    v26 = (int *)_tolower((int)a1);
    sub_413290(v26, v25);
    a1 = v80;
  }
  if ( *(_DWORD *)_tolower((int)a1) == 1 )
  {
    while ( 1 )
    {
      v42 = std::_tree_uid_acc1::_Root_const((std::_tree_uid_acc1 *)v75);
      if ( v82 == v42->_Left || *(_DWORD *)_tolower((int)v82) != 1 )
        break;
      v43 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v82);
      v44 = std::_tree_uid_acc::_Left(v43->_Left);
      if ( v82 == v44->_Left )
      {
        v45 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v82);
        v78 = std::_tree_uid_acc::_Right(v45->_Left)->_Left;
        if ( !*(_DWORD *)_tolower((int)v78) )
        {
          *(_DWORD *)_tolower((int)v78) = 1;
          v46 = (int *)std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v82);
          *(_DWORD *)_tolower(*v46) = 0;
          v47 = (int *)std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v82);
          sub_412E30(v75, *v47);
          v48 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v82);
          v78 = std::_tree_uid_acc::_Right(v48->_Left)->_Left;
        }
        v49 = (int *)std::_tree_uid_acc::_Left(v78);
        if ( *(_DWORD *)_tolower(*v49) != 1
          || (v50 = (int *)std::_tree_uid_acc::_Right(v78), *(_DWORD *)_tolower(*v50) != 1) )
        {
          v51 = (int *)std::_tree_uid_acc::_Right(v78);
          if ( *(_DWORD *)_tolower(*v51) == 1 )
          {
            v52 = (int *)std::_tree_uid_acc::_Left(v78);
            *(_DWORD *)_tolower(*v52) = 1;
            *(_DWORD *)_tolower((int)v78) = 0;
            sub_412FE0(v75, (int)v78);
            v53 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v82);
            v78 = std::_tree_uid_acc::_Right(v53->_Left)->_Left;
          }
          v54 = (int *)std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v82);
          v55 = (_DWORD *)_tolower(*v54);
          *(_DWORD *)_tolower((int)v78) = *v55;
          v56 = (int *)std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v82);
          *(_DWORD *)_tolower(*v56) = 1;
          v57 = (int *)std::_tree_uid_acc::_Right(v78);
          *(_DWORD *)_tolower(*v57) = 1;
          v58 = (int *)std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v82);
          sub_412E30(v75, *v58);
          break;
        }
        *(_DWORD *)_tolower((int)v78) = 0;
        v82 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v82)->_Left;
      }
      else
      {
        v59 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v82);
        v77 = std::_tree_uid_acc::_Left(v59->_Left)->_Left;
        if ( !*(_DWORD *)_tolower((int)v77) )
        {
          *(_DWORD *)_tolower((int)v77) = 1;
          v60 = (int *)std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v82);
          *(_DWORD *)_tolower(*v60) = 0;
          v61 = (int *)std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v82);
          sub_412FE0(v75, *v61);
          v62 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v82);
          v77 = std::_tree_uid_acc::_Left(v62->_Left)->_Left;
        }
        v63 = (int *)std::_tree_uid_acc::_Right(v77);
        if ( *(_DWORD *)_tolower(*v63) != 1
          || (v64 = (int *)std::_tree_uid_acc::_Left(v77), *(_DWORD *)_tolower(*v64) != 1) )
        {
          v65 = (int *)std::_tree_uid_acc::_Left(v77);
          if ( *(_DWORD *)_tolower(*v65) == 1 )
          {
            v66 = (int *)std::_tree_uid_acc::_Right(v77);
            *(_DWORD *)_tolower(*v66) = 1;
            *(_DWORD *)_tolower((int)v77) = 0;
            sub_412E30(v75, (int)v77);
            v67 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v82);
            v77 = std::_tree_uid_acc::_Left(v67->_Left)->_Left;
          }
          v68 = (int *)std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v82);
          v69 = (_DWORD *)_tolower(*v68);
          *(_DWORD *)_tolower((int)v77) = *v69;
          v70 = (int *)std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v82);
          *(_DWORD *)_tolower(*v70) = 1;
          v71 = (int *)std::_tree_uid_acc::_Left(v77);
          *(_DWORD *)_tolower(*v71) = 1;
          v72 = (int *)std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v82);
          sub_412FE0(v75, *v72);
          break;
        }
        *(_DWORD *)_tolower((int)v77) = 0;
        v82 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v82)->_Left;
      }
    }
    *(_DWORD *)_tolower((int)v82) = 1;
  }
  v83 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v79);
  v73 = sub_411DF0(a1);
  sub_413180(v73);
  std::_tree_uid_acc1::_Freenode(a1);
  --v75->_Size;
  *a2 = a3;
  return a2;
}
// 412CC0: using guessed type int __thiscall unknown_libname_62(_DWORD);

//----- (004126B0) --------------------------------------------------------
void *__thiscall sub_4126B0(std::_tree *this, void *a2)
{
  void *result; // eax@1
  std::_tree_uid_acc::_Node *v3; // eax@3
  void **v4; // eax@3
  std::_tree *v5; // [sp+0h] [bp-8h]@1
  std::_tree_uid_acc::_Node *a1; // [sp+4h] [bp-4h]@1

  v5 = this;
  result = a2;
  for ( a1 = (std::_tree_uid_acc::_Node *)a2; a1 != std::_tree_uid_acc1::_Nil; a2 = a1 )
  {
    v3 = std::_tree_uid_acc::_Right(a1);
    sub_4126B0(v5, v3->_Left);
    a1 = std::_tree_uid_acc::_Left(a1)->_Left;
    v4 = sub_411DF0((std::_tree_uid_acc::_Node *)a2);
    sub_413180(v4);
    std::_tree_uid_acc1::_Freenode((std::_tree_uid_acc::_Node *)a2);
  }
  return result;
}

//----- (00412730) --------------------------------------------------------
int __thiscall std::_tree_uid_acc1::_Insert(void *this, int a2, int a3, int a4, struct Concurrency::IExecutionContext *a5)
{
  void **v5; // eax@1
  struct Concurrency::details::InternalContextBase *v6; // ST04_4@3
  struct Concurrency::details::InternalContextBase *v7; // eax@3
  int *v8; // eax@13
  std::_tree_uid_acc::_Node *v9; // esi@14
  std::_tree_uid_acc1 **v10; // eax@14
  std::_tree_uid_acc::_Node *v11; // eax@14
  std::_tree_uid_acc1 **v12; // eax@15
  std::_tree_uid_acc::_Node *v13; // eax@15
  int *v14; // eax@15
  int *v15; // eax@16
  std::_tree_uid_acc1 **v16; // eax@16
  int *v17; // eax@16
  std::_tree_uid_acc1 **v18; // eax@16
  std::_tree_uid_acc::_Node *v19; // eax@17
  int *v20; // eax@19
  std::_tree_uid_acc1 **v21; // eax@19
  int *v22; // eax@19
  std::_tree_uid_acc1 **v23; // eax@19
  int *v24; // eax@19
  std::_tree_uid_acc1 **v25; // eax@21
  std::_tree_uid_acc::_Node *v26; // eax@21
  int *v27; // eax@21
  int *v28; // eax@22
  std::_tree_uid_acc1 **v29; // eax@22
  int *v30; // eax@22
  std::_tree_uid_acc1 **v31; // eax@22
  std::_tree_uid_acc::_Node *v32; // eax@23
  int *v33; // eax@25
  std::_tree_uid_acc1 **v34; // eax@25
  int *v35; // eax@25
  std::_tree_uid_acc1 **v36; // eax@25
  int *v37; // eax@25
  int *v38; // eax@27
  std::_tree_uid_acc1 *v40; // [sp+4h] [bp-Ch]@1
  std::_tree_uid_acc::_Node *v41; // [sp+Ch] [bp-4h]@1
  std::_tree_uid_acc::_Node *v42; // [sp+1Ch] [bp+Ch]@11
  int a1; // [sp+20h] [bp+10h]@15
  int a1a; // [sp+20h] [bp+10h]@21

  v40 = (std::_tree_uid_acc1 *)this;
  v41 = std::_tree_uid_acc1::_Buynode((std::_tree_uid_acc::_Node *)a4, 0);
  std::_tree_uid_acc::_Left(v41)->_Left = std::_tree_uid_acc1::_Nil;
  std::_tree_uid_acc::_Right(v41)->_Left = std::_tree_uid_acc1::_Nil;
  v5 = sub_411DF0(v41);
  sub_413160(v5, (int)a5);
  ++v40->_Size;
  if ( (std::_tree_uid_acc::_Node *)a4 == v40->_Head
    || (std::_tree_uid_acc::_Node *)a3 != std::_tree_uid_acc1::_Nil
    || (v6 = std::_tree_uid_acc1::_Key(a4),
        v7 = std::_tree_uid_acc1::_Kfn(a5),
        (unsigned __int8)std::_tree::key_compare(v7, v6)) )
  {
    std::_tree_uid_acc::_Left((std::_tree_uid_acc::_Node *)a4)->_Left = v41;
    if ( (std::_tree_uid_acc::_Node *)a4 == v40->_Head )
    {
      std::_tree_uid_acc1::_Root_const(v40)->_Left = v41;
      std::_tree_uid_acc1::_Rmost(v40)->_Left = v41;
    }
    else if ( (std::_tree_uid_acc::_Node *)a4 == std::_tree_uid_acc1::_Lmost(v40)->_Left )
    {
      std::_tree_uid_acc1::_Lmost(v40)->_Left = v41;
    }
  }
  else
  {
    std::_tree_uid_acc::_Right((std::_tree_uid_acc::_Node *)a4)->_Left = v41;
    if ( (std::_tree_uid_acc::_Node *)a4 == std::_tree_uid_acc1::_Rmost(v40)->_Left )
      std::_tree_uid_acc1::_Rmost(v40)->_Left = v41;
  }
  v42 = v41;
  while ( v42 != std::_tree_uid_acc1::_Root_const(v40)->_Left )
  {
    v8 = (int *)std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v42);
    if ( *(_DWORD *)_tolower(*v8) )
      break;
    v9 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v42);
    v10 = (std::_tree_uid_acc1 **)std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v42);
    v11 = std::_tree_uid_acc1::_Parent(*v10);
    if ( v9->_Left == std::_tree_uid_acc::_Left(v11->_Left)->_Left )
    {
      v12 = (std::_tree_uid_acc1 **)std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v42);
      v13 = std::_tree_uid_acc1::_Parent(*v12);
      v14 = (int *)std::_tree_uid_acc::_Right(v13->_Left);
      a1 = *v14;
      if ( *(_DWORD *)_tolower(*v14) )
      {
        v19 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v42);
        if ( v42 == std::_tree_uid_acc::_Right(v19->_Left)->_Left )
        {
          v42 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v42)->_Left;
          sub_412E30(v40, (int)v42);
        }
        v20 = (int *)std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v42);
        *(_DWORD *)_tolower(*v20) = 1;
        v21 = (std::_tree_uid_acc1 **)std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v42);
        v22 = (int *)std::_tree_uid_acc1::_Parent(*v21);
        *(_DWORD *)_tolower(*v22) = 0;
        v23 = (std::_tree_uid_acc1 **)std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v42);
        v24 = (int *)std::_tree_uid_acc1::_Parent(*v23);
        sub_412FE0(v40, *v24);
      }
      else
      {
        v15 = (int *)std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v42);
        *(_DWORD *)_tolower(*v15) = 1;
        *(_DWORD *)_tolower(a1) = 1;
        v16 = (std::_tree_uid_acc1 **)std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v42);
        v17 = (int *)std::_tree_uid_acc1::_Parent(*v16);
        *(_DWORD *)_tolower(*v17) = 0;
        v18 = (std::_tree_uid_acc1 **)std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v42);
        v42 = std::_tree_uid_acc1::_Parent(*v18)->_Left;
      }
    }
    else
    {
      v25 = (std::_tree_uid_acc1 **)std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v42);
      v26 = std::_tree_uid_acc1::_Parent(*v25);
      v27 = (int *)std::_tree_uid_acc::_Left(v26->_Left);
      a1a = *v27;
      if ( *(_DWORD *)_tolower(*v27) )
      {
        v32 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v42);
        if ( v42 == std::_tree_uid_acc::_Left(v32->_Left)->_Left )
        {
          v42 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v42)->_Left;
          sub_412FE0(v40, (int)v42);
        }
        v33 = (int *)std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v42);
        *(_DWORD *)_tolower(*v33) = 1;
        v34 = (std::_tree_uid_acc1 **)std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v42);
        v35 = (int *)std::_tree_uid_acc1::_Parent(*v34);
        *(_DWORD *)_tolower(*v35) = 0;
        v36 = (std::_tree_uid_acc1 **)std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v42);
        v37 = (int *)std::_tree_uid_acc1::_Parent(*v36);
        sub_412E30(v40, *v37);
      }
      else
      {
        v28 = (int *)std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v42);
        *(_DWORD *)_tolower(*v28) = 1;
        *(_DWORD *)_tolower(a1a) = 1;
        v29 = (std::_tree_uid_acc1 **)std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v42);
        v30 = (int *)std::_tree_uid_acc1::_Parent(*v29);
        *(_DWORD *)_tolower(*v30) = 0;
        v31 = (std::_tree_uid_acc1 **)std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v42);
        v42 = std::_tree_uid_acc1::_Parent(*v31)->_Left;
      }
    }
  }
  v38 = (int *)std::_tree_uid_acc1::_Root_const(v40);
  *(_DWORD *)_tolower(*v38) = 1;
  std::_tree_uid_acc::iterator::iterator((std::_tree_uid_acc::iterator *)a2, v41);
  return a2;
}

//----- (00412BC0) --------------------------------------------------------
std::_tree_uid_acc::_Node *__thiscall std::_tree_uid_acc1::_Lmost(std::_tree_uid_acc1 *this)
{
  return std::_tree_uid_acc::_Left(this->_Head);
}

//----- (00412BE0) --------------------------------------------------------
std::_tree_uid_acc::_Node *__thiscall std::_tree_uid_acc1::_Rmost(std::_tree_uid_acc1 *this)
{
  return std::_tree_uid_acc::_Right(this->_Head);
}

//----- (00412C00) --------------------------------------------------------
std::_tree_uid_acc::_Node *__thiscall std::_tree_uid_acc1::_Root_const(std::_tree_uid_acc1 *this)
{
  return std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)this->_Head);
}

//----- (00412C20) --------------------------------------------------------
std::_tree_uid_acc::_Node *__thiscall std::_tree_uid_acc::iterator::_Inc(std::_tree_uid_acc::iterator *this)
{
  int *v1; // eax@2
  std::_tree_uid_acc::_Node *result; // eax@2
  std::_tree_uid_acc::_Node *v3; // eax@3
  std::_tree_uid_acc1 *this_; // [sp+0h] [bp-8h]@1
  std::_tree_uid_acc::_Node *a1; // [sp+4h] [bp-4h]@3

  this_ = (std::_tree_uid_acc1 *)this;
  if ( std::_tree_uid_acc::_Right(this->_Ptr)->_Left == std::_tree_uid_acc1::_Nil )
  {
    while ( 1 )
    {
      v3 = std::_tree_uid_acc1::_Parent(*(std::_tree_uid_acc1 **)&this_->allocator);
      a1 = v3->_Left;
      if ( *(std::_tree_uid_acc::_Node **)&this_->allocator != std::_tree_uid_acc::_Right(v3->_Left)->_Left )
        break;
      *(_DWORD *)&this_->allocator = a1;
    }
    result = std::_tree_uid_acc::_Right(*(std::_tree_uid_acc::_Node **)&this_->allocator);
    if ( result->_Left != a1 )
    {
      result = a1;
      *(_DWORD *)&this_->allocator = a1;
    }
  }
  else
  {
    v1 = (int *)std::_tree_uid_acc::_Right(*(std::_tree_uid_acc::_Node **)&this_->allocator);
    result = (std::_tree_uid_acc::_Node *)sub_412FA0(*v1);
    *(_DWORD *)&this_->allocator = result;
  }
  return result;
}

//----- (00412D20) --------------------------------------------------------
std::_tree_uid_acc::_Node *__cdecl std::_tree_uid_acc1::_Parent(std::_tree_uid_acc1 *a1)
{
  return (std::_tree_uid_acc::_Node *)&a1->_Head;
}

//----- (00412D30) --------------------------------------------------------
std::_tree_uid_acc::_Node *__thiscall std::_tree_uid_acc1::_Init(std::_tree_uid_acc1 *this)
{
  std::_tree_uid_acc::_Node *result; // eax@5
  std::_tree_uid_acc1 *v2; // [sp+0h] [bp-18h]@1
  char v3; // [sp+4h] [bp-14h]@1
  std::_tree_uid_acc::_Node *a2; // [sp+8h] [bp-10h]@1
  int v5; // [sp+14h] [bp-4h]@1

  v2 = this;
  a2 = std::_tree_uid_acc1::_Buynode(0, 1);
  std::_Lockit::_Lockit((std::_Lockit *)&v3);
  v5 = 0;
  if ( !std::_tree_uid_acc1::_Nil )
  {
    std::_tree_uid_acc1::_Nil = a2;
    a2 = 0;
    std::_tree_uid_acc::_Left(std::_tree_uid_acc1::_Nil)->_Left = 0;
    std::_tree_uid_acc::_Right(std::_tree_uid_acc1::_Nil)->_Left = 0;
  }
  ++std::_tree_uid_acc1::_Nilrefs;
  v5 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v3);
  if ( a2 )
    std::_tree_uid_acc1::_Freenode(a2);
  v2->_Head = std::_tree_uid_acc1::_Buynode(std::_tree_uid_acc1::_Nil, 0);
  v2->_Size = 0;
  std::_tree_uid_acc1::_Lmost(v2)->_Left = v2->_Head;
  result = std::_tree_uid_acc1::_Rmost(v2);
  result->_Left = v2->_Head;
  return result;
}
// 478600: using guessed type int std::_tree_uid_acc1::_Nilrefs;

//----- (00412E30) --------------------------------------------------------
std::_tree_uid_acc::_Node *__thiscall sub_412E30(void *this, int a2)
{
  std::_tree_uid_acc::_Node *v2; // esi@1
  std::_tree_uid_acc1 **v3; // eax@2
  std::_tree_uid_acc::_Node *v4; // esi@3
  std::_tree_uid_acc::_Node *v5; // eax@5
  std::_tree_uid_acc::_Node *v6; // eax@6
  std::_tree_uid_acc::_Node *v7; // eax@7
  std::_tree_uid_acc::_Node *result; // eax@8
  std::_tree_uid_acc1 *v9; // [sp+4h] [bp-8h]@1
  std::_tree_uid_acc::_Node *v10; // [sp+8h] [bp-4h]@1

  v9 = (std::_tree_uid_acc1 *)this;
  v10 = std::_tree_uid_acc::_Right((std::_tree_uid_acc::_Node *)a2)->_Left;
  v2 = std::_tree_uid_acc::_Left(v10);
  std::_tree_uid_acc::_Right((std::_tree_uid_acc::_Node *)a2)->_Left = v2->_Left;
  if ( std::_tree_uid_acc::_Left(v10)->_Left != std::_tree_uid_acc1::_Nil )
  {
    v3 = (std::_tree_uid_acc1 **)std::_tree_uid_acc::_Left(v10);
    std::_tree_uid_acc1::_Parent(*v3)->_Left = (std::_tree_uid_acc::_Node *)a2;
  }
  v4 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)a2);
  std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)v10)->_Left = v4->_Left;
  if ( (std::_tree_uid_acc::_Node *)a2 == std::_tree_uid_acc1::_Root_const(v9)->_Left )
  {
    std::_tree_uid_acc1::_Root_const(v9)->_Left = v10;
  }
  else
  {
    v5 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)a2);
    if ( (std::_tree_uid_acc::_Node *)a2 == std::_tree_uid_acc::_Left(v5->_Left)->_Left )
    {
      v6 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)a2);
      std::_tree_uid_acc::_Left(v6->_Left)->_Left = v10;
    }
    else
    {
      v7 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)a2);
      std::_tree_uid_acc::_Right(v7->_Left)->_Left = v10;
    }
  }
  std::_tree_uid_acc::_Left(v10)->_Left = (std::_tree_uid_acc::_Node *)a2;
  result = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)a2);
  result->_Left = v10;
  return result;
}

//----- (00412F60) --------------------------------------------------------
int __cdecl sub_412F60(int a1)
{
  while ( std::_tree_uid_acc::_Right((std::_tree_uid_acc::_Node *)a1)->_Left != std::_tree_uid_acc1::_Nil )
    a1 = (int)std::_tree_uid_acc::_Right((std::_tree_uid_acc::_Node *)a1)->_Left;
  return a1;
}

//----- (00412FA0) --------------------------------------------------------
int __cdecl sub_412FA0(int a1)
{
  while ( std::_tree_uid_acc::_Left((std::_tree_uid_acc::_Node *)a1)->_Left != std::_tree_uid_acc1::_Nil )
    a1 = (int)std::_tree_uid_acc::_Left((std::_tree_uid_acc::_Node *)a1)->_Left;
  return a1;
}

//----- (00412FE0) --------------------------------------------------------
std::_tree_uid_acc::_Node *__thiscall sub_412FE0(void *this, int a2)
{
  std::_tree_uid_acc::_Node *v2; // esi@1
  std::_tree_uid_acc1 **v3; // eax@2
  std::_tree_uid_acc::_Node *v4; // esi@3
  std::_tree_uid_acc::_Node *v5; // eax@5
  std::_tree_uid_acc::_Node *v6; // eax@6
  std::_tree_uid_acc::_Node *v7; // eax@7
  std::_tree_uid_acc::_Node *result; // eax@8
  std::_tree_uid_acc1 *v9; // [sp+4h] [bp-8h]@1
  std::_tree_uid_acc::_Node *a1; // [sp+8h] [bp-4h]@1

  v9 = (std::_tree_uid_acc1 *)this;
  a1 = std::_tree_uid_acc::_Left((std::_tree_uid_acc::_Node *)a2)->_Left;
  v2 = std::_tree_uid_acc::_Right(a1);
  std::_tree_uid_acc::_Left((std::_tree_uid_acc::_Node *)a2)->_Left = v2->_Left;
  if ( std::_tree_uid_acc::_Right(a1)->_Left != std::_tree_uid_acc1::_Nil )
  {
    v3 = (std::_tree_uid_acc1 **)std::_tree_uid_acc::_Right(a1);
    std::_tree_uid_acc1::_Parent(*v3)->_Left = (std::_tree_uid_acc::_Node *)a2;
  }
  v4 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)a2);
  std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)a1)->_Left = v4->_Left;
  if ( (std::_tree_uid_acc::_Node *)a2 == std::_tree_uid_acc1::_Root_const(v9)->_Left )
  {
    std::_tree_uid_acc1::_Root_const(v9)->_Left = a1;
  }
  else
  {
    v5 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)a2);
    if ( (std::_tree_uid_acc::_Node *)a2 == std::_tree_uid_acc::_Right(v5->_Left)->_Left )
    {
      v6 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)a2);
      std::_tree_uid_acc::_Right(v6->_Left)->_Left = a1;
    }
    else
    {
      v7 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)a2);
      std::_tree_uid_acc::_Left(v7->_Left)->_Left = a1;
    }
  }
  std::_tree_uid_acc::_Right(a1)->_Left = (std::_tree_uid_acc::_Node *)a2;
  result = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)a2);
  result->_Left = a1;
  return result;
}

//----- (00413110) --------------------------------------------------------
std::_tree_uid_acc::_Node *__stdcall std::_tree_uid_acc1::_Buynode(std::_tree_uid_acc::_Node *a1, int a2)
{
  std::_tree_uid_acc::_Node *result; // eax@1

  result = (std::_tree_uid_acc::_Node *)sub_40E2F0(0x24u);
  std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)result)->_Left = a1;
  *(_DWORD *)_tolower((int)result) = a2;
  return result;
}

//----- (00413160) --------------------------------------------------------
void *__stdcall sub_413160(void *a1, int a2)
{
  return sub_4132C0(a1, a2);
}

//----- (00413180) --------------------------------------------------------
void __stdcall sub_413180(void *a1)
{
  __ExceptionPtrDestroy(a1);
}

//----- (004131C0) --------------------------------------------------------
std::_tree_uid_acc::_Node *__thiscall sub_4131C0(int *this)
{
  std::_tree_uid_acc1 **v1; // eax@2
  std::_tree_uid_acc::_Node *result; // eax@3
  int *v3; // eax@5
  std::_tree_uid_acc::_Node *v4; // eax@6
  int *v5; // [sp+0h] [bp-8h]@1
  std::_tree_uid_acc::_Node *v6; // [sp+4h] [bp-4h]@6

  v5 = this;
  if ( *(_DWORD *)_tolower(*this)
    || (v1 = (std::_tree_uid_acc1 **)std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)*v5),
        std::_tree_uid_acc1::_Parent(*v1)->_Left != (std::_tree_uid_acc::_Node *)*v5) )
  {
    if ( std::_tree_uid_acc::_Left((std::_tree_uid_acc::_Node *)*v5)->_Left == std::_tree_uid_acc1::_Nil )
    {
      while ( 1 )
      {
        v4 = std::_tree_uid_acc1::_Parent((std::_tree_uid_acc1 *)*v5);
        v6 = v4->_Left;
        if ( (std::_tree_uid_acc::_Node *)*v5 != std::_tree_uid_acc::_Left(v4->_Left)->_Left )
          break;
        *v5 = (int)v6;
      }
      result = v6;
      *v5 = (int)v6;
    }
    else
    {
      v3 = (int *)std::_tree_uid_acc::_Left((std::_tree_uid_acc::_Node *)*v5);
      result = (std::_tree_uid_acc::_Node *)sub_412F60(*v3);
      *v5 = (int)result;
    }
  }
  else
  {
    result = std::_tree_uid_acc::_Right((std::_tree_uid_acc::_Node *)*v5);
    *v5 = (int)result->_Left;
  }
  return result;
}

//----- (00413290) --------------------------------------------------------
int __cdecl sub_413290(int *a1, int *a2)
{
  int v2; // ST00_4@1
  int result; // eax@1

  v2 = *a1;
  *a1 = *a2;
  result = v2;
  *a2 = v2;
  return result;
}

//----- (004132C0) --------------------------------------------------------
void *__cdecl sub_4132C0(void *a1, int a2)
{
  void *result; // eax@1

  result = operator new(0x14u, a1);
  if ( result )
    result = (void *)unknown_libname_66(a2);
  return result;
}
// 413340: using guessed type _DWORD __stdcall unknown_libname_66(_DWORD);

//----- (00413370) --------------------------------------------------------
void *__thiscall sub_413370(void *this, char a2)
{
  void *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  unknown_libname_53((int)this);
  if ( a2 & 1 )
    _delete_table(v3);
  return v3;
}

//----- (004133A0) --------------------------------------------------------
int StaticInit_Database()
{
  CallStaticCtorForDatabase();
  return RegisterStatic_destructorForDatabase();
}

//----- (004133AF) --------------------------------------------------------
Database *CallStaticCtorForDatabase()
{
  return Database::Database(&g_dbManager);
}

//----- (004133BE) --------------------------------------------------------
int RegisterStatic_destructorForDatabase()
{
  return atexit(CallDatabaseDestructor);
}

//----- (004133D0) --------------------------------------------------------
void __cdecl CallDatabaseDestructor()
{
  Database::Destructor(&g_dbManager);
}

//----- (004133DF) --------------------------------------------------------
Database *__thiscall Database::Database(Database *this)
{
  Database *this_; // ST08_4@1

  this_ = this;
  MemoryObject::MemoryObject(&this->base);
  SpinLock::SpinLock(&this_->spinLock, LockType_WaitLock, 0);
  this_->base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&Database_vtable_45F4B0;
  this_->sqlEnvHandle = 0;
  this_->sqlConnections = 0;
  this_->connectionsHead = 0;
  this_->connectionNumber = 0;
  this_->base.m_nRefCount = 1;
  return this_;
}
// 45F4B0: using guessed type int (__stdcall *Database_vtable_45F4B0)(int);

//----- (0041346F) --------------------------------------------------------
MemoryObject *__thiscall Database::Destructor(Database *this)
{
  Database *this_; // [sp+0h] [bp-14h]@1

  this_ = this;
  this->base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&Database_vtable_45F4B0;
  if ( this->sqlEnvHandle )
    Database::clearConnections(this);
  if ( this_->sqlConnections )
    _delete_table(this_->sqlConnections);
  SpinLock::Destructor(&this_->spinLock);
  return MemoryObject::Destructor(&this_->base);
}
// 45F4B0: using guessed type int (__stdcall *Database_vtable_45F4B0)(int);

//----- (004134F8) --------------------------------------------------------
Database *__thiscall Database::init(Database *this, int dbConnectionNumber)
{
  Database *result; // eax@6
  Database *this_; // [sp+0h] [bp-Ch]@1
  SQLRETURN allocRes; // [sp+8h] [bp-4h]@1
  SQLRETURN allocResa; // [sp+8h] [bp-4h]@3

  this_ = this;
  this->connectionNumber = dbConnectionNumber;
  this->sqlConnections = (SqlConnection *)operator new(16 * this->connectionNumber);
  SQLSetEnvAttr((SQLHENV)SQL_NULL_HANDLE, SQL_ATTR_CONNECTION_POOLING, (SQLPOINTER)SQL_CP_ONE_PER_DRIVER, SQL_TINYINT);
  allocRes = SQLAllocHandle(SQL_HANDLE_ENV, (SQLHANDLE)SQL_NULL_HANDLE, &this_->sqlEnvHandle);
  if ( allocRes && allocRes != SQL_SUCCESS_WITH_INFO
    || (allocResa = SQLSetEnvAttr(this_->sqlEnvHandle, SQL_ATTR_ODBC_VERSION, (SQLPOINTER)SQL_OV_ODBC3, 0)) != 0// SQL_SUCCESS
    && allocResa != SQL_SUCCESS_WITH_INFO )
  {
    result = (Database *)LogWindow::Add(&g_LogWindow, 3, aDbEnvAllocatio);
  }
  else if ( Database::showDBConnectDialog(this_, 0) )
  {
    result = Database::initConnections(this_);
  }
  else
  {
    LogWindow::Add(&g_LogWindow, 3, aDbLoginFailed);
    SQLFreeHandle(SQL_HANDLE_ENV, this_->sqlEnvHandle);
    result = this_;
    this_->sqlEnvHandle = 0;
  }
  return result;
}

//----- (004135F2) --------------------------------------------------------
char __thiscall Database::showDBConnectDialog(Database *this, char reconnect)
{
  SQLSMALLINT len; // ax@9
  char result; // al@11
  Database *this_; // [sp+0h] [bp-410h]@1
  SQLCHAR szConnStrOut[1024]; // [sp+4h] [bp-40Ch]@9
  SQLSMALLINT pcchConnStrOut; // [sp+404h] [bp-Ch]@9
  __int16 sqlResult; // [sp+408h] [bp-8h]@3
  SQLHANDLE OutputHandle; // [sp+40Ch] [bp-4h]@3

  this_ = this;
  if ( !Database::loadConnectionString(this) )
    DialogBoxParamA(hInstance, (LPCSTR)DLG_DB_CONNECTION, 0, Database::dialogFunc, (LPARAM)this_);
  sqlResult = SQLAllocHandle(SQL_HANDLE_DBC, this_->sqlEnvHandle, &OutputHandle);
  if ( sqlResult && sqlResult != SQL_SUCCESS_WITH_INFO )
  {
    LogWindow::Add(&g_LogWindow, 1, format);
    result = 0;
  }
  else
  {
    if ( reconnect == 1 )
      SQLSetConnectAttr(OutputHandle, SQL_ATTR_LOGIN_TIMEOUT, (SQLPOINTER)20, 0);
    else
      SQLSetConnectAttr(OutputHandle, SQL_ATTR_LOGIN_TIMEOUT, (SQLPOINTER)60, 0);
    SQLSetConnectAttr(OutputHandle, SQL_ATTR_CONNECTION_TIMEOUT, (SQLPOINTER)60, 0);
    while ( 1 )
    {
      len = strlen(this_->connectionStr);
      sqlResult = SQLDriverConnect(
                    OutputHandle,
                    0,
                    (SQLCHAR *)this_->connectionStr,
                    len,
                    szConnStrOut,
                    1024,
                    &pcchConnStrOut,
                    0);
      if ( !sqlResult || sqlResult == SQL_SUCCESS_WITH_INFO )
        break;
      if ( !reconnect )
        DialogBoxParamA(hInstance, (LPCSTR)DLG_DB_CONNECTION, 0, Database::dialogFunc, (LPARAM)this_);
    }
    SQLDisconnect(OutputHandle);
    SQLFreeHandle(SQL_HANDLE_DBC, OutputHandle);
    result = 1;
  }
  return result;
}

//----- (00413759) --------------------------------------------------------
Database *__thiscall Database::initConnections(Database *this)
{
  SQLSMALLINT len; // ax@5
  Database *result; // eax@17
  Database *this_; // [sp+0h] [bp-410h]@1
  SQLCHAR szConnStrOut[1024]; // [sp+4h] [bp-40Ch]@5
  SQLSMALLINT pcchConnStrOut; // [sp+404h] [bp-Ch]@5
  __int16 sqlResult; // [sp+408h] [bp-8h]@3
  int i; // [sp+40Ch] [bp-4h]@1

  this_ = this;
  for ( i = 0; i < this_->connectionNumber; ++i )
  {
    this_->sqlConnections[i].prevConnection = 0;
    sqlResult = SQLAllocHandle(SQL_HANDLE_DBC, this_->sqlEnvHandle, &this_->sqlConnections[i].dbcSqlHandler);
    if ( sqlResult && sqlResult != SQL_SUCCESS_WITH_INFO )
    {
      LogWindow::Add(&g_LogWindow, 3, aHdbcAllocati_0);
      this_->sqlConnections[i].stmtSqlHandler = 0;
      this_->sqlConnections[i].dbcSqlHandler = 0;
      this_->sqlConnections[i].free = 0;
    }
    else
    {
      SQLSetConnectAttr(this_->sqlConnections[i].dbcSqlHandler, SQL_ATTR_LOGIN_TIMEOUT, (SQLPOINTER)60, 0);
      SQLSetConnectAttr(this_->sqlConnections[i].dbcSqlHandler, SQL_ATTR_CONNECTION_TIMEOUT, (SQLPOINTER)60, 0);
      len = strlen(this_->connectionStr);
      sqlResult = SQLDriverConnect(
                    this_->sqlConnections[i].dbcSqlHandler,
                    0,
                    (SQLCHAR *)this_->connectionStr,
                    len,
                    szConnStrOut,
                    1024,
                    &pcchConnStrOut,
                    0);
      if ( sqlResult && sqlResult != SQL_SUCCESS_WITH_INFO )
      {
        LogWindow::Add(&g_LogWindow, 3, aHdbcConnection);
        SQLFreeHandle(SQL_HANDLE_DBC, this_->sqlConnections[i].dbcSqlHandler);
        this_->sqlConnections[i].stmtSqlHandler = 0;
        this_->sqlConnections[i].dbcSqlHandler = 0;
        this_->sqlConnections[i].free = 0;
      }
      else
      {
        sqlResult = SQLAllocHandle(
                      SQL_HANDLE_STMT,
                      this_->sqlConnections[i].dbcSqlHandler,
                      &this_->sqlConnections[i].stmtSqlHandler);
        if ( sqlResult && sqlResult != SQL_SUCCESS_WITH_INFO )
        {
          LogWindow::Add(&g_LogWindow, 3, aStmtAllocation);
          SQLFreeHandle(SQL_HANDLE_DBC, this_->sqlConnections[i].dbcSqlHandler);
          this_->sqlConnections[i].stmtSqlHandler = 0;
          this_->sqlConnections[i].dbcSqlHandler = 0;
          this_->sqlConnections[i].free = 0;
        }
        else
        {
          this_->sqlConnections[i].free = 1;
        }
      }
    }
  }
  for ( i = 0; ; ++i )
  {
    result = this_;
    if ( i >= this_->connectionNumber )
      break;
    if ( this_->sqlConnections[i].stmtSqlHandler )
    {
      if ( this_->connectionsHead )
      {
        this_->sqlConnections[i].prevConnection = this_->connectionsHead;
        this_->connectionsHead = &this_->sqlConnections[i];
      }
      else
      {
        this_->connectionsHead = &this_->sqlConnections[i];
      }
    }
  }
  return result;
}

//----- (00413AC8) --------------------------------------------------------
int __thiscall Database::clearConnections(Database *this)
{
  int result; // eax@8
  Database *this_; // [sp+0h] [bp-8h]@1
  int i; // [sp+4h] [bp-4h]@1

  this_ = this;
  for ( i = 0; i < this_->connectionNumber; ++i )
  {
    if ( this_->sqlConnections[i].stmtSqlHandler )
      SQLFreeHandle(SQL_HANDLE_STMT, this_->sqlConnections[i].stmtSqlHandler);
    if ( this_->sqlConnections[i].dbcSqlHandler )
    {
      SQLDisconnect(this_->sqlConnections[i].dbcSqlHandler);
      SQLFreeHandle(SQL_HANDLE_DBC, this_->sqlConnections[i].dbcSqlHandler);
    }
  }
  LOWORD(result) = SQLFreeHandle(SQL_HANDLE_ENV, this_->sqlEnvHandle);
  this_->sqlEnvHandle = 0;
  return result;
}

//----- (00413B7E) --------------------------------------------------------
char __thiscall Database::loadConnectionString(Database *this)
{
  Database *this_; // [sp+0h] [bp-11Ch]@1
  HKEY key; // [sp+4h] [bp-118h]@7
  unsigned __int8 storedValue[256]; // [sp+8h] [bp-114h]@8
  LPCSTR valueName; // [sp+108h] [bp-14h]@4
  DWORD length; // [sp+10Ch] [bp-10h]@8
  LSTATUS regResult; // [sp+110h] [bp-Ch]@7
  int succeed; // [sp+114h] [bp-8h]@1
  DWORD valueType; // [sp+118h] [bp-4h]@8

  this_ = this;
  LOBYTE(succeed) = 0;
  if ( g_Config.GameID != 8 && g_Config.GameID != 0x10 && g_Config.GameID != 0x20 )
  {
    if ( g_Config.GameID == 4 )
      valueName = aSldb;
  }
  else
  {
    valueName = aL2conn;
  }
  regResult = RegOpenKeyExA(HKEY_LOCAL_MACHINE, SubKey, 0, KEY_READ, &key);
  if ( !regResult )
  {
    length = 256;
    regResult = RegQueryValueExA(key, valueName, 0, &valueType, storedValue, &length);
    if ( !regResult && valueType == REG_BINARY )
      LOBYTE(succeed) = 1;
    RegCloseKey(key);
  }
  if ( (_BYTE)succeed )
  {
    DesFrontEnd::decodeData((char *)storedValue, 256);
    strcpy(this_->connectionStr, (const char *)storedValue);
  }
  return succeed;
}

//----- (00413C76) --------------------------------------------------------
LSTATUS __thiscall Database::storeConnectionString(Database *this)
{
  LSTATUS result; // eax@7
  HKEY key; // [sp+Ch] [bp-110h]@7
  BYTE connectionString[256]; // [sp+10h] [bp-10Ch]@7
  LPCSTR valueName; // [sp+110h] [bp-Ch]@4
  DWORD dwDisposition; // [sp+114h] [bp-8h]@7
  LSTATUS v6; // [sp+118h] [bp-4h]@7

  if ( g_Config.GameID != 8 && g_Config.GameID != 0x10 && g_Config.GameID != 0x20 )
  {
    if ( g_Config.GameID == 4 )
      valueName = aSldb_0;
  }
  else
  {
    valueName = aL2conn_0;
  }
  strcpy((char *)connectionString, this->connectionStr);
  DesFrontEnd::encodeData((char *)connectionString, 256);
  result = RegCreateKeyExA(HKEY_LOCAL_MACHINE, aSoftwareNcso_0, 0, aRegClass, 0, KEY_WRITE, 0, &key, &dwDisposition);
  v6 = result;
  if ( !result )
  {
    RegSetValueExA(key, valueName, 0, REG_BINARY, connectionString, 256u);
    result = RegCloseKey(key);
  }
  return result;
}

//----- (00413D60) --------------------------------------------------------
LONG __thiscall Database::OnTimerCallback(Database *this)
{
  Database *this_; // [sp+0h] [bp-8h]@1
  SQLRETURN allocRes; // [sp+4h] [bp-4h]@2
  SQLRETURN setEnvRes; // [sp+4h] [bp-4h]@4

  this_ = this;
  if ( Database::showDBConnectDialog(this, 1) )
  {
    SpinLock::Enter(&this_->spinLock);
    Database::clearConnections(this_);
    SQLSetEnvAttr((SQLHENV)SQL_NULL_HANDLE, SQL_ATTR_CONNECTION_POOLING, (SQLPOINTER)SQL_CP_ONE_PER_DRIVER, SQL_TINYINT);
    allocRes = SQLAllocHandle(SQL_HANDLE_ENV, (SQLHANDLE)SQL_NULL_HANDLE, &this_->sqlEnvHandle);
    if ( allocRes && allocRes != SQL_SUCCESS_WITH_INFO )
    {
      SpinLock::Leave(&this_->spinLock);
    }
    else
    {
      setEnvRes = SQLSetEnvAttr(this_->sqlEnvHandle, SQL_ATTR_ODBC_VERSION, (SQLPOINTER)SQL_OV_ODBC3, 0);
      if ( setEnvRes && setEnvRes != SQL_SUCCESS_WITH_INFO )
      {
        SpinLock::Leave(&this_->spinLock);
        this_->base.vftbl_0_45F520->AddTimer((MemoryObject *)this_, 30000, 1);
        LogWindow::Add(&g_LogWindow, 3, aDbRecoveryFail);
      }
      else
      {
        Database::initConnections(this_);
        this_->recoveryTriggered = 0;
        SpinLock::Leave(&this_->spinLock);
        LogWindow::Add(&g_LogWindow, 0, aDbRecoverySucc);
      }
    }
  }
  else
  {
    LogWindow::Add(&g_LogWindow, 3, aDbRecoveryFa_0);
    this_->base.vftbl_0_45F520->AddTimer((MemoryObject *)this_, 30000, 1);
  }
  return MemoryObject::Release(&this_->base);
}

//----- (00413E9E) --------------------------------------------------------
int __thiscall SqlQuery::SqlQuery(SqlQuery *this, Database *dbManager)
{
  SqlQuery *this_; // [sp+0h] [bp-4h]@1

  this_ = this;
  this->dbManager = dbManager;
  this->sqlConnection = 0;
  while ( 1 )
  {
    SpinLock::Enter(&this_->dbManager->spinLock);
    if ( this_->dbManager->connectionsHead->prevConnection )
    {
      this_->sqlConnection = this_->dbManager->connectionsHead;
      this_->dbManager->connectionsHead = this_->dbManager->connectionsHead->prevConnection;
      this_->sqlConnection->free = 0;
    }
    SpinLock::Leave(&this_->dbManager->spinLock);
    if ( this_->sqlConnection )
      break;
    Sleep(1000u);
  }
  this_->sqlHandler = this_->sqlConnection->stmtSqlHandler;
  this_->currentCollumn = 1;
  this_->field_8 = 1;
  return (int)this_;
}

//----- (00413F5F) --------------------------------------------------------
void __thiscall SqlQuery::Destructor(SqlQuery *this)
{
  SqlQuery *this_; // [sp+0h] [bp-4h]@1

  this_ = this;
  SpinLock::Enter(&this->dbManager->spinLock);
  if ( !this_->sqlConnection->free )
  {
    SQLFreeStmt(this_->sqlHandler, SQL_HANDLE_DBC);
    SQLFreeStmt(this_->sqlHandler, SQL_NULL_HANDLE);
    SQLFreeStmt(this_->sqlHandler, SQL_HANDLE_STMT);
    this_->sqlConnection->prevConnection = this_->dbManager->connectionsHead;
    this_->dbManager->connectionsHead = this_->sqlConnection;
  }
  SpinLock::Leave(&this_->dbManager->spinLock);
}

//----- (00413FD9) --------------------------------------------------------
BOOL __stdcall Database::dialogFunc(HWND hDlg, UINT msgType, WPARAM wparam, LPARAM lparam)
{
  BOOL result; // eax@4
  char *connStr; // ST1C_4@6
  char buffer[64]; // [sp+Ch] [bp-48h]@6
  LPARAM lParam; // [sp+4Ch] [bp-8h]@4

  if ( msgType == WM_INITDIALOG )
  {
    Database::instance = (Database *)lparam;
    lParam = (LPARAM)aL2conn_1;
    SendDlgItemMessageA(hDlg, DLG_DB_CONNECTION_FILE_DSN, WM_SETTEXT, 0, (LPARAM)aL2conn_1);
    SetWindowTextA(hDlg, aL2OdbcConnecti);
    result = 0;
  }
  else
  {
    if ( msgType == WM_COMMAND && wparam == IDOK )
    {
      connStr = Database::instance->connectionStr;
      SendDlgItemMessageA(hDlg, DLG_DB_CONNECTION_FILE_DSN, WM_GETTEXT, 64u, (LPARAM)buffer);
      strcpy(connStr, aFiledsn);
      strcat(connStr, buffer);
      SendDlgItemMessageA(hDlg, DLG_DB_CONNECTION_LOGIN_NAME, WM_GETTEXT, 64u, (LPARAM)buffer);
      strcat(connStr, aUid);
      strcat(connStr, buffer);
      SendDlgItemMessageA(hDlg, DLG_DB_CONNECTION_PASSWORD, WM_GETTEXT, 64u, (LPARAM)buffer);
      strcat(connStr, aPwd);
      strcat(connStr, buffer);
      Database::storeConnectionString(Database::instance);
      EndDialog(hDlg, 0);
    }
    result = 0;
  }
  return result;
}

//----- (00414123) --------------------------------------------------------
char SqlQuery::exec(SqlQuery *this, char *format, ...)
{
  char result; // al@4
  char sqlQuery[8192]; // [sp+0h] [bp-200Ch]@1
  int sqlQueryLength; // [sp+2000h] [bp-Ch]@1
  va_list unused_1; // [sp+2004h] [bp-8h]@1
  __int16 sqlResult; // [sp+2008h] [bp-4h]@1
  va_list va; // [sp+201Ch] [bp+10h]@1

  va_start(va, format);
  unused_1 = va;
  sqlQueryLength = vsprintf(sqlQuery, format, va);
  unused_1 = 0;
  sqlResult = -1;
  if ( sqlQueryLength > 0 )
    sqlResult = SqlQuery::execRaw((SqlQuery *)this->sqlHandler, sqlQuery, sqlQueryLength);
  if ( sqlResult )
  {
    SqlQuery::printError(this, SQL_HANDLE_STMT, this->sqlHandler, sqlQuery);
    result = false;
  }
  else
  {
    result = true;
  }
  return result;
}

//----- (004141A6) --------------------------------------------------------
char sub_4141A6(SqlQuery *a1, char *a2, ...)
{
  char result; // al@5
  SQLCHAR StatementText; // [sp+0h] [bp-100Ch]@1
  int v4; // [sp+1000h] [bp-Ch]@1
  va_list v5; // [sp+1004h] [bp-8h]@1
  __int16 v6; // [sp+1008h] [bp-4h]@1
  va_list va; // [sp+101Ch] [bp+10h]@1

  va_start(va, a2);
  v5 = va;
  v4 = vsprintf((char *)&StatementText, a2, va);
  v5 = 0;
  v6 = -1;
  if ( v4 > 0 )
  {
    SQLPrepare(a1->sqlHandler, &StatementText, -3);
    v6 = SQLExecute(a1->sqlHandler);
  }
  if ( v6 && v6 != 1 )
  {
    SqlQuery::printError(a1, 3, a1->sqlHandler, (char *)&StatementText);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (0041423B) --------------------------------------------------------
char unused_sub_41423B(SqlQuery *this, char *format, ...)
{
  char result; // al@5
  SQLCHAR StatementText; // [sp+0h] [bp-100Ch]@1
  SQLINTEGER TextLength; // [sp+1000h] [bp-Ch]@1
  va_list v5; // [sp+1004h] [bp-8h]@1
  __int16 v6; // [sp+1008h] [bp-4h]@1
  va_list va; // [sp+101Ch] [bp+10h]@1

  va_start(va, format);
  v5 = va;
  TextLength = vsprintf((char *)&StatementText, format, va);
  v5 = 0;
  v6 = -1;
  if ( TextLength > 0 )
    v6 = SqlQuery::execRaw((SqlQuery *)this->sqlHandler, (const char *)&StatementText, TextLength);
  if ( v6 && v6 != 1 )
  {
    SqlQuery::printError2(SQL_HANDLE_STMT, this->sqlHandler, (char *)&StatementText);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (004142C7) --------------------------------------------------------
char unused_sub_4142C7(SQLHSTMT *a1, char *a2, ...)
{
  char result; // al@5
  SQLCHAR StatementText; // [sp+0h] [bp-100Ch]@1
  int v4; // [sp+1000h] [bp-Ch]@1
  va_list v5; // [sp+1004h] [bp-8h]@1
  __int16 v6; // [sp+1008h] [bp-4h]@1
  va_list va; // [sp+101Ch] [bp+10h]@1

  va_start(va, a2);
  v5 = va;
  v4 = vsprintf((char *)&StatementText, a2, va);
  v5 = 0;
  v6 = -1;
  if ( v4 > 0 )
  {
    SQLPrepare(*a1, &StatementText, -3);
    v6 = SQLExecute(*a1);
  }
  if ( v6 && v6 != 1 )
  {
    SqlQuery::printError2(3, *a1, (char *)&StatementText);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (0041435C) --------------------------------------------------------
char SqlQuery::sub_41435C(SqlQuery *a1, char *a2, ...)
{
  char result; // al@6
  char sqlQuery; // [sp+0h] [bp-100Ch]@1
  int textLength; // [sp+1000h] [bp-Ch]@1
  va_list v5; // [sp+1004h] [bp-8h]@1
  __int16 v6; // [sp+1008h] [bp-4h]@1
  va_list va; // [sp+101Ch] [bp+10h]@1

  va_start(va, a2);
  v5 = va;
  textLength = vsprintf(&sqlQuery, a2, va);
  v5 = 0;
  v6 = -1;
  if ( textLength > 0 )
    v6 = SqlQuery::execRaw((SqlQuery *)a1->sqlHandler, &sqlQuery, textLength);
  if ( v6 && v6 != 1 && v6 != 100 )
  {
    SqlQuery::printError(a1, 3, a1->sqlHandler, &sqlQuery);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (004143F1) --------------------------------------------------------
char __thiscall SqlQuery::fetch(SqlQuery *this, bool *notFound)
{
  char result; // al@2
  SQLRETURN sqlreturn; // [sp+4h] [bp-4h]@1

  sqlreturn = SQLFetch(this->sqlHandler);
  if ( notFound )
  {
    *notFound = sqlreturn == SQL_NO_DATA;
    result = 1;
  }
  else if ( sqlreturn && sqlreturn != SQL_SUCCESS_WITH_INFO )// SQL_SUCCESS = 0
  {
    if ( sqlreturn != SQL_NO_DATA )
      LogWindow::Add(&g_LogWindow, 3, aFetchErrorD, sqlreturn);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (00414463) --------------------------------------------------------
char __thiscall SqlQuery::sub_414463(SqlQuery *this, char a2)
{
  char result; // al@6
  SqlQuery *v3; // [sp+0h] [bp-8h]@1
  SQLRETURN v4; // [sp+4h] [bp-4h]@2

  v3 = this;
  if ( a2 )
    v4 = SQLSetConnectAttr(this->sqlConnection->dbcSqlHandler, 102, (SQLPOINTER)1, 4);
  else
    v4 = SQLSetConnectAttr(this->sqlConnection->dbcSqlHandler, 102, 0, 4);
  if ( v4 != -1 && v4 != -2 )
  {
    result = 1;
  }
  else
  {
    SqlQuery::printError(v3, 2, v3->sqlConnection->dbcSqlHandler, 0);
    result = 0;
  }
  return result;
}

//----- (00414532) --------------------------------------------------------
void __thiscall SqlQuery::printError(SqlQuery *this, SQLSMALLINT handlerType, SQLHANDLE handler, char *sqlQuery)
{
  SqlQuery *this_; // [sp+0h] [bp-11Ch]@1
  SQLSMALLINT textLength; // [sp+4h] [bp-118h]@1
  SQLCHAR errorText[256]; // [sp+8h] [bp-114h]@1
  SQLINTEGER nativeError; // [sp+108h] [bp-14h]@1
  char sqlState[12]; // [sp+10Ch] [bp-10h]@1
  __int16 sqlResult; // [sp+118h] [bp-4h]@1

  this_ = this;
  sqlResult = SQLGetDiagRec(handlerType, handler, 1, (SQLCHAR *)sqlState, &nativeError, errorText, 256, &textLength);
  if ( !sqlResult )
  {
    if ( sqlQuery )
      LogWindow::Add(&g_LogWindow, 3, aSqlFormat, sqlQuery);
    LogWindow::Add(&g_LogWindow, 3, aSS, sqlState, errorText);
    if ( !strcmp(sqlState, a08s01) )
    {
      SpinLock::Enter(&this_->dbManager->spinLock);
      if ( !this_->dbManager->recoveryTriggered && !this_->sqlConnection->free )
      {
        this_->dbManager->base.vftbl_0_45F520->AddTimer((MemoryObject *)this_->dbManager, 30000, 1);
        this_->dbManager->recoveryTriggered = 1;
      }
      SpinLock::Leave(&this_->dbManager->spinLock);
    }
  }
}

//----- (00414647) --------------------------------------------------------
int __stdcall SqlQuery::printError2(SQLSMALLINT handlerType, SQLHANDLE handler, char *sqlQuery)
{
  int sqlResult; // eax@1
  SQLSMALLINT textLength; // [sp+4h] [bp-114h]@1
  SQLCHAR errorText[256]; // [sp+8h] [bp-110h]@1
  SQLINTEGER nativeError; // [sp+108h] [bp-10h]@1
  char Sqlstate[12]; // [sp+10Ch] [bp-Ch]@1

  sqlResult = SQLGetDiagRec(handlerType, handler, 1, (SQLCHAR *)Sqlstate, &nativeError, errorText, 256, &textLength);
  if ( !(_WORD)sqlResult )
  {
    sqlResult = strcmp(Sqlstate, a23000);
    if ( sqlResult )
    {
      if ( sqlQuery )
        LogWindow::Add(&g_LogWindow, 3, aSqlS_0, sqlQuery);
      sqlResult = (int)LogWindow::Add(&g_LogWindow, 3, aSS_0, Sqlstate, errorText);
    }
  }
  return sqlResult;
}

//----- (004146F6) --------------------------------------------------------
SQLRETURN __thiscall SqlQuery::bindByte(SqlQuery *this, SQLPOINTER value)
{
  SQLUSMALLINT collumn; // ST04_2@1
  SQLHSTMT handler; // ST00_4@1

  collumn = this->currentCollumn;
  handler = this->sqlHandler;
  ++this->currentCollumn;
  return SQLBindCol(handler, collumn, -6, value, 1, 0);// SQL_TINYINT = -6
}

//----- (00414739) --------------------------------------------------------
SQLRETURN __thiscall SqlQuery::bindBool(SqlQuery *this, SQLPOINTER value)
{
  SQLUSMALLINT collumn; // ST04_2@1
  SQLHSTMT handler; // ST00_4@1

  collumn = this->currentCollumn;
  handler = this->sqlHandler;
  ++this->currentCollumn;
  return SQLBindCol(handler, collumn, -6, value, 1, 0);// SQL_TINYINT = -6
}

//----- (0041477C) --------------------------------------------------------
SQLRETURN __thiscall SqlQuery::bindStr(SqlQuery *this, SQLPOINTER value, SQLINTEGER length)
{
  SQLUSMALLINT collumn; // ST04_2@1
  SQLHSTMT handler; // ST00_4@1

  collumn = this->currentCollumn;
  handler = this->sqlHandler;
  ++this->currentCollumn;
  return SQLBindCol(handler, collumn, SQL_CHAR, value, length, 0);
}

//----- (004147C1) --------------------------------------------------------
SQLRETURN __thiscall SqlQuery::bindUInt(SqlQuery *this, SQLPOINTER value)
{
  SQLUSMALLINT collumn; // ST04_2@1
  SQLHSTMT v3; // ST00_4@1

  collumn = this->currentCollumn;
  v3 = this->sqlHandler;
  ++this->currentCollumn;
  return SQLBindCol(v3, collumn, SQL_INTEGER, value, 4, 0);
}

//----- (00414804) --------------------------------------------------------
SQLRETURN __thiscall SqlQuery::bindInt(SqlQuery *this, SQLPOINTER value)
{
  SQLUSMALLINT collumn; // ST04_2@1
  SQLHSTMT handler; // ST00_4@1

  collumn = this->currentCollumn;
  handler = this->sqlHandler;
  ++this->currentCollumn;
  return SQLBindCol(handler, collumn, SQL_INTEGER, value, 4, 0);
}

//----- (00414847) --------------------------------------------------------
SQLRETURN __thiscall SqlQuery::bindShort(SqlQuery *this, SQLPOINTER TargetValue)
{
  SQLUSMALLINT v2; // ST04_2@1
  SQLHSTMT v3; // ST00_4@1

  v2 = this->currentCollumn;
  v3 = this->sqlHandler;
  ++this->currentCollumn;
  return SQLBindCol(v3, v2, SQL_SMALLINT, TargetValue, 2, 0);
}

//----- (004148A0) --------------------------------------------------------
SQLRETURN __thiscall SqlQuery::bindSmthng(SqlQuery *this, SQLPOINTER rgbValue, SQLSMALLINT fParamType)
{
  SQLUSMALLINT v3; // ST04_2@1
  SqlQuery *v4; // ST00_4@1

  v3 = this->field_8;
  v4 = (SqlQuery *)this->sqlHandler;
  ++this->field_8;
  return SqlQuery::bindParam(v4, v3, fParamType, -6, -6, 0, 0, rgbValue, 0, 0);
}

//----- (004148EE) --------------------------------------------------------
SQLRETURN __thiscall SqlQuery::sub_4148EE(SqlQuery *this, SQLPOINTER rgbValue, SQLSMALLINT fParamType)
{
  SQLUSMALLINT v3; // ST04_2@1
  SqlQuery *v4; // ST00_4@1

  v3 = this->field_8;
  v4 = (SqlQuery *)this->sqlHandler;
  ++this->field_8;
  return SqlQuery::bindParam(v4, v3, fParamType, -6, -6, 0, 0, rgbValue, 0, 0);
}

//----- (0041493C) --------------------------------------------------------
SQLRETURN __thiscall SqlQuery::sub_41493C(SqlQuery *this, SQLPOINTER rgbValue, SQLUINTEGER cbColDef, SQLSMALLINT fParamType)
{
  SQLUSMALLINT v4; // ST04_2@1
  SqlQuery *v5; // ST00_4@1

  v4 = this->field_8;
  v5 = (SqlQuery *)this->sqlHandler;
  ++this->field_8;
  return SqlQuery::bindParam(v5, v4, fParamType, 1, 12, cbColDef, 0, rgbValue, cbColDef + 1, 0);
}

//----- (00414991) --------------------------------------------------------
SQLRETURN __thiscall SqlQuery::sub_414991(SqlQuery *this, SQLPOINTER rgbValue, SQLSMALLINT fParamType)
{
  SQLUSMALLINT v3; // ST04_2@1
  SqlQuery *v4; // ST00_4@1

  v3 = this->field_8;
  v4 = (SqlQuery *)this->sqlHandler;
  ++this->field_8;
  return SqlQuery::bindParam(v4, v3, fParamType, 4, 4, 0, 0, rgbValue, 0, 0);
}

//----- (004149DF) --------------------------------------------------------
SQLRETURN __thiscall SqlQuery::sub_4149DF(SqlQuery *this, SQLPOINTER rgbValue, SQLSMALLINT fParamType)
{
  SQLUSMALLINT v3; // ST04_2@1
  SqlQuery *v4; // ST00_4@1

  v3 = this->field_8;
  v4 = (SqlQuery *)this->sqlHandler;
  ++this->field_8;
  return SqlQuery::bindParam(v4, v3, fParamType, 4, 4, 0, 0, rgbValue, 0, 0);
}

//----- (00414A2D) --------------------------------------------------------
SQLRETURN __thiscall SqlQuery::sub_414A2D(SqlQuery *this, SQLPOINTER rgbValue, SQLSMALLINT fParamType)
{
  SQLUSMALLINT v3; // ST04_2@1
  SqlQuery *v4; // ST00_4@1

  v3 = this->field_8;
  v4 = (SqlQuery *)this->sqlHandler;
  ++this->field_8;
  return SqlQuery::bindParam(v4, v3, fParamType, 5, 5, 0, 0, rgbValue, 0, 0);
}

//----- (00414A7B) --------------------------------------------------------
SQLRETURN __thiscall SqlQuery::reset(SqlQuery *this)
{
  SqlQuery *this_; // ST08_4@1

  this_ = this;
  this->currentCollumn = 1;
  this->field_8 = 1;
  SQLFreeStmt(this->sqlHandler, SQL_UNBIND);
  return SQLFreeStmt(this_->sqlHandler, SQL_CLOSE);
}

//----- (00414AB4) --------------------------------------------------------
int SomeStaticInit11()
{
  SomeBitsInit();
  return sub_414AC3();
}

//----- (00414AC3) --------------------------------------------------------
int sub_414AC3()
{
  return atexit(emptystub);
}

//----- (00414AE0) --------------------------------------------------------
void Database::OnWaitCallback()
{
  ;
}

//----- (00414AF0) --------------------------------------------------------
void __stdcall Database::OnIOCallback(Database *this, int a2, int a3)
{
  ;
}

//----- (00414B00) --------------------------------------------------------
Database *__thiscall Database::DestructorCall(Database *this, char a2)
{
  Database *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  Database::Destructor(this);
  if ( a2 & 1 )
    operator_delete(v3);
  return v3;
}

//----- (00414B30) --------------------------------------------------------
char *__cdecl DesFrontEnd::encodeData(char *data, int size)
{
  int trunkatedSize; // eax@1

  trunkatedSize = size;
  LOBYTE(trunkatedSize) = size & 248;
  return DesFrontEnd::processData(data, trunkatedSize, 1);
}

//----- (00414B49) --------------------------------------------------------
char *__cdecl DesFrontEnd::processData(char *data, int size, int encrypt)
{
  char *result; // eax@1
  char *iterator; // [sp+0h] [bp-4h]@1

  result = data;
  iterator = data;
  while ( size > 0 )
  {
    if ( encrypt )
      result = DesFrontEnd::encryptBlock(iterator, iterator);
    else
      result = DesFrontEnd::decryptBlock(iterator, iterator);
    size -= 8;
    iterator += 8;
  }
  return result;
}

//----- (00414B9B) --------------------------------------------------------
_BYTE *__cdecl DesFrontEnd::encryptBlock(_BYTE *a1, _BYTE *a2)
{
  unsigned __int8 v3[8]; // [sp+0h] [bp-9Ch]@4
  int i; // [sp+8h] [bp-94h]@1
  char subKey[8]; // [sp+Ch] [bp-90h]@1
  char v6[120]; // [sp+14h] [bp-88h]@3
  unsigned __int8 v7[8]; // [sp+8Ch] [bp-10h]@4
  unsigned __int8 *v8; // [sp+94h] [bp-8h]@4
  int *v9; // [sp+98h] [bp-4h]@4

  Des::decrypt_encrypt(a1, Crypto::some_des_key.desInner, subKey);
  for ( i = 0; i < 16; ++i )
    Des::Ffunc(i, &subKey[8 * i], &v6[8 * i]);
  v3[0] = v7[4];
  v3[1] = v7[5];
  v3[2] = v7[6];
  v3[3] = v7[7];
  v3[4] = v7[0];
  v3[5] = v7[1];
  v3[6] = v7[2];
  v3[7] = v7[3];
  v9 = &i;
  v8 = &v7[4];
  return Des::decrypt_encrypt((char *)v3, Crypto::some_other_des_key.desInner, a2);
}
// 414B9B: using guessed type char subKey[8];
// 414B9B: using guessed type char var_88[120];

//----- (00414D1E) --------------------------------------------------------
_BYTE *__cdecl Des::decrypt_encrypt(char *a1, DesInner *a2, _BYTE *a3)
{
  _BYTE *result; // eax@1
  char *v4; // [sp+0h] [bp-18h]@4
  signed int v5; // [sp+4h] [bp-14h]@4
  signed int v6; // [sp+8h] [bp-10h]@1
  signed int i; // [sp+8h] [bp-10h]@6
  _BYTE *v8; // [sp+Ch] [bp-Ch]@1
  _BYTE *v9; // [sp+Ch] [bp-Ch]@6
  char *v10; // [sp+10h] [bp-8h]@6
  char *v11; // [sp+14h] [bp-4h]@6

  v6 = 0;
  result = a3;
  v8 = a3;
  while ( v6 < 8 )
  {
    *v8 = 0;
    result = v8++ + 1;
    ++v6;
  }
  v4 = a1;
  v5 = 0;
  while ( v5 < 16 )
  {
    v9 = a3;
    v11 = (char *)&a2[v5] + 8 * ((*v4 >> 4) & 0xF);
    v10 = (char *)&a2[v5 + 1] + 8 * (*v4 & 0xF);
    for ( i = 0; i < 8; ++i )
      *v9++ |= *v10++ | *v11++;
    v5 += 2;
    result = v4++ + 1;
  }
  return result;
}

//----- (00414E16) --------------------------------------------------------
_BYTE *__cdecl Des::Ffunc(int index, char *a2, _BYTE *a3)
{
  char v4; // [sp+4h] [bp-Ch]@1
  _BYTE *v5; // [sp+8h] [bp-8h]@1
  char *v6; // [sp+Ch] [bp-4h]@1

  v5 = a3;
  Des::Ffunc_inner((int)(a2 + 4), index, (int)&v4);
  *v5++ = a2[4];
  *v5++ = a2[5];
  *v5++ = a2[6];
  *v5++ = a2[7];
  v6 = &v4;
  *v5++ = v4 ^ *a2;
  *v5++ = *++v6 ^ a2[1];
  *v5 = *++v6 ^ a2[2];
  *++v5 = v6[1] ^ a2[3];
  return v5 + 1;
}

//----- (00414F77) --------------------------------------------------------
_BYTE *__cdecl Des::Ffunc_inner(int a1, int a2, int a3)
{
  char v4; // [sp+0h] [bp-20h]@1
  char v5; // [sp+4h] [bp-1Ch]@1
  char *v6; // [sp+Ch] [bp-14h]@1
  char *v7; // [sp+10h] [bp-10h]@1
  char *v8; // [sp+14h] [bp-Ch]@1
  char v9; // [sp+18h] [bp-8h]@1

  v6 = Crypto::byte_47DFBC[a2];
  v8 = &v5;
  v7 = &v9;
  Des::sub_415201(a1, (int)&v5);
  *v7++ = *v6++ ^ *v8;
  *v7++ = *v6 ^ *++v8;
  *v7++ = *++v6 ^ *++v8;
  *v7++ = *++v6 ^ *++v8;
  *v7++ = *++v6 ^ *++v8;
  *v7++ = *++v6 ^ *++v8;
  ++v6;
  ++v8;
  Des::sub_4153A3((unsigned __int8 *)&v9, (unsigned __int8 *)&v4);
  return Des::sub_4150DF(&v4, a3);
}

//----- (004150DF) --------------------------------------------------------
_BYTE *__cdecl Des::sub_4150DF(_BYTE *a1, int a2)
{
  _BYTE *result; // eax@1
  char *v3; // ST0C_4@3
  _BYTE *v4; // [sp+0h] [bp-10h]@1
  signed int v5; // [sp+4h] [bp-Ch]@1

  *(_BYTE *)a2 = 0;
  *(_BYTE *)(a2 + 1) = 0;
  *(_BYTE *)(a2 + 2) = 0;
  *(_BYTE *)(a2 + 3) = 0;
  result = a1;
  v4 = a1;
  v5 = 0;
  while ( v5 < 4 )
  {
    v3 = Crypto::byte_47874C[v5][*v4];
    *(_BYTE *)a2 |= *v3++;
    *(_BYTE *)(a2 + 1) |= *v3++;
    *(_BYTE *)(a2 + 2) |= *v3++;
    *(_BYTE *)(a2 + 3) |= *v3;
    result = v3 + 1;
    ++v5;
    ++v4;
  }
  return result;
}

//----- (00415201) --------------------------------------------------------
int __cdecl Des::sub_415201(int a1, int a2)
{
  char v2; // ST00_1@1
  char v3; // ST14_1@1
  char v4; // ST0C_1@1
  char v5; // ST08_1@1
  int v6; // ST10_4@1

  v2 = *(_BYTE *)a1;
  v3 = *(_BYTE *)(a1 + 1);
  v4 = *(_BYTE *)(a1 + 2);
  v5 = *(_BYTE *)(a1 + 3);
  *(_BYTE *)a2 = ((v2 & 0x18) >> 3) | ((v2 & 248) >> 1) | ((v5 & 1) << 7);
  *(_BYTE *)(a2 + 1) = ((v3 & 224) >> 5) | 8 * (v2 & 1) | ((v3 & 0x80) >> 3) | 32 * (v2 & 7);
  *(_BYTE *)(a2 + 2) = ((v4 & 128) >> 7) | 2 * (v3 & 31) | 8 * (v3 & 0x18);
  *(_BYTE *)(a2 + 3) = ((v4 & 24) >> 3) | ((v4 & 0xF8) >> 1) | ((v3 & 1) << 7);
  v6 = a2 + 4;
  *(_BYTE *)v6 = ((v5 & 0xE0) >> 5) | 8 * (v4 & 1) | ((v5 & 0x80) >> 3) | 32 * (v4 & 7);
  *(_BYTE *)(v6 + 1) = ((v2 & 0x80) >> 7) | 2 * (v5 & 0x1F) | 8 * (v5 & 0x18);
  return a2 + 6;
}

//----- (004153A3) --------------------------------------------------------
unsigned __int8 *__cdecl Des::sub_4153A3(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2; // ST10_4@1
  unsigned __int8 v3; // ST0C_1@1
  __int16 v4; // ST08_2@1
  signed int v5; // ST04_4@1
  unsigned __int8 v6; // ST00_1@1

  v2 = (char)a1[1];
  v3 = a1[2];
  v4 = (char)a1[3];
  v5 = (char)a1[4];
  v6 = a1[5];
  *a2 = Crypto::byte_47974C[0][((v2 >> 4) & 0xF | (unsigned __int16)(16 * (char)*a1)) & 0xFFF];
  a2[1] = Crypto::byte_47974C[4][(v3 | (unsigned __int16)((_WORD)v2 << 8)) & 0xFFF];
  a2[2] = Crypto::byte_47974C[8][((v5 >> 4) & 0xF | (unsigned __int16)(16 * v4)) & 0xFFF];
  a2[3] = Crypto::byte_47974C[12][(v6 | (unsigned __int16)((_WORD)v5 << 8)) & 0xFFF];
  return a2 + 4;
}

//----- (004154CF) --------------------------------------------------------
_BYTE *__cdecl DesFrontEnd::decryptBlock(char *a1, char *a2)
{
  char v3[8]; // [sp+0h] [bp-9Ch]@4
  int i; // [sp+8h] [bp-94h]@1
  char subKey[8]; // [sp+Ch] [bp-90h]@1
  char v6[120]; // [sp+14h] [bp-88h]@3
  unsigned __int8 v7[8]; // [sp+8Ch] [bp-10h]@4
  unsigned __int8 *v8; // [sp+94h] [bp-8h]@4
  int *v9; // [sp+98h] [bp-4h]@4

  Des::decrypt_encrypt(a1, Crypto::some_des_key.desInner, subKey);
  for ( i = 0; i < 16; ++i )
    Des::Ffunc(15 - i, &subKey[8 * i], &v6[8 * i]);
  v3[0] = v7[4];
  v3[1] = v7[5];
  v3[2] = v7[6];
  v3[3] = v7[7];
  v3[4] = v7[0];
  v3[5] = v7[1];
  v3[6] = v7[2];
  v3[7] = v7[3];
  v9 = &i;
  v8 = &v7[4];
  return Des::decrypt_encrypt(v3, Crypto::some_other_des_key.desInner, a2);
}
// 4154CF: using guessed type char subKey[8];
// 4154CF: using guessed type char var_88[120];

//----- (00415657) --------------------------------------------------------
char *__cdecl DesFrontEnd::decodeData(char *data, int size)
{
  int trunkatedSize; // eax@1

  trunkatedSize = size;
  LOBYTE(trunkatedSize) = size & 248;
  return DesFrontEnd::processData(data, trunkatedSize, 0);
}

//----- (00415670) --------------------------------------------------------
int __cdecl DesFrontEnd::initDesKey(const char *stringKey)
{
  signed int i; // [sp+0h] [bp-10h]@1
  char compressedKey[8]; // [sp+8h] [bp-8h]@1

  memset(compressedKey, 0, 8u);
  for ( i = 0; *stringKey && i < 40; ++i )
    compressedKey[i % 8] ^= *stringKey++;
  Des::init_sub_415AD1(&Crypto::some_des_key, Des::ip);
  Des::init_sub_415AD1(&Crypto::some_other_des_key, Des::fp);
  Des::init_sub_4157F0(compressedKey);
  Des::init_Sfunc();
  return Des::init_sub_415984();
}

//----- (00415727) --------------------------------------------------------
void Des::init_Sfunc()
{
  char v0; // bl@5
  signed int j; // [sp+4h] [bp-8h]@3
  signed int i; // [sp+8h] [bp-4h]@1

  for ( i = 0; i < 4; ++i )
  {
    for ( j = 0; j < 0x1000; ++j )
    {
      v0 = 16 * Des::init_getFrom_S_Table(2 * i, j >> 6);// >> 6 -> 0..63
      Crypto::byte_47974C[4 * i][j] = Des::init_getFrom_S_Table(2 * i + 1, j & 63) & 15 | v0;// >> & 63 -> 0..63
    }
  }
}

//----- (004157B0) --------------------------------------------------------
int __cdecl Des::init_getFrom_S_Table(int row, int collumn)
{
  return *(&Des::SBoxes[row][16 * (collumn & 1 | ((collumn & 0x20) >> 4))] + ((collumn & 31) >> 1));
}

//----- (004157F0) --------------------------------------------------------
int __cdecl Des::init_sub_4157F0(char *desKey)
{
  int result; // eax@3
  int v2; // eax@14
  int v3; // [sp+0h] [bp-14h]@15
  int v4; // [sp+8h] [bp-Ch]@14
  signed int i; // [sp+Ch] [bp-8h]@1
  signed int k; // [sp+Ch] [bp-8h]@6
  signed int m; // [sp+Ch] [bp-8h]@12
  signed int n; // [sp+Ch] [bp-8h]@18
  signed int j; // [sp+10h] [bp-4h]@4
  signed int l; // [sp+10h] [bp-4h]@10
                                                // PTBIT - BIT TABLE FOR PERMUTATIONS 
  for ( i = 0; i < 56; ++i )                    // 64 -> 56 permutation
  {
    Des::permutedKeyBits[i] = (Des::PTBIT[(Des::kp_PC[i] - 1) & 7] & desKey[(Des::kp_PC[i] - 1) >> 3]) != 0;
    result = i + 1;
  }
  for ( j = 0; j < 16; ++j )                    // zeroed some data
  {
    for ( k = 0; k < 6; ++k )
      Crypto::byte_47DFBC[j][k] = 0;
    result = j + 1;
  }
  for ( l = 0; l < 16; ++l )
  {
    for ( m = 0; m < 56; ++m )
    {                                           // 1  2  3  4  5   6   7   8   9  10  11  12  13  14  15  16
      v4 = Des::loop_table_[l] + m;             // 1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28
      v2 = m < 28;                              // 1  1  2  2  2  2   2   2   1   2   2   2   2   2   2   1
      LOBYTE(v2) = m >= 28;
      --v2;
      LOBYTE(v2) = v2 & 228;                    // 1110 0100
      if ( v4 >= v2 + 56 )
        v3 = v4 - 28;
      else
        v3 = Des::loop_table_[l] + m;
      result = m;
      Crypto::byte_47D784[m] = Des::permutedKeyBits[v3];
    }
    for ( n = 0; n < 48; ++n )
    {
      if ( Des::permutedKeyBits[Des::kp2[n] + 55] )
        Crypto::byte_47DFBC[l][n >> 3] |= LOBYTE(Des::PTBIT[n & 7]);
      result = n + 1;
    }
  }
  return result;
}

//----- (00415984) --------------------------------------------------------
int Des::init_sub_415984()
{
  int result; // eax@9
  signed int v1; // [sp+8h] [bp-10h]@17
  signed int k; // [sp+Ch] [bp-Ch]@5
  signed int n; // [sp+Ch] [bp-Ch]@14
  signed int j; // [sp+10h] [bp-8h]@3
  signed int m; // [sp+10h] [bp-8h]@12
  signed int i; // [sp+14h] [bp-4h]@1
  signed int l; // [sp+14h] [bp-4h]@10

  for ( i = 0; i < 4; ++i )
  {
    for ( j = 0; j < 256; ++j )
    {
      for ( k = 0; k < 4; ++k )
        Crypto::byte_47874C[i][j][k] = 0;
    }
    result = i + 1;
  }
  for ( l = 0; l < 4; ++l )
  {
    for ( m = 0; m < 256; ++m )
    {
      for ( n = 0; n < 32; ++n )
      {
        v1 = Des::pc[n] - 1;
        if ( v1 >> 3 == l && Des::PTBIT[v1 & 7] & m )
          Crypto::byte_47874C[l][m][n >> 3] |= LOBYTE(Des::PTBIT[n & 7]);
      }
    }
    result = l + 1;
  }
  return result;
}

//----- (00415AD1) --------------------------------------------------------
int __cdecl Des::init_sub_415AD1(DesItem *a1, const unsigned __int8 *constants)
{
  int result; // eax@9
  signed int v3; // [sp+8h] [bp-10h]@17
  signed int k; // [sp+Ch] [bp-Ch]@5
  signed int n; // [sp+Ch] [bp-Ch]@14
  signed int j; // [sp+10h] [bp-8h]@3
  signed int m; // [sp+10h] [bp-8h]@12
  signed int i; // [sp+14h] [bp-4h]@1
  signed int l; // [sp+14h] [bp-4h]@10

  for ( i = 0; i < 16; ++i )
  {
    for ( j = 0; j < 16; ++j )
    {
      for ( k = 0; k < 8; ++k )
        a1->desInner[i].des8[j].bits[k] = 0;
    }
    result = i + 1;
  }
  for ( l = 0; l < 16; ++l )
  {
    for ( m = 0; m < 16; ++m )
    {
      for ( n = 0; n < 64; ++n )
      {
        v3 = constants[n] - 1;
        if ( v3 >> 2 == l && Des::SmallBoolMask[v3 & 3] & m )
          a1->desInner[l].des8[m].bits[n >> 3] |= LOBYTE(Des::PTBIT[n & 7]);// BitToByte
        result = n + 1;
      }
    }
  }
  return result;
}

//----- (00415C20) --------------------------------------------------------
int Static_ExceptionHandler()
{
  CallExceptionHandler_Ctor();
  return RegisterExceptionHandlerDestructor();
}

//----- (00415C2F) --------------------------------------------------------
ExceptionHandler *CallExceptionHandler_Ctor()
{
  return ExceptionHandler::ExceptionHandler(&g_ExceptionHandler);
}

//----- (00415C3E) --------------------------------------------------------
int RegisterExceptionHandlerDestructor()
{
  return atexit(CallExceptionHandlerDestructor);
}

//----- (00415C50) --------------------------------------------------------
void __cdecl CallExceptionHandlerDestructor()
{
  ExceptionHandler::Destructor();
}

//----- (00415CD1) --------------------------------------------------------
int __cdecl CoreDump::writeModule_Raw(LPCVOID pcOffset, LPSTR lpFilename, DWORD nSize, int *numberOfSections, int *a5)
{
  int result; // eax@2
  DWORD v6; // [sp+0h] [bp-40h]@8
  unsigned int virtualAddress; // [sp+4h] [bp-3Ch]@7
  MEMORY_BASIC_INFORMATION memoryInfo; // [sp+Ch] [bp-34h]@1
  unsigned int regionSize; // [sp+28h] [bp-18h]@5
  unsigned int sectionIndex; // [sp+2Ch] [bp-14h]@5
  IMAGE_SECTION_HEADER *sectionTable; // [sp+30h] [bp-10h]@5
  IMAGE_NT_HEADERS32 *ntHeader; // [sp+34h] [bp-Ch]@5
  IMAGE_DOS_HEADER *unused; // [sp+38h] [bp-8h]@5
  IMAGE_DOS_HEADER *moduleLocation; // [sp+3Ch] [bp-4h]@3

  if ( VirtualQuery(pcOffset, &memoryInfo, 28u) )// The GetModuleBase function retrieves the base address of the module that contains the specified address. 
  {
    moduleLocation = (IMAGE_DOS_HEADER *)memoryInfo.AllocationBase;
    if ( GetModuleFileNameA((HMODULE)memoryInfo.AllocationBase, lpFilename, nSize) )
    {
      unused = moduleLocation;
      ntHeader = (IMAGE_NT_HEADERS32 *)((char *)moduleLocation + moduleLocation->e_lfanew);
      sectionTable = (IMAGE_SECTION_HEADER *)((char *)&ntHeader->OptionalHeader
                                            + ntHeader->FileHeader.SizeOfOptionalHeader);//  offsetof (IMAGE_NT_HEADERS, OptionalHeader)
      regionSize = (_BYTE *)pcOffset - (_BYTE *)moduleLocation;
      sectionIndex = 0;
      while ( sectionIndex < ntHeader->FileHeader.NumberOfSections )
      {
        virtualAddress = sectionTable->VirtualAddress;
        if ( sectionTable->SizeOfRawData <= sectionTable->Misc.PhysicalAddress )
          v6 = sectionTable->Misc.PhysicalAddress;
        else
          v6 = sectionTable->SizeOfRawData;
        if ( regionSize >= virtualAddress && regionSize <= v6 + virtualAddress )
        {
          *numberOfSections = sectionIndex + 1;
          *a5 = regionSize - virtualAddress;
          return 1;
        }
        ++sectionIndex;
        ++sectionTable;
      }
      result = 0;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00415DD8) --------------------------------------------------------
BOOL __cdecl CoreDump::writeCallStackWithSymbols(HANDLE hFile, CONTEXT *contextRecord)
{
  HANDLE currThread; // ST08_4@2
  HANDLE currProc; // eax@2
  BOOL result; // eax@2
  DWORD pc; // ST18_4@4
  HANDLE hProcess; // eax@4
  signed int i; // [sp+Ch] [bp-514h]@9
  char exeFilename[260]; // [sp+10h] [bp-510h]@7
  void *pc1; // [sp+114h] [bp-40Ch]@9
  MEMORY_BASIC_INFORMATION memoryInfo; // [sp+118h] [bp-408h]@6
  char *filename; // [sp+134h] [bp-3ECh]@6
  int a5; // [sp+138h] [bp-3E8h]@9
  char moduleFilename[260]; // [sp+13Ch] [bp-3E4h]@9
  char *numberOfSections; // [sp+240h] [bp-2E0h]@9
  PIMAGEHLP_SYMBOL symbol; // [sp+244h] [bp-2DCh]@4
  DWORD dwDisp; // [sp+248h] [bp-2D8h]@4
  char symbolBuffer[536]; // [sp+24Ch] [bp-2D4h]@4
  STACKFRAME stackFrame; // [sp+464h] [bp-BCh]@1
  CPPEH_RECORD ms_exc; // [sp+508h] [bp-18h]@11

  CoreDump::writeLine(hFile, aCallStackInfor);
  SymSetOptions(SYMOPT_DEFERRED_LOADS);
  memset(&stackFrame, 0, 164u);
  stackFrame.AddrPC.Offset = contextRecord->Eip;
  stackFrame.AddrPC.Mode = AddrModeFlat;
  stackFrame.AddrStack.Offset = contextRecord->Esp;
  stackFrame.AddrStack.Mode = AddrModeFlat;
  stackFrame.AddrFrame.Offset = contextRecord->Ebp;
  stackFrame.AddrFrame.Mode = AddrModeFlat;
  while ( true )
  {
    currThread = GetCurrentThread();
    currProc = GetCurrentProcess();
    result = StackWalk(
               IMAGE_FILE_MACHINE_I386,
               currProc,
               currThread,
               &stackFrame,
               contextRecord,
               0,
               SymFunctionTableAccess,
               SymGetModuleBase,
               0);
    if ( !result || !stackFrame.AddrFrame.Offset )
      break;
    CoreDump::writeLine(hFile, a08x08x, stackFrame.AddrPC.Offset, stackFrame.AddrFrame.Offset);
    symbol = (PIMAGEHLP_SYMBOL)symbolBuffer;
    *(_DWORD *)symbolBuffer = 536;
    *(_DWORD *)&symbolBuffer[16] = 512;
    dwDisp = 0;
    pc = stackFrame.AddrPC.Offset;
    hProcess = GetCurrentProcess();
    if ( SymGetSymFromAddr(hProcess, pc, &dwDisp, (PIMAGEHLP_SYMBOL)symbolBuffer) )
      CoreDump::writeLine(hFile, aSX, symbol->Name, dwDisp);
    filename = aUnknown;
    if ( VirtualQuery((LPCVOID)stackFrame.AddrPC.Offset, &memoryInfo, 28u)
      && GetModuleFileNameA((HMODULE)memoryInfo.AllocationBase, exeFilename, 260u) )
    {
      filename = Utils::getFileName(exeFilename);
    }
    moduleFilename[0] = dword_47EA54;
    memset(&moduleFilename[1], 0, 256u);
    *(_WORD *)&moduleFilename[257] = 0;
    moduleFilename[259] = 0;
    numberOfSections = 0;
    a5 = 0;
    CoreDump::writeModule_Raw((LPCVOID)stackFrame.AddrPC.Offset, moduleFilename, 260u, (int *)&numberOfSections, &a5);
    CoreDump::writeLine(hFile, a04x08xS, numberOfSections, a5, moduleFilename);
    CoreDump::writeLine(
      hFile,
      aParams08x08x08,
      stackFrame.Params[0],
      stackFrame.Params[1],
      stackFrame.Params[2],
      stackFrame.Params[3]);
    CoreDump::writeLine(hFile, aSBytesAtCsEip, filename);
    pc1 = (void *)stackFrame.AddrPC.Offset;
    for ( i = 0; i < 16; ++i )
    {
      ms_exc.registration.TryLevel = 0;
      CoreDump::writeLine(hFile, a02x, *((_BYTE *)pc1 + i));
      ms_exc.registration.TryLevel = -1;
    }
    CoreDump::writeLine(hFile, asc_46B030);
  }
  return result;
}
// 47EA54: using guessed type int dword_47EA54;

//----- (0041612B) --------------------------------------------------------
BOOL CoreDump::writeLine(HANDLE hFile, const char *format, ...)
{
  int len; // eax@1
  DWORD written; // [sp+0h] [bp-7D8h]@1
  va_list arglist; // [sp+4h] [bp-7D4h]@1
  char buffer[2016]; // [sp+8h] [bp-7D0h]@1
  va_list va; // [sp+7E8h] [bp+10h]@1

  va_start(va, format);
  wvsprintfA(buffer, format, va);
  arglist = 0;
  len = lstrlenA(buffer);
  return WriteFile(hFile, buffer, len, &written, 0);
}

//----- (0041618B) --------------------------------------------------------
char *__cdecl Utils::getFileName(char *str)
{
  char *backSlash; // [sp+0h] [bp-4h]@1
  char *nextSymbol; // [sp+0h] [bp-4h]@2

  backSlash = strrchr(str, '\\');
  if ( backSlash )
    nextSymbol = backSlash + 1;
  else
    nextSymbol = str;
  return nextSymbol;
}

//----- (004161BE) --------------------------------------------------------
char *__cdecl CoreDump::writeCallStackWithoutSymbols(HANDLE hFile, CONTEXT *contextRecord)
{
  char *result; // eax@5
  signed int i; // [sp+Ch] [bp-138h]@2
  char *stackIt; // [sp+10h] [bp-134h]@2
  int a5; // [sp+14h] [bp-130h]@2
  char moduleFilename[260]; // [sp+18h] [bp-12Ch]@2
  int numberOfSections; // [sp+11Ch] [bp-28h]@2
  int *addrFrameOffsetPrev; // [sp+120h] [bp-24h]@5
  int *pcOffset; // [sp+124h] [bp-20h]@1
  int *addrFrameOffset; // [sp+128h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+12Ch] [bp-18h]@4

  CoreDump::writeLine(hFile, aIntelCallStack);
  pcOffset = (int *)contextRecord->Eip;
  addrFrameOffset = (int *)contextRecord->Ebp;
  do
  {
    moduleFilename[0] = (char)dword_47EA58;
    memset(&moduleFilename[1], 0, 256u);
    *(_WORD *)&moduleFilename[257] = 0;
    moduleFilename[259] = 0;
    numberOfSections = 0;
    a5 = 0;
    CoreDump::writeModule_Raw(pcOffset, moduleFilename, 260u, &numberOfSections, &a5);
    CoreDump::writeLine(hFile, a08x08x04x08xS, pcOffset, addrFrameOffset, numberOfSections, a5, moduleFilename);
    CoreDump::writeLine(hFile, aBytesAtCsEip);
    stackIt = (char *)pcOffset;
    for ( i = 0; i < 16; ++i )
    {
      ms_exc.registration.TryLevel = 0;
      CoreDump::writeLine(hFile, a02x_0, (unsigned __int8)stackIt[i]);
      ms_exc.registration.TryLevel = -1;
    }
    CoreDump::writeLine(hFile, asc_46B098);
    pcOffset = (int *)addrFrameOffset[1];
    addrFrameOffsetPrev = addrFrameOffset;
    result = (char *)addrFrameOffset;
    addrFrameOffset = (int *)*addrFrameOffset;
    if ( (unsigned __int8)addrFrameOffset & 3 )
      break;
    result = (char *)addrFrameOffset;
    if ( addrFrameOffset <= addrFrameOffsetPrev )
      break;
    result = (char *)IsBadWritePtr(addrFrameOffset, 8u);
  }
  while ( !result );
  return result;
}

//----- (00416386) --------------------------------------------------------
LONG __stdcall ExceptionHandler::TopLevelExceptionFilter(struct _EXCEPTION_POINTERS *exceptionInfo)
{
  LONG result; // eax@3

  if ( ExceptionHandler::bBeenHere )            //  https://pidgin.im/~datallah/exchndl.c
  {
    if ( ExceptionHandler::s_oldFilter )
      result = ExceptionHandler::s_oldFilter(exceptionInfo);
    else
      result = EXCEPTION_CONTINUE_SEARCH;
  }
  else
  {
    ExceptionHandler::bBeenHere = true;
    if ( !ExceptionHandler::s_errorReported && exceptionInfo->ExceptionRecord->ExceptionCode != 0xE0000001 )
    {
      ExceptionHandler::enterCritSection();
      if ( !ExceptionHandler::s_mailServerIP )
        DeleteFileA(ExceptionHandler::s_logPath);
      CoreDump::createReport(exceptionInfo);
      if ( ExceptionHandler::s_mailServerIP
        && ExceptionHandler::sendMail(
             ExceptionHandler::s_mailServerIP,
             aServer_ncsoft_,
             aDarkangel_ncso,
             ExceptionHandler::s_logPath) )
      {
        DeleteFileA(ExceptionHandler::s_logPath);
      }
      ExceptionHandler::leaveCritSection();
    }
    if ( ExceptionHandler::s_oldFilter )
      result = ExceptionHandler::s_oldFilter(exceptionInfo);
    else
      result = EXCEPTION_CONTINUE_SEARCH;
  }
  return result;
}
// 47E820: using guessed type int ExceptionHandler::s_errorReported;
// 47E948: using guessed type int ExceptionHandler::bBeenHere;

//----- (00416486) --------------------------------------------------------
MyBool __cdecl ExceptionHandler::sendMail(char *ipAddress, char *mailFrom, char *mailTo, LPCSTR errorLogPath)
{
  int headerLen; // eax@14
  int mailFromLen; // eax@15
  int rcptLen; // eax@18
  int dataLen; // eax@20
  int templateLen; // eax@21
  int newLineLen; // eax@23
  int quitLen; // eax@24
  int namelen; // [sp+0h] [bp-9D4h]@21
  sockaddr_in unused2; // [sp+4h] [bp-9D0h]@21
  struct hostent *host; // [sp+14h] [bp-9C0h]@11
  char *v15; // [sp+18h] [bp-9BCh]@12
  SOCKET socket; // [sp+1Ch] [bp-9B8h]@3
  MyBool result_1; // [sp+20h] [bp-9B4h]@1
  sockaddr_in name; // [sp+24h] [bp-9B0h]@7
  int optval; // [sp+34h] [bp-9A0h]@5
  char buf[2048]; // [sp+38h] [bp-99Ch]@14
  struct WSAData wsaData; // [sp+838h] [bp-19Ch]@1
  time_t unused; // [sp+9C8h] [bp-Ch]@21
  int rcvResult; // [sp+9CCh] [bp-8h]@14
  int sockOptRes; // [sp+9D0h] [bp-4h]@5

  result_1 = false;
  if ( WSAStartup(WINSOCK_VERSION, &wsaData) )
    return false;
  socket = ::socket(SOCK_DGRAM, AF_UNIX, IPPROTO_IP);
  if ( socket == INVALID_SOCKET )
  {
    WSACleanup();
    return false;
  }
  optval = 5000;
  sockOptRes = setsockopt(socket, SOL_SOCKET, SO_RCVTIMEO, (const char *)&optval, 4);
  if ( sockOptRes != SOCKET_ERROR )
  {
    optval = 5000;
    sockOptRes = setsockopt(socket, SOL_SOCKET, SO_SNDTIMEO, (const char *)&optval, 4);
    if ( sockOptRes != SOCKET_ERROR )
    {
      name.sin_family = SOCK_DGRAM;
      name.sin_addr.S_un.S_addr = 0;
      name.sin_port = 0;
      if ( bind(socket, (const struct sockaddr *)&name, 16) != SOCKET_ERROR )
      {
        name.sin_family = SOCK_DGRAM;
        if ( *ipAddress >= '0' && *ipAddress <= '9' )
        {
          name.sin_addr.S_un.S_addr = inet_addr(ipAddress);
LABEL_13:
          name.sin_port = htons(25u);
          if ( connect(socket, (const struct sockaddr *)&name, 16) != SOCKET_ERROR )
          {
            rcvResult = recv(socket, buf, 0x800, 0);
            headerLen = strlen(mailHeader);
            if ( send(socket, mailHeader, headerLen, 0) > 0 )
            {
              rcvResult = recv(socket, buf, 0x800, 0);
              sprintf(aMail_From, aMailFromS, mailFrom);
              mailFromLen = strlen(aMail_From);
              if ( send(socket, aMail_From, mailFromLen, 0) > 0 )
              {
                rcvResult = recv(socket, buf, 0x800, 0);
                while ( *mailTo )
                {
                  sprintf(aRcptToDarkange, aRcptToS, mailTo);
                  rcptLen = strlen(aRcptToDarkange);
                  if ( send(socket, aRcptToDarkange, rcptLen, 0) <= 0 )
                    goto LABEL_26;
                  rcvResult = recv(socket, buf, 0x800, 0);
                  mailTo += strlen(mailTo) + 1;
                }
                dataLen = strlen(aData);
                if ( send(socket, aData, dataLen, 0) > 0 )
                {
                  rcvResult = recv(socket, buf, 0x800, 0);
                  unused = time(0);
                  memset(&unused2, 0, 16u);
                  namelen = 16;
                  getsockname(socket, (struct sockaddr *)&unused2, &namelen);
                  templateLen = strlen(ExceptionHandler::s_mailTemplate);
                  if ( send(socket, ExceptionHandler::s_mailTemplate, templateLen, 0) > 0 )
                  {
                    if ( ExceptionHandler::sendFile(socket, errorLogPath) )
                    {
                      newLineLen = strlen(aNewLine);
                      if ( send(socket, aNewLine, newLineLen, 0) > 0 )
                      {
                        rcvResult = recv(socket, buf, 0x800, 0);
                        quitLen = strlen(aQuit);
                        if ( send(socket, aQuit, quitLen, 0) > 0 )
                        {
                          rcvResult = recv(socket, buf, 0x800, 0);
                          result_1 = true;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          goto LABEL_26;
        }
        host = gethostbyname(ipAddress);
        if ( host )
        {
          memcpy(&name.sin_addr, *(const void **)host->h_addr_list, host->h_length);
          v15 = inet_ntoa(name.sin_addr);
          goto LABEL_13;
        }
      }
    }
  }
LABEL_26:
  closesocket(socket);
  socket = 0;
  WSACleanup();
  return result_1;
}

//----- (00416943) --------------------------------------------------------
char __cdecl ExceptionHandler::sendFile(SOCKET socket, LPCSTR lpFileName)
{
  char result; // al@2
  DWORD bytesRead; // [sp+0h] [bp-408h]@3
  HANDLE hFile; // [sp+4h] [bp-404h]@1
  char buffer[1024]; // [sp+8h] [bp-400h]@3

  hFile = CreateFileA(lpFileName, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
  if ( hFile == (HANDLE)INVALID_HANDLE_VALUE )
  {
    result = true;                              // to be chaned -> true <-> false
  }
  else
  {
    do
    {
      if ( !ReadFile(hFile, buffer, 0x400u, &bytesRead, 0) || !bytesRead )
      {
        CloseHandle(hFile);
        return true;
      }
    }
    while ( send(socket, buffer, bytesRead, 0) > 0 );
    result = false;
  }
  return result;
}

//----- (004169E0) --------------------------------------------------------
void __cdecl CoreDump::createReport(_EXCEPTION_POINTERS *ex)
{
  int v1; // ST20_4@3
  int v2; // ST1C_4@3
  int v3; // ST18_4@3
  int v4; // ST14_4@3
  int v5; // ST10_4@3
  int v6; // ST0C_4@3
  DWORD v7; // eax@3
  DWORD eip_; // ST20_4@6
  DWORD segCs; // ST1C_4@6
  char *moduleName1; // ST18_4@6
  char *exceptionStr; // eax@6
  HANDLE currProc; // eax@26
  HANDLE currProc1; // eax@27
  char *spaceOrEoL; // [sp+Ch] [bp-954h]@20
  char *iterator; // [sp+14h] [bp-94Ch]@16
  signed int counter; // [sp+18h] [bp-948h]@16
  char stackBuffer[1000]; // [sp+1Ch] [bp-944h]@16
  char *limit; // [sp+404h] [bp-55Ch]@16
  int *stackBase; // [sp+408h] [bp-558h]@14
  int *stackPointer; // [sp+40Ch] [bp-554h]@14
  char *v21; // [sp+410h] [bp-550h]@8
  char violationBuffer[1000]; // [sp+414h] [bp-54Ch]@10
  int i; // [sp+7FCh] [bp-164h]@11
  char moduleFilename[260]; // [sp+800h] [bp-160h]@4
  DWORD eip_2; // [sp+904h] [bp-5Ch]@11
  MEMORY_BASIC_INFORMATION memoryInfo; // [sp+908h] [bp-58h]@3
  HANDLE hFile; // [sp+924h] [bp-3Ch]@1
  SYSTEMTIME now; // [sp+928h] [bp-38h]@3
  PEXCEPTION_RECORD exceptionRecord; // [sp+938h] [bp-28h]@3
  char *moduleName; // [sp+93Ch] [bp-24h]@3
  PCONTEXT context; // [sp+940h] [bp-20h]@3
  struct tm *startTime; // [sp+944h] [bp-1Ch]@6
  CPPEH_RECORD ms_exc; // [sp+948h] [bp-18h]@13

  hFile = CreateFileA(ExceptionHandler::s_logPath, GENERIC_WRITE, 0, 0, OPEN_ALWAYS, 0x80000080, 0);
  if ( hFile == (HANDLE)INVALID_HANDLE_VALUE )
  {
    OutputDebugStringA(anOutputString);
  }
  else
  {
    SetFilePointer(hFile, 0, 0, FILE_END);
    now.wYear = 0;
    *(_DWORD *)&now.wMonth = 0;
    *(_DWORD *)&now.wDay = 0;
    *(_DWORD *)&now.wMinute = 0;
    now.wMilliseconds = 0;
    GetLocalTime(&now);
    v1 = now.wSecond;
    v2 = now.wMinute;
    v3 = now.wHour;
    v4 = now.wDay;
    v5 = now.wMonth;
    v6 = now.wYear;
    v7 = GetCurrentThreadId();
    CoreDump::writeLine(hFile, aD04d02d02d02d0, v7, v6, v5, v4, v3, v2, v1);
    exceptionRecord = ex->ExceptionRecord;
    context = ex->ContextRecord;
    moduleName = aUnknown_0;
    if ( VirtualQuery((LPCVOID)context->Eip, &memoryInfo, 28u)
      && GetModuleFileNameA((HMODULE)memoryInfo.AllocationBase, moduleFilename, 260u) )
    {
      moduleName = Utils::getFileName(moduleFilename);
    }
    eip_ = context->Eip;
    segCs = context->SegCs;
    moduleName1 = moduleName;
    exceptionStr = CoreDump::exceptionToString(exceptionRecord->ExceptionCode);
    CoreDump::writeLine(hFile, aSInModuleSAt04, exceptionStr, moduleName1, segCs, eip_);
    CoreDump::writeLine(hFile, aExceptionHandl);
    startTime = localtime(&ExceptionHandler::s_startTime);
    CoreDump::writeLine(
      hFile,
      aStartAtDDD02d0,
      startTime->tm_year + 1900,
      startTime->tm_mon + 1,
      startTime->tm_mday,
      startTime->tm_hour,
      startTime->tm_min,
      startTime->tm_sec);
    CoreDump::writeExtraInfo(hFile);
    if ( exceptionRecord->ExceptionCode == EXCEPTION_ACCESS_VIOLATION && exceptionRecord->NumberParameters >= 2 )
    {
      v21 = aReadFrom;
      if ( exceptionRecord->ExceptionInformation[0] )// ExceptionInformation[0] indicates if it was a read (0), write (1), or data execution attempt (8).
        v21 = aWriteTo;
      wsprintfA(violationBuffer, aSLocation08xCa, v21, exceptionRecord->ExceptionInformation[1]);
      CoreDump::writeLine(hFile, aS_1, violationBuffer);
    }
    CoreDump::writeLine(hFile, asc_46B21C);
    CoreDump::writeLine(hFile, aRegisters);
    CoreDump::writeLine(hFile, aEax08xCs04xEip, context->Eax, context->SegCs, context->Eip, context->EFlags);
    CoreDump::writeLine(hFile, aEbx08xSs04xEsp, context->Ebx, context->SegSs, context->Esp, context->Ebp);
    CoreDump::writeLine(hFile, aEcx08xDs04xEsi, context->Ecx, context->SegDs, context->Esi, context->SegFs);
    CoreDump::writeLine(hFile, aEdx08xEs04xEdi, context->Edx, context->SegEs, context->Edi, context->SegGs);
    CoreDump::writeLine(hFile, aBytesAtCsEip_0);
    eip_2 = context->Eip;
    for ( i = 0; i < 16; ++i )
    {
      ms_exc.registration.TryLevel = 0;
      CoreDump::writeLine(hFile, a02x_1, *(_BYTE *)(i + eip_2));
      ms_exc.registration.TryLevel = -1;
    }
    CoreDump::writeLine(hFile, aStackDump);
    ms_exc.registration.TryLevel = 1;
    stackPointer = (int *)context->Esp;
    stackBase = (int *)__readfsdword(4);
    if ( stackBase > stackPointer + 80 )
      stackBase = stackPointer + 80;
    counter = 0;
    stackBuffer[0] = dword_47EA5C;
    memset(&stackBuffer[1], 0, 996u);
    *(_WORD *)&stackBuffer[997] = 0;
    stackBuffer[999] = 0;
    limit = &stackBuffer[950];
    iterator = stackBuffer;
    while ( stackPointer + 1 <= stackBase )
    {
      if ( !(counter % 8) )
        iterator += wsprintfA(iterator, a08x, stackPointer);
      spaceOrEoL = asc_46B300;
      if ( !(++counter % 8) || stackPointer + 2 > stackBase )
        spaceOrEoL = asc_46B304;
      iterator += wsprintfA(iterator, a08xS, *stackPointer, spaceOrEoL);
      ++stackPointer;
      if ( iterator > limit )
      {
        CoreDump::writeLine(hFile, aS_2, stackBuffer);
        stackBuffer[0] = 0;
        iterator = stackBuffer;
      }
    }
    CoreDump::writeLine(hFile, aS_3, stackBuffer);
    ms_exc.registration.TryLevel = -1;
    currProc = GetCurrentProcess();
    if ( SymInitialize(currProc, 0, true) )     // debug symbols are found
    {
      CoreDump::writeCallStackWithSymbols(hFile, context);
      currProc1 = GetCurrentProcess();
      SymCleanup(currProc1);
    }
    else
    {
      CoreDump::writeCallStackWithoutSymbols(hFile, context);
    }
    CoreDump::writeModules(hFile);
    CloseHandle(hFile);
  }
}
// 47EA5C: using guessed type int dword_47EA5C;

//----- (0041703B) --------------------------------------------------------
unsigned int __cdecl CoreDump::writeModules(HANDLE hFile)
{
  unsigned int result; // eax@2
  MEMORY_BASIC_INFORMATION memoryInfo; // [sp+0h] [bp-50h]@3
  unsigned int pageSize; // [sp+1Ch] [bp-34h]@1
  DWORD pageCount; // [sp+20h] [bp-30h]@1
  SYSTEM_INFO systemInfo; // [sp+24h] [bp-2Ch]@1
  unsigned int pageIndex; // [sp+48h] [bp-8h]@1
  HMODULE hModule; // [sp+4Ch] [bp-4h]@1

  CoreDump::writeLine(hFile, aModuleListName);
  GetSystemInfo(&systemInfo);
  pageSize = systemInfo.dwPageSize;
  pageCount = 4 * (0x40000000 / systemInfo.dwPageSize);// 4 GB / pageSize => TODO: x64
  pageIndex = 0;
  hModule = 0;
  while ( true )
  {
    result = pageIndex;
    if ( pageIndex >= pageCount )
      break;
    if ( VirtualQuery((LPCVOID)(pageSize * pageIndex), &memoryInfo, 28u) )
    {
      if ( memoryInfo.RegionSize )
      {
        pageIndex += memoryInfo.RegionSize / pageSize;
        if ( memoryInfo.State == MEM_COMMIT && memoryInfo.AllocationBase > hModule )
        {
          hModule = (HMODULE)memoryInfo.AllocationBase;
          CoreDump::writeModuleInfo(hFile, (HMODULE)memoryInfo.AllocationBase);
        }
      }
      else
      {
        pageIndex += 0x10000 / pageSize;
      }
    }
    else
    {
      pageIndex += 0x10000 / pageSize;
    }
  }
  return result;
}

//----- (00417112) --------------------------------------------------------
_IMAGE_DOS_HEADER *__cdecl CoreDump::writeModuleInfo(HANDLE hFile_1, HMODULE hModule)
{
  _IMAGE_DOS_HEADER *result; // eax@1
  struct _FILETIME lastWriteTime1; // ST14_8@8
  int buffEnd; // eax@8
  struct _FILETIME lastWriteTime; // [sp+Ch] [bp-198h]@7
  IMAGE_NT_HEADERS *ntHeader; // [sp+14h] [bp-190h]@4
  HANDLE hFile; // [sp+18h] [bp-18Ch]@6
  IMAGE_DOS_HEADER *hModule1; // [sp+1Ch] [bp-188h]@2
  char buffer[100]; // [sp+20h] [bp-184h]@6
  DWORD fileSize; // [sp+84h] [bp-120h]@6
  char moduleFilename[260]; // [sp+88h] [bp-11Ch]@1
  CPPEH_RECORD ms_exc; // [sp+18Ch] [bp-18h]@1

  ms_exc.registration.TryLevel = 0;
  result = (_IMAGE_DOS_HEADER *)GetModuleFileNameA(hModule, moduleFilename, 260u);
  if ( result )
  {
    hModule1 = (IMAGE_DOS_HEADER *)hModule;
    result = (_IMAGE_DOS_HEADER *)hModule;
    if ( *(_WORD *)hModule == IMAGE_DOS_SIGNATURE )
    {
      result = (IMAGE_DOS_HEADER *)((char *)hModule1 + hModule1->e_lfanew);
      ntHeader = (IMAGE_NT_HEADERS *)((char *)hModule1 + hModule1->e_lfanew);
      if ( ntHeader->Signature == IMAGE_NT_SIGNATURE )
      {
        hFile = CreateFileA(moduleFilename, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
        buffer[0] = dword_47EA60;
        memset(&buffer[1], 0, 0x60u);
        *(_WORD *)&buffer[97] = 0;
        buffer[99] = 0;
        fileSize = 0;
        if ( hFile != (HANDLE)INVALID_HANDLE_VALUE )
        {
          fileSize = GetFileSize(hFile, 0);
          if ( GetFileTime(hFile, 0, 0, &lastWriteTime) )
          {
            wsprintfA(buffer, aFileDateIs);
            lastWriteTime1 = lastWriteTime;
            buffEnd = lstrlenA(buffer);
            CoreDump::getFileTime(&buffer[buffEnd], lastWriteTime1);
          }
          CloseHandle(hFile);
        }
        result = (_IMAGE_DOS_HEADER *)CoreDump::writeLine(
                                        hFile_1,
                                        aSLoadedAt0x08x,
                                        moduleFilename,
                                        hModule,
                                        fileSize,
                                        ntHeader->FileHeader.TimeDateStamp,
                                        buffer);
      }
      else
      {
        ms_exc.registration.TryLevel = -1;
      }
    }
    else
    {
      ms_exc.registration.TryLevel = -1;
    }
  }
  return result;
}
// 47EA60: using guessed type int dword_47EA60;

//----- (004172E8) --------------------------------------------------------
int __cdecl CoreDump::getFileTime(char *out, FILETIME fileTime)
{
  int result; // eax@1
  WORD fatTime; // [sp+0h] [bp-8h]@2
  WORD fatDate; // [sp+4h] [bp-4h]@2

  result = FileTimeToLocalFileTime(&fileTime, &fileTime);
  if ( result && (result = FileTimeToDosDateTime(&fileTime, &fatDate, &fatTime)) != 0 )
    result = wsprintfA(
               out,
               aDDD02d02d02d,
               ((signed int)fatDate >> 5) & 15,
               fatDate & 31,
               ((signed int)fatDate >> 9) + 1980,
               (signed int)fatTime >> 11,
               ((signed int)fatTime >> 5) & 63,
               2 * (fatTime & 31));
  else
    *out = '\0';
  return result;
}

//----- (004173B0) --------------------------------------------------------
BOOL __cdecl CoreDump::writeExtraInfo(HANDLE hFile)
{
  char buffer[200]; // [sp+0h] [bp-280h]@3
  struct _MEMORYSTATUS memoryStatus; // [sp+C8h] [bp-1B8h]@5
  char moduleFilename[260]; // [sp+E8h] [bp-198h]@1
  char logCreationTime[100]; // [sp+1ECh] [bp-94h]@1
  struct _SYSTEM_INFO systemInfo; // [sp+250h] [bp-30h]@5
  struct _FILETIME systemTimeAsFileTime; // [sp+274h] [bp-Ch]@1
  DWORD pcbBuffer; // [sp+27Ch] [bp-4h]@3

  GetSystemTimeAsFileTime(&systemTimeAsFileTime);
  CoreDump::getFileTime(logCreationTime, systemTimeAsFileTime);
  CoreDump::writeLine(hFile, aErrorOccurredA, logCreationTime);
  if ( !GetModuleFileNameA(0, moduleFilename, 260u) )
    lstrcpyA(moduleFilename, String2);
  pcbBuffer = 200;
  if ( !GetUserNameA(buffer, &pcbBuffer) )
    lstrcpyA(buffer, aUnknown_2);
  CoreDump::writeLine(hFile, aSRunByS_, moduleFilename, buffer);
  GetSystemInfo(&systemInfo);
  CoreDump::writeLine(hFile, aDProcessorSTyp, systemInfo.dwNumberOfProcessors, systemInfo.dwProcessorType);
  memoryStatus.dwLength = 32;
  GlobalMemoryStatus(&memoryStatus);
  return CoreDump::writeLine(hFile, aDMbytesPhysica, (memoryStatus.dwTotalPhys + 0xFFFFF) >> 20);
}

//----- (004174C8) --------------------------------------------------------
char *__cdecl CoreDump::exceptionToString(int exceptionCode)
{
  ExceptionName exceptions[24]; // [sp+0h] [bp-C4h]@1
  unsigned int i; // [sp+C0h] [bp-4h]@1

  exceptions[0].code = DBG_CONTROL_C;
  exceptions[0].name = aAControlC;
  exceptions[1].code = DBG_CONTROL_BREAK;
  exceptions[1].name = aAControlBreak;
  exceptions[2].code = EXCEPTION_DATATYPE_MISALIGNMENT;
  exceptions[2].name = aADatatypeMisal;
  exceptions[3].code = EXCEPTION_BREAKPOINT;
  exceptions[3].name = aABreakpoint;
  exceptions[4].code = EXCEPTION_ACCESS_VIOLATION;
  exceptions[4].name = aAnAccessViolat;
  exceptions[5].code = EXCEPTION_IN_PAGE_ERROR;
  exceptions[5].name = aAnInPageError;
  exceptions[6].code = STATUS_NO_MEMORY;
  exceptions[6].name = aANoMemory;
  exceptions[7].code = EXCEPTION_ILLEGAL_INSTRUCTION;
  exceptions[7].name = aAnIllegalInstr;
  exceptions[8].code = EXCEPTION_NONCONTINUABLE_EXCEPTION;
  exceptions[8].name = aANoncontinuabl;
  exceptions[9].code = EXCEPTION_INVALID_DISPOSITION;
  exceptions[9].name = aAnInvalidDispo;
  exceptions[10].code = EXCEPTION_ARRAY_BOUNDS_EXCEEDED;
  exceptions[10].name = aAArrayBoundsEx;
  exceptions[11].code = EXCEPTION_FLT_DENORMAL_OPERAND;
  exceptions[11].name = aAFloatDenormal;
  exceptions[12].code = EXCEPTION_FLT_DIVIDE_BY_ZERO;
  exceptions[12].name = aAFloatDivideBy;
  exceptions[13].code = EXCEPTION_FLT_INEXACT_RESULT;
  exceptions[13].name = aAFloatInexactR;
  exceptions[14].code = EXCEPTION_FLT_INVALID_OPERATION;
  exceptions[14].name = aAFloatInvalidO;
  exceptions[15].code = EXCEPTION_FLT_OVERFLOW;
  exceptions[15].name = aAFloatOverflow;
  exceptions[16].code = EXCEPTION_FLT_STACK_CHECK;
  exceptions[16].name = aAFloatStackChe;
  exceptions[17].code = EXCEPTION_FLT_UNDERFLOW;
  exceptions[17].name = aAFloatUnderflo;
  exceptions[18].code = EXCEPTION_INT_DIVIDE_BY_ZERO;
  exceptions[18].name = aAnIntegerDivid;
  exceptions[19].code = EXCEPTION_INT_OVERFLOW;
  exceptions[19].name = aAnIntegerOverf;
  exceptions[20].code = EXCEPTION_PRIV_INSTRUCTION;
  exceptions[20].name = aAPrivilegedIns;
  exceptions[21].code = EXCEPTION_STACK_OVERFLOW;
  exceptions[21].name = aAStackOverflow;
  exceptions[22].code = STATUS_DLL_INIT_FAILED;
  exceptions[22].name = aADllInitializa;
  exceptions[23].code = 0xE06D7363;
  exceptions[23].name = aAMicrosoftCExc;
  for ( i = 0; i < 24; ++i )
  {
    if ( exceptionCode == exceptions[i].code )
      return exceptions[i].name;
  }
  return aUnknownExcepti;
}

//----- (00417692) --------------------------------------------------------
LONG *__cdecl ExceptionHandler::installTopLevelFilter()
{
  LPTOP_LEVEL_EXCEPTION_FILTER result; // eax@1

  result = SetUnhandledExceptionFilter(ExceptionHandler::TopLevelExceptionFilter);
  ExceptionHandler::s_oldFilter = result;
  return (LONG *)result;
}

//----- (004176A7) --------------------------------------------------------
LPTOP_LEVEL_EXCEPTION_FILTER ExceptionHandler::restoreTopLevelFilter()
{
  LPTOP_LEVEL_EXCEPTION_FILTER result; // eax@2

  if ( ExceptionHandler::s_oldFilter )
    result = SetUnhandledExceptionFilter(ExceptionHandler::s_oldFilter);
  return result;
}

//----- (004176C1) --------------------------------------------------------
ExceptionHandler *__thiscall ExceptionHandler::ExceptionHandler(ExceptionHandler *this)
{
  ExceptionHandler *v2; // [sp+4h] [bp-110h]@1
  char buffer[260]; // [sp+8h] [bp-10Ch]@1
  LPCSTR exeName; // [sp+10Ch] [bp-8h]@3
  char *extension; // [sp+110h] [bp-4h]@3

  v2 = this;
  ExceptionHandler::initCritSection();
  strcpy(buffer, "Unknown");
  memset(&buffer[8], 0, 252u);
  if ( !GetModuleFileNameA(0, ExceptionHandler::s_logPath, 260u) )
    ExceptionHandler::s_logPath[0] = '\0';
  exeName = Utils::getFileName(ExceptionHandler::s_logPath);
  lstrcpyA(buffer, exeName);
  extension = strrchr(buffer, '.');
  if ( extension )
    *extension = '\0';
  lstrcpyA((LPSTR)exeName, aL2authderror_t);
  ExceptionHandler::s_startTime = time(0);
  ExceptionHandler::installTopLevelFilter();
  return v2;
}

//----- (00417788) --------------------------------------------------------
void ExceptionHandler::Destructor()
{
  ExceptionHandler::restoreTopLevelFilter();
  ExceptionHandler::deleteCritSection();
}

//----- (0041779D) --------------------------------------------------------
void ExceptionHandler::logException(char *format, ...)
{
  int wSecond; // ST24_4@4
  int wMinute; // ST20_4@4
  int wHour; // ST1C_4@4
  int wDay; // ST18_4@4
  int wMonth; // ST14_4@4
  int wYear; // ST10_4@4
  DWORD currentThrea; // eax@4
  char *newLine; // [sp+0h] [bp-438h]@8
  int len; // [sp+8h] [bp-430h]@4
  int len2; // [sp+8h] [bp-430h]@5
  HANDLE hFile; // [sp+Ch] [bp-42Ch]@2
  int i; // [sp+10h] [bp-428h]@6
  char buffer[1024]; // [sp+14h] [bp-424h]@4
  struct _SYSTEMTIME now; // [sp+414h] [bp-24h]@2
  va_list va1; // [sp+424h] [bp-14h]@2
  DWORD bytesWritten; // [sp+428h] [bp-10h]@5
  int unused; // [sp+434h] [bp-4h]@2
  va_list va; // [sp+444h] [bp+Ch]@1

  va_start(va, format);
  if ( !ExceptionHandler::s_errorReported )
  {
    ExceptionHandler::enterCritSection();
    unused = 0;
    va1 = va;
    now.wYear = 0;
    *(_DWORD *)&now.wMonth = 0;
    *(_DWORD *)&now.wDay = 0;
    *(_DWORD *)&now.wMinute = 0;
    now.wMilliseconds = 0;
    GetLocalTime(&now);
    hFile = CreateFileA(ExceptionHandler::s_logPath, 0xC0000000, 0, 0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);// GENERIC_READ                     (0x80000000L) GENERIC_WRITE                    (0x40000000L)
    if ( hFile == (HANDLE)INVALID_HANDLE_VALUE )
    {
      unused = -1;
      ExceptionHandler::leaveCritSection();
    }
    else
    {
      SetFilePointer(hFile, 0, 0, FILE_END);
      wSecond = now.wSecond;
      wMinute = now.wMinute;
      wHour = now.wHour;
      wDay = now.wDay;
      wMonth = now.wMonth;
      wYear = now.wYear;
      currentThrea = GetCurrentThreadId();
      len = _snprintf(buffer, 1024u, aD04d02d02d02_0, currentThrea, wYear, wMonth, wDay, wHour, wMinute, wSecond);
      if ( len >= 0 )
      {
        WriteFile(hFile, buffer, len, &bytesWritten, 0);
        len2 = _vsnprintf(buffer, 1024u, format, va1);
        if ( len2 >= 0 )
        {
          for ( i = 0; i < len2; i += 2 )
          {
            newLine = (char *)memchr(&buffer[i], '\n', len2 - i);
            if ( !newLine )
              break;
            if ( (unsigned int)len2 < 1024 )
              ++len2;
            i = newLine - buffer;
            memmove(newLine + 1, newLine, len2 - (newLine - buffer) - 1);
            *newLine = '\r';
          }
          WriteFile(hFile, buffer, len2, &bytesWritten, 0);
        }
      }
      va1 = 0;
      CloseHandle(hFile);
      unused = -1;
      ExceptionHandler::leaveCritSection();
    }
  }
}
// 47E820: using guessed type int ExceptionHandler::s_errorReported;
// 41779D: using guessed type char buffer[1024];

//----- (00417A31) --------------------------------------------------------
MACRO_EXCEPTION __cdecl ExceptionHandler::exceptionFilter(_EXCEPTION_POINTERS *ex)
{
  if ( !ExceptionHandler::s_errorReported && ex->ExceptionRecord->ExceptionCode != ERR_NO_DISK_SPACE )
  {
    ExceptionHandler::enterCritSection();
    if ( !ExceptionHandler::s_mailServerIP )
      DeleteFileA(ExceptionHandler::s_logPath);
    CoreDump::createReport(ex);
    ExceptionHandler::leaveCritSection();
  }
  return EXCEPTION_EXECUTE_HANDLER;
}
// 47E820: using guessed type int ExceptionHandler::s_errorReported;

//----- (00417AB1) --------------------------------------------------------
void __cdecl ExceptionHandler::sendExceptionLog(char fatal)
{
  if ( !ExceptionHandler::s_errorReported )
  {
    ExceptionHandler::enterCritSection();
    if ( ExceptionHandler::s_mailServerIP
      && ExceptionHandler::sendMail(
           ExceptionHandler::s_mailServerIP,
           aServer_ncsof_0,
           aDarkangel_nc_0,
           ExceptionHandler::s_logPath) )
    {
      DeleteFileA(ExceptionHandler::s_logPath);
    }
    ExceptionHandler::leaveCritSection();
    if ( fatal )
    {
      ExceptionHandler::s_errorReported = true;
      ExitProcess(0);
    }
  }
}
// 47E820: using guessed type int ExceptionHandler::s_errorReported;

//----- (00417B55) --------------------------------------------------------
void ExceptionHandler::sendLastCrashReport()
{
  HANDLE exists; // [sp+0h] [bp-4h]@2

  if ( ExceptionHandler::s_mailServerIP )
  {
    exists = CreateFileA(ExceptionHandler::s_logPath, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
    if ( exists != (HANDLE)INVALID_HANDLE_VALUE )
    {
      CloseHandle(exists);
      ExceptionHandler::sendMail(
        ExceptionHandler::s_mailServerIP,
        ExceptionHandler::fromMail,
        ExceptionHandler::toMail,
        ExceptionHandler::s_logPath);
      DeleteFileA(ExceptionHandler::s_logPath);
    }
  }
}

//----- (00417BBE) --------------------------------------------------------
void ExceptionHandler::intentionalException()
{
  if ( ExceptionHandler::s_intentionException )
  {
    ExceptionHandler::s_intentionException = 0;
    ExceptionHandler::logException(aIntentionalExc);
    v0 = 0;
  }
}
// 46AF5B: using guessed type char ExceptionHandler::s_intentionException;

//----- (00417C70) --------------------------------------------------------
int SomeStaticInit13()
{
  SomeBitsInit();
  return sub_417C7F();
}

//----- (00417C7F) --------------------------------------------------------
int sub_417C7F()
{
  return atexit(emptystub);
}

//----- (00417CA0) --------------------------------------------------------
void *__cdecl ExceptionHandler::enterCritSection()
{
  void *v0; // ecx@0
  void *v1; // ST04_4@1

  v1 = v0;
  EnterCriticalSection(&ExceptionHandler::g_criticalSection);
  return v1;
}

//----- (00417CC0) --------------------------------------------------------
void ExceptionHandler::leaveCritSection()
{
  LeaveCriticalSection(&ExceptionHandler::g_criticalSection);
}

//----- (00417CE0) --------------------------------------------------------
void __cdecl ExceptionHandler::initCritSection()
{
  InitializeCriticalSection(&ExceptionHandler::g_criticalSection);
}

//----- (00417CF0) --------------------------------------------------------
void ExceptionHandler::deleteCritSection()
{
  DeleteCriticalSection(&ExceptionHandler::g_criticalSection);
}

//----- (00417D00) --------------------------------------------------------
CIOBuffer *__thiscall CIOBuffer::CIOBuffer(CIOBuffer *this)
{
  this->vftable = (int)CIOBuffer_vtable_off_45F51C;
  return this;
}
// 45F51C: using guessed type int (__stdcall *CIOBuffer_vtable_off_45F51C[2])(int);

//----- (00417D17) --------------------------------------------------------
CIOBuffer *__thiscall CIOBuffer::Destructor(CIOBuffer *this)
{
  CIOBuffer *result; // eax@1

  result = this;
  this->vftable = (int)CIOBuffer_vtable_off_45F51C;
  return result;
}
// 45F51C: using guessed type int (__stdcall *CIOBuffer_vtable_off_45F51C[2])(int);

//----- (00417D2B) --------------------------------------------------------
int Static_InitCallCIOBufferPool::g_slotDestructor()
{
  CallCIOBufferPool::g_slotConstructor();
  return RegisterlCIOBufferPool::g_slotDestructor();
}

//----- (00417D3A) --------------------------------------------------------
int CallCIOBufferPool::g_slotConstructor()
{
  return `eh vector constructor iterator'(
           CIOBufferPool::g_slot,
           0x24u,
           16,
           (int)CIOBufferSlot::CIOBufferSlot,
           (void (__thiscall *)(void *))CIOBufferSlot::Destructor);
}

//----- (00417D57) --------------------------------------------------------
int RegisterlCIOBufferPool::g_slotDestructor()
{
  return atexit(CallCIOBufferPool::g_slotDestructor);
}

//----- (00417D69) --------------------------------------------------------
void __cdecl CallCIOBufferPool::g_slotDestructor()
{
  if ( !(byte_47ECA9 & 1) )
  {
    byte_47ECA9 |= 1u;
    `eh vector destructor iterator'(
      CIOBufferPool::g_slot,
      0x24u,
      16,
      (void (__thiscall *)(void *))CIOBufferSlot::Destructor);
  }
}
// 47ECA9: using guessed type char byte_47ECA9;

//----- (00417D9E) --------------------------------------------------------
int StaticInitIOBufferPool()
{
  CallIOBufferPoolCtor();
  return RegisterIOBufferPoolDestructor();
}

//----- (00417DAD) --------------------------------------------------------
void CallIOBufferPoolCtor()
{
  ;
}

//----- (00417DB2) --------------------------------------------------------
int RegisterIOBufferPoolDestructor()
{
  return atexit(CallIOBufferPoolDestructor);
}

//----- (00417DC4) --------------------------------------------------------
void __cdecl CallIOBufferPoolDestructor()
{
  IOBufferPool::Destructor();
}

//----- (00417DD3) --------------------------------------------------------
CIOBuffer *CIOBuffer::Alloc()
{
  CIOBuffer *v1; // [sp+0h] [bp-20h]@4
  CIOBuffer *buffer_; // [sp+4h] [bp-1Ch]@3
  CIOBufferSlot *slot; // [sp+Ch] [bp-14h]@1
  CIOBuffer *buffer; // [sp+10h] [bp-10h]@1

  slot = &CIOBufferPool::g_slot[InterlockedIncrement(&CIOBufferPool::g_nAlloc) & 0xF];
  SpinLock::Enter(&slot->m_lock);
  buffer = slot->m_pBuffer;
  if ( slot->m_pBuffer )
  {
    slot->m_pBuffer = buffer->m_pNext;
    SpinLock::Leave(&slot->m_lock);
  }
  else
  {
    SpinLock::Leave(&slot->m_lock);
    buffer_ = (CIOBuffer *)operator new(0x2010u);
    if ( buffer_ )
      v1 = CIOBuffer::CIOBuffer(buffer_);
    else
      v1 = 0;
    buffer = v1;
  }
  buffer->m_dwSize = 0;
  buffer->m_nRefCount = 1;
  buffer->m_pNext = 0;
  return buffer;
}

//----- (00417EC2) --------------------------------------------------------
void __thiscall CIOBuffer::Free(CIOBuffer *this)
{
  CIOBuffer *this_; // ST04_4@1
  CIOBufferSlot *slot; // ST08_4@1

  this_ = this;
  slot = &CIOBufferPool::g_slot[InterlockedDecrement(&CIOBufferPool::g_nFree) & 0xF];
  SpinLock::Enter(&slot->m_lock);
  this_->m_pNext = slot->m_pBuffer;
  slot->m_pBuffer = this_;
  SpinLock::Leave(&slot->m_lock);
}

//----- (00417F14) --------------------------------------------------------
void CIOBuffer::FreeAll()
{
  CIOBufferSlot *slot; // [sp+Ch] [bp-Ch]@3
  CIOBuffer *packet; // [sp+10h] [bp-8h]@4
  signed int i; // [sp+14h] [bp-4h]@1

  for ( i = 0; i < 16; ++i )
  {
    slot = &CIOBufferPool::g_slot[i];
    SpinLock::Enter(&CIOBufferPool::g_slot[i].m_lock);
    while ( 1 )
    {
      packet = slot->m_pBuffer;
      if ( !slot->m_pBuffer )
        break;
      slot->m_pBuffer = packet->m_pNext;
      if ( packet )
        (*(void (__thiscall **)(_DWORD, _DWORD))packet->vftable)(packet, 1);
    }
    SpinLock::Leave(&slot->m_lock);
  }
}

//----- (00417FA5) --------------------------------------------------------
int SomeStaticInit16()
{
  SomeBitsInit();
  return sub_417FB4();
}

//----- (00417FB4) --------------------------------------------------------
int sub_417FB4()
{
  return atexit(emptystub);
}

//----- (00417FD0) --------------------------------------------------------
void *__thiscall CallCIOBufferDestructor(void *this, char a2)
{
  void *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  CIOBuffer::Destructor((CIOBuffer *)this);
  if ( a2 & 1 )
    _delete_table(v3);
  return v3;
}

//----- (00418020) --------------------------------------------------------
CIOBufferSlot *__thiscall CIOBufferSlot::CIOBufferSlot(CIOBufferSlot *this)
{
  CIOBufferSlot *v1; // ST08_4@1

  v1 = this;
  this->m_pBuffer = 0;
  SpinLock::SpinLock(&this->m_lock, LockType_WaitLock, 0);
  return v1;
}

//----- (00418050) --------------------------------------------------------
void IOBufferPool::Destructor()
{
  CIOBuffer::FreeAll();
}

//----- (00418060) --------------------------------------------------------
MemoryObject *__thiscall MemoryObject::MemoryObject(MemoryObject *this)
{
  this->vftbl_0_45F520 = &MemoryObject_vftable_offset_45F520;
  this->m_nRefCount = 0;
  return this;
}

//----- (00418081) --------------------------------------------------------
MemoryObject *__thiscall MemoryObject::Destructor(MemoryObject *this)
{
  MemoryObject *result; // eax@1

  result = this;
  this->vftbl_0_45F520 = &MemoryObject_vftable_offset_45F520;
  return result;
}

//----- (00418095) --------------------------------------------------------
int __thiscall MemoryObject::AddRef(MemoryObject *this)
{
  MemoryObject *this_; // ST04_4@1

  this_ = this;
  InterlockedIncrement(&this->m_nRefCount);
  return this_->m_nRefCount;
}

//----- (004180B3) --------------------------------------------------------
LONG __thiscall MemoryObject::Release(MemoryObject *this)
{
  LONG result; // eax@1
  MemoryObject *this_; // [sp+4h] [bp-Ch]@1

  this_ = this;
  result = InterlockedDecrement(&this->m_nRefCount);
  if ( !result )
  {
    if ( this_ )
      result = this_->vftbl_0_45F520->DestructorCall(this_, 1);
  }
  return result;
}

//----- (004180FB) --------------------------------------------------------
BOOL __thiscall CPacket::PostObject(WorldSrvPacket *this, DWORD id, HANDLE completionPort)
{
  return PostQueuedCompletionStatus(completionPort, id, (ULONG_PTR)this, 0);
}

//----- (0041811C) --------------------------------------------------------
signed int __thiscall MemoryObject::AddTimer(MemoryObject *this, unsigned int dwTime, int id)
{
  signed int result; // eax@2
  MemoryObject *this_; // [sp+0h] [bp-4h]@1

  this_ = this;
  if ( TimerQueue::AddTimer(&g_timerQueue, this, dwTime, id) )
  {
    MemoryObject::AddRef(this_);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00418154) --------------------------------------------------------
bool __thiscall MemoryObject::RegisterWait(MemoryObject *this, HANDLE eventObject)
{
  return TimerQueue::RegisterWait(&g_timerQueue, eventObject, this) != 0;
}

//----- (0041817D) --------------------------------------------------------
void __stdcall MemoryObject::OnIOCallback_empty(MemoryObject *this, int a2, int a3)
{
  ;
}

//----- (0041818A) --------------------------------------------------------
LONG __thiscall MemoryObject::OnTimerCallback(MemoryObject *this)
{
  return MemoryObject::Release(this);
}

//----- (0041819D) --------------------------------------------------------
void __cdecl MemoryObject::OnWaitCallback(MemoryObject *this)
{
  ;
}

//----- (004181A8) --------------------------------------------------------
int SomeStaticInit17()
{
  SomeBitsInit();
  return sub_4181B7();
}

//----- (004181B7) --------------------------------------------------------
int sub_4181B7()
{
  return atexit(emptystub);
}

//----- (004181D0) --------------------------------------------------------
MemoryObject *__thiscall MemoryObject::DeletingDestructor(MemoryObject *this, char a2)
{
  MemoryObject *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  MemoryObject::Destructor(this);
  if ( a2 & 1 )
    operator_delete(v3);
  return v3;
}

//----- (00418200) --------------------------------------------------------
int StaticInit_WorldSrvServer()
{
  CallStaticCtorForWorldSrvServer();
  return RegisterStatic_destructorForWorldSrvServer();
}

//----- (0041820F) --------------------------------------------------------
WorldSrvServer *CallStaticCtorForWorldSrvServer()
{
  return WorldSrvServer::WorldSrvServer(&g_worldServServer);
}

//----- (0041821E) --------------------------------------------------------
int RegisterStatic_destructorForWorldSrvServer()
{
  return atexit(CallStaticDestructorForWorldSrvServer);
}

//----- (00418230) --------------------------------------------------------
void __cdecl CallStaticDestructorForWorldSrvServer()
{
  WorldSrvServer::Destructor(&g_worldServServer);
}

//----- (0041823F) --------------------------------------------------------
int StaticInit_CAuthServer()
{
  CallStaticCtorFor_CAuthServer();
  return RegisterStaticDtor_CAuthServer();
}

//----- (0041824E) --------------------------------------------------------
CAuthServer *CallStaticCtorFor_CAuthServer()
{
  return CAuthServer::CAuthServer(&g_authServer);
}

//----- (0041825D) --------------------------------------------------------
int RegisterStaticDtor_CAuthServer()
{
  return atexit(CallStaticDtorFor_CAuthServer);
}

//----- (0041826F) --------------------------------------------------------
void __cdecl CallStaticDtorFor_CAuthServer()
{
  CAuthServer::Destructor(&g_authServer);
}

//----- (0041827E) --------------------------------------------------------
int StaticInit_CIOServerInt()
{
  CallStaticCtorForCIOServerInt();
  return RegisterStatic_destructorForCIOServerInt();
}

//----- (0041828D) --------------------------------------------------------
CIOServerInt *CallStaticCtorForCIOServerInt()
{
  return CIOServerInt::CIOServerInt(&g_CIOServerInt);
}

//----- (0041829C) --------------------------------------------------------
int RegisterStatic_destructorForCIOServerInt()
{
  return atexit(CIOServerInt::static_destructor);
}

//----- (004182AE) --------------------------------------------------------
void __cdecl CIOServerInt::static_destructor()
{
  CIOServerInt::Destructor(&g_CIOServerInt);
}

//----- (004182BD) --------------------------------------------------------
CIOServer *__thiscall CIOServer::CIOServer(CIOServer *this)
{
  CIOServer *this_; // ST00_4@1

  this_ = this;
  MemoryObject::MemoryObject(&this->base);
  this_->base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&CIOServerBase_vftable_offset_45F538;
  this_->m_socket = INVALID_SOCKET;
  this_->m_hAcceptEvent = NULL;
  return this_;
}
// 45F538: using guessed type int (__stdcall *CIOServerBase_vftable_offset_45F538)(int);

//----- (004182F0) --------------------------------------------------------
MemoryObject *__thiscall CIOServer::Destructor(CIOServer *this)
{
  CIOServer *this_; // ST04_4@1

  this_ = this;
  this->base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&CIOServerBase_vftable_offset_45F538;
  CIOServer::Close(this);
  WSACloseEvent(this_->m_hAcceptEvent);
  return MemoryObject::Destructor(&this_->base);
}
// 45F538: using guessed type int (__stdcall *CIOServerBase_vftable_offset_45F538)(int);

//----- (0041834E) --------------------------------------------------------
CIOServer *__thiscall CIOServer::Close(CIOServer *this)
{
  CIOServer *result; // eax@1
  SOCKET oldSocket; // ST0C_4@2

  result = this;
  if ( this->m_socket != INVALID_SOCKET )
  {
    oldSocket = InterlockedExchange((volatile LONG *)&this->m_socket, INVALID_SOCKET);
    result = (CIOServer *)closesocket(oldSocket);
  }
  return result;
}

//----- (004183AA) --------------------------------------------------------
MyBool __thiscall CIOServer::Create(CIOServer *this, int port)
{
  int err; // eax@2
  int err1; // eax@4
  int err2; // eax@6
  CIOServer *this_; // [sp+0h] [bp-14h]@1
  sockaddr_in name; // [sp+4h] [bp-10h]@3

  this_ = this;
  this->m_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
  if ( this_->m_socket == INVALID_SOCKET )
  {
    err = WSAGetLastError();
    LogWindow::Add(&g_LogWindow, 3, aSocketErrorD, err);
    return false;
  }
  name.sin_family = AF_INET;
  name.sin_addr.S_un.S_addr = htonl(INADDR_ANY);
  name.sin_port = htons(port);
  if ( bind(this_->m_socket, (const struct sockaddr *)&name, 16) )
  {
    err1 = WSAGetLastError();
    LogWindow::Add(&g_LogWindow, 3, aBindErrorD, err1);
  }
  else if ( listen(this_->m_socket, 5) )
  {
    err2 = WSAGetLastError();
    LogWindow::Add(&g_LogWindow, 3, aListenErrorD, err2);
  }
  else
  {
    this_->m_hAcceptEvent = WSACreateEvent();
    WSAEventSelect(this_->m_socket, this_->m_hAcceptEvent, FD_ACCEPT);
    if ( this_->base.vftbl_0_45F520->RegisterWait((MemoryObject *)this_, this_->m_hAcceptEvent) & 0xFF )
      return true;
    LogWindow::Add(&g_LogWindow, 3, aRegisterwaitEr, port);
  }
  CIOServer::Close(this_);
  return false;
}

//----- (004184ED) --------------------------------------------------------
LogWindow *__thiscall CIOServer::OnIOCallback(CIOServer *this)
{
  LogWindow *result; // eax@2
  int err; // eax@5
  CIOServer *this_; // [sp+Ch] [bp-38h]@1
  CIOSocket *socket; // [sp+10h] [bp-34h]@7
  int clientAddressLength; // [sp+14h] [bp-30h]@1
  SOCKET newSocket; // [sp+18h] [bp-2Ch]@1
  struct sockaddr clientAddress; // [sp+1Ch] [bp-28h]@1
  CPPEH_RECORD ms_exc; // [sp+2Ch] [bp-18h]@1

  this_ = this;
  ms_exc.registration.TryLevel = 0;
  clientAddressLength = 16;
  newSocket = accept(this->m_socket, &clientAddress, &clientAddressLength);
  if ( newSocket == INVALID_SOCKET )
  {
    result = (LogWindow *)WSAGetLastError();
    if ( result == (LogWindow *)WSAEWOULDBLOCK )
    {
      ms_exc.registration.TryLevel = -1;
    }
    else
    {
      if ( this_->m_socket != INVALID_SOCKET )
      {
        err = WSAGetLastError();
        result = LogWindow::Add(&g_LogWindow, 3, aAcceptErrorD, err);
      }
      ms_exc.registration.TryLevel = -1;
    }
  }
  else
  {
    socket = (CIOSocket *)((int (__thiscall *)(CIOServer *, SOCKET, struct sockaddr *))this_->base.vftbl_0_45F520->derived_func_7)(
                            this_,
                            newSocket,
                            &clientAddress);    // CreateSocket
    if ( socket )
    {
      result = (LogWindow *)CIOSocket::Initialize(socket, Threading::g_hCompletionPort);
    }
    else
    {
      LogWindow::Add(&g_LogWindow, 3, aServercloseCre);
      result = (LogWindow *)closesocket(newSocket);
      ms_exc.registration.TryLevel = -1;
    }
  }
  return result;
}

//----- (00418633) --------------------------------------------------------
BOOL __thiscall CIOServer::OnWaitCallback(CIOServer *this)
{
  CIOServer *this_; // ST10_4@1

  this_ = this;
  WSAResetEvent(this->m_hAcceptEvent);
  return PostQueuedCompletionStatus(Threading::g_hCompletionPort, 0, (ULONG_PTR)this_, NULL);
}

//----- (0041865F) --------------------------------------------------------
WorldSrvServer *__thiscall WorldSrvServer::WorldSrvServer(WorldSrvServer *this)
{
  WorldSrvServer *this_; // ST08_4@1
  char v3; // [sp+4h] [bp-14h]@1
  char v4; // [sp+8h] [bp-10h]@1
  int v5; // [sp+14h] [bp-4h]@1

  this_ = this;
  CIOServer::CIOServer(&this->base);
  v5 = 0;
  std::map_ip_sock::map_ip_sock(&this_->m_sockets, &v3, &v4);
  this_->base.base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&WorldServServer_vftable_offset_45F574;
  LOBYTE(this_->unused1) = SocketStatus_Init;
  InitializeCriticalSectionAndSpinCount(&this_->m_lock, 4000u);
  return this_;
}
// 45F574: using guessed type int (__stdcall *WorldServServer_vftable_offset_45F574)(int);

//----- (004186D9) --------------------------------------------------------
WorldSrvServer *__thiscall WorldSrvServer::Destructor(WorldSrvServer *this)
{
  WorldSrvServer *this_; // ST04_4@1

  this_ = this;
  this->base.base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&WorldServServer_vftable_offset_45F574;
  DeleteCriticalSection(&this->m_lock);
  std::map_ip_sock::destructor(&this_->m_sockets);
  return (WorldSrvServer *)CIOServer::Destructor(&this_->base);
}
// 45F574: using guessed type int (__stdcall *WorldServServer_vftable_offset_45F574)(int);

//----- (0041873A) --------------------------------------------------------
WorldSrvSocket *__thiscall WorldSrvServer::CreateSocket(WorldSrvServer *this, SOCKET socket, sockaddr_in *address)
{
  WorldSrvSocket *result; // eax@2
  WorldSrvSocket *worldSocket; // eax@5
  struct Concurrency::IExecutionContext *pair; // eax@5
  WorldSrvServer *this_; // [sp+0h] [bp-1Ch]@1
  int v7; // [sp+4h] [bp-18h]@5
  char v8; // [sp+Ch] [bp-10h]@5
  WorldSrvSocket *worldSocket1; // [sp+14h] [bp-8h]@5
  int serverId; // [sp+18h] [bp-4h]@1

  this_ = this;
  LogWindow::Add(
    &g_LogWindow,
    0,
    aNewWorldServer,
    address->sin_addr.S_un.S_un_b.s_b1,
    address->sin_addr.S_un.S_un_b.s_b2,
    address->sin_addr.S_un.S_un_b.s_b3,
    address->sin_addr.S_un.S_un_b.s_b4);
  serverId = 0;
  serverId = ServersProvider::updateServerAndGetServerID(address->sin_addr.S_un.S_addr, socket);
  if ( serverId )
  {
    if ( serverId == -1 )
    {
      LogWindow::Add(
        &g_LogWindow,
        3,
        aIpD_D_D_DWorld,
        address->sin_addr.S_un.S_un_b.s_b1,
        address->sin_addr.S_un.S_un_b.s_b2,
        address->sin_addr.S_un.S_un_b.s_b3,
        address->sin_addr.S_un.S_un_b.s_b4);
      result = 0;
    }
    else
    {
      worldSocket = this_->factoryMethod(socket);
      worldSocket1 = worldSocket;
      worldSocket->m_serverID = serverId;
      WorldSrvSocket::setIPAddress(worldSocket1, address->sin_addr);
      EnterCriticalSection(&this_->m_lock);
      pair = (struct Concurrency::IExecutionContext *)std::pair_ip_socket::pair_ip_socket(
                                                        (std::pair_ip_socket *)&v8,
                                                        (int *)&address->sin_addr,
                                                        (CIOSocket **)&worldSocket1);
      std::map_ip_sock::insert(&this_->m_sockets, (int)&v7, pair);
      LeaveCriticalSection(&this_->m_lock);
      result = worldSocket1;
    }
  }
  else
  {
    LogWindow::Add(
      &g_LogWindow,
      3,
      aNonRegisteredW,
      address->sin_addr.S_un.S_un_b.s_b1,
      address->sin_addr.S_un.S_un_b.s_b2,
      address->sin_addr.S_un.S_un_b.s_b3,
      address->sin_addr.S_un.S_un_b.s_b4);
    result = 0;
  }
  return result;
}

//----- (004188A6) --------------------------------------------------------
WorldSrvServer *__thiscall WorldSrvServer::Create(WorldSrvServer *this, int port, WorldSrvSocket *(__cdecl *factoryMethod)(SOCKET), char a4)
{
  WorldSrvServer *result; // eax@3
  WorldSrvServer *this_; // [sp+0h] [bp-4h]@1

  this_ = this;
  this->factoryMethod = factoryMethod;
  LOBYTE(this->unused3) = a4;
  if ( CIOServer::Create(&this->base, port) )
    LogWindow::Add(&g_LogWindow, 0, aServerReadyOnP, port);
  result = this_;
  this_->m_listenSocket = this_->base.m_socket;
  return result;
}

//----- (004188F9) --------------------------------------------------------
WorldSrvSocket *__thiscall WorldSrvServer::getSocket(WorldSrvServer *this, int ipAddress)
{
  std::_tree_ip_sock::iterator *end; // eax@1
  WorldSrvServer *this_; // [sp+0h] [bp-10h]@1
  int a2; // [sp+4h] [bp-Ch]@1
  WorldSrvSocket *socket; // [sp+8h] [bp-8h]@1
  std::_tree_ip_sock::iterator it; // [sp+Ch] [bp-4h]@1

  this_ = this;
  socket = 0;
  EnterCriticalSection(&this->m_lock);
  std::map_ip_sock::find(&this_->m_sockets, &it, &ipAddress);
  end = std::map_ip_sock::end(&this_->m_sockets, (int)&a2);
  if ( (unsigned __int8)std::_tree_ip_sock::iterator::not_equal(&it, end) )
  {
    socket = std::_tree_ip_sock::iterator::value(&it)->socket;
    MemoryObject::AddRef(&socket->m_base.base);
  }
  LeaveCriticalSection(&this_->m_lock);
  return socket;
}

//----- (00418976) --------------------------------------------------------
char __thiscall WorldSrvServer::socketExists(WorldSrvServer *this, int ipAddress)
{
  std::_tree_ip_sock::iterator *end; // eax@1
  WorldSrvServer *this_; // [sp+0h] [bp-10h]@1
  int a2a; // [sp+4h] [bp-Ch]@1
  std::_tree_ip_sock::iterator v6; // [sp+8h] [bp-8h]@1
  char exists; // [sp+Ch] [bp-4h]@1

  this_ = this;
  exists = false;
  EnterCriticalSection(&this->m_lock);
  std::map_ip_sock::find(&this_->m_sockets, &v6, &ipAddress);
  end = std::map_ip_sock::end(&this_->m_sockets, (int)&a2a);
  if ( (unsigned __int8)std::_tree_ip_sock::iterator::not_equal(&v6, end) )
    exists = true;
  LeaveCriticalSection(&this_->m_lock);
  return exists;
}

//----- (004189DE) --------------------------------------------------------
void __thiscall WorldSrvServer::removeServer(WorldSrvServer *this, int ipAddress)
{
  std::_tree_ip_sock::iterator *end; // eax@1
  WorldSrvServer *this_; // [sp+0h] [bp-10h]@1
  int v4; // [sp+4h] [bp-Ch]@2
  int a2a; // [sp+8h] [bp-8h]@1
  std::_tree_ip_sock::iterator it; // [sp+Ch] [bp-4h]@1

  this_ = this;
  EnterCriticalSection(&this->m_lock);
  std::map_ip_sock::find(&this_->m_sockets, &it, &ipAddress);
  end = std::map_ip_sock::end(&this_->m_sockets, (int)&a2a);
  if ( (unsigned __int8)std::_tree_ip_sock::iterator::not_equal(&it, end) )
    std::map_ip_sock::erase(&this_->m_sockets, &v4, (std::_tree_ip_sock::iterator *)it._Ptr);
  if ( !std::map_ip_sock::size(&this_->m_sockets) )
    UserManager::clear(&g_userManager);
  LeaveCriticalSection(&this_->m_lock);
}

//----- (00418A67) --------------------------------------------------------
CIOServerInt *__thiscall CIOServerInt::CIOServerInt(CIOServerInt *this)
{
  CIOServerInt *this_; // ST08_4@1

  this_ = this;
  CIOServer::CIOServer(&this->base);
  this_->base.base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&CIOServerInt_vftable_off_45F590;
  this_->m_someBool = false;
  InitializeCriticalSectionAndSpinCount(&this_->m_lock, 4000u);
  return this_;
}
// 45F590: using guessed type int (__stdcall *CIOServerInt_vftable_off_45F590)(int);

//----- (00418A9F) --------------------------------------------------------
MemoryObject *__thiscall CIOServerInt::Destructor(CIOServerInt *this)
{
  CIOServerInt *v1; // ST04_4@1

  v1 = this;
  this->base.base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&CIOServerInt_vftable_off_45F590;
  DeleteCriticalSection(&this->m_lock);
  CloseHandle(Threading::g_hCompletionPortExtra);
  return CIOServer::Destructor(&v1->base);
}
// 45F590: using guessed type int (__stdcall *CIOServerInt_vftable_off_45F590)(int);

//----- (00418AD5) --------------------------------------------------------
LogWindow *__thiscall CIOServerInt::OnIOCallback(CIOServerInt *this, int a2, int a3, int a4)
{
  LogWindow *error; // eax@2
  int error1; // eax@4
  CIOServerInt *this_; // [sp+0h] [bp-20h]@1
  CIOSocket *socket; // [sp+4h] [bp-1Ch]@6
  int addrlen; // [sp+8h] [bp-18h]@1
  SOCKET newSocket; // [sp+Ch] [bp-14h]@1
  sockaddr_in addr; // [sp+10h] [bp-10h]@1

  this_ = this;
  addrlen = 16;
  newSocket = accept(this->base.m_socket, (struct sockaddr *)&addr, &addrlen);
  if ( newSocket == INVALID_SOCKET )
  {
    error = (LogWindow *)WSAGetLastError();
    if ( error != (LogWindow *)WSAEWOULDBLOCK && this_->base.m_socket != INVALID_SOCKET )
    {
      error1 = WSAGetLastError();
      error = LogWindow::Add(&g_LogWindow, 3, aAcceptErrorD_0, error1);
    }
  }
  else
  {
    socket = (CIOSocket *)((int (__thiscall *)(CIOServerInt *, SOCKET, sockaddr_in *))this_->base.base.vftbl_0_45F520->derived_func_7)(
                            this_,
                            newSocket,
                            &addr);             // CreateSocket
    if ( socket )
      error = (LogWindow *)CIOSocket::Initialize(socket, Threading::g_hCompletionPortExtra);
    else
      error = (LogWindow *)closesocket(newSocket);
  }
  return error;
}

//----- (00418B75) --------------------------------------------------------
CSocketInt *__thiscall CIOServerInt::CreateSocket(CIOServerInt *this, SOCKET socket, sockaddr_in *clientAddress)
{
  CSocketInt *interactiveSocket; // ST20_4@1

  interactiveSocket = this->m_factoryMethod(socket);
  CSocketInt::setIPAddress(interactiveSocket, clientAddress->sin_addr.S_un.S_addr);
  LogWindow::Add(
    &g_LogWindow,
    0,
    aNewInteractive,
    clientAddress->sin_addr.S_un.S_un_b.s_b1,
    clientAddress->sin_addr.S_un.S_un_b.s_b2,
    clientAddress->sin_addr.S_un.S_un_b.s_b3,
    clientAddress->sin_addr.S_un.S_un_b.s_b4);
  return interactiveSocket;
}

//----- (00418BF7) --------------------------------------------------------
int __thiscall CIOServerInt::Create(CIOServerInt *this, int port, MemoryObject *(__cdecl *factoryMethod)(int))
{
  int result; // eax@3
  CIOServerInt *this_; // [sp+0h] [bp-4h]@1

  this_ = this;
  this->m_factoryMethod = (CSocketInt *(__cdecl *)(SOCKET))factoryMethod;
  if ( CIOServer::Create(&this->base, port) )
    LogWindow::Add(&g_LogWindow, 0, aInteractiveSer, port);
  result = this_->base.m_socket;
  this_->m_socket = result;
  return result;
}

//----- (00418C41) --------------------------------------------------------
int StaticInitFor_LSOverlappedPool::g_overlapped()
{
  LSOverlappedPool::g_overlapped_construction();
  return LSOverlappedPool::Call_g_overlapped_destruction();
}

//----- (00418C50) --------------------------------------------------------
int LSOverlappedPool::g_overlapped_construction()
{
  return `eh vector constructor iterator'(
           CAuthOverlappedPool::g_slot,
           0x24u,
           16,
           (int)OverlappedSlot::OverlappedSlot,
           (void (__thiscall *)(void *))OverlappedSlot::Destructor);
}

//----- (00418C6D) --------------------------------------------------------
int LSOverlappedPool::Call_g_overlapped_destruction()
{
  return atexit(LSOverlappedPool::g_overlapped_destruction);
}

//----- (00418C7F) --------------------------------------------------------
void __cdecl LSOverlappedPool::g_overlapped_destruction()
{
  if ( !(byte_47EFD4 & 1) )
  {
    byte_47EFD4 |= 1u;
    `eh vector destructor iterator'(
      CAuthOverlappedPool::g_slot,
      0x24u,
      16,
      (void (__thiscall *)(void *))OverlappedSlot::Destructor);
  }
}
// 47EFD4: using guessed type char byte_47EFD4;

//----- (00418CB4) --------------------------------------------------------
int StaticInit_ForLSOverlappedPool()
{
  CallLSOverlappedPoolStaticCtor();
  return RegitsterLSOverlappedPoolDestructor();
}

//----- (00418CC3) --------------------------------------------------------
void CallLSOverlappedPoolStaticCtor()
{
  ;
}

//----- (00418CC8) --------------------------------------------------------
int RegitsterLSOverlappedPoolDestructor()
{
  return atexit(CallLSOverlappedPoolDestructor);
}

//----- (00418CDA) --------------------------------------------------------
void __cdecl CallLSOverlappedPoolDestructor()
{
  LSOverlappedPool::Destructor(&unk_47ECB0);
}

//----- (00418CE9) --------------------------------------------------------
AuthOverlapped *__cdecl LSOverlapped::Alloc()
{
  AuthOverlapped *overlapped; // [sp+4h] [bp-8h]@1
  OverlappedSlot *slot; // [sp+8h] [bp-4h]@1

  slot = &CAuthOverlappedPool::g_slot[InterlockedIncrement(&LSOverlappedPool::g_nAlloc) & 0xF];
  SpinLock::Enter(&slot->m_lock);
  overlapped = slot->m_overlapped;
  if ( slot->m_overlapped )
  {
    slot->m_overlapped = (AuthOverlapped *)overlapped->m_pNext;
    SpinLock::Leave(&slot->m_lock);
  }
  else
  {
    SpinLock::Leave(&slot->m_lock);
    overlapped = (AuthOverlapped *)operator new(0x11Cu);
  }
  memset(overlapped, 0, 20u);
  overlapped->acceptSocket = INVALID_SOCKET;
  overlapped->m_pNext = 0;
  return overlapped;
}

//----- (00418D8B) --------------------------------------------------------
void __cdecl LSOverlapped::Free(AuthOverlapped *this)
{
  OverlappedSlot *slot; // ST04_4@1

  slot = &CAuthOverlappedPool::g_slot[InterlockedIncrement(&LSOverlappedPool::g_nFree) & 0xF];
  SpinLock::Enter(&slot->m_lock);
  this->m_pNext = slot->m_overlapped;
  slot->m_overlapped = this;
  SpinLock::Leave(&slot->m_lock);
}

//----- (00418DD8) --------------------------------------------------------
int LSOverlapped::FreeAll()
{
  int result; // eax@6
  OverlappedSlot *slot; // [sp+4h] [bp-Ch]@3
  AuthOverlapped *overlapped; // [sp+8h] [bp-8h]@4
  signed int i; // [sp+Ch] [bp-4h]@1

  for ( i = 0; i < 16; ++i )
  {
    slot = &CAuthOverlappedPool::g_slot[i];
    SpinLock::Enter(&CAuthOverlappedPool::g_slot[i].m_lock);
    while ( 1 )
    {
      overlapped = slot->m_overlapped;
      if ( !slot->m_overlapped )
        break;
      slot->m_overlapped = (AuthOverlapped *)overlapped->m_pNext;
      _delete_table(overlapped);
    }
    SpinLock::Leave(&slot->m_lock);
    result = i + 1;
  }
  return result;
}

//----- (00418E51) --------------------------------------------------------
CAuthServer *__thiscall CAuthServer::CAuthServer(CAuthServer *this)
{
  CAuthServer *this_; // [sp+0h] [bp-18h]@1
  char v3; // [sp+4h] [bp-14h]@1
  char v4; // [sp+8h] [bp-10h]@1
  int unused1; // [sp+14h] [bp-4h]@1

  this_ = this;
  MemoryObject::MemoryObject(&this->base);
  unused1 = 0;
  std::map_sock_sock::map_sock_sock(&this_->m_sockets, &v3, &v4);
  LOBYTE(unused1) = 1;
  this_->base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&UserLoginServer_vtable_off_45F5AC;
  this_->m_socket = INVALID_SOCKET;
  this_->m_acceptEvent = NULL;
  this_->m_acceptSocket = INVALID_SOCKET;
  g_SocketTimer = CreateTimerQueue();
  if ( !g_SocketTimer )
    LogWindow::Add(&g_LogWindow, 3, aCioserverexCon);
  InitializeCriticalSectionAndSpinCount(&this_->m_lock, 4000u);
  return this_;
}
// 45F5AC: using guessed type int (__stdcall *UserLoginServer_vtable_off_45F5AC)(int);

//----- (00418F0E) --------------------------------------------------------
MemoryObject *__thiscall CAuthServer::Destructor(CAuthServer *this)
{
  CAuthServer *this_; // [sp+0h] [bp-10h]@1

  this_ = this;
  this->base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&UserLoginServer_vtable_off_45F5AC;
  CAuthServer::close(this);
  DeleteCriticalSection(&this_->m_lock);
  DeleteTimerQueueEx(g_SocketTimer, 0);
  if ( this_->m_acceptEvent )
    WSACloseEvent(this_->m_acceptEvent);
  unknown_libname_75(&this_->m_sockets);
  return MemoryObject::Destructor(&this_->base);
}
// 45F5AC: using guessed type int (__stdcall *UserLoginServer_vtable_off_45F5AC)(int);

//----- (00418FA0) --------------------------------------------------------
void __thiscall CAuthServer::OnIOCallback(CAuthServer *this, int success, DWORD dwTransferred, AuthOverlapped *lpOverlapped)
{
  CAuthServer *this_; // [sp+Ch] [bp-38h]@1
  struct sockaddr *removeTddr; // [sp+14h] [bp-30h]@5
  int localSockaddrLength; // [sp+18h] [bp-2Ch]@5
  CAuthSocket *userSocket; // [sp+1Ch] [bp-28h]@5
  int addrLength; // [sp+20h] [bp-24h]@1
  struct sockaddr *localSockaddr; // [sp+24h] [bp-20h]@5
  AuthOverlapped *overlapped; // [sp+28h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+2Ch] [bp-18h]@1

  this_ = this;
  ms_exc.registration.TryLevel = 0;
  addrLength = 16;
  overlapped = 0;
  if ( success )
  {
    QueueUserWorkItem(CAuthServer::initListenSocketJob, this, 0);
    overlapped = lpOverlapped;
    GetAcceptExSockaddrs(
      lpOverlapped->outputBuffer,
      dwTransferred,
      32u,
      32u,
      &localSockaddr,
      &localSockaddrLength,
      &removeTddr,
      &addrLength);
    userSocket = (CAuthSocket *)((int (__thiscall *)(CAuthServer *, SOCKET, struct sockaddr *))this_->base.vftbl_0_45F520->derived_func_7)(
                                  this_,
                                  overlapped->acceptSocket,
                                  removeTddr);  // OnNewConnection
    if ( userSocket )
      CIOSocket::Initialize(&userSocket->base, Threading::g_hCompletionPort);
    else
      closesocket(overlapped->acceptSocket);
    LSOverlapped::Free(overlapped);
  }
  else
  {
    if ( lpOverlapped )
    {
      overlapped = lpOverlapped;
      closesocket(lpOverlapped->acceptSocket);
      _delete_table(lpOverlapped);
      QueueUserWorkItem(CAuthServer::initListenSocketJob, this_, 0);
    }
    ms_exc.registration.TryLevel = -1;
  }
}

//----- (00419109) --------------------------------------------------------
bool __thiscall CAuthServer::initListenSocket(CAuthServer *this)
{
  int lastError; // eax@2
  int error; // eax@5
  CAuthServer *this_; // [sp+0h] [bp-Ch]@1
  DWORD dwReceived; // [sp+4h] [bp-8h]@3
  AuthOverlapped *overlapped; // [sp+8h] [bp-4h]@1

  this_ = this;
  overlapped = LSOverlapped::Alloc();
  overlapped->acceptSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
  if ( overlapped->acceptSocket == INVALID_SOCKET )
  {
    lastError = WSAGetLastError();
    LogWindow::Add(&g_LogWindow, 3, aSocketErrorD_0, lastError);
  }
  else
  {
    if ( AcceptEx(
           this_->m_socket,
           overlapped->acceptSocket,
           overlapped->outputBuffer,
           0,
           32u,
           32u,
           &dwReceived,
           &overlapped->base)
      || GetLastError() == ERROR_IO_PENDING )
    {
      return true;
    }
    error = WSAGetLastError();
    LogWindow::Add(&g_LogWindow, 3, aAcceptexErrorD, error);
  }
  if ( overlapped->acceptSocket != INVALID_SOCKET )
    closesocket(overlapped->acceptSocket);
  LSOverlapped::Free(overlapped);
  return false;
}

//----- (004191DD) --------------------------------------------------------
DWORD __stdcall CAuthServer::initListenSocketJob(LPVOID lpThreadParameter)
{
  CAuthServer::initListenSocket((CAuthServer *)lpThreadParameter);
  return 0;
}

//----- (004191F7) --------------------------------------------------------
LogWindow *__thiscall CAuthServer::OnWaitCallback(CAuthServer *this)
{
  CAuthServer *this_; // ST10_4@1
  LogWindow *result; // eax@1

  this_ = this;
  WSAResetEvent(this->m_acceptEvent);
  result = (LogWindow *)CAuthServer::initListenSocket(this_);
  if ( result )
  {
    InterlockedIncrement(&StatusLine::g_acceptCalls);
    result = LogWindow::Add(&g_LogWindow, 0, aAcceptexThread, StatusLine::g_acceptCalls);
  }
  return result;
}

//----- (00419258) --------------------------------------------------------
CAuthServer *__thiscall CAuthServer::stop(CAuthServer *this)
{
  return CAuthServer::close(this);
}

//----- (0041926B) --------------------------------------------------------
CAuthServer *__thiscall CAuthServer::close(CAuthServer *this)
{
  LONG oldSocket; // ST0C_4@2
  CAuthServer *result; // eax@3
  CAuthServer *this_; // [sp+0h] [bp-8h]@1

  this_ = this;
  if ( this->m_socket != INVALID_SOCKET )
  {
    oldSocket = InterlockedExchange((volatile LONG *)&this->m_socket, INVALID_SOCKET);
    closesocket(oldSocket);
  }
  result = this_;
  if ( this_->m_acceptEvent )
  {
    WSACloseEvent(this_->m_acceptEvent);
    result = this_;
    this_->m_acceptEvent = NULL;
  }
  return result;
}

//----- (004192BD) --------------------------------------------------------
CAuthServer *__thiscall CAuthServer::Create(CAuthServer *this, int hostshort, CAuthSocket *(__cdecl *authSocketFactory)(SOCKET))
{
  int lastError; // eax@2
  int lastError_; // eax@4
  int lastError_1; // eax@6
  HANDLE v7; // ST14_4@8
  int v8; // ST10_4@8
  DWORD lastError_2; // eax@8
  CAuthServer *this_; // [sp+0h] [bp-1Ch]@1
  int i; // [sp+4h] [bp-18h]@9
  sockaddr_in name; // [sp+8h] [bp-14h]@3
  HANDLE ioResult; // [sp+18h] [bp-4h]@7

  this_ = this;
  this->m_authSocketFactory = authSocketFactory;
  this->m_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
  if ( this_->m_socket == INVALID_SOCKET )
  {
    lastError = WSAGetLastError();
    return (CAuthServer *)LogWindow::Add(&g_LogWindow, 3, aAcceptexSocket, lastError);
  }
  name.sin_family = AF_INET;
  name.sin_addr.S_un.S_addr = htonl(0);
  name.sin_port = htons(hostshort);
  if ( bind(this_->m_socket, (const struct sockaddr *)&name, 16) )
  {
    lastError_ = WSAGetLastError();
    LogWindow::Add(&g_LogWindow, 3, aBindPortDError, hostshort, lastError_);
    return CAuthServer::close(this_);
  }
  if ( listen(this_->m_socket, 5) )             // maximum length of the queue of pending connections
  {
    lastError_1 = WSAGetLastError();
    LogWindow::Add(&g_LogWindow, 3, aListenErrorD_0, lastError_1);
    return CAuthServer::close(this_);
  }
  ioResult = CreateIoCompletionPort((HANDLE)this_->m_socket, Threading::g_hCompletionPort, (ULONG_PTR)this_, 0);
  if ( !ioResult )
  {
    v7 = Threading::g_hCompletionPort;
    v8 = this_->m_socket;
    lastError_2 = GetLastError();
    LogWindow::Add(&g_LogWindow, 3, aCreateiocomple, lastError_2, v8, v7);
    return CAuthServer::close(this_);
  }
  for ( i = 0; i < g_Config.AcceptCallNum; ++i )
  {
    if ( !CAuthServer::initListenSocket(this_) )
      return CAuthServer::close(this_);
  }
  StatusLine::g_acceptCalls = g_Config.AcceptCallNum;
  return (CAuthServer *)LogWindow::Add(&g_LogWindow, 0, aServiceReadyOn, hostshort);
}

//----- (00419454) --------------------------------------------------------
CAuthSocket *__thiscall CAuthServer::CreateSocket(CAuthServer *this, SOCKET socket, sockaddr_in *addr)
{
  CAuthSocket *result; // eax@2
  std::pair_Socket *pair; // eax@5
  CAuthServer *this_; // [sp+0h] [bp-1Ch]@1
  int a2; // [sp+4h] [bp-18h]@5
  std::pair_Socket v7; // [sp+Ch] [bp-10h]@5
  CAuthSocket *client; // [sp+14h] [bp-8h]@5
  in_addr ipAddress; // [sp+18h] [bp-4h]@3

  this_ = this;
  if ( g_StatusLine.sockets < g_Config.SocketLimit )
  {
    ipAddress = (in_addr)addr->sin_addr.S_un.S_addr;
    if ( IpRegistry::insert(&g_ipRegistry, ipAddress.S_un.S_addr) )
    {
      client = this_->m_authSocketFactory(socket);
      CAuthSocket::setIPAddress(client, addr->sin_addr.S_un.S_addr);
      EnterCriticalSection(&this_->m_lock);
      pair = std::pair_Socket::pair_Socket(&v7, &socket, &client);// make pair
      std::map_sock_sock::insert(&this_->m_sockets, (int)&a2, pair);
      LeaveCriticalSection(&this_->m_lock);
      result = client;
    }
    else
    {
      LogWindow::Add(
        &g_LogWindow,
        2,
        aAccesslimitExp,
        ipAddress.S_un.S_un_b.s_b1,
        ipAddress.S_un.S_un_b.s_b2,
        ipAddress.S_un.S_un_b.s_b3,
        ipAddress.S_un.S_un_b.s_b4);
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00419532) --------------------------------------------------------
CAuthSocket *__thiscall CAuthServer::getIOSocket(CAuthServer *this, SOCKET socket)
{
  std::_tree_sock_sock::iterator *end; // eax@1
  CAuthServer *this_; // [sp+0h] [bp-10h]@1
  std::_tree_sock_sock::iterator *a2; // [sp+4h] [bp-Ch]@1
  CAuthSocket *authSocket; // [sp+8h] [bp-8h]@1
  std::_tree_sock_sock::iterator it; // [sp+Ch] [bp-4h]@1

  this_ = this;
  authSocket = 0;
  EnterCriticalSection(&this->m_lock);
  std::map_sock_sock::find(&this_->m_sockets, &it, &socket);
  end = std::map_sock_sock::end(&this_->m_sockets, (std::_tree_sock_sock::iterator *)&a2);
  if ( (unsigned __int8)std::_tree_sock_sock::iterator::iterator_operator_not_eq(&it, end) )
  {
    authSocket = std::_tree_sock_sock::iterator::value(&it)->socket;
    MemoryObject::AddRef(&authSocket->base.base);
  }
  LeaveCriticalSection(&this_->m_lock);
  return authSocket;
}

//----- (004195AF) --------------------------------------------------------
char __thiscall CAuthServer::removeSocket(CAuthServer *this, SOCKET socket)
{
  CAuthServer *this_; // ST04_4@1

  this_ = this;
  EnterCriticalSection(&this->m_lock);
  std::map_sock_sock::erase(&this_->m_sockets, &socket);
  LeaveCriticalSection(&this_->m_lock);
  return 1;
}

//----- (004195E7) --------------------------------------------------------
int SomeStaticInit23()
{
  SomeBitsInit();
  return sub_4195F6();
}

//----- (004195F6) --------------------------------------------------------
int sub_4195F6()
{
  return atexit(emptystub);
}

//----- (00419610) --------------------------------------------------------
CIOServer *__thiscall CIOServer::DeletingDestructor(CIOServer *this, char a2)
{
  CIOServer *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  CIOServer::Destructor(this);
  if ( a2 & 1 )
    operator_delete(v3);
  return v3;
}

//----- (00419640) --------------------------------------------------------
WorldSrvServer *__thiscall WorldSrvServer::DeletingDestructor(WorldSrvServer *this, char a2)
{
  WorldSrvServer *this_; // [sp+0h] [bp-4h]@1

  this_ = this;
  WorldSrvServer::Destructor(this);
  if ( a2 & 1 )
    operator_delete(this_);
  return this_;
}

//----- (004196B0) --------------------------------------------------------
CIOServerInt *__thiscall CIOServerInt::DestructorCall(CIOServerInt *this, char a2)
{
  CIOServerInt *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  CIOServerInt::Destructor(this);
  if ( a2 & 1 )
    operator_delete(v3);
  return v3;
}

//----- (004196E0) --------------------------------------------------------
// Microsoft VisualC 2-11/net runtime
void __thiscall OverlappedSlot::Destructor(OverlappedSlot *this)
{
  SpinLock::Destructor(&this->m_lock);
}

//----- (00419700) --------------------------------------------------------
CAuthServer *__thiscall CAuthServer::DeletingDestructor(CAuthServer *this, char a2)
{
  CAuthServer *this_; // [sp+0h] [bp-4h]@1

  this_ = this;
  CAuthServer::Destructor(this);
  if ( a2 & 1 )
    operator_delete(this_);
  return this_;
}

//----- (00419770) --------------------------------------------------------
std::map_ip_sock *__thiscall std::map_ip_sock::map_ip_sock(std::map_ip_sock *this, _BYTE *a2, _BYTE *a3)
{
  std::map_ip_sock *v3; // ST08_4@1

  v3 = this;
  std::map_ip_sock::map_ip_sock2(this, a2, a3);
  return v3;
}

//----- (00419790) --------------------------------------------------------
std::_tree_ip_sock::iterator *__thiscall std::map_ip_sock::end(void *this, int a2)
{
  sub_419BD0((int)this, a2);
  return (std::_tree_ip_sock::iterator *)a2;
}

//----- (004197D0) --------------------------------------------------------
int __thiscall std::map_ip_sock::insert(std::map_ip_sock *this, int a2, struct Concurrency::IExecutionContext *a3)
{
  int v4; // [sp+4h] [bp-8h]@1
  char v5; // [sp+8h] [bp-4h]@1

  sub_419C10(this, (int)&v4, a3);
  sub_41ACE0(a2, &v4, &v5);
  return a2;
}

//----- (00419810) --------------------------------------------------------
_DWORD *__thiscall std::map_ip_sock::erase(std::map_ip_sock *this, _DWORD *a2, std::_tree_ip_sock::iterator *a3)
{
  sub_419DE0(&this->_Tr, a2, (int)a3);
  return a2;
}

//----- (00419830) --------------------------------------------------------
_DWORD *__thiscall std::map_ip_sock::find(void *this, _DWORD *a2, _DWORD *a3)
{
  sub_41A730(this, a2, a3);
  return a2;
}

//----- (00419850) --------------------------------------------------------
void __thiscall sub_419850(std::_tree_ip_sock *this)
{
  int v1; // ST08_4@1
  int *v2; // eax@1
  std::_tree_ip_sock *v3; // [sp+0h] [bp-18h]@1
  char v4; // [sp+4h] [bp-14h]@1
  char v5; // [sp+8h] [bp-10h]@1
  char v6; // [sp+Ch] [bp-Ch]@1
  char v7; // [sp+10h] [bp-8h]@1
  void *v8; // [sp+14h] [bp-4h]@1

  v3 = this;
  v1 = *(_DWORD *)sub_419BD0((int)this, (int)&v6);
  v2 = (int *)sub_419BA0(v3, (int)&v5);
  sub_41A630(v3, &v4, *v2, v1);
  Concurrency::details::_NonReentrantPPLLock::_Acquire((std::_tree *)v3, v3->_Head);
  v3->_Head = 0;
  v3->_Size = 0;
  v8 = 0;
  std::_Lockit::_Lockit((std::_Lockit *)&v7);
  if ( !--dword_47EFE0 )
  {
    v8 = (void *)dword_47EFDC;
    dword_47EFDC = 0;
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v7);
  if ( v8 )
    Concurrency::details::_NonReentrantPPLLock::_Acquire((std::_tree *)v3, v8);
}
// 47EFDC: using guessed type int dword_47EFDC;
// 47EFE0: using guessed type int dword_47EFE0;

//----- (00419900) --------------------------------------------------------
std::pair_ip_socket *__thiscall std::pair_ip_socket::pair_ip_socket(std::pair_ip_socket *this, int *a2, CIOSocket **a3)
{
  this->ipAddress = *a2;
  this->socket = (WorldSrvSocket *)*a3;
  return this;
}

//----- (00419950) --------------------------------------------------------
BOOL __thiscall std::_tree_ip_sock::iterator::not_equal(std::_tree_ip_sock::iterator *this, std::_tree_ip_sock::iterator *a2)
{
  return (unsigned __int8)sub_41A810(this, a2) == 0;
}

//----- (00419980) --------------------------------------------------------
std::map_sock_sock *__thiscall std::map_sock_sock::map_sock_sock(std::map_sock_sock *this, _BYTE *a2, _BYTE *a3)
{
  std::map_sock_sock *v3; // ST08_4@1

  v3 = this;
  std::map_sock_sock::map_sock_sock2(this, a2, a3);
  return v3;
}

//----- (004199A0) --------------------------------------------------------
std::_tree_sock_sock::iterator *__thiscall std::map_sock_sock::end(std::map_sock_sock *this, std::_tree_sock_sock::iterator *a2)
{
  std::_tree_sock_sock::end(&this->_Tr, a2);
  return a2;
}

//----- (004199C0) --------------------------------------------------------
int __thiscall std::map_sock_sock::insert(std::map_sock_sock *this, int a2, std::pair_Socket *a3)
{
  int a2a; // [sp+4h] [bp-8h]@1
  char v5; // [sp+8h] [bp-4h]@1

  std::_tree_sock_sock::insert3(&this->_Tr, (int)&a2a, a3);
  std::pair::pair_iterator_bool_2(a2, &a2a, &v5);
  return a2;
}

//----- (00419A20) --------------------------------------------------------
_DWORD *__thiscall std::map_sock_sock::find(std::map_sock_sock *this, _DWORD *a2, _DWORD *a3)
{
  std::_tree_sock_sock::find(&this->_Tr, a2, a3);
  return a2;
}

//----- (00419A40) --------------------------------------------------------
void __thiscall sub_419A40(std::_tree *this)
{
  std::_tree *v1; // ST0C_4@1
  std::_tree_sock_sock::_Node *v2; // ST08_4@1
  std::_tree_sock_sock::iterator **v3; // eax@1
  char v4; // [sp+4h] [bp-14h]@1
  int v5; // [sp+8h] [bp-10h]@1
  int a2; // [sp+Ch] [bp-Ch]@1
  char v7; // [sp+10h] [bp-8h]@1
  void *v8; // [sp+14h] [bp-4h]@1

  v1 = this;
  v2 = std::_tree_sock_sock::end((std::_tree_sock_sock *)this, (std::_tree_sock_sock::iterator *)&a2)->_Ptr;
  v3 = (std::_tree_sock_sock::iterator **)std::_tree_sock_sock::begin(v1, (int)&v5);
  std::_tree_sock_sock::erase((std::_tree_sock_sock *)v1, &v4, *v3, (char)v2);
  std::_tree_sock_sock::_Freenode((std::_tree_sock_sock *)v1->_Head);
  v1->_Head = 0;
  v1->_Size = 0;
  v8 = 0;
  std::_Lockit::_Lockit((std::_Lockit *)&v7);
  if ( !--std::_tree_sock_sock::_Nilrefs )
  {
    v8 = std::_tree_sock_sock::_Nil;
    std::_tree_sock_sock::_Nil = 0;
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v7);
  if ( v8 )
    std::_tree_sock_sock::_Freenode((std::_tree_sock_sock *)v8);
}
// 47EFE8: using guessed type int std::_tree_sock_sock::_Nilrefs;

//----- (00419AF0) --------------------------------------------------------
std::pair_Socket *__thiscall std::pair_Socket::pair_Socket(std::pair_Socket *this, SOCKET *a2, CAuthSocket **a3)
{
  this->socketHandler = *a2;
  this->socket = *a3;
  return this;
}

//----- (00419B40) --------------------------------------------------------
BOOL __thiscall std::_tree_sock_sock::iterator::iterator_operator_not_eq(std::_tree_sock_sock::iterator *this, std::_tree_sock_sock::iterator *a2)
{
  return (unsigned __int8)std::_tree_sock_sock::iterator::iterator_operator_eq(this, a2) == 0;
}

//----- (00419B70) --------------------------------------------------------
std::map_ip_sock *__thiscall std::map_ip_sock::map_ip_sock2(std::map_ip_sock *this, _BYTE *a2, _BYTE *a3)
{
  std::map_ip_sock *v3; // ST0C_4@1

  v3 = this;
  std::_tree_ip_sock::_tree_ip_sock(&this->_Tr, a2, 0, a3);
  return v3;
}

//----- (00419BA0) --------------------------------------------------------
int __thiscall sub_419BA0(void *this, int a2)
{
  int *v2; // eax@1

  v2 = (int *)sub_41B3C0((int)this);
  unknown_libname_85((void *)a2, *v2);
  return a2;
}

//----- (00419BD0) --------------------------------------------------------
int __thiscall sub_419BD0(int this, int a2)
{
  unknown_libname_85((void *)a2, *(_DWORD *)(this + 4));
  return a2;
}

//----- (00419C10) --------------------------------------------------------
int __thiscall sub_419C10(void *this, int a2, struct Concurrency::IExecutionContext *a3)
{
  struct Concurrency::details::InternalContextBase *v3; // ST10_4@3
  struct Concurrency::details::InternalContextBase *v4; // eax@3
  _DWORD *v5; // eax@8
  int result; // eax@8
  _DWORD *v7; // eax@10
  _DWORD *v8; // eax@11
  struct Concurrency::details::InternalContextBase *v9; // ST10_4@13
  int v10; // eax@13
  struct Concurrency::details::InternalContextBase *v11; // eax@13
  _DWORD *v12; // eax@14
  int v13; // [sp+0h] [bp-40h]@4
  void *v14; // [sp+4h] [bp-3Ch]@1
  char v15; // [sp+8h] [bp-38h]@15
  int v16; // [sp+Ch] [bp-34h]@14
  char v17; // [sp+10h] [bp-30h]@14
  char v18; // [sp+14h] [bp-2Ch]@13
  int v19; // [sp+18h] [bp-28h]@11
  char v20; // [sp+1Ch] [bp-24h]@11
  char v21; // [sp+20h] [bp-20h]@10
  int v22; // [sp+24h] [bp-1Ch]@8
  char v23; // [sp+28h] [bp-18h]@8
  char v24; // [sp+2Ch] [bp-14h]@3
  int v25; // [sp+30h] [bp-10h]@1
  int v26; // [sp+34h] [bp-Ch]@1
  int v27; // [sp+38h] [bp-8h]@1
  int v28; // [sp+3Ch] [bp-4h]@9

  v14 = this;
  v26 = *(_DWORD *)sub_41B5B0((int)this);
  v25 = *((_DWORD *)v14 + 1);
  LOBYTE(v27) = 1;
  while ( v26 != dword_47EFDC )
  {
    v25 = v26;
    v3 = sub_41ADE0(v26);
    v4 = Concurrency::details::VirtualProcessor::ToInternalContext((Concurrency::details::VirtualProcessor *)&v24, a3);
    LOBYTE(v27) = sub_41AD90(v4, v3);
    if ( (_BYTE)v27 )
      v13 = *(_DWORD *)unknown_libname_83(v26);
    else
      v13 = *(_DWORD *)sub_41AE20(v26);
    v26 = v13;
  }
  if ( *((_BYTE *)v14 + 8) )
  {
    v23 = 1;
    v5 = (_DWORD *)sub_41AF30(v14, (int)&v22, v26, v25, a3);
    sub_41ACE0(a2, v5, &v23);
    return a2;
  }
  unknown_libname_85(&v28, v25);
  if ( (_BYTE)v27 )
  {
    v7 = (_DWORD *)sub_419BA0(v14, (int)&v21);
    if ( (unsigned __int8)sub_41A810(&v28, v7) )
    {
      v20 = 1;
      v8 = (_DWORD *)sub_41AF30(v14, (int)&v19, v26, v25, a3);
      sub_41ACE0(a2, v8, &v20);
      return a2;
    }
    unknown_libname_86(&v28);
  }
  v9 = Concurrency::details::VirtualProcessor::ToInternalContext((Concurrency::details::VirtualProcessor *)&v18, a3);
  v10 = unknown_libname_84(&v28);
  v11 = sub_41ADE0(v10);
  if ( (unsigned __int8)sub_41AD90(v11, v9) )
  {
    v17 = 1;
    v12 = (_DWORD *)sub_41AF30(v14, (int)&v16, v26, v25, a3);
    sub_41ACE0(a2, v12, &v17);
    result = a2;
  }
  else
  {
    v15 = 0;
    sub_41ACE0(a2, &v28, &v15);
    result = a2;
  }
  return result;
}
// 41AE00: using guessed type _DWORD __cdecl unknown_libname_83(_DWORD);
// 47EFDC: using guessed type int dword_47EFDC;

//----- (00419DE0) --------------------------------------------------------
_DWORD *__thiscall sub_419DE0(std::_tree_ip_sock *this, _DWORD *a2, int a3)
{
  _DWORD *v3; // eax@1
  int *v4; // eax@5
  int *v5; // eax@7
  std::_tree_ip_sock::_Node **v6; // eax@7
  _DWORD *v7; // esi@7
  std::_tree_ip_sock::_Node **v8; // eax@7
  std::_tree_ip_sock::_Node **v9; // eax@8
  _DWORD *v10; // esi@9
  _DWORD *v11; // eax@9
  _DWORD *v12; // eax@9
  _DWORD *v13; // esi@9
  int *v14; // eax@9
  std::_tree_ip_sock::_Node **v15; // eax@9
  std::_tree_ip_sock::_Node **v16; // eax@10
  std::_tree_ip_sock::_Node **v17; // eax@11
  _DWORD *v18; // eax@12
  std::_tree_ip_sock::_Node **v19; // eax@12
  _DWORD *v20; // eax@13
  std::_tree_ip_sock::_Node **v21; // eax@13
  int *v22; // eax@14
  std::_tree_ip_sock::_Node **v23; // eax@14
  _DWORD *v24; // esi@15
  int *v25; // ST04_4@15
  int *v26; // eax@15
  _DWORD *v27; // esi@16
  std::_tree_ip_sock::_Node **v28; // eax@16
  _DWORD *v29; // eax@17
  _DWORD *v30; // eax@18
  std::_tree_ip_sock::_Node **v31; // eax@18
  _DWORD *v32; // eax@19
  _DWORD *v33; // eax@19
  int *v34; // eax@20
  _DWORD *v35; // eax@20
  std::_tree_ip_sock::_Node **v36; // eax@21
  _DWORD *v37; // esi@23
  int v38; // esi@24
  std::_tree_ip_sock::_Node **v39; // eax@25
  _DWORD *v40; // esi@27
  int v41; // esi@28
  _DWORD *v42; // eax@30
  _DWORD *v43; // eax@32
  _DWORD *v44; // eax@32
  int *v45; // eax@33
  int *v46; // eax@34
  int *v47; // eax@34
  int *v48; // eax@34
  int *v49; // eax@35
  int *v50; // eax@36
  int *v51; // eax@38
  int *v52; // eax@39
  int *v53; // eax@39
  int *v54; // eax@40
  _DWORD *v55; // esi@40
  int *v56; // eax@40
  int *v57; // eax@40
  int *v58; // eax@40
  _DWORD *v59; // eax@41
  int *v60; // eax@42
  int *v61; // eax@42
  _DWORD *v62; // eax@42
  int *v63; // eax@43
  int *v64; // eax@44
  int *v65; // eax@46
  int *v66; // eax@47
  _DWORD *v67; // eax@47
  int *v68; // eax@48
  _DWORD *v69; // esi@48
  int *v70; // eax@48
  int *v71; // eax@48
  int *v72; // eax@48
  void **v73; // eax@51
  std::_tree *v75; // [sp+4h] [bp-2Ch]@1
  char v76; // [sp+8h] [bp-28h]@1
  int v77; // [sp+Ch] [bp-24h]@41
  int v78; // [sp+10h] [bp-20h]@33
  char v79; // [sp+14h] [bp-1Ch]@6
  std::_tree_ip_sock::_Node *v80; // [sp+18h] [bp-18h]@1
  std::_tree_ip_sock::_Node *a1; // [sp+1Ch] [bp-14h]@1
  int v82; // [sp+20h] [bp-10h]@2
  int v83; // [sp+2Ch] [bp-4h]@6

  v75 = (std::_tree *)this;
  v3 = sub_41B750(&a3, &v76, 0);
  a1 = (std::_tree_ip_sock::_Node *)unknown_libname_84(v3);
  v80 = a1;
  if ( *(_DWORD *)unknown_libname_83(a1) == dword_47EFDC )
  {
    v82 = *(_DWORD *)sub_41AE20((int)a1);
  }
  else if ( *(_DWORD *)sub_41AE20((int)a1) == dword_47EFDC )
  {
    v82 = *(_DWORD *)unknown_libname_83(a1);
  }
  else
  {
    v4 = (int *)sub_41AE20((int)a1);
    a1 = (std::_tree_ip_sock::_Node *)sub_41B550(*v4);
    v82 = *(_DWORD *)sub_41AE20((int)a1);
  }
  std::_Lockit::_Lockit((std::_Lockit *)&v79);
  v83 = 0;
  if ( a1 == v80 )
  {
    v27 = (_DWORD *)sub_41AE10((int)a1);
    *(_DWORD *)sub_41AE10(v82) = *v27;
    v28 = (std::_tree_ip_sock::_Node **)sub_41B5B0((int)v75);
    if ( *v28 == v80 )
    {
      v29 = (_DWORD *)sub_41B5B0((int)v75);
      *v29 = v82;
    }
    else
    {
      v30 = (_DWORD *)sub_41AE10((int)v80);
      v31 = (std::_tree_ip_sock::_Node **)unknown_libname_83(*v30);
      if ( *v31 == v80 )
      {
        v32 = (_DWORD *)sub_41AE10((int)v80);
        v33 = (_DWORD *)unknown_libname_83(*v32);
        *v33 = v82;
      }
      else
      {
        v34 = (int *)sub_41AE10((int)v80);
        v35 = (_DWORD *)sub_41AE20(*v34);
        *v35 = v82;
      }
    }
    v36 = (std::_tree_ip_sock::_Node **)sub_41B3C0((int)v75);
    if ( *v36 == v80 )
    {
      if ( *(_DWORD *)sub_41AE20((int)v80) == dword_47EFDC )
      {
        v37 = (_DWORD *)sub_41AE10((int)v80);
        *(_DWORD *)sub_41B3C0((int)v75) = *v37;
      }
      else
      {
        v38 = sub_41B550(v82);
        *(_DWORD *)sub_41B3C0((int)v75) = v38;
      }
    }
    v39 = (std::_tree_ip_sock::_Node **)sub_41B590((int)v75);
    if ( *v39 == v80 )
    {
      if ( *(_DWORD *)unknown_libname_83(v80) == dword_47EFDC )
      {
        v40 = (_DWORD *)sub_41AE10((int)v80);
        *(_DWORD *)sub_41B590((int)v75) = *v40;
      }
      else
      {
        v41 = sub_41B510(v82);
        *(_DWORD *)sub_41B590((int)v75) = v41;
      }
    }
  }
  else
  {
    v5 = (int *)unknown_libname_83(v80);
    v6 = (std::_tree_ip_sock::_Node **)sub_41AE10(*v5);
    *v6 = a1;
    v7 = (_DWORD *)unknown_libname_83(v80);
    *(_DWORD *)unknown_libname_83(a1) = *v7;
    v8 = (std::_tree_ip_sock::_Node **)sub_41AE20((int)v80);
    if ( a1 == *v8 )
    {
      v9 = (std::_tree_ip_sock::_Node **)sub_41AE10(v82);
      *v9 = a1;
    }
    else
    {
      v10 = (_DWORD *)sub_41AE10((int)a1);
      *(_DWORD *)sub_41AE10(v82) = *v10;
      v11 = (_DWORD *)sub_41AE10((int)a1);
      v12 = (_DWORD *)unknown_libname_83(*v11);
      *v12 = v82;
      v13 = (_DWORD *)sub_41AE20((int)v80);
      *(_DWORD *)sub_41AE20((int)a1) = *v13;
      v14 = (int *)sub_41AE20((int)v80);
      v15 = (std::_tree_ip_sock::_Node **)sub_41AE10(*v14);
      *v15 = a1;
    }
    v16 = (std::_tree_ip_sock::_Node **)sub_41B5B0((int)v75);
    if ( *v16 == v80 )
    {
      v17 = (std::_tree_ip_sock::_Node **)sub_41B5B0((int)v75);
      *v17 = a1;
    }
    else
    {
      v18 = (_DWORD *)sub_41AE10((int)v80);
      v19 = (std::_tree_ip_sock::_Node **)unknown_libname_83(*v18);
      if ( *v19 == v80 )
      {
        v20 = (_DWORD *)sub_41AE10((int)v80);
        v21 = (std::_tree_ip_sock::_Node **)unknown_libname_83(*v20);
        *v21 = a1;
      }
      else
      {
        v22 = (int *)sub_41AE10((int)v80);
        v23 = (std::_tree_ip_sock::_Node **)sub_41AE20(*v22);
        *v23 = a1;
      }
    }
    v24 = (_DWORD *)sub_41AE10((int)v80);
    *(_DWORD *)sub_41AE10((int)a1) = *v24;
    v25 = (int *)sub_41ADD0((int)v80);
    v26 = (int *)sub_41ADD0((int)a1);
    sub_41D340(v26, v25);
    a1 = v80;
  }
  if ( *(_DWORD *)sub_41ADD0((int)a1) == 1 )
  {
    while ( 1 )
    {
      v42 = (_DWORD *)sub_41B5B0((int)v75);
      if ( v82 == *v42 || *(_DWORD *)sub_41ADD0(v82) != 1 )
        break;
      v43 = (_DWORD *)sub_41AE10(v82);
      v44 = (_DWORD *)unknown_libname_83(*v43);
      if ( v82 == *v44 )
      {
        v45 = (int *)sub_41AE10(v82);
        v78 = *(_DWORD *)sub_41AE20(*v45);
        if ( !*(_DWORD *)sub_41ADD0(v78) )
        {
          *(_DWORD *)sub_41ADD0(v78) = 1;
          v46 = (int *)sub_41AE10(v82);
          *(_DWORD *)sub_41ADD0(*v46) = 0;
          v47 = (int *)sub_41AE10(v82);
          sub_41B3E0(v75, *v47);
          v48 = (int *)sub_41AE10(v82);
          v78 = *(_DWORD *)sub_41AE20(*v48);
        }
        v49 = (int *)unknown_libname_83(v78);
        if ( *(_DWORD *)sub_41ADD0(*v49) != 1 || (v50 = (int *)sub_41AE20(v78), *(_DWORD *)sub_41ADD0(*v50) != 1) )
        {
          v51 = (int *)sub_41AE20(v78);
          if ( *(_DWORD *)sub_41ADD0(*v51) == 1 )
          {
            v52 = (int *)unknown_libname_83(v78);
            *(_DWORD *)sub_41ADD0(*v52) = 1;
            *(_DWORD *)sub_41ADD0(v78) = 0;
            sub_41B5D0(v75, v78);
            v53 = (int *)sub_41AE10(v82);
            v78 = *(_DWORD *)sub_41AE20(*v53);
          }
          v54 = (int *)sub_41AE10(v82);
          v55 = (_DWORD *)sub_41ADD0(*v54);
          *(_DWORD *)sub_41ADD0(v78) = *v55;
          v56 = (int *)sub_41AE10(v82);
          *(_DWORD *)sub_41ADD0(*v56) = 1;
          v57 = (int *)sub_41AE20(v78);
          *(_DWORD *)sub_41ADD0(*v57) = 1;
          v58 = (int *)sub_41AE10(v82);
          sub_41B3E0(v75, *v58);
          break;
        }
        *(_DWORD *)sub_41ADD0(v78) = 0;
        v82 = *(_DWORD *)sub_41AE10(v82);
      }
      else
      {
        v59 = (_DWORD *)sub_41AE10(v82);
        v77 = *(_DWORD *)unknown_libname_83(*v59);
        if ( !*(_DWORD *)sub_41ADD0(v77) )
        {
          *(_DWORD *)sub_41ADD0(v77) = 1;
          v60 = (int *)sub_41AE10(v82);
          *(_DWORD *)sub_41ADD0(*v60) = 0;
          v61 = (int *)sub_41AE10(v82);
          sub_41B5D0(v75, *v61);
          v62 = (_DWORD *)sub_41AE10(v82);
          v77 = *(_DWORD *)unknown_libname_83(*v62);
        }
        v63 = (int *)sub_41AE20(v77);
        if ( *(_DWORD *)sub_41ADD0(*v63) != 1
          || (v64 = (int *)unknown_libname_83(v77), *(_DWORD *)sub_41ADD0(*v64) != 1) )
        {
          v65 = (int *)unknown_libname_83(v77);
          if ( *(_DWORD *)sub_41ADD0(*v65) == 1 )
          {
            v66 = (int *)sub_41AE20(v77);
            *(_DWORD *)sub_41ADD0(*v66) = 1;
            *(_DWORD *)sub_41ADD0(v77) = 0;
            sub_41B3E0(v75, v77);
            v67 = (_DWORD *)sub_41AE10(v82);
            v77 = *(_DWORD *)unknown_libname_83(*v67);
          }
          v68 = (int *)sub_41AE10(v82);
          v69 = (_DWORD *)sub_41ADD0(*v68);
          *(_DWORD *)sub_41ADD0(v77) = *v69;
          v70 = (int *)sub_41AE10(v82);
          *(_DWORD *)sub_41ADD0(*v70) = 1;
          v71 = (int *)unknown_libname_83(v77);
          *(_DWORD *)sub_41ADD0(*v71) = 1;
          v72 = (int *)sub_41AE10(v82);
          sub_41B5D0(v75, *v72);
          break;
        }
        *(_DWORD *)sub_41ADD0(v77) = 0;
        v82 = *(_DWORD *)sub_41AE10(v82);
      }
    }
    *(_DWORD *)sub_41ADD0(v82) = 1;
  }
  v83 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v79);
  v73 = sub_41AE30(a1);
  sub_41B700((int)v73);
  Concurrency::details::_NonReentrantPPLLock::_Acquire(v75, a1);
  --v75->_Size;
  *a2 = a3;
  return a2;
}
// 41AE00: using guessed type _DWORD __cdecl unknown_libname_83(_DWORD);
// 47EFDC: using guessed type int dword_47EFDC;

//----- (0041A630) --------------------------------------------------------
_DWORD *__thiscall sub_41A630(void *this, _DWORD *a2, int a3, char a4)
{
  std::_tree_ip_sock::iterator *v4; // eax@2
  std::_tree_ip_sock::iterator *v5; // eax@3
  int *v6; // eax@5
  _DWORD *result; // eax@6
  void **v8; // eax@7
  std::_tree_ip_sock *v9; // [sp+0h] [bp-14h]@1
  char v10; // [sp+4h] [bp-10h]@5
  char v11; // [sp+8h] [bp-Ch]@5
  char v12; // [sp+Ch] [bp-8h]@3
  char v13; // [sp+10h] [bp-4h]@2

  v9 = (std::_tree_ip_sock *)this;
  if ( !unknown_libname_81((std::_tree_ip_sock *)this)
    || (v4 = (std::_tree_ip_sock::iterator *)sub_419BA0(v9, (int)&v13),
        (unsigned __int8)std::_tree_ip_sock::iterator::not_equal((std::_tree_ip_sock::iterator *)&a3, v4))
    || (v5 = (std::_tree_ip_sock::iterator *)sub_419BD0((int)v9, (int)&v12),
        (unsigned __int8)std::_tree_ip_sock::iterator::not_equal((std::_tree_ip_sock::iterator *)&a4, v5)) )
  {
    while ( (unsigned __int8)std::_tree_ip_sock::iterator::not_equal(
                               (std::_tree_ip_sock::iterator *)&a3,
                               (std::_tree_ip_sock::iterator *)&a4) )
    {
      v6 = sub_41B750(&a3, &v11, 0);
      sub_419DE0(v9, &v10, *v6);
    }
    *a2 = a3;
    result = a2;
  }
  else
  {
    v8 = (void **)sub_41B5B0((int)v9);
    sub_41AEB0((std::_tree *)v9, *v8);
    *(_DWORD *)sub_41B5B0((int)v9) = dword_47EFDC;
    v9->_Size = 0;
    *(_DWORD *)sub_41B3C0((int)v9) = v9->_Head;
    *(_DWORD *)sub_41B590((int)v9) = v9->_Head;
    sub_419BA0(v9, (int)a2);
    result = a2;
  }
  return result;
}
// 47EFDC: using guessed type int dword_47EFDC;

//----- (0041A730) --------------------------------------------------------
_DWORD *__thiscall sub_41A730(void *this, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // eax@1
  int v4; // eax@2
  struct Concurrency::details::InternalContextBase *v5; // eax@2
  char *v7; // [sp+0h] [bp-18h]@3
  void *v8; // [sp+4h] [bp-14h]@1
  char v9; // [sp+8h] [bp-10h]@4
  char v10; // [sp+Ch] [bp-Ch]@1
  char *v11; // [sp+10h] [bp-8h]@5
  char v12; // [sp+14h] [bp-4h]@1

  v8 = this;
  sub_41AE80(this, (int)&v12, a3);
  v3 = (_DWORD *)sub_419BD0((int)v8, (int)&v10);
  if ( (unsigned __int8)sub_41A810(&v12, v3)
    || (v4 = unknown_libname_84(&v12), v5 = sub_41ADE0(v4), (unsigned __int8)sub_41AD90(a3, v5)) )
  {
    v7 = (char *)sub_419BD0((int)v8, (int)&v9);
  }
  else
  {
    v7 = &v12;
  }
  v11 = v7;
  *a2 = *(_DWORD *)v7;
  return a2;
}

//----- (0041A7F0) --------------------------------------------------------
void **__thiscall sub_41A7F0(std::_tree_ip_sock::iterator *this)
{
  return sub_41AE30(this->_Ptr);
}

//----- (0041A810) --------------------------------------------------------
BOOL __thiscall sub_41A810(void *this, _DWORD *a2)
{
  return *(_DWORD *)this == *a2;
}

//----- (0041A830) --------------------------------------------------------
std::map_sock_sock *__thiscall std::map_sock_sock::map_sock_sock2(std::map_sock_sock *this, _BYTE *a2, _BYTE *a3)
{
  std::map_sock_sock *v3; // ST0C_4@1

  v3 = this;
  std::_tree_sock_sock::_tree_sock_sock(&this->_Tr, a2, 0, a3);
  return v3;
}

//----- (0041A860) --------------------------------------------------------
std::_tree_sock_sock::iterator *__thiscall std::_tree_sock_sock::begin(void *this, int a2)
{
  std::_tree_sock_sock::_Node *v2; // eax@1

  v2 = std::_tree_sock_sock::_Lmost((std::_tree_sock_sock *)this);
  std::_tree_sock_sock::iterator::iterator((std::_tree_sock_sock::iterator *)a2, v2->_Left);
  return (std::_tree_sock_sock::iterator *)a2;
}

//----- (0041A890) --------------------------------------------------------
std::_tree_sock_sock::iterator *__thiscall std::_tree_sock_sock::end(std::_tree_sock_sock *this, std::_tree_sock_sock::iterator *a2)
{
  std::_tree_sock_sock::iterator::iterator(a2, this->_Head);
  return a2;
}

//----- (0041A8B0) --------------------------------------------------------
int __thiscall std::_tree_sock_sock::insert3(std::_tree_sock_sock *this, int a2, std::pair_Socket *a3)
{
  struct Concurrency::details::InternalContextBase *v3; // ST10_4@3
  struct Concurrency::details::InternalContextBase *v4; // eax@3
  _DWORD *v5; // eax@8
  int result; // eax@8
  std::_tree_sock_sock::iterator *v7; // eax@10
  _DWORD *v8; // eax@11
  struct Concurrency::details::InternalContextBase *v9; // ST10_4@13
  int v10; // eax@13
  struct Concurrency::details::InternalContextBase *v11; // eax@13
  _DWORD *v12; // eax@14
  std::_tree_sock_sock::_Node *v13; // [sp+0h] [bp-40h]@4
  std::_tree_sock_sock *v14; // [sp+4h] [bp-3Ch]@1
  char v15; // [sp+8h] [bp-38h]@15
  int v16; // [sp+Ch] [bp-34h]@14
  char v17; // [sp+10h] [bp-30h]@14
  int v18; // [sp+18h] [bp-28h]@11
  char v19; // [sp+1Ch] [bp-24h]@11
  int a2a; // [sp+20h] [bp-20h]@10
  int v21; // [sp+24h] [bp-1Ch]@8
  char v22; // [sp+28h] [bp-18h]@8
  std::_tree_sock_sock::_Node *_Y; // [sp+30h] [bp-10h]@1
  std::_tree_sock_sock::_Node *_X; // [sp+34h] [bp-Ch]@1
  int v25; // [sp+38h] [bp-8h]@1
  std::_tree_sock_sock::iterator *v26; // [sp+3Ch] [bp-4h]@9

  v14 = this;
  _X = std::_tree_sock_sock::_Root_const(this)->_Left;
  _Y = v14->_Head;
  LOBYTE(v25) = 1;
  while ( _X != std::_tree_sock_sock::_Nil )
  {
    _Y = _X;
    v3 = std::_tree_sock_sock::_Key((int)_X);
    v4 = std::_tree_sock_sock::_Kfn((struct Concurrency::IExecutionContext *)a3);
    LOBYTE(v25) = std::_tree_sock_sock::key_compare(v4, v3);
    if ( (_BYTE)v25 )
      v13 = std::_tree_sock_sock::_Left(_X)->_Left;
    else
      v13 = std::_tree_sock_sock::_Right(_X)->_Left;
    _X = v13;
  }
  if ( v14->_Multi )
  {
    v22 = 1;
    v5 = (_DWORD *)std::_tree_sock_sock::_Insert(
                     v14,
                     (int)&v21,
                     (int)_X,
                     (int)_Y,
                     (struct Concurrency::IExecutionContext *)a3);
    std::pair::pair_iterator_bool_2(a2, v5, &v22);
    return a2;
  }
  std::_tree_sock_sock::iterator::iterator((std::_tree_sock_sock::iterator *)&v26, _Y);
  if ( (_BYTE)v25 )
  {
    v7 = std::_tree_sock_sock::begin(v14, (int)&a2a);
    if ( (unsigned __int8)std::_tree_sock_sock::iterator::iterator_operator_eq(&v26, v7) )
    {
      v19 = 1;
      v8 = (_DWORD *)std::_tree_sock_sock::_Insert(
                       v14,
                       (int)&v18,
                       (int)_X,
                       (int)_Y,
                       (struct Concurrency::IExecutionContext *)a3);
      std::pair::pair_iterator_bool_2(a2, v8, &v19);
      return a2;
    }
    unknown_libname_92((int *)&v26);
  }
  v9 = std::_tree_sock_sock::_Kfn((struct Concurrency::IExecutionContext *)a3);
  v10 = unknown_libname_90(&v26);
  v11 = std::_tree_sock_sock::_Key(v10);
  if ( (unsigned __int8)std::_tree_sock_sock::key_compare(v11, v9) )
  {
    v17 = 1;
    v12 = (_DWORD *)std::_tree_sock_sock::_Insert(
                      v14,
                      (int)&v16,
                      (int)_X,
                      (int)_Y,
                      (struct Concurrency::IExecutionContext *)a3);
    std::pair::pair_iterator_bool_2(a2, v12, &v17);
    result = a2;
  }
  else
  {
    v15 = 0;
    std::pair::pair_iterator_bool_2(a2, &v26, &v15);
    result = a2;
  }
  return result;
}
// 41C6D0: using guessed type int __thiscall unknown_libname_90(_DWORD);

//----- (0041AA80) --------------------------------------------------------
_DWORD *__thiscall std::_tree_sock_sock::erase(std::_tree_sock_sock *this, _DWORD *a2, std::_tree_sock_sock::iterator *a3, char a4)
{
  std::_tree_sock_sock::iterator *v4; // eax@2
  std::_tree_sock_sock::iterator *v5; // eax@3
  int *v6; // eax@5
  _DWORD *result; // eax@6
  std::_tree_sock_sock::_Node *v8; // eax@7
  std::_tree_sock_sock *v9; // [sp+0h] [bp-14h]@1
  int v10; // [sp+4h] [bp-10h]@5
  char v11; // [sp+8h] [bp-Ch]@5
  int a2a; // [sp+Ch] [bp-8h]@3
  int v13; // [sp+10h] [bp-4h]@2

  v9 = this;
  if ( !std::_tree_sock_sock::size((int)this)
    || (v4 = std::_tree_sock_sock::begin(v9, (int)&v13),
        (unsigned __int8)std::_tree_sock_sock::iterator::iterator_operator_not_eq(
                           (std::_tree_sock_sock::iterator *)&a3,
                           v4))
    || (v5 = std::_tree_sock_sock::end(v9, (std::_tree_sock_sock::iterator *)&a2a),
        (unsigned __int8)std::_tree_sock_sock::iterator::iterator_operator_not_eq(
                           (std::_tree_sock_sock::iterator *)&a4,
                           v5)) )
  {
    while ( (unsigned __int8)std::_tree_sock_sock::iterator::iterator_operator_not_eq(
                               (std::_tree_sock_sock::iterator *)&a3,
                               (std::_tree_sock_sock::iterator *)&a4) )
    {
      v6 = std::_tree_sock_sock::iterator::post_increment(&a3, &v11, 0);
      std::_tree_sock_sock::erase2(v9, &v10, *v6);
    }
    *a2 = a3;
    result = a2;
  }
  else
  {
    v8 = std::_tree_sock_sock::_Root_const(v9);
    sub_41C160((std::_tree *)v9, v8->_Left);
    std::_tree_sock_sock::_Root_const(v9)->_Left = std::_tree_sock_sock::_Nil;
    v9->_Size = 0;
    std::_tree_sock_sock::_Lmost(v9)->_Left = v9->_Head;
    std::_tree_sock_sock::_Rmost(v9)->_Left = v9->_Head;
    std::_tree_sock_sock::begin(v9, (int)a2);
    result = a2;
  }
  return result;
}

//----- (0041AB80) --------------------------------------------------------
int __thiscall std::_tree_sock_sock::erase3(std::_tree_sock_sock *this, _DWORD *a2)
{
  std::_tree_sock_sock *v2; // ST0C_4@1
  int a2a; // [sp+4h] [bp-10h]@1
  int v5; // [sp+8h] [bp-Ch]@1
  std::_tree_sock_sock::iterator *a3; // [sp+Ch] [bp-8h]@1
  char a4[4]; // [sp+10h] [bp-4h]@1

  v2 = this;
  std::_tree_sock_sock::equal_range(this, (int)&a3, a2);
  v5 = 0;
  std::_tree_sock_sock::_Distance((char)a3, a4[0], &v5);
  std::_tree_sock_sock::erase(v2, &a2a, a3, a4[0]);
  return v5;
}

//----- (0041ABE0) --------------------------------------------------------
_DWORD *__thiscall std::_tree_sock_sock::find(std::_tree_sock_sock *this, _DWORD *a2, _DWORD *a3)
{
  std::_tree_sock_sock::iterator *v3; // eax@1
  int v4; // eax@2
  struct Concurrency::details::InternalContextBase *v5; // eax@2
  std::_tree_sock_sock::iterator *v7; // [sp+0h] [bp-18h]@3
  std::_tree_sock_sock *v8; // [sp+4h] [bp-14h]@1
  int v9; // [sp+8h] [bp-10h]@4
  int a2a; // [sp+Ch] [bp-Ch]@1
  std::_tree_sock_sock::iterator *v11; // [sp+10h] [bp-8h]@5
  char v12; // [sp+14h] [bp-4h]@1

  v8 = this;
  std::_tree_sock_sock::lower_bound(this, (int)&v12, a3);
  v3 = std::_tree_sock_sock::end(v8, (std::_tree_sock_sock::iterator *)&a2a);
  if ( (unsigned __int8)std::_tree_sock_sock::iterator::iterator_operator_eq(&v12, v3)
    || (v4 = unknown_libname_90(&v12),
        v5 = std::_tree_sock_sock::_Key(v4),
        (unsigned __int8)std::_tree_sock_sock::key_compare(a3, v5)) )
  {
    v7 = std::_tree_sock_sock::end(v8, (std::_tree_sock_sock::iterator *)&v9);
  }
  else
  {
    v7 = (std::_tree_sock_sock::iterator *)&v12;
  }
  v11 = v7;
  *a2 = v7->_Ptr;
  return a2;
}
// 41C6D0: using guessed type int __thiscall unknown_libname_90(_DWORD);

//----- (0041ACA0) --------------------------------------------------------
void **__thiscall std::_tree_sock_sock::iterator::_Mynode(std::_tree_sock_sock::iterator *this)
{
  return std::_tree_sock_sock::_Node::_Value2(this->_Ptr);
}

//----- (0041ACC0) --------------------------------------------------------
BOOL __thiscall std::_tree_sock_sock::iterator::iterator_operator_eq(void *this, _DWORD *a2)
{
  return *(_DWORD *)this == *a2;
}

//----- (0041ACE0) --------------------------------------------------------
int __thiscall sub_41ACE0(int this, _DWORD *a2, _BYTE *a3)
{
  *(_DWORD *)this = *a2;
  *(_BYTE *)(this + 4) = *a3;
  return this;
}

//----- (0041AD10) --------------------------------------------------------
int __thiscall std::pair::pair_iterator_bool_2(int this, _DWORD *a2, _BYTE *a3)
{
  *(_DWORD *)this = *a2;
  *(_BYTE *)(this + 4) = *a3;
  return this;
}

//----- (0041AD40) --------------------------------------------------------
OverlappedSlot *__thiscall OverlappedSlot::OverlappedSlot(OverlappedSlot *this)
{
  OverlappedSlot *this_; // ST08_4@1

  this_ = this;
  this->m_overlapped = 0;
  SpinLock::SpinLock(&this->m_lock, LockType_WaitLock, 0);
  return this_;
}

//----- (0041AD70) --------------------------------------------------------
int __thiscall LSOverlappedPool::Destructor(void *this)
{
  return LSOverlapped::FreeAll();
}

//----- (0041AD90) --------------------------------------------------------
BOOL __stdcall sub_41AD90(_DWORD *a1, _DWORD *a2)
{
  return *a1 < *a2;
}

//----- (0041ADD0) --------------------------------------------------------
int __cdecl sub_41ADD0(int a1)
{
  return a1 + 20;
}

//----- (0041ADE0) --------------------------------------------------------
struct Concurrency::details::InternalContextBase *__cdecl sub_41ADE0(int a1)
{
  int v1; // ecx@0
  void **v2; // eax@1
  int v4; // [sp+0h] [bp-4h]@1

  v4 = v1;
  v2 = sub_41AE30((std::_tree_ip_sock::_Node *)a1);
  return Concurrency::details::VirtualProcessor::ToInternalContext(
           (Concurrency::details::VirtualProcessor *)&v4,
           (struct Concurrency::IExecutionContext *)v2);
}

//----- (0041AE10) --------------------------------------------------------
int __cdecl sub_41AE10(int a1)
{
  return a1 + 4;
}

//----- (0041AE20) --------------------------------------------------------
int __cdecl sub_41AE20(int a1)
{
  return a1 + 8;
}

//----- (0041AE30) --------------------------------------------------------
void **__cdecl sub_41AE30(std::_tree_ip_sock::_Node *a1)
{
  return &a1->_Value;
}

//----- (0041AE40) --------------------------------------------------------
std::_tree_ip_sock *__thiscall std::_tree_ip_sock::_tree_ip_sock(std::_tree_ip_sock *this, _BYTE *a2, char a3, _BYTE *a4)
{
  std::_tree_ip_sock *v4; // ST00_4@1

  v4 = this;
  this->allocator = *a4;
  this->keyComparer = *a2;
  this->_Multi = a3;
  std::_tree_ip_sock::_Init(this);
  return v4;
}

//----- (0041AE80) --------------------------------------------------------
int __thiscall sub_41AE80(void *this, int a2, _DWORD *a3)
{
  int v3; // eax@1

  v3 = sub_41C850(this, a3);
  unknown_libname_85((void *)a2, v3);
  return a2;
}

//----- (0041AEB0) --------------------------------------------------------
void *__thiscall sub_41AEB0(std::_tree *this, void *a2)
{
  void *result; // eax@1
  void **v3; // eax@3
  void **v4; // eax@3
  std::_tree *v5; // [sp+0h] [bp-8h]@1
  void *i; // [sp+4h] [bp-4h]@1

  v5 = this;
  result = a2;
  for ( i = a2; i != (void *)dword_47EFDC; a2 = i )
  {
    v3 = (void **)sub_41AE20((int)i);
    sub_41AEB0(v5, *v3);
    i = *(void **)unknown_libname_83(i);
    v4 = sub_41AE30((std::_tree_ip_sock::_Node *)a2);
    sub_41B700((int)v4);
    Concurrency::details::_NonReentrantPPLLock::_Acquire(v5, a2);
  }
  return result;
}
// 41AE00: using guessed type _DWORD __cdecl unknown_libname_83(_DWORD);
// 47EFDC: using guessed type int dword_47EFDC;

//----- (0041AF30) --------------------------------------------------------
int __thiscall sub_41AF30(void *this, int a2, int a3, int a4, struct Concurrency::IExecutionContext *a5)
{
  void **v5; // eax@1
  struct Concurrency::details::InternalContextBase *v6; // ST04_4@3
  struct Concurrency::details::InternalContextBase *v7; // eax@3
  char **v8; // eax@4
  char **v9; // eax@5
  char **v10; // eax@5
  char **v11; // eax@7
  char **v12; // eax@9
  char **v13; // eax@10
  int *v14; // eax@13
  _DWORD *v15; // esi@14
  int *v16; // eax@14
  _DWORD *v17; // eax@14
  int *v18; // eax@15
  int *v19; // eax@15
  int *v20; // eax@15
  int *v21; // eax@16
  int *v22; // eax@16
  int *v23; // eax@16
  int *v24; // eax@16
  int *v25; // eax@17
  int *v26; // eax@19
  int *v27; // eax@19
  int *v28; // eax@19
  int *v29; // eax@19
  int *v30; // eax@19
  int *v31; // eax@21
  _DWORD *v32; // eax@21
  int *v33; // eax@21
  int *v34; // eax@22
  int *v35; // eax@22
  int *v36; // eax@22
  int *v37; // eax@22
  _DWORD *v38; // eax@23
  int *v39; // eax@25
  int *v40; // eax@25
  int *v41; // eax@25
  int *v42; // eax@25
  int *v43; // eax@25
  int *v44; // eax@27
  _DWORD *v46; // [sp+4h] [bp-Ch]@1
  char v47; // [sp+8h] [bp-8h]@3
  char *v48; // [sp+Ch] [bp-4h]@1
  char *v49; // [sp+1Ch] [bp+Ch]@11
  int v50; // [sp+20h] [bp+10h]@15
  int v51; // [sp+20h] [bp+10h]@21

  v46 = this;
  v48 = sub_41C8E0(a4, 0);
  *(_DWORD *)unknown_libname_83(v48) = dword_47EFDC;
  *(_DWORD *)sub_41AE20((int)v48) = dword_47EFDC;
  v5 = sub_41AE30((std::_tree_ip_sock::_Node *)v48);
  sub_41C930(v5, (int)a5);
  ++v46[3];
  if ( a4 == v46[1]
    || a3 != dword_47EFDC
    || (v6 = sub_41ADE0(a4),
        v7 = Concurrency::details::VirtualProcessor::ToInternalContext(
               (Concurrency::details::VirtualProcessor *)&v47,
               a5),
        (unsigned __int8)sub_41AD90(v7, v6)) )
  {
    v8 = (char **)unknown_libname_83(a4);
    *v8 = v48;
    if ( a4 == v46[1] )
    {
      v9 = (char **)sub_41B5B0((int)v46);
      *v9 = v48;
      v10 = (char **)sub_41B590((int)v46);
      *v10 = v48;
    }
    else if ( a4 == *(_DWORD *)sub_41B3C0((int)v46) )
    {
      v11 = (char **)sub_41B3C0((int)v46);
      *v11 = v48;
    }
  }
  else
  {
    v12 = (char **)sub_41AE20(a4);
    *v12 = v48;
    if ( a4 == *(_DWORD *)sub_41B590((int)v46) )
    {
      v13 = (char **)sub_41B590((int)v46);
      *v13 = v48;
    }
  }
  v49 = v48;
  while ( v49 != *(char **)sub_41B5B0((int)v46) )
  {
    v14 = (int *)sub_41AE10((int)v49);
    if ( *(_DWORD *)sub_41ADD0(*v14) )
      break;
    v15 = (_DWORD *)sub_41AE10((int)v49);
    v16 = (int *)sub_41AE10((int)v49);
    v17 = (_DWORD *)sub_41AE10(*v16);
    if ( *v15 == *(_DWORD *)unknown_libname_83(*v17) )
    {
      v18 = (int *)sub_41AE10((int)v49);
      v19 = (int *)sub_41AE10(*v18);
      v20 = (int *)sub_41AE20(*v19);
      v50 = *v20;
      if ( *(_DWORD *)sub_41ADD0(*v20) )
      {
        v25 = (int *)sub_41AE10((int)v49);
        if ( v49 == *(char **)sub_41AE20(*v25) )
        {
          v49 = *(char **)sub_41AE10((int)v49);
          sub_41B3E0(v46, (int)v49);
        }
        v26 = (int *)sub_41AE10((int)v49);
        *(_DWORD *)sub_41ADD0(*v26) = 1;
        v27 = (int *)sub_41AE10((int)v49);
        v28 = (int *)sub_41AE10(*v27);
        *(_DWORD *)sub_41ADD0(*v28) = 0;
        v29 = (int *)sub_41AE10((int)v49);
        v30 = (int *)sub_41AE10(*v29);
        sub_41B5D0(v46, *v30);
      }
      else
      {
        v21 = (int *)sub_41AE10((int)v49);
        *(_DWORD *)sub_41ADD0(*v21) = 1;
        *(_DWORD *)sub_41ADD0(v50) = 1;
        v22 = (int *)sub_41AE10((int)v49);
        v23 = (int *)sub_41AE10(*v22);
        *(_DWORD *)sub_41ADD0(*v23) = 0;
        v24 = (int *)sub_41AE10((int)v49);
        v49 = *(char **)sub_41AE10(*v24);
      }
    }
    else
    {
      v31 = (int *)sub_41AE10((int)v49);
      v32 = (_DWORD *)sub_41AE10(*v31);
      v33 = (int *)unknown_libname_83(*v32);
      v51 = *v33;
      if ( *(_DWORD *)sub_41ADD0(*v33) )
      {
        v38 = (_DWORD *)sub_41AE10((int)v49);
        if ( v49 == *(char **)unknown_libname_83(*v38) )
        {
          v49 = *(char **)sub_41AE10((int)v49);
          sub_41B5D0(v46, (int)v49);
        }
        v39 = (int *)sub_41AE10((int)v49);
        *(_DWORD *)sub_41ADD0(*v39) = 1;
        v40 = (int *)sub_41AE10((int)v49);
        v41 = (int *)sub_41AE10(*v40);
        *(_DWORD *)sub_41ADD0(*v41) = 0;
        v42 = (int *)sub_41AE10((int)v49);
        v43 = (int *)sub_41AE10(*v42);
        sub_41B3E0(v46, *v43);
      }
      else
      {
        v34 = (int *)sub_41AE10((int)v49);
        *(_DWORD *)sub_41ADD0(*v34) = 1;
        *(_DWORD *)sub_41ADD0(v51) = 1;
        v35 = (int *)sub_41AE10((int)v49);
        v36 = (int *)sub_41AE10(*v35);
        *(_DWORD *)sub_41ADD0(*v36) = 0;
        v37 = (int *)sub_41AE10((int)v49);
        v49 = *(char **)sub_41AE10(*v37);
      }
    }
  }
  v44 = (int *)sub_41B5B0((int)v46);
  *(_DWORD *)sub_41ADD0(*v44) = 1;
  unknown_libname_85((void *)a2, (int)v48);
  return a2;
}
// 41AE00: using guessed type _DWORD __cdecl unknown_libname_83(_DWORD);
// 47EFDC: using guessed type int dword_47EFDC;

//----- (0041B3C0) --------------------------------------------------------
int __thiscall sub_41B3C0(int this)
{
  return unknown_libname_83(*(_DWORD *)(this + 4));
}
// 41AE00: using guessed type _DWORD __cdecl unknown_libname_83(_DWORD);

//----- (0041B3E0) --------------------------------------------------------
int *__thiscall sub_41B3E0(void *this, int a2)
{
  _DWORD *v2; // esi@1
  int *v3; // eax@2
  _DWORD *v4; // esi@3
  _DWORD *v5; // eax@5
  _DWORD *v6; // eax@6
  int *v7; // eax@7
  int *result; // eax@8
  void *v9; // [sp+4h] [bp-8h]@1
  int v10; // [sp+8h] [bp-4h]@1

  v9 = this;
  v10 = *(_DWORD *)sub_41AE20(a2);
  v2 = (_DWORD *)unknown_libname_83(v10);
  *(_DWORD *)sub_41AE20(a2) = *v2;
  if ( *(_DWORD *)unknown_libname_83(v10) != dword_47EFDC )
  {
    v3 = (int *)unknown_libname_83(v10);
    *(_DWORD *)sub_41AE10(*v3) = a2;
  }
  v4 = (_DWORD *)sub_41AE10(a2);
  *(_DWORD *)sub_41AE10(v10) = *v4;
  if ( a2 == *(_DWORD *)sub_41B5B0((int)v9) )
  {
    *(_DWORD *)sub_41B5B0((int)v9) = v10;
  }
  else
  {
    v5 = (_DWORD *)sub_41AE10(a2);
    if ( a2 == *(_DWORD *)unknown_libname_83(*v5) )
    {
      v6 = (_DWORD *)sub_41AE10(a2);
      *(_DWORD *)unknown_libname_83(*v6) = v10;
    }
    else
    {
      v7 = (int *)sub_41AE10(a2);
      *(_DWORD *)sub_41AE20(*v7) = v10;
    }
  }
  *(_DWORD *)unknown_libname_83(v10) = a2;
  result = (int *)sub_41AE10(a2);
  *result = v10;
  return result;
}
// 41AE00: using guessed type _DWORD __cdecl unknown_libname_83(_DWORD);
// 47EFDC: using guessed type int dword_47EFDC;

//----- (0041B510) --------------------------------------------------------
int __cdecl sub_41B510(int a1)
{
  while ( *(_DWORD *)sub_41AE20(a1) != dword_47EFDC )
    a1 = *(_DWORD *)sub_41AE20(a1);
  return a1;
}
// 47EFDC: using guessed type int dword_47EFDC;

//----- (0041B550) --------------------------------------------------------
int __cdecl sub_41B550(int a1)
{
  while ( *(_DWORD *)unknown_libname_83(a1) != dword_47EFDC )
    a1 = *(_DWORD *)unknown_libname_83(a1);
  return a1;
}
// 41AE00: using guessed type _DWORD __cdecl unknown_libname_83(_DWORD);
// 47EFDC: using guessed type int dword_47EFDC;

//----- (0041B590) --------------------------------------------------------
int __thiscall sub_41B590(int this)
{
  return sub_41AE20(*(_DWORD *)(this + 4));
}

//----- (0041B5B0) --------------------------------------------------------
int __thiscall sub_41B5B0(int this)
{
  return sub_41AE10(*(_DWORD *)(this + 4));
}

//----- (0041B5D0) --------------------------------------------------------
int *__thiscall sub_41B5D0(void *this, int a2)
{
  _DWORD *v2; // esi@1
  int *v3; // eax@2
  _DWORD *v4; // esi@3
  int *v5; // eax@5
  int *v6; // eax@6
  _DWORD *v7; // eax@7
  int *result; // eax@8
  void *v9; // [sp+4h] [bp-8h]@1
  int v10; // [sp+8h] [bp-4h]@1

  v9 = this;
  v10 = *(_DWORD *)unknown_libname_83(a2);
  v2 = (_DWORD *)sub_41AE20(v10);
  *(_DWORD *)unknown_libname_83(a2) = *v2;
  if ( *(_DWORD *)sub_41AE20(v10) != dword_47EFDC )
  {
    v3 = (int *)sub_41AE20(v10);
    *(_DWORD *)sub_41AE10(*v3) = a2;
  }
  v4 = (_DWORD *)sub_41AE10(a2);
  *(_DWORD *)sub_41AE10(v10) = *v4;
  if ( a2 == *(_DWORD *)sub_41B5B0((int)v9) )
  {
    *(_DWORD *)sub_41B5B0((int)v9) = v10;
  }
  else
  {
    v5 = (int *)sub_41AE10(a2);
    if ( a2 == *(_DWORD *)sub_41AE20(*v5) )
    {
      v6 = (int *)sub_41AE10(a2);
      *(_DWORD *)sub_41AE20(*v6) = v10;
    }
    else
    {
      v7 = (_DWORD *)sub_41AE10(a2);
      *(_DWORD *)unknown_libname_83(*v7) = v10;
    }
  }
  *(_DWORD *)sub_41AE20(v10) = a2;
  result = (int *)sub_41AE10(a2);
  *result = v10;
  return result;
}
// 41AE00: using guessed type _DWORD __cdecl unknown_libname_83(_DWORD);
// 47EFDC: using guessed type int dword_47EFDC;

//----- (0041B700) --------------------------------------------------------
void __stdcall sub_41B700(int a1)
{
  sub_41D3A0();
}

//----- (0041B750) --------------------------------------------------------
_DWORD *__thiscall sub_41B750(void *this, _DWORD *a2, int a3)
{
  int v3; // ST04_4@1

  v3 = *(_DWORD *)this;
  unknown_libname_94(this);
  *a2 = v3;
  return a2;
}
// 41CA40: using guessed type int __cdecl unknown_libname_94(_DWORD);

//----- (0041B7B0) --------------------------------------------------------
BOOL __stdcall std::_tree_sock_sock::key_compare(_DWORD *a1, _DWORD *a2)
{
  return *a1 < *a2;
}

//----- (0041B7F0) --------------------------------------------------------
struct Concurrency::details::InternalContextBase *__cdecl std::_tree_sock_sock::_Key(int a1)
{
  void **v1; // eax@1

  v1 = std::_tree_sock_sock::_Node::_Value2((std::_tree_sock_sock::_Node *)a1);
  return std::_tree_sock_sock::_Kfn((struct Concurrency::IExecutionContext *)v1);
}

//----- (0041B820) --------------------------------------------------------
std::_tree_sock_sock::_Node *__cdecl std::_tree_sock_sock::_Right(std::_tree_sock_sock::_Node *a1)
{
  return (std::_tree_sock_sock::_Node *)((char *)a1 + 8);
}

//----- (0041B830) --------------------------------------------------------
void **__cdecl std::_tree_sock_sock::_Node::_Value2(std::_tree_sock_sock::_Node *a1)
{
  return &a1->_Value;
}

//----- (0041B840) --------------------------------------------------------
std::_tree_sock_sock *__thiscall std::_tree_sock_sock::_tree_sock_sock(std::_tree_sock_sock *this, _BYTE *a2, char a3, _BYTE *a4)
{
  std::_tree_sock_sock *v4; // ST00_4@1

  v4 = this;
  this->allocator = *a4;
  this->keyComparer = *a2;
  this->_Multi = a3;
  std::_tree_sock_sock::_Init(this);
  return v4;
}

//----- (0041B8A0) --------------------------------------------------------
_DWORD *__thiscall std::_tree_sock_sock::erase2(std::_tree_sock_sock *this, _DWORD *a2, int a3)
{
  _DWORD *v3; // eax@1
  int *v4; // eax@5
  int *v5; // eax@7
  std::_tree_sock_sock::_Node **v6; // eax@7
  std::_tree_sock_sock::_Node *v7; // esi@7
  std::_tree_sock_sock::_Node *v8; // eax@7
  std::_tree_sock_sock::_Node **v9; // eax@8
  _DWORD *v10; // esi@9
  std::_tree_sock_sock::_Node **v11; // eax@9
  std::_tree_sock_sock::_Node *v12; // eax@9
  std::_tree_sock_sock::_Node *v13; // esi@9
  int *v14; // eax@9
  std::_tree_sock_sock::_Node **v15; // eax@9
  std::_tree_sock_sock::_Node *v16; // eax@10
  std::_tree_sock_sock::_Node *v17; // eax@11
  std::_tree_sock_sock::_Node **v18; // eax@12
  std::_tree_sock_sock::_Node *v19; // eax@12
  std::_tree_sock_sock::_Node **v20; // eax@13
  std::_tree_sock_sock::_Node *v21; // eax@13
  std::_tree_sock_sock::_Node **v22; // eax@14
  std::_tree_sock_sock::_Node *v23; // eax@14
  _DWORD *v24; // esi@15
  int *v25; // ST04_4@15
  int *v26; // eax@15
  _DWORD *v27; // esi@16
  std::_tree_sock_sock::_Node *v28; // eax@16
  std::_tree_sock_sock::_Node *v29; // eax@17
  std::_tree_sock_sock::_Node **v30; // eax@18
  std::_tree_sock_sock::_Node *v31; // eax@18
  std::_tree_sock_sock::_Node **v32; // eax@19
  std::_tree_sock_sock::_Node *v33; // eax@19
  std::_tree_sock_sock::_Node **v34; // eax@20
  std::_tree_sock_sock::_Node *v35; // eax@20
  std::_tree_sock_sock::_Node *v36; // eax@21
  std::_tree_sock_sock::_Node **v37; // esi@23
  std::_tree_sock_sock::_Node *v38; // esi@24
  std::_tree_sock_sock::_Node *v39; // eax@25
  std::_tree_sock_sock::_Node **v40; // esi@27
  std::_tree_sock_sock::_Node *v41; // esi@28
  std::_tree_sock_sock::_Node *v42; // eax@30
  std::_tree_sock_sock::_Node **v43; // eax@32
  std::_tree_sock_sock::_Node *v44; // eax@32
  std::_tree_sock_sock::_Node **v45; // eax@33
  int *v46; // eax@34
  int *v47; // eax@34
  std::_tree_sock_sock::_Node **v48; // eax@34
  int *v49; // eax@35
  int *v50; // eax@36
  int *v51; // eax@38
  int *v52; // eax@39
  std::_tree_sock_sock::_Node **v53; // eax@39
  int *v54; // eax@40
  _DWORD *v55; // esi@40
  int *v56; // eax@40
  int *v57; // eax@40
  int *v58; // eax@40
  std::_tree_sock_sock::_Node **v59; // eax@41
  int *v60; // eax@42
  int *v61; // eax@42
  std::_tree_sock_sock::_Node **v62; // eax@42
  int *v63; // eax@43
  int *v64; // eax@44
  int *v65; // eax@46
  int *v66; // eax@47
  std::_tree_sock_sock::_Node **v67; // eax@47
  int *v68; // eax@48
  _DWORD *v69; // esi@48
  int *v70; // eax@48
  int *v71; // eax@48
  int *v72; // eax@48
  void **v73; // eax@51
  std::_tree_sock_sock *v75; // [sp+4h] [bp-2Ch]@1
  char v76; // [sp+8h] [bp-28h]@1
  std::_tree_sock_sock::_Node *v77; // [sp+Ch] [bp-24h]@41
  std::_tree_sock_sock::_Node *v78; // [sp+10h] [bp-20h]@33
  char v79; // [sp+14h] [bp-1Ch]@6
  std::_tree_sock_sock::_Node *v80; // [sp+18h] [bp-18h]@1
  std::_tree_sock_sock::_Node *a1; // [sp+1Ch] [bp-14h]@1
  std::_tree_sock_sock::_Node *v82; // [sp+20h] [bp-10h]@2
  int v83; // [sp+2Ch] [bp-4h]@6

  v75 = this;
  v3 = std::_tree_sock_sock::iterator::post_increment(&a3, &v76, 0);
  a1 = (std::_tree_sock_sock::_Node *)unknown_libname_90(v3);
  v80 = a1;
  if ( std::_tree_sock_sock::_Left(a1)->_Left == std::_tree_sock_sock::_Nil )
  {
    v82 = std::_tree_sock_sock::_Right(a1)->_Left;
  }
  else if ( std::_tree_sock_sock::_Right(a1)->_Left == std::_tree_sock_sock::_Nil )
  {
    v82 = std::_tree_sock_sock::_Left(a1)->_Left;
  }
  else
  {
    v4 = (int *)std::_tree_sock_sock::_Right(a1);
    a1 = (std::_tree_sock_sock::_Node *)sub_41CDB0(*v4);
    v82 = std::_tree_sock_sock::_Right(a1)->_Left;
  }
  std::_Lockit::_Lockit((std::_Lockit *)&v79);
  v83 = 0;
  if ( a1 == v80 )
  {
    v27 = (_DWORD *)sub_41CA70((int)a1);
    *(_DWORD *)sub_41CA70((int)v82) = *v27;
    v28 = std::_tree_sock_sock::_Root_const(v75);
    if ( v28->_Left == v80 )
    {
      v29 = std::_tree_sock_sock::_Root_const(v75);
      v29->_Left = v82;
    }
    else
    {
      v30 = (std::_tree_sock_sock::_Node **)sub_41CA70((int)v80);
      v31 = std::_tree_sock_sock::_Left(*v30);
      if ( v31->_Left == v80 )
      {
        v32 = (std::_tree_sock_sock::_Node **)sub_41CA70((int)v80);
        v33 = std::_tree_sock_sock::_Left(*v32);
        v33->_Left = v82;
      }
      else
      {
        v34 = (std::_tree_sock_sock::_Node **)sub_41CA70((int)v80);
        v35 = std::_tree_sock_sock::_Right(*v34);
        v35->_Left = v82;
      }
    }
    v36 = std::_tree_sock_sock::_Lmost(v75);
    if ( v36->_Left == v80 )
    {
      if ( std::_tree_sock_sock::_Right(v80)->_Left == std::_tree_sock_sock::_Nil )
      {
        v37 = (std::_tree_sock_sock::_Node **)sub_41CA70((int)v80);
        std::_tree_sock_sock::_Lmost(v75)->_Left = *v37;
      }
      else
      {
        v38 = (std::_tree_sock_sock::_Node *)sub_41CDB0((int)v82);
        std::_tree_sock_sock::_Lmost(v75)->_Left = v38;
      }
    }
    v39 = std::_tree_sock_sock::_Rmost(v75);
    if ( v39->_Left == v80 )
    {
      if ( std::_tree_sock_sock::_Left(v80)->_Left == std::_tree_sock_sock::_Nil )
      {
        v40 = (std::_tree_sock_sock::_Node **)sub_41CA70((int)v80);
        std::_tree_sock_sock::_Rmost(v75)->_Left = *v40;
      }
      else
      {
        v41 = (std::_tree_sock_sock::_Node *)sub_41CD70((int)v82);
        std::_tree_sock_sock::_Rmost(v75)->_Left = v41;
      }
    }
  }
  else
  {
    v5 = (int *)std::_tree_sock_sock::_Left(v80);
    v6 = (std::_tree_sock_sock::_Node **)sub_41CA70(*v5);
    *v6 = a1;
    v7 = std::_tree_sock_sock::_Left(v80);
    std::_tree_sock_sock::_Left(a1)->_Left = v7->_Left;
    v8 = std::_tree_sock_sock::_Right(v80);
    if ( a1 == v8->_Left )
    {
      v9 = (std::_tree_sock_sock::_Node **)sub_41CA70((int)v82);
      *v9 = a1;
    }
    else
    {
      v10 = (_DWORD *)sub_41CA70((int)a1);
      *(_DWORD *)sub_41CA70((int)v82) = *v10;
      v11 = (std::_tree_sock_sock::_Node **)sub_41CA70((int)a1);
      v12 = std::_tree_sock_sock::_Left(*v11);
      v12->_Left = v82;
      v13 = std::_tree_sock_sock::_Right(v80);
      std::_tree_sock_sock::_Right(a1)->_Left = v13->_Left;
      v14 = (int *)std::_tree_sock_sock::_Right(v80);
      v15 = (std::_tree_sock_sock::_Node **)sub_41CA70(*v14);
      *v15 = a1;
    }
    v16 = std::_tree_sock_sock::_Root_const(v75);
    if ( v16->_Left == v80 )
    {
      v17 = std::_tree_sock_sock::_Root_const(v75);
      v17->_Left = a1;
    }
    else
    {
      v18 = (std::_tree_sock_sock::_Node **)sub_41CA70((int)v80);
      v19 = std::_tree_sock_sock::_Left(*v18);
      if ( v19->_Left == v80 )
      {
        v20 = (std::_tree_sock_sock::_Node **)sub_41CA70((int)v80);
        v21 = std::_tree_sock_sock::_Left(*v20);
        v21->_Left = a1;
      }
      else
      {
        v22 = (std::_tree_sock_sock::_Node **)sub_41CA70((int)v80);
        v23 = std::_tree_sock_sock::_Right(*v22);
        v23->_Left = a1;
      }
    }
    v24 = (_DWORD *)sub_41CA70((int)v80);
    *(_DWORD *)sub_41CA70((int)a1) = *v24;
    v25 = (int *)sub_41CA60((int)v80);
    v26 = (int *)sub_41CA60((int)a1);
    sub_41D3B0(v26, v25);
    a1 = v80;
  }
  if ( *(_DWORD *)sub_41CA60((int)a1) == 1 )
  {
    while ( 1 )
    {
      v42 = std::_tree_sock_sock::_Root_const(v75);
      if ( v82 == v42->_Left || *(_DWORD *)sub_41CA60((int)v82) != 1 )
        break;
      v43 = (std::_tree_sock_sock::_Node **)sub_41CA70((int)v82);
      v44 = std::_tree_sock_sock::_Left(*v43);
      if ( v82 == v44->_Left )
      {
        v45 = (std::_tree_sock_sock::_Node **)sub_41CA70((int)v82);
        v78 = std::_tree_sock_sock::_Right(*v45)->_Left;
        if ( !*(_DWORD *)sub_41CA60((int)v78) )
        {
          *(_DWORD *)sub_41CA60((int)v78) = 1;
          v46 = (int *)sub_41CA70((int)v82);
          *(_DWORD *)sub_41CA60(*v46) = 0;
          v47 = (int *)sub_41CA70((int)v82);
          sub_41CC40(v75, *v47);
          v48 = (std::_tree_sock_sock::_Node **)sub_41CA70((int)v82);
          v78 = std::_tree_sock_sock::_Right(*v48)->_Left;
        }
        v49 = (int *)std::_tree_sock_sock::_Left(v78);
        if ( *(_DWORD *)sub_41CA60(*v49) != 1
          || (v50 = (int *)std::_tree_sock_sock::_Right(v78), *(_DWORD *)sub_41CA60(*v50) != 1) )
        {
          v51 = (int *)std::_tree_sock_sock::_Right(v78);
          if ( *(_DWORD *)sub_41CA60(*v51) == 1 )
          {
            v52 = (int *)std::_tree_sock_sock::_Left(v78);
            *(_DWORD *)sub_41CA60(*v52) = 1;
            *(_DWORD *)sub_41CA60((int)v78) = 0;
            sub_41CDF0(v75, (int)v78);
            v53 = (std::_tree_sock_sock::_Node **)sub_41CA70((int)v82);
            v78 = std::_tree_sock_sock::_Right(*v53)->_Left;
          }
          v54 = (int *)sub_41CA70((int)v82);
          v55 = (_DWORD *)sub_41CA60(*v54);
          *(_DWORD *)sub_41CA60((int)v78) = *v55;
          v56 = (int *)sub_41CA70((int)v82);
          *(_DWORD *)sub_41CA60(*v56) = 1;
          v57 = (int *)std::_tree_sock_sock::_Right(v78);
          *(_DWORD *)sub_41CA60(*v57) = 1;
          v58 = (int *)sub_41CA70((int)v82);
          sub_41CC40(v75, *v58);
          break;
        }
        *(_DWORD *)sub_41CA60((int)v78) = 0;
        v82 = *(std::_tree_sock_sock::_Node **)sub_41CA70((int)v82);
      }
      else
      {
        v59 = (std::_tree_sock_sock::_Node **)sub_41CA70((int)v82);
        v77 = std::_tree_sock_sock::_Left(*v59)->_Left;
        if ( !*(_DWORD *)sub_41CA60((int)v77) )
        {
          *(_DWORD *)sub_41CA60((int)v77) = 1;
          v60 = (int *)sub_41CA70((int)v82);
          *(_DWORD *)sub_41CA60(*v60) = 0;
          v61 = (int *)sub_41CA70((int)v82);
          sub_41CDF0(v75, *v61);
          v62 = (std::_tree_sock_sock::_Node **)sub_41CA70((int)v82);
          v77 = std::_tree_sock_sock::_Left(*v62)->_Left;
        }
        v63 = (int *)std::_tree_sock_sock::_Right(v77);
        if ( *(_DWORD *)sub_41CA60(*v63) != 1
          || (v64 = (int *)std::_tree_sock_sock::_Left(v77), *(_DWORD *)sub_41CA60(*v64) != 1) )
        {
          v65 = (int *)std::_tree_sock_sock::_Left(v77);
          if ( *(_DWORD *)sub_41CA60(*v65) == 1 )
          {
            v66 = (int *)std::_tree_sock_sock::_Right(v77);
            *(_DWORD *)sub_41CA60(*v66) = 1;
            *(_DWORD *)sub_41CA60((int)v77) = 0;
            sub_41CC40(v75, (int)v77);
            v67 = (std::_tree_sock_sock::_Node **)sub_41CA70((int)v82);
            v77 = std::_tree_sock_sock::_Left(*v67)->_Left;
          }
          v68 = (int *)sub_41CA70((int)v82);
          v69 = (_DWORD *)sub_41CA60(*v68);
          *(_DWORD *)sub_41CA60((int)v77) = *v69;
          v70 = (int *)sub_41CA70((int)v82);
          *(_DWORD *)sub_41CA60(*v70) = 1;
          v71 = (int *)std::_tree_sock_sock::_Left(v77);
          *(_DWORD *)sub_41CA60(*v71) = 1;
          v72 = (int *)sub_41CA70((int)v82);
          sub_41CDF0(v75, *v72);
          break;
        }
        *(_DWORD *)sub_41CA60((int)v77) = 0;
        v82 = *(std::_tree_sock_sock::_Node **)sub_41CA70((int)v82);
      }
    }
    *(_DWORD *)sub_41CA60((int)v82) = 1;
  }
  v83 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v79);
  v73 = std::_tree_sock_sock::_Node::_Value2(a1);
  sub_41CF90((int)v73);
  std::_tree_sock_sock::_Freenode((std::_tree_sock_sock *)a1);
  --v75->_Size;
  *a2 = a3;
  return a2;
}
// 41C6D0: using guessed type int __thiscall unknown_libname_90(_DWORD);

//----- (0041C0F0) --------------------------------------------------------
int __thiscall std::_tree_sock_sock::lower_bound(void *this, int a2, _DWORD *a3)
{
  std::_tree_sock_sock::_Node *v3; // eax@1

  v3 = sub_41CBB0(this, a3);
  std::_tree_sock_sock::iterator::iterator((std::_tree_sock_sock::iterator *)a2, v3);
  return a2;
}

//----- (0041C120) --------------------------------------------------------
int __thiscall std::_tree_sock_sock::equal_range(std::_tree_sock_sock *this, int a2, _DWORD *a3)
{
  std::_tree_sock_sock *v3; // ST0C_4@1
  _DWORD *v4; // ST08_4@1
  _DWORD *v5; // eax@1
  char v7; // [sp+4h] [bp-8h]@1
  char v8; // [sp+8h] [bp-4h]@1

  v3 = this;
  v4 = (_DWORD *)std::_tree_sock_sock::upper_bound(this, (int)&v8, a3);
  v5 = (_DWORD *)std::_tree_sock_sock::lower_bound(v3, (int)&v7, a3);
  sub_41D0C0(a2, v5, v4);
  return a2;
}

//----- (0041C160) --------------------------------------------------------
void *__thiscall sub_41C160(std::_tree *this, void *a2)
{
  void *result; // eax@1
  std::_tree_sock_sock::_Node *v3; // eax@3
  void **v4; // eax@3
  std::_tree *v5; // [sp+0h] [bp-8h]@1
  std::_tree_sock_sock::_Node *a1; // [sp+4h] [bp-4h]@1

  v5 = this;
  result = a2;
  for ( a1 = (std::_tree_sock_sock::_Node *)a2; a1 != std::_tree_sock_sock::_Nil; a2 = a1 )
  {
    v3 = std::_tree_sock_sock::_Right(a1);
    sub_41C160(v5, v3->_Left);
    a1 = std::_tree_sock_sock::_Left(a1)->_Left;
    v4 = std::_tree_sock_sock::_Node::_Value2((std::_tree_sock_sock::_Node *)a2);
    sub_41CF90((int)v4);
    std::_tree_sock_sock::_Freenode((std::_tree_sock_sock *)a2);
  }
  return result;
}

//----- (0041C1E0) --------------------------------------------------------
int __thiscall std::_tree_sock_sock::_Insert(void *this, int a2, int a3, int a4, struct Concurrency::IExecutionContext *a5)
{
  void **v5; // eax@1
  struct Concurrency::details::InternalContextBase *v6; // ST04_4@3
  struct Concurrency::details::InternalContextBase *v7; // eax@3
  int *v8; // eax@13
  std::_tree_sock_sock::_Node **v9; // esi@14
  int *v10; // eax@14
  std::_tree_sock_sock::_Node **v11; // eax@14
  int *v12; // eax@15
  std::_tree_sock_sock::_Node **v13; // eax@15
  int *v14; // eax@15
  int *v15; // eax@16
  int *v16; // eax@16
  int *v17; // eax@16
  int *v18; // eax@16
  std::_tree_sock_sock::_Node **v19; // eax@17
  int *v20; // eax@19
  int *v21; // eax@19
  int *v22; // eax@19
  int *v23; // eax@19
  int *v24; // eax@19
  int *v25; // eax@21
  std::_tree_sock_sock::_Node **v26; // eax@21
  int *v27; // eax@21
  int *v28; // eax@22
  int *v29; // eax@22
  int *v30; // eax@22
  int *v31; // eax@22
  std::_tree_sock_sock::_Node **v32; // eax@23
  int *v33; // eax@25
  int *v34; // eax@25
  int *v35; // eax@25
  int *v36; // eax@25
  int *v37; // eax@25
  int *v38; // eax@27
  std::_tree_sock_sock *v40; // [sp+4h] [bp-Ch]@1
  std::_tree_sock_sock::_Node *a1; // [sp+Ch] [bp-4h]@1
  std::_tree_sock_sock::_Node *v42; // [sp+1Ch] [bp+Ch]@11
  std::_tree_sock_sock::_Node *v43; // [sp+20h] [bp+10h]@15
  std::_tree_sock_sock::_Node *v44; // [sp+20h] [bp+10h]@21

  v40 = (std::_tree_sock_sock *)this;
  a1 = std::_tree_sock_sock::_Buynode((std::_tree_sock_sock::_Node *)a4, 0);
  std::_tree_sock_sock::_Left(a1)->_Left = std::_tree_sock_sock::_Nil;
  std::_tree_sock_sock::_Right(a1)->_Left = std::_tree_sock_sock::_Nil;
  v5 = std::_tree_sock_sock::_Node::_Value2(a1);
  sub_41CF70(v5, (int)a5);
  ++v40->_Size;
  if ( (std::_tree_sock_sock::_Node *)a4 == v40->_Head
    || (std::_tree_sock_sock::_Node *)a3 != std::_tree_sock_sock::_Nil
    || (v6 = std::_tree_sock_sock::_Key(a4),
        v7 = std::_tree_sock_sock::_Kfn(a5),
        (unsigned __int8)std::_tree_sock_sock::key_compare(v7, v6)) )
  {
    std::_tree_sock_sock::_Left((std::_tree_sock_sock::_Node *)a4)->_Left = a1;
    if ( (std::_tree_sock_sock::_Node *)a4 == v40->_Head )
    {
      std::_tree_sock_sock::_Root_const(v40)->_Left = a1;
      std::_tree_sock_sock::_Rmost(v40)->_Left = a1;
    }
    else if ( (std::_tree_sock_sock::_Node *)a4 == std::_tree_sock_sock::_Lmost(v40)->_Left )
    {
      std::_tree_sock_sock::_Lmost(v40)->_Left = a1;
    }
  }
  else
  {
    std::_tree_sock_sock::_Right((std::_tree_sock_sock::_Node *)a4)->_Left = a1;
    if ( (std::_tree_sock_sock::_Node *)a4 == std::_tree_sock_sock::_Rmost(v40)->_Left )
      std::_tree_sock_sock::_Rmost(v40)->_Left = a1;
  }
  v42 = a1;
  while ( v42 != std::_tree_sock_sock::_Root_const(v40)->_Left )
  {
    v8 = (int *)sub_41CA70((int)v42);
    if ( *(_DWORD *)sub_41CA60(*v8) )
      break;
    v9 = (std::_tree_sock_sock::_Node **)sub_41CA70((int)v42);
    v10 = (int *)sub_41CA70((int)v42);
    v11 = (std::_tree_sock_sock::_Node **)sub_41CA70(*v10);
    if ( *v9 == std::_tree_sock_sock::_Left(*v11)->_Left )
    {
      v12 = (int *)sub_41CA70((int)v42);
      v13 = (std::_tree_sock_sock::_Node **)sub_41CA70(*v12);
      v14 = (int *)std::_tree_sock_sock::_Right(*v13);
      v43 = (std::_tree_sock_sock::_Node *)*v14;
      if ( *(_DWORD *)sub_41CA60(*v14) )
      {
        v19 = (std::_tree_sock_sock::_Node **)sub_41CA70((int)v42);
        if ( v42 == std::_tree_sock_sock::_Right(*v19)->_Left )
        {
          v42 = *(std::_tree_sock_sock::_Node **)sub_41CA70((int)v42);
          sub_41CC40(v40, (int)v42);
        }
        v20 = (int *)sub_41CA70((int)v42);
        *(_DWORD *)sub_41CA60(*v20) = 1;
        v21 = (int *)sub_41CA70((int)v42);
        v22 = (int *)sub_41CA70(*v21);
        *(_DWORD *)sub_41CA60(*v22) = 0;
        v23 = (int *)sub_41CA70((int)v42);
        v24 = (int *)sub_41CA70(*v23);
        sub_41CDF0(v40, *v24);
      }
      else
      {
        v15 = (int *)sub_41CA70((int)v42);
        *(_DWORD *)sub_41CA60(*v15) = 1;
        *(_DWORD *)sub_41CA60((int)v43) = 1;
        v16 = (int *)sub_41CA70((int)v42);
        v17 = (int *)sub_41CA70(*v16);
        *(_DWORD *)sub_41CA60(*v17) = 0;
        v18 = (int *)sub_41CA70((int)v42);
        v42 = *(std::_tree_sock_sock::_Node **)sub_41CA70(*v18);
      }
    }
    else
    {
      v25 = (int *)sub_41CA70((int)v42);
      v26 = (std::_tree_sock_sock::_Node **)sub_41CA70(*v25);
      v27 = (int *)std::_tree_sock_sock::_Left(*v26);
      v44 = (std::_tree_sock_sock::_Node *)*v27;
      if ( *(_DWORD *)sub_41CA60(*v27) )
      {
        v32 = (std::_tree_sock_sock::_Node **)sub_41CA70((int)v42);
        if ( v42 == std::_tree_sock_sock::_Left(*v32)->_Left )
        {
          v42 = *(std::_tree_sock_sock::_Node **)sub_41CA70((int)v42);
          sub_41CDF0(v40, (int)v42);
        }
        v33 = (int *)sub_41CA70((int)v42);
        *(_DWORD *)sub_41CA60(*v33) = 1;
        v34 = (int *)sub_41CA70((int)v42);
        v35 = (int *)sub_41CA70(*v34);
        *(_DWORD *)sub_41CA60(*v35) = 0;
        v36 = (int *)sub_41CA70((int)v42);
        v37 = (int *)sub_41CA70(*v36);
        sub_41CC40(v40, *v37);
      }
      else
      {
        v28 = (int *)sub_41CA70((int)v42);
        *(_DWORD *)sub_41CA60(*v28) = 1;
        *(_DWORD *)sub_41CA60((int)v44) = 1;
        v29 = (int *)sub_41CA70((int)v42);
        v30 = (int *)sub_41CA70(*v29);
        *(_DWORD *)sub_41CA60(*v30) = 0;
        v31 = (int *)sub_41CA70((int)v42);
        v42 = *(std::_tree_sock_sock::_Node **)sub_41CA70(*v31);
      }
    }
  }
  v38 = (int *)std::_tree_sock_sock::_Root_const(v40);
  *(_DWORD *)sub_41CA60(*v38) = 1;
  std::_tree_sock_sock::iterator::iterator((std::_tree_sock_sock::iterator *)a2, a1);
  return a2;
}

//----- (0041C670) --------------------------------------------------------
std::_tree_sock_sock::_Node *__thiscall std::_tree_sock_sock::_Lmost(std::_tree_sock_sock *this)
{
  return std::_tree_sock_sock::_Left(this->_Head);
}

//----- (0041C690) --------------------------------------------------------
std::_tree_sock_sock::_Node *__thiscall std::_tree_sock_sock::_Rmost(std::_tree_sock_sock *this)
{
  return std::_tree_sock_sock::_Right(this->_Head);
}

//----- (0041C6B0) --------------------------------------------------------
std::_tree_sock_sock::_Node *__thiscall std::_tree_sock_sock::_Root_const(std::_tree_sock_sock *this)
{
  return (std::_tree_sock_sock::_Node *)sub_41CA70((int)this->_Head);
}

//----- (0041C700) --------------------------------------------------------
_DWORD *__thiscall std::_tree_sock_sock::iterator::post_increment(void *this, _DWORD *a2, int a3)
{
  int v3; // ST04_4@1

  v3 = *(_DWORD *)this;
  unknown_libname_96(this);
  *a2 = v3;
  return a2;
}
// 41D0A0: using guessed type int __cdecl unknown_libname_96(_DWORD);

//----- (0041C750) --------------------------------------------------------
std::_tree_ip_sock::_Node *__thiscall std::_tree_ip_sock::_Init(std::_tree_ip_sock *this)
{
  std::_tree_ip_sock::_Node *result; // eax@5
  std::_tree_ip_sock *v2; // [sp+0h] [bp-18h]@1
  char v3; // [sp+4h] [bp-14h]@1
  void *v4; // [sp+8h] [bp-10h]@1
  int v5; // [sp+14h] [bp-4h]@1

  v2 = this;
  v4 = sub_41C8E0(0, 1);
  std::_Lockit::_Lockit((std::_Lockit *)&v3);
  v5 = 0;
  if ( !dword_47EFDC )
  {
    dword_47EFDC = (int)v4;
    v4 = 0;
    *(_DWORD *)unknown_libname_83(dword_47EFDC) = 0;
    *(_DWORD *)sub_41AE20(dword_47EFDC) = 0;
  }
  ++dword_47EFE0;
  v5 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v3);
  if ( v4 )
    Concurrency::details::_NonReentrantPPLLock::_Acquire((std::_tree *)v2, v4);
  v2->_Head = (std::_tree_ip_sock::_Node *)sub_41C8E0(dword_47EFDC, 0);
  v2->_Size = 0;
  *(_DWORD *)sub_41B3C0((int)v2) = v2->_Head;
  result = (std::_tree_ip_sock::_Node *)sub_41B590((int)v2);
  result->_Left = v2->_Head;
  return result;
}
// 41AE00: using guessed type _DWORD __cdecl unknown_libname_83(_DWORD);
// 47EFDC: using guessed type int dword_47EFDC;
// 47EFE0: using guessed type int dword_47EFE0;

//----- (0041C850) --------------------------------------------------------
int __thiscall sub_41C850(void *this, _DWORD *a2)
{
  _DWORD *v2; // ST08_4@1
  struct Concurrency::details::InternalContextBase *v3; // eax@3
  int v5; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v2 = this;
  v6 = *(_DWORD *)sub_41D110((int)this);
  v5 = v2[1];
  while ( v6 != dword_47EFDC )
  {
    v3 = sub_41ADE0(v6);
    if ( (unsigned __int8)sub_41AD90(v3, a2) )
    {
      v6 = *(_DWORD *)sub_41AE20(v6);
    }
    else
    {
      v5 = v6;
      v6 = *(_DWORD *)unknown_libname_83(v6);
    }
  }
  return v5;
}
// 41AE00: using guessed type _DWORD __cdecl unknown_libname_83(_DWORD);
// 47EFDC: using guessed type int dword_47EFDC;

//----- (0041C8E0) --------------------------------------------------------
char *__stdcall sub_41C8E0(int a1, int a2)
{
  char *result; // eax@1

  result = sub_41D0F0(0x18u);
  *(_DWORD *)sub_41AE10((int)result) = a1;
  *(_DWORD *)sub_41ADD0((int)result) = a2;
  return result;
}

//----- (0041C930) --------------------------------------------------------
_DWORD *__stdcall sub_41C930(void *a1, int a2)
{
  return sub_41D3E0(a1, a2);
}

//----- (0041C970) --------------------------------------------------------
int *__thiscall sub_41C970(int *this)
{
  int *v1; // eax@2
  int *result; // eax@3
  int *v3; // eax@5
  int **v4; // eax@6
  int *v5; // [sp+0h] [bp-8h]@1
  int *v6; // [sp+4h] [bp-4h]@6

  v5 = this;
  if ( *(_DWORD *)sub_41ADD0(*this) || (v1 = (int *)sub_41AE10(*v5), *(_DWORD *)sub_41AE10(*v1) != *v5) )
  {
    if ( *(_DWORD *)unknown_libname_83(*v5) == dword_47EFDC )
    {
      while ( 1 )
      {
        v4 = (int **)sub_41AE10(*v5);
        v6 = *v4;
        if ( *v5 != *(_DWORD *)unknown_libname_83(*v4) )
          break;
        *v5 = (int)v6;
      }
      result = v6;
      *v5 = (int)v6;
    }
    else
    {
      v3 = (int *)unknown_libname_83(*v5);
      result = (int *)sub_41B510(*v3);
      *v5 = (int)result;
    }
  }
  else
  {
    result = (int *)sub_41AE20(*v5);
    *v5 = *result;
  }
  return result;
}
// 41AE00: using guessed type _DWORD __cdecl unknown_libname_83(_DWORD);
// 47EFDC: using guessed type int dword_47EFDC;

//----- (0041CA60) --------------------------------------------------------
int __cdecl sub_41CA60(int a1)
{
  return a1 + 20;
}

//----- (0041CA70) --------------------------------------------------------
int __cdecl sub_41CA70(int a1)
{
  return a1 + 4;
}

//----- (0041CA80) --------------------------------------------------------
int __thiscall std::_tree_sock_sock::upper_bound(void *this, int a2, _DWORD *a3)
{
  std::_tree_sock_sock::_Node *v3; // eax@1

  v3 = sub_41D210(this, a3);
  std::_tree_sock_sock::iterator::iterator((std::_tree_sock_sock::iterator *)a2, v3);
  return a2;
}

//----- (0041CAB0) --------------------------------------------------------
std::_tree_sock_sock::_Node *__thiscall std::_tree_sock_sock::_Init(std::_tree_sock_sock *this)
{
  std::_tree_sock_sock::_Node *result; // eax@5
  std::_tree_sock_sock *v2; // [sp+0h] [bp-18h]@1
  char v3; // [sp+4h] [bp-14h]@1
  std::_tree_sock_sock::_Node *v4; // [sp+8h] [bp-10h]@1
  int v5; // [sp+14h] [bp-4h]@1

  v2 = this;
  v4 = std::_tree_sock_sock::_Buynode(0, (std::_tree_sock_sock::_Node *)1);
  std::_Lockit::_Lockit((std::_Lockit *)&v3);
  v5 = 0;
  if ( !std::_tree_sock_sock::_Nil )
  {
    std::_tree_sock_sock::_Nil = v4;
    v4 = 0;
    std::_tree_sock_sock::_Left(std::_tree_sock_sock::_Nil)->_Left = 0;
    std::_tree_sock_sock::_Right(std::_tree_sock_sock::_Nil)->_Left = 0;
  }
  ++std::_tree_sock_sock::_Nilrefs;
  v5 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v3);
  if ( v4 )
    std::_tree_sock_sock::_Freenode((std::_tree_sock_sock *)v4);
  v2->_Head = std::_tree_sock_sock::_Buynode(std::_tree_sock_sock::_Nil, 0);
  v2->_Size = 0;
  std::_tree_sock_sock::_Lmost(v2)->_Left = v2->_Head;
  result = std::_tree_sock_sock::_Rmost(v2);
  result->_Left = v2->_Head;
  return result;
}
// 47EFE8: using guessed type int std::_tree_sock_sock::_Nilrefs;

//----- (0041CBB0) --------------------------------------------------------
std::_tree_sock_sock::_Node *__thiscall sub_41CBB0(void *this, _DWORD *a2)
{
  _DWORD *v2; // ST08_4@1
  struct Concurrency::details::InternalContextBase *v3; // eax@3
  std::_tree_sock_sock::_Node *v5; // [sp+4h] [bp-8h]@1
  std::_tree_sock_sock::_Node *a1; // [sp+8h] [bp-4h]@1

  v2 = this;
  a1 = *(std::_tree_sock_sock::_Node **)sub_41D1F0((int)this);
  v5 = (std::_tree_sock_sock::_Node *)v2[1];
  while ( a1 != std::_tree_sock_sock::_Nil )
  {
    v3 = std::_tree_sock_sock::_Key((int)a1);
    if ( (unsigned __int8)std::_tree_sock_sock::key_compare(v3, a2) )
    {
      a1 = std::_tree_sock_sock::_Right(a1)->_Left;
    }
    else
    {
      v5 = a1;
      a1 = std::_tree_sock_sock::_Left(a1)->_Left;
    }
  }
  return v5;
}

//----- (0041CC40) --------------------------------------------------------
std::_tree_sock_sock::_Node **__thiscall sub_41CC40(void *this, int a2)
{
  std::_tree_sock_sock::_Node *v2; // esi@1
  int *v3; // eax@2
  _DWORD *v4; // esi@3
  std::_tree_sock_sock::_Node **v5; // eax@5
  std::_tree_sock_sock::_Node **v6; // eax@6
  std::_tree_sock_sock::_Node **v7; // eax@7
  std::_tree_sock_sock::_Node **result; // eax@8
  std::_tree_sock_sock *v9; // [sp+4h] [bp-8h]@1
  std::_tree_sock_sock::_Node *v10; // [sp+8h] [bp-4h]@1

  v9 = (std::_tree_sock_sock *)this;
  v10 = std::_tree_sock_sock::_Right((std::_tree_sock_sock::_Node *)a2)->_Left;
  v2 = std::_tree_sock_sock::_Left(v10);
  std::_tree_sock_sock::_Right((std::_tree_sock_sock::_Node *)a2)->_Left = v2->_Left;
  if ( std::_tree_sock_sock::_Left(v10)->_Left != std::_tree_sock_sock::_Nil )
  {
    v3 = (int *)std::_tree_sock_sock::_Left(v10);
    *(_DWORD *)sub_41CA70(*v3) = a2;
  }
  v4 = (_DWORD *)sub_41CA70(a2);
  *(_DWORD *)sub_41CA70((int)v10) = *v4;
  if ( (std::_tree_sock_sock::_Node *)a2 == std::_tree_sock_sock::_Root_const(v9)->_Left )
  {
    std::_tree_sock_sock::_Root_const(v9)->_Left = v10;
  }
  else
  {
    v5 = (std::_tree_sock_sock::_Node **)sub_41CA70(a2);
    if ( (std::_tree_sock_sock::_Node *)a2 == std::_tree_sock_sock::_Left(*v5)->_Left )
    {
      v6 = (std::_tree_sock_sock::_Node **)sub_41CA70(a2);
      std::_tree_sock_sock::_Left(*v6)->_Left = v10;
    }
    else
    {
      v7 = (std::_tree_sock_sock::_Node **)sub_41CA70(a2);
      std::_tree_sock_sock::_Right(*v7)->_Left = v10;
    }
  }
  std::_tree_sock_sock::_Left(v10)->_Left = (std::_tree_sock_sock::_Node *)a2;
  result = (std::_tree_sock_sock::_Node **)sub_41CA70(a2);
  *result = v10;
  return result;
}

//----- (0041CD70) --------------------------------------------------------
int __cdecl sub_41CD70(int a1)
{
  while ( std::_tree_sock_sock::_Right((std::_tree_sock_sock::_Node *)a1)->_Left != std::_tree_sock_sock::_Nil )
    a1 = (int)std::_tree_sock_sock::_Right((std::_tree_sock_sock::_Node *)a1)->_Left;
  return a1;
}

//----- (0041CDB0) --------------------------------------------------------
int __cdecl sub_41CDB0(int a1)
{
  while ( std::_tree_sock_sock::_Left((std::_tree_sock_sock::_Node *)a1)->_Left != std::_tree_sock_sock::_Nil )
    a1 = (int)std::_tree_sock_sock::_Left((std::_tree_sock_sock::_Node *)a1)->_Left;
  return a1;
}

//----- (0041CDF0) --------------------------------------------------------
std::_tree_sock_sock::_Node **__thiscall sub_41CDF0(void *this, int a2)
{
  std::_tree_sock_sock::_Node *v2; // esi@1
  int *v3; // eax@2
  _DWORD *v4; // esi@3
  std::_tree_sock_sock::_Node **v5; // eax@5
  std::_tree_sock_sock::_Node **v6; // eax@6
  std::_tree_sock_sock::_Node **v7; // eax@7
  std::_tree_sock_sock::_Node **result; // eax@8
  std::_tree_sock_sock *v9; // [sp+4h] [bp-8h]@1
  std::_tree_sock_sock::_Node *a1; // [sp+8h] [bp-4h]@1

  v9 = (std::_tree_sock_sock *)this;
  a1 = std::_tree_sock_sock::_Left((std::_tree_sock_sock::_Node *)a2)->_Left;
  v2 = std::_tree_sock_sock::_Right(a1);
  std::_tree_sock_sock::_Left((std::_tree_sock_sock::_Node *)a2)->_Left = v2->_Left;
  if ( std::_tree_sock_sock::_Right(a1)->_Left != std::_tree_sock_sock::_Nil )
  {
    v3 = (int *)std::_tree_sock_sock::_Right(a1);
    *(_DWORD *)sub_41CA70(*v3) = a2;
  }
  v4 = (_DWORD *)sub_41CA70(a2);
  *(_DWORD *)sub_41CA70((int)a1) = *v4;
  if ( (std::_tree_sock_sock::_Node *)a2 == std::_tree_sock_sock::_Root_const(v9)->_Left )
  {
    std::_tree_sock_sock::_Root_const(v9)->_Left = a1;
  }
  else
  {
    v5 = (std::_tree_sock_sock::_Node **)sub_41CA70(a2);
    if ( (std::_tree_sock_sock::_Node *)a2 == std::_tree_sock_sock::_Right(*v5)->_Left )
    {
      v6 = (std::_tree_sock_sock::_Node **)sub_41CA70(a2);
      std::_tree_sock_sock::_Right(*v6)->_Left = a1;
    }
    else
    {
      v7 = (std::_tree_sock_sock::_Node **)sub_41CA70(a2);
      std::_tree_sock_sock::_Left(*v7)->_Left = a1;
    }
  }
  std::_tree_sock_sock::_Right(a1)->_Left = (std::_tree_sock_sock::_Node *)a2;
  result = (std::_tree_sock_sock::_Node **)sub_41CA70(a2);
  *result = a1;
  return result;
}

//----- (0041CF20) --------------------------------------------------------
std::_tree_sock_sock::_Node *__stdcall std::_tree_sock_sock::_Buynode(std::_tree_sock_sock::_Node *a1, std::_tree_sock_sock::_Node *a2)
{
  std::_tree_sock_sock::_Node *result; // eax@1

  result = (std::_tree_sock_sock::_Node *)sub_41D1D0(0x18u);
  *(_DWORD *)sub_41CA70((int)result) = a1;
  *(_DWORD *)sub_41CA60((int)result) = a2;
  return result;
}

//----- (0041CF70) --------------------------------------------------------
_DWORD *__stdcall sub_41CF70(void *a1, int a2)
{
  return sub_41D420(a1, a2);
}

//----- (0041CF90) --------------------------------------------------------
void __stdcall sub_41CF90(int a1)
{
  sub_41D460();
}

//----- (0041CFD0) --------------------------------------------------------
std::_tree_sock_sock::_Node *__thiscall sub_41CFD0(int *this)
{
  int *v1; // eax@2
  std::_tree_sock_sock::_Node *result; // eax@3
  int *v3; // eax@5
  std::_tree_sock_sock::_Node **v4; // eax@6
  int *v5; // [sp+0h] [bp-8h]@1
  std::_tree_sock_sock::_Node *v6; // [sp+4h] [bp-4h]@6

  v5 = this;
  if ( *(_DWORD *)sub_41CA60(*this) || (v1 = (int *)sub_41CA70(*v5), *(_DWORD *)sub_41CA70(*v1) != *v5) )
  {
    if ( std::_tree_sock_sock::_Left((std::_tree_sock_sock::_Node *)*v5)->_Left == std::_tree_sock_sock::_Nil )
    {
      while ( 1 )
      {
        v4 = (std::_tree_sock_sock::_Node **)sub_41CA70(*v5);
        v6 = *v4;
        if ( (std::_tree_sock_sock::_Node *)*v5 != std::_tree_sock_sock::_Left(*v4)->_Left )
          break;
        *v5 = (int)v6;
      }
      result = v6;
      *v5 = (int)v6;
    }
    else
    {
      v3 = (int *)std::_tree_sock_sock::_Left((std::_tree_sock_sock::_Node *)*v5);
      result = (std::_tree_sock_sock::_Node *)sub_41CD70(*v3);
      *v5 = (int)result;
    }
  }
  else
  {
    result = std::_tree_sock_sock::_Right((std::_tree_sock_sock::_Node *)*v5);
    *v5 = (int)result->_Left;
  }
  return result;
}

//----- (0041D0C0) --------------------------------------------------------
int __thiscall sub_41D0C0(int this, _DWORD *a2, _DWORD *a3)
{
  *(_DWORD *)this = *a2;
  *(_DWORD *)(this + 4) = *a3;
  return this;
}

//----- (0041D0F0) --------------------------------------------------------
char *__stdcall sub_41D0F0(size_t a1)
{
  return std::_Allocate(a1);
}

//----- (0041D110) --------------------------------------------------------
int __thiscall sub_41D110(int this)
{
  return sub_41AE10(*(_DWORD *)(this + 4));
}

//----- (0041D130) --------------------------------------------------------
_DWORD *__thiscall sub_41D130(int *this)
{
  int *v1; // eax@2
  _DWORD *result; // eax@2
  int *v3; // eax@3
  int *v4; // [sp+0h] [bp-8h]@1
  _DWORD *v5; // [sp+4h] [bp-4h]@3

  v4 = this;
  if ( *(_DWORD *)sub_41AE20(*this) == dword_47EFDC )
  {
    while ( 1 )
    {
      v3 = (int *)sub_41AE10(*v4);
      v5 = (_DWORD *)*v3;
      if ( *v4 != *(_DWORD *)sub_41AE20(*v3) )
        break;
      *v4 = (int)v5;
    }
    result = (_DWORD *)sub_41AE20(*v4);
    if ( (_DWORD *)*result != v5 )
    {
      result = v5;
      *v4 = (int)v5;
    }
  }
  else
  {
    v1 = (int *)sub_41AE20(*v4);
    result = (_DWORD *)sub_41B550(*v1);
    *v4 = (int)result;
  }
  return result;
}
// 47EFDC: using guessed type int dword_47EFDC;

//----- (0041D1D0) --------------------------------------------------------
char *__stdcall sub_41D1D0(size_t a1)
{
  return std::_Allocate(a1);
}

//----- (0041D1F0) --------------------------------------------------------
int __thiscall sub_41D1F0(int this)
{
  return sub_41CA70(*(_DWORD *)(this + 4));
}

//----- (0041D210) --------------------------------------------------------
std::_tree_sock_sock::_Node *__thiscall sub_41D210(void *this, _DWORD *a2)
{
  _DWORD *v2; // ST08_4@1
  struct Concurrency::details::InternalContextBase *v3; // eax@3
  std::_tree_sock_sock::_Node *v5; // [sp+4h] [bp-8h]@1
  std::_tree_sock_sock::_Node *a1; // [sp+8h] [bp-4h]@1

  v2 = this;
  a1 = *(std::_tree_sock_sock::_Node **)sub_41D1F0((int)this);
  v5 = (std::_tree_sock_sock::_Node *)v2[1];
  while ( a1 != std::_tree_sock_sock::_Nil )
  {
    v3 = std::_tree_sock_sock::_Key((int)a1);
    if ( (unsigned __int8)std::_tree_sock_sock::key_compare(a2, v3) )
    {
      v5 = a1;
      a1 = std::_tree_sock_sock::_Left(a1)->_Left;
    }
    else
    {
      a1 = std::_tree_sock_sock::_Right(a1)->_Left;
    }
  }
  return v5;
}

//----- (0041D2A0) --------------------------------------------------------
std::_tree_sock_sock::_Node *__thiscall sub_41D2A0(int *this)
{
  int *v1; // eax@2
  std::_tree_sock_sock::_Node *result; // eax@2
  std::_tree_sock_sock::_Node **v3; // eax@3
  int *v4; // [sp+0h] [bp-8h]@1
  std::_tree_sock_sock::_Node *a1; // [sp+4h] [bp-4h]@3

  v4 = this;
  if ( std::_tree_sock_sock::_Right((std::_tree_sock_sock::_Node *)*this)->_Left == std::_tree_sock_sock::_Nil )
  {
    while ( 1 )
    {
      v3 = (std::_tree_sock_sock::_Node **)sub_41CA70(*v4);
      a1 = *v3;
      if ( (std::_tree_sock_sock::_Node *)*v4 != std::_tree_sock_sock::_Right(*v3)->_Left )
        break;
      *v4 = (int)a1;
    }
    result = std::_tree_sock_sock::_Right((std::_tree_sock_sock::_Node *)*v4);
    if ( result->_Left != a1 )
    {
      result = a1;
      *v4 = (int)a1;
    }
  }
  else
  {
    v1 = (int *)std::_tree_sock_sock::_Right((std::_tree_sock_sock::_Node *)*v4);
    result = (std::_tree_sock_sock::_Node *)sub_41CDB0(*v1);
    *v4 = (int)result;
  }
  return result;
}

//----- (0041D340) --------------------------------------------------------
int __cdecl sub_41D340(int *a1, int *a2)
{
  int v2; // ST00_4@1
  int result; // eax@1

  v2 = *a1;
  *a1 = *a2;
  result = v2;
  *a2 = v2;
  return result;
}

//----- (0041D370) --------------------------------------------------------
int __cdecl std::_tree_sock_sock::_Distance(char a1, char a2, _DWORD *a3)
{
  int v3; // ecx@0
  char v4; // dl@1
  int v6; // [sp+0h] [bp-4h]@1

  v6 = v3;
  v4 = *sub_41D470(&v6);
  return sub_41D490(a1, a2, a3);
}

//----- (0041D3A0) --------------------------------------------------------
void sub_41D3A0()
{
  ;
}

//----- (0041D3B0) --------------------------------------------------------
int __cdecl sub_41D3B0(int *a1, int *a2)
{
  int v2; // ST00_4@1
  int result; // eax@1

  v2 = *a1;
  *a1 = *a2;
  result = v2;
  *a2 = v2;
  return result;
}

//----- (0041D3E0) --------------------------------------------------------
_DWORD *__cdecl sub_41D3E0(void *a1, int a2)
{
  _DWORD *result; // eax@1
  _DWORD *v3; // [sp+4h] [bp-4h]@1

  result = operator new(8u, a1);
  v3 = result;
  if ( result )
  {
    result = *(_DWORD **)(a2 + 4);
    *v3 = *(_DWORD *)a2;
    v3[1] = result;
  }
  return result;
}

//----- (0041D420) --------------------------------------------------------
_DWORD *__cdecl sub_41D420(void *a1, int a2)
{
  _DWORD *result; // eax@1
  _DWORD *v3; // [sp+4h] [bp-4h]@1

  result = operator new(8u, a1);
  v3 = result;
  if ( result )
  {
    result = *(_DWORD **)(a2 + 4);
    *v3 = *(_DWORD *)a2;
    v3[1] = result;
  }
  return result;
}

//----- (0041D460) --------------------------------------------------------
void sub_41D460()
{
  ;
}

//----- (0041D470) --------------------------------------------------------
_BYTE *__cdecl sub_41D470(_BYTE *a1)
{
  char v2; // [sp+4h] [bp-4h]@1

  *a1 = v2;
  return a1;
}

//----- (0041D490) --------------------------------------------------------
int __cdecl sub_41D490(char a1, char a2, _DWORD *a3)
{
  int result; // eax@1
  int savedregs; // [sp+0h] [bp+0h]@0

  while ( 1 )
  {
    result = (unsigned __int8)std::_tree_sock_sock::iterator::iterator_operator_not_eq(
                                (std::_tree_sock_sock::iterator *)&a1,
                                (std::_tree_sock_sock::iterator *)&a2);
    if ( !result )
      break;
    ++*a3;
    unknown_libname_96(savedregs);
  }
  return result;
}
// 41D0A0: using guessed type int __cdecl unknown_libname_96(_DWORD);

//----- (0041D4D0) --------------------------------------------------------
CIOSocket *__thiscall CIOSocket::CIOSocket(CIOSocket *this, SOCKET socket)
{
  CIOSocket *this_; // ST0C_4@1

  this_ = this;
  MemoryObject::MemoryObject(&this->base);
  this_->base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&CIOSocket_vtable_off_45F5C8;
  InitializeCriticalSection(&this_->m_lock);
  this_->m_hSocket = socket;
  memset(&this_->m_overlappedRead, 0, 20u);
  memset(&this_->m_overlappedWrite, 0, 20u);
  this_->m_pReadBuf = CIOBuffer::Alloc();
  this_->m_nPendingWrite = 0;
  this_->m_pLastBuf = 0;
  this_->m_pFirstBuf = 0;
  return this_;
}
// 45F5C8: using guessed type int (__stdcall *CIOSocket_vtable_off_45F5C8)(int);

//----- (0041D583) --------------------------------------------------------
MemoryObject *__thiscall CIOSocket::Destructor(CIOSocket *this)
{
  CIOBuffer *buffer; // ST08_4@3
  CIOSocket *this_; // [sp+0h] [bp-14h]@1

  this_ = this;
  this->base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&CIOSocket_vtable_off_45F5C8;
  DeleteCriticalSection(&this->m_lock);
  CIOBuffer::Release(this_->m_pReadBuf);
  while ( this_->m_pFirstBuf )
  {
    buffer = this_->m_pFirstBuf;
    this_->m_pFirstBuf = this_->m_pFirstBuf->m_pNext;
    CIOBuffer::Free(buffer);
  }
  return MemoryObject::Destructor(&this_->base);
}
// 45F5C8: using guessed type int (__stdcall *CIOSocket_vtable_off_45F5C8)(int);

//----- (0041D614) --------------------------------------------------------
void CIOSocket::OnClose()
{
  ;
}

//----- (0041D61F) --------------------------------------------------------
LONG __thiscall CIOSocket::Close(CIOSocket *this)
{
  LONG result; // eax@1
  CIOSocket *this_; // [sp+0h] [bp-Ch]@1
  linger optval; // [sp+4h] [bp-8h]@2
  SOCKET oldSocket; // [sp+8h] [bp-4h]@1

  this_ = this;
  result = InterlockedExchange((volatile LONG *)&this->m_hSocket, INVALID_SOCKET);
  oldSocket = result;
  if ( result != INVALID_SOCKET )
  {
    ((void (__thiscall *)(CIOSocket *))this_->base.vftbl_0_45F520->derived_func_7)(this_);
    optval.l_onoff = 1;                         // WTF?
    optval.l_linger = 0;
    setsockopt(oldSocket, SOL_SOCKET, SO_LINGER, (const char *)&optval, 4);
    closesocket(oldSocket);
    result = MemoryObject::Release(&this_->base);
  }
  return result;
}

//----- (0041D687) --------------------------------------------------------
int __thiscall CIOSocket::Initialize(CIOSocket *this, HANDLE ExistingCompletionPort)
{
  int result; // eax@2
  CIOSocket *this_; // [sp+0h] [bp-8h]@1
  int buffLen; // [sp+4h] [bp-4h]@1

  this_ = this;
  buffLen = 0;
  setsockopt(this->m_hSocket, SOL_SOCKET, SO_RCVBUF, (const char *)&buffLen, 4);
  buffLen = 0;
  setsockopt(this_->m_hSocket, SOL_SOCKET, SO_SNDBUF, (const char *)&buffLen, 4);
  if ( CreateIoCompletionPort((HANDLE)this_->m_hSocket, ExistingCompletionPort, (ULONG_PTR)this_, 0) )
  {
    result = ((int (__thiscall *)(CIOSocket *))this_->base.vftbl_0_45F520->derived_func_8)(this_);// OnCreate
  }
  else
  {
    LogWindow::Add(&g_LogWindow, 3, aInitilizeCompl);
    result = CIOSocket::Close(this_);
  }
  return result;
}

//----- (0041D722) --------------------------------------------------------
int __thiscall CIOSocket::OnCreate(CIOSocket *this)
{
  return ((int (__cdecl *)(CIOSocket *))this->base.vftbl_0_45F520->derived_func_9)(this);
}

//----- (0041D738) --------------------------------------------------------
LONG __thiscall CIOSocket::OnIOCallback(CIOSocket *this, int bSuccess, int dwTransferred, LPOVERLAPPED lpOverlapped)
{
  CIOSocket *this_; // [sp+0h] [bp-4h]@1

  this_ = this;
  if ( bSuccess )
  {
    if ( lpOverlapped == &this->m_overlappedRead )
    {
      this->base.vftbl_0_45F520[1].DestructorCall((MemoryObject *)this, dwTransferred);
    }
    else if ( lpOverlapped == &this->m_overlappedWrite )
    {
      ((void (__thiscall *)(CIOSocket *, int))this->base.vftbl_0_45F520[1].OnIOCallback)(this, dwTransferred);
    }
  }
  else if ( lpOverlapped == &this->m_overlappedRead || lpOverlapped == &this->m_overlappedWrite )
  {
    CIOSocket::Close(this);
  }
  return MemoryObject::Release(&this_->base);
}

//----- (0041D7A9) --------------------------------------------------------
LogWindow *__thiscall CIOSocket::ReadCallback(CIOSocket *this, int dwTransferred)
{
  LogWindow *result; // eax@2

  if ( dwTransferred )
  {
    if ( this->base.m_nRefCount > 0 )
    {
      this->m_pReadBuf->m_dwSize += dwTransferred;
      result = (LogWindow *)this->base.vftbl_0_45F520->derived_func_9(this);
    }
    else
    {
      result = LogWindow::Add(&g_LogWindow, 3, aInvalidSocket);
    }
  }
  else
  {
    result = (LogWindow *)CIOSocket::Close(this);
  }
  return result;
}

//----- (0041D80B) --------------------------------------------------------
void __thiscall CIOSocket::WriteCallback(CIOSocket *this, int dwTransferred)
{
  CIOSocket *this_; // [sp+0h] [bp-18h]@1
  DWORD errorCode; // [sp+4h] [bp-14h]@6
  DWORD NumberOfBytesSent; // [sp+8h] [bp-10h]@4
  struct _WSABUF buffers; // [sp+Ch] [bp-Ch]@4
  CIOBuffer *buffer; // [sp+14h] [bp-4h]@3

  this_ = this;
  EnterCriticalSection(&this->m_lock);
  if ( dwTransferred == this_->m_pFirstBuf->m_dwSize )
  {
    this_->m_nPendingWrite -= this_->m_pFirstBuf->m_dwSize;
    buffer = this_->m_pFirstBuf;
    this_->m_pFirstBuf = this_->m_pFirstBuf->m_pNext;
    if ( this_->m_pFirstBuf )
    {
      LeaveCriticalSection(&this_->m_lock);
      MemoryObject::AddRef(&this_->base);
      buffers.len = this_->m_pFirstBuf->m_dwSize;
      buffers.buf = (char *)this_->m_pFirstBuf->m_Buffer;
      if ( WSASend(this_->m_hSocket, &buffers, 1u, &NumberOfBytesSent, 0, (LPWSAOVERLAPPED)&this_->m_overlappedWrite, 0)
        && GetLastError() != ERROR_IO_PENDING ) // WSA_IO_PENDING
      {
        errorCode = GetLastError();
        if ( errorCode != WSAENOTSOCK && errorCode != WSAECONNRESET && errorCode != WSAECONNABORTED )
          LogWindow::Add(&g_LogWindow, 3, aCiosocketWrite, this_->m_hSocket, this_, errorCode);
        MemoryObject::Release(&this_->base);
      }
    }
    else
    {
      this_->m_pLastBuf = 0;
      LeaveCriticalSection(&this_->m_lock);
    }
    CIOBuffer::Free(buffer);
  }
  else
  {
    LogWindow::Add(
      &g_LogWindow,
      3,
      aDifferentWrite,
      this_->m_hSocket,
      this_,
      dwTransferred,
      this_->m_pFirstBuf->m_dwSize);
    LeaveCriticalSection(&this_->m_lock);
    MemoryObject::Release(&this_->base);
  }
}

//----- (0041D995) --------------------------------------------------------
LONG __thiscall CIOSocket::Read(CIOSocket *this, size_t dwLeft)
{
  CIOBuffer *pNextBuf; // ST24_4@2
  LONG result; // eax@4
  CIOSocket *this_; // [sp+0h] [bp-1Ch]@1
  DWORD errorCode; // [sp+4h] [bp-18h]@6
  DWORD dwRecv; // [sp+Ch] [bp-10h]@4
  DWORD dwFlag; // [sp+10h] [bp-Ch]@4
  struct _WSABUF buffers; // [sp+14h] [bp-8h]@4

  this_ = this;
  this->m_pReadBuf->m_dwSize -= dwLeft;
  if ( this->m_pReadBuf->m_nRefCount == 1 )
  {
    memmove(this->m_pReadBuf->m_Buffer, &this->m_pReadBuf->m_Buffer[this->m_pReadBuf->m_dwSize], dwLeft);
  }
  else
  {
    pNextBuf = CIOBuffer::Alloc();
    memcpy(pNextBuf->m_Buffer, &this_->m_pReadBuf->m_Buffer[this_->m_pReadBuf->m_dwSize], dwLeft);
    CIOBuffer::Release(this_->m_pReadBuf);
    this_->m_pReadBuf = pNextBuf;
  }
  this_->m_pReadBuf->m_dwSize = dwLeft;
  MemoryObject::AddRef(&this_->base);
  buffers.len = 0x2000 - this_->m_pReadBuf->m_dwSize;
  buffers.buf = (char *)&this_->m_pReadBuf->m_Buffer[this_->m_pReadBuf->m_dwSize];
  dwFlag = 0;
  result = WSARecv(this_->m_hSocket, &buffers, 1u, &dwRecv, &dwFlag, (LPWSAOVERLAPPED)&this_->m_overlappedRead, 0);
  if ( result )
  {
    result = GetLastError();
    if ( result != ERROR_IO_PENDING )
    {
      errorCode = GetLastError();
      if ( errorCode != WSAENOTSOCK && errorCode != WSAECONNRESET && errorCode != WSAECONNABORTED )
        LogWindow::Add(&g_LogWindow, 3, aCiosocketReadX, this_->m_hSocket, this_, errorCode);
      CIOSocket::Close(this_);
      result = MemoryObject::Release(&this_->base);
    }
  }
  return result;
}

//----- (0041DB1A) --------------------------------------------------------
void __thiscall CIOSocket::Write(CIOSocket *this, CIOBuffer *buff)
{
  CIOSocket *this_; // [sp+0h] [bp-14h]@1
  DWORD errorCode; // [sp+4h] [bp-10h]@6
  DWORD dwSent; // [sp+8h] [bp-Ch]@4
  struct _WSABUF wsabuf; // [sp+Ch] [bp-8h]@4

  this_ = this;
  if ( buff->m_dwSize )
  {
    EnterCriticalSection(&this->m_lock);
    this_->m_nPendingWrite += buff->m_dwSize;
    if ( this_->m_pLastBuf )
    {
      if ( this_->m_pFirstBuf == this_->m_pLastBuf || buff->m_dwSize + this_->m_pLastBuf->m_dwSize > 0x2000 )
      {
        this_->m_pLastBuf->m_pNext = buff;
        this_->m_pLastBuf = buff;
        LeaveCriticalSection(&this_->m_lock);
      }
      else
      {
        memcpy(&this_->m_pLastBuf->m_Buffer[this_->m_pLastBuf->m_dwSize], buff->m_Buffer, buff->m_dwSize);
        this_->m_pLastBuf->m_dwSize += buff->m_dwSize;
        LeaveCriticalSection(&this_->m_lock);
        CIOBuffer::Free(buff);
      }
    }
    else
    {
      this_->m_pLastBuf = buff;
      this_->m_pFirstBuf = buff;
      LeaveCriticalSection(&this_->m_lock);
      MemoryObject::AddRef(&this_->base);
      wsabuf.len = buff->m_dwSize;
      wsabuf.buf = (char *)buff->m_Buffer;
      dwSent = 0;
      if ( WSASend(this_->m_hSocket, &wsabuf, 1u, &dwSent, 0, (LPWSAOVERLAPPED)&this_->m_overlappedWrite, 0)
        && GetLastError() != ERROR_IO_PENDING )
      {
        errorCode = GetLastError();
        if ( errorCode != WSAENOTSOCK && errorCode != WSAECONNRESET && errorCode != WSAECONNABORTED )
          LogWindow::Add(&g_LogWindow, 3, aCiosocketWri_0, this_->m_hSocket, this_, errorCode);
        MemoryObject::Release(&this_->base);
      }
    }
  }
  else
  {
    CIOBuffer::Free(buff);
  }
}

//----- (0041DD75) --------------------------------------------------------
int StaticVectorInit_For_CPacketPool::CSlot()
{
  VectorInitializationFor_CPacketPool::CSlot();
  return RegisterCPacketPool_CSlotDtor();
}

//----- (0041DD84) --------------------------------------------------------
int VectorInitializationFor_CPacketPool::CSlot()
{
  return `eh vector constructor iterator'(
           WorldSrvPacketPool::g_slot,
           0x24u,
           16,
           (int)WorldSrvPacketSlot::WorldSrvPacketSlot,
           (void (__thiscall *)(void *))WorldSrvPacketSlot::Destructor);
}

//----- (0041DDA1) --------------------------------------------------------
int RegisterCPacketPool_CSlotDtor()
{
  return atexit(CallVectorDtorFor_CPacketPool::CSlot);
}

//----- (0041DDB3) --------------------------------------------------------
void __cdecl CallVectorDtorFor_CPacketPool::CSlot()
{
  if ( !(byte_47F235 & 1) )
  {
    byte_47F235 |= 1u;
    `eh vector destructor iterator'(
      WorldSrvPacketPool::g_slot,
      0x24u,
      16,
      (void (__thiscall *)(void *))WorldSrvPacketSlot::Destructor);
  }
}
// 47F235: using guessed type char byte_47F235;

//----- (0041DDE8) --------------------------------------------------------
int StaticRegisterCPacketPool()
{
  callEmptyCtor();
  return RegisterCPacketPoolDtor();
}

//----- (0041DDF7) --------------------------------------------------------
void callEmptyCtor()
{
  ;
}

//----- (0041DDFC) --------------------------------------------------------
int RegisterCPacketPoolDtor()
{
  return atexit(CalDtorCPacketPool);
}

//----- (0041DE0E) --------------------------------------------------------
void __cdecl CalDtorCPacketPool()
{
  WorldSrvPacketPool::Destructor();
}

//----- (0041DE1D) --------------------------------------------------------
WorldSrvPacket *WorldSrvPacket::Alloc()
{
  WorldSrvPacket *v1; // [sp+0h] [bp-20h]@4
  WorldSrvPacket *v2; // [sp+4h] [bp-1Ch]@3
  WorldSrvPacketSlot *pSlot; // [sp+Ch] [bp-14h]@1
  WorldSrvPacket *packet; // [sp+10h] [bp-10h]@1

  pSlot = &WorldSrvPacketPool::g_slot[InterlockedIncrement(&CPacketPool::g_nAlloc) & 0xF];
  SpinLock::Enter(&pSlot->m_lock);
  packet = pSlot->m_pPacket;
  if ( pSlot->m_pPacket )
  {
    pSlot->m_pPacket = (WorldSrvPacket *)packet->m_pSocket;
    SpinLock::Leave(&pSlot->m_lock);
  }
  else
  {
    SpinLock::Leave(&pSlot->m_lock);
    v2 = (WorldSrvPacket *)operator_new(0x14u);
    if ( v2 )
      v1 = WorldSrvPacket::WorldSrvPacket(v2);
    else
      v1 = 0;
    packet = v1;
  }
  return packet;
}

//----- (0041DEDF) --------------------------------------------------------
void __thiscall WorldSrvPacket::Free(WorldSrvPacket *this)
{
  WorldSrvPacket *this_; // ST04_4@1
  WorldSrvPacketSlot *slot; // ST08_4@1

  this_ = this;
  slot = &WorldSrvPacketPool::g_slot[InterlockedDecrement(&CPacketPool::g_nFree) & 0xF];
  SpinLock::Enter(&slot->m_lock);
  this_->m_pSocket = (CIOSocket *)slot->m_pPacket;
  slot->m_pPacket = this_;
  SpinLock::Leave(&slot->m_lock);
}

//----- (0041DF2E) --------------------------------------------------------
void WorldSrvPacket::FreeAll()
{
  WorldSrvPacketSlot *socket; // [sp+Ch] [bp-Ch]@3
  WorldSrvPacket *packet; // [sp+10h] [bp-8h]@4
  signed int i; // [sp+14h] [bp-4h]@1

  for ( i = 0; i < 16; ++i )
  {
    socket = &WorldSrvPacketPool::g_slot[i];
    SpinLock::Enter(&WorldSrvPacketPool::g_slot[i].m_lock);
    while ( true )
    {
      packet = socket->m_pPacket;
      if ( !socket->m_pPacket )
        break;
      socket->m_pPacket = (WorldSrvPacket *)packet->m_pSocket;
      if ( packet )
        packet->base.vftbl_0_45F520->DestructorCall((MemoryObject *)packet, 1);// delete packet;
    }
    SpinLock::Leave(&socket->m_lock);
  }
}

//----- (0041DFBC) --------------------------------------------------------
void __thiscall WorldSrvPacket::OnIOCallback(WorldSrvPacket *this, int bSuccess, int dwTransferred, int LPOVERLAPPED)
{
  WorldSrvPacket *this_; // [sp+0h] [bp-8h]@1

  this_ = this;
  if ( ((int (__cdecl *)(_DWORD, _DWORD))this->m_pFunc)(this->m_pSocket, &this->m_pBuf->m_Buffer[dwTransferred + 1]) & 0xFF )
  {
    CIOSocket::Close(this_->m_pSocket);
    LogWindow::Add(&g_LogWindow, 3, aServerclosePac);
  }
  MemoryObject::Release(&this_->m_pSocket->base);
  CIOBuffer::Release(this_->m_pBuf);
  InterlockedDecrement(&WorldSrvPacket::g_nPendingPacket);
  WorldSrvPacket::Free(this_);
}

//----- (0041E043) --------------------------------------------------------
int SomeStaticInit26()
{
  SomeBitsInit();
  return sub_41E052();
}

//----- (0041E052) --------------------------------------------------------
int sub_41E052()
{
  return atexit(emptystub);
}

//----- (0041E070) --------------------------------------------------------
CIOSocket *__thiscall CallCIOSocketDestructor(CIOSocket *this, char a2)
{
  CIOSocket *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  CIOSocket::Destructor(this);
  if ( a2 & 1 )
    operator_delete(v3);
  return v3;
}

//----- (0041E0A0) --------------------------------------------------------
WorldSrvPacketSlot *__thiscall WorldSrvPacketSlot::WorldSrvPacketSlot(WorldSrvPacketSlot *this)
{
  WorldSrvPacketSlot *v1; // ST08_4@1

  v1 = this;
  this->m_pPacket = 0;
  SpinLock::SpinLock(&this->m_lock, LockType_WaitLock, 0);
  return v1;
}

//----- (0041E0D0) --------------------------------------------------------
// Microsoft VisualC 2-11/net runtime
void __thiscall WorldSrvPacketSlot::Destructor(WorldSrvPacketSlot *this)
{
  SpinLock::Destructor(&this->m_lock);
}

//----- (0041E0F0) --------------------------------------------------------
void WorldSrvPacketPool::Destructor()
{
  WorldSrvPacket::FreeAll();
}

//----- (0041E100) --------------------------------------------------------
WorldSrvPacket *__thiscall WorldSrvPacket::WorldSrvPacket(WorldSrvPacket *this)
{
  WorldSrvPacket *v1; // ST00_4@1

  v1 = this;
  MemoryObject::MemoryObject(&this->base);
  v1->base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&WorldSrvPacket_vtable_off_45F5F4;
  return v1;
}
// 45F5F4: using guessed type int (__stdcall *WorldSrvPacket_vtable_off_45F5F4)(int);

//----- (0041E120) --------------------------------------------------------
WorldSrvPacket *__thiscall WorldSrvPacket::CallDestructor(WorldSrvPacket *this, char a2)
{
  WorldSrvPacket *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  WorldSrvPacket::Destructor(this);
  if ( a2 & 1 )
    operator_delete(v3);
  return v3;
}

//----- (0041E150) --------------------------------------------------------
// Microsoft VisualC 2-11/net runtime
MemoryObject *__thiscall WorldSrvPacket::Destructor(WorldSrvPacket *this)
{
  return MemoryObject::Destructor(&this->base);
}

//----- (0041E170) --------------------------------------------------------
void __thiscall CIOBuffer::Release(CIOBuffer *this)
{
  CIOBuffer *this_; // [sp+0h] [bp-4h]@1

  this_ = this;
  if ( !InterlockedDecrement(&this->m_nRefCount) )
    CIOBuffer::Free(this_);
}

//----- (0041E1A0) --------------------------------------------------------
int StaticInit_ForIpRegistry()
{
  CallIpRegistryCtor();
  return IpRegistry_RegisterDestructor();
}

//----- (0041E1AF) --------------------------------------------------------
IpRegistry *CallIpRegistryCtor()
{
  return IpRegistry::IpRegistry(&g_ipRegistry);
}

//----- (0041E1BE) --------------------------------------------------------
int IpRegistry_RegisterDestructor()
{
  return atexit(IpRegistry_CallDestructor);
}

//----- (0041E1D0) --------------------------------------------------------
void __cdecl IpRegistry_CallDestructor()
{
  IpRegistry::Destructor(&g_ipRegistry);
}

//----- (0041E1DF) --------------------------------------------------------
IPList *__thiscall IPList::IPList(IPList *this)
{
  IPList *this_; // ST04_4@1
  char a2; // [sp+4h] [bp-10h]@1
  int v4; // [sp+10h] [bp-4h]@1

  this_ = this;
  std::vector_IPRange::vector_IPRange(&this->m_addresses, &a2);
  v4 = 0;
  ReadWriteLock::ReadWriteLock(&this_->m_lock);
  return this_;
}

//----- (0041E233) --------------------------------------------------------
IpRegistry *__thiscall IpRegistry::IpRegistry(IpRegistry *this)
{
  IpRegistry *this_; // [sp+0h] [bp-8h]@1
  signed int i; // [sp+4h] [bp-4h]@1

  this_ = this;
  `eh vector constructor iterator'(this->m_ipLimits, 0x10u, 16, (int)sub_41EE00, unknown_libname_101);
  this_->vtable = (int)off_45F60C;
  for ( i = 0; i < 16; ++i )
    InitializeCriticalSection(&this_->m_locks[i]);
  return this_;
}
// 45F60C: using guessed type int (__stdcall *off_45F60C[2])(int);

//----- (0041E296) --------------------------------------------------------
int __thiscall IpRegistry::Destructor(IpRegistry *this)
{
  IpRegistry *this_; // [sp+0h] [bp-8h]@1
  signed int i; // [sp+4h] [bp-4h]@1

  this_ = this;
  this->vtable = (int)off_45F60C;
  for ( i = 0; i < 16; ++i )
    DeleteCriticalSection(&this_->m_locks[i]);
  return `eh vector destructor iterator'(this_->m_ipLimits, 0x10u, 16, unknown_libname_101);
}
// 45F60C: using guessed type int (__stdcall *off_45F60C[2])(int);

//----- (0041E2F2) --------------------------------------------------------
unsigned int __stdcall IpRegistry::hash(int ipAddress)
{
  unsigned int index; // [sp+4h] [bp-8h]@1

  index = (BYTE3(ipAddress) + BYTE2(ipAddress) + BYTE1(ipAddress) + (_BYTE)ipAddress) & 15;
  if ( index >= 16 )
    index = 15;
  return index;
}

//----- (0041E346) --------------------------------------------------------
char __thiscall IpRegistry::insert(IpRegistry *this, int ipAddress)
{
  char result; // al@2
  std::_tree_int_int::iterator *end; // eax@3
  int *limit; // ST08_4@5
  std::pair_int_int *pair; // eax@7
  IpRegistry *this_; // [sp+4h] [bp-2Ch]@1
  std::pair_int_int pair_; // [sp+8h] [bp-28h]@7
  std::_tree_int_int::iterator v8; // [sp+10h] [bp-20h]@3
  int a2; // [sp+14h] [bp-1Ch]@3
  int v10; // [sp+18h] [bp-18h]@7
  std::_tree_int_int::iterator it; // [sp+20h] [bp-10h]@3
  int newLimit; // [sp+24h] [bp-Ch]@3
  unsigned int index; // [sp+28h] [bp-8h]@3
  char canContinue; // [sp+2Ch] [bp-4h]@3

  this_ = this;
  if ( g_Config.IpAccessLimit > 0 )
  {
    canContinue = false;
    std::_tree_uint_int::iterator::iterator(&it);
    index = IpRegistry::hash(ipAddress);
    newLimit = 1;
    EnterCriticalSection(&this_->m_locks[index]);
    it._Ptr = std::map_ip::find(&this_->m_ipLimits[index], &a2, &ipAddress)->_Ptr;
    end = std::map_ip::end(&this_->m_ipLimits[index], &v8);
    if ( (unsigned __int8)std::map_ip::iterator::not_equal(&it, end) )
    {
      if ( std::map_ip::iterator::value(&it)->second < g_Config.IpAccessLimit )
      {
        limit = &std::map_ip::iterator::value(&it)->second;
        ++*limit;
        canContinue = true;
      }
    }
    else
    {
      pair = std::pair_unt_int(&pair_, &ipAddress, &newLimit);
      std::map_ip::insert(&this_->m_ipLimits[index], (int)&v10, pair);
      canContinue = true;
    }
    LeaveCriticalSection(&this_->m_locks[index]);
    result = canContinue;
  }
  else
  {
    result = true;
  }
  return result;
}
// 41F0C0: using guessed type int __thiscall std::_tree_uint_int::iterator::iterator(_DWORD);

//----- (0041E461) --------------------------------------------------------
char __thiscall IpRegistry::remove(IpRegistry *this, int ipAddress)
{
  char result; // al@2
  std::_tree_int_int::iterator *end; // eax@3
  std::pair_int_int *pair; // eax@5
  IpRegistry *this_; // [sp+4h] [bp-1Ch]@1
  int v6; // [sp+8h] [bp-18h]@6
  std::_tree_int_int::iterator v7; // [sp+Ch] [bp-14h]@3
  int a2a; // [sp+10h] [bp-10h]@3
  std::_tree_int_int::iterator it; // [sp+14h] [bp-Ch]@3
  unsigned int index; // [sp+18h] [bp-8h]@3
  char v11; // [sp+1Ch] [bp-4h]@3

  this_ = this;
  if ( g_Config.IpAccessLimit > 0 )
  {
    v11 = 0;
    std::_tree_uint_int::iterator::iterator(&it);
    index = IpRegistry::hash(ipAddress);
    EnterCriticalSection(&this_->m_locks[index]);
    it._Ptr = std::map_ip::find(&this_->m_ipLimits[index], &a2a, &ipAddress)->_Ptr;
    end = std::map_ip::end(&this_->m_ipLimits[index], &v7);
    if ( (unsigned __int8)std::map_ip::iterator::not_equal(&it, end) )
    {
      if ( std::map_ip::iterator::value(&it)->second <= 1 )
      {
        std::map_ip::erase(&this_->m_ipLimits[index], &v6, (int)it._Ptr);
      }
      else
      {
        pair = std::map_ip::iterator::value(&it);
        --pair->second;
      }
      v11 = 1;
    }
    LeaveCriticalSection(&this_->m_locks[index]);
    result = v11;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 41F0C0: using guessed type int __thiscall std::_tree_uint_int::iterator::iterator(_DWORD);

//----- (0041E55F) --------------------------------------------------------
int SomeStaticInit_ForIPList()
{
  StaticCallIPListConstructor();
  return RegisterIPListDestructor();
}

//----- (0041E56E) --------------------------------------------------------
IPList *StaticCallIPListConstructor()
{
  return IPList::IPList(&g_blockedIPs);
}

//----- (0041E57D) --------------------------------------------------------
int RegisterIPListDestructor()
{
  return atexit(StaticCallIPListDestructor);
}

//----- (0041E58F) --------------------------------------------------------
void __cdecl StaticCallIPListDestructor()
{
  IPList::Destructor(&g_blockedIPs);
}

//----- (0041E59E) --------------------------------------------------------
int StaticInit_IPList_2()
{
  StaticCall_IPList_2_Constructor();
  return Register_IPList_2_Destructor();
}

//----- (0041E5AD) --------------------------------------------------------
IPList *StaticCall_IPList_2_Constructor()
{
  return IPList::IPList(&g_unusedIPs);
}

//----- (0041E5BC) --------------------------------------------------------
int Register_IPList_2_Destructor()
{
  return atexit(StaticCall_IPList_2_Destructor);
}

//----- (0041E5CE) --------------------------------------------------------
void __cdecl StaticCall_IPList_2_Destructor()
{
  IPList::Destructor(&g_unusedIPs);
}

//----- (0041E5DD) --------------------------------------------------------
signed int __thiscall IPList::load(IPList *this, char *fileName)
{
  int symbol; // edx@3
  size_t nextWhiteSpaceIndex; // eax@8
  size_t nextWhiteSpaceIndex_1; // eax@9
  std::vector_IPRange::iterator *end; // ST28_4@22
  std::vector_IPRange::iterator *begin; // eax@22
  std::vector_IPRange::iterator *end_; // eax@22
  std::vector_IPRange::iterator *end_2; // eax@28
  unsigned int ipRange_endAddress1; // [sp+0h] [bp-4D8h]@17
  unsigned int ipRange_endAddress2; // [sp+4h] [bp-4D4h]@15
  IPList *this_; // [sp+8h] [bp-4D0h]@1
  unsigned int startAddress; // [sp+10h] [bp-4C8h]@22
  std::vector_IPRange::iterator *first; // [sp+18h] [bp-4C0h]@22
  __int32 ip_4; // [sp+1Ch] [bp-4BCh]@8
  IPRange ipRange; // [sp+20h] [bp-4B8h]@8
  __int32 ip_3; // [sp+28h] [bp-4B0h]@7
  __int32 ip_2; // [sp+2Ch] [bp-4ACh]@6
  __int32 ip_1; // [sp+30h] [bp-4A8h]@5
  char *buff_it; // [sp+34h] [bp-4A4h]@5
  char buffer[1024]; // [sp+38h] [bp-4A0h]@4
  int reader; // [sp+438h] [bp-A0h]@1 std::istrstream
  int readLine; // [sp+4C8h] [bp-10h]@1
  int unused; // [sp+4D4h] [bp-4h]@1

  this_ = this;
  sub_41F2F0((int)&reader, fileName, 1, 1);
  unused = 0;
  readLine = 0;
  if ( (unsigned __int8)std::ios_base::fail((std::ios_base *)((char *)&reader + *(_DWORD *)(reader + 4))) )
  {
    unused = -1;
    std::istrstream::`vbase destructor((int)&reader);
    return 0;
  }
  ReadWriteLock::writeLock(&this_->m_lock);
  std::vector_IPRange::clear(&this_->m_addresses);
  while ( true )
  {
    std::basic_istream::getline((int)&reader, symbol, buffer, 0x400);
    ++readLine;
    if ( (unsigned __int8)std::ios_base::fail((std::ios_base *)((char *)&reader + *(_DWORD *)(reader + 4))) )
      break;
    buff_it = buffer;
    ip_1 = strtol(buffer, &buff_it, 10);
    symbol = *buff_it;
    if ( symbol == '.' )
    {
      ++buff_it;
      ip_2 = strtol(buff_it, &buff_it, 10);
      if ( *buff_it == '.' )
      {
        ++buff_it;
        ip_3 = strtol(buff_it, &buff_it, 10);
        symbol = (int)buff_it;
        if ( *buff_it == '.' )
        {
          ++buff_it;
          ip_4 = strtol(buff_it, &buff_it, 10);
          ipRange.startAddress = ip_4 | (ip_3 << 8) | (ip_2 << 16) | (ip_1 << 24);
          nextWhiteSpaceIndex = strspn(buff_it, asc_46BBEC);
          buff_it += nextWhiteSpaceIndex;
          if ( *buff_it != '-' )
          {
            if ( ip_4 )
            {
              ipRange_endAddress1 = ipRange.startAddress + 1;
            }
            else
            {
              if ( ip_3 )
                ipRange_endAddress2 = ipRange.startAddress + 0x100;
              else
                ipRange_endAddress2 = ipRange.startAddress + 0x10000;
              ipRange_endAddress1 = ipRange_endAddress2;
            }
            ipRange.endAddress = ipRange_endAddress1;
            goto LABEL_20;
          }
          nextWhiteSpaceIndex_1 = strspn(++buff_it, asc_46BBF0);
          buff_it += nextWhiteSpaceIndex_1;
          ip_1 = strtol(buff_it, &buff_it, 10);
          symbol = *buff_it;
          if ( symbol == '.' )
          {
            ++buff_it;
            ip_2 = strtol(buff_it, &buff_it, 10);
            if ( *buff_it == '.' )
            {
              ++buff_it;
              ip_3 = strtol(buff_it, &buff_it, 10);
              symbol = (int)buff_it;
              if ( *buff_it == '.' )
              {
                ++buff_it;
                ip_4 = strtol(buff_it, &buff_it, 10);
                ipRange.endAddress = (ip_4 | (ip_3 << 8) | (ip_2 << 16) | (ip_1 << 24)) + 1;
LABEL_20:
                if ( ipRange.startAddress < ipRange.endAddress )
                {
                  startAddress = ipRange.startAddress - 1;
                  end = std::vector_IPRange::end(&this_->m_addresses);
                  begin = std::vector_IPRange::begin(&this_->m_addresses);
                  first = std::algorithm::lower_bound(begin, end, &startAddress);
                  end_ = std::vector_IPRange::end(&this_->m_addresses);
                  if ( first == end_ || first->value.startAddress > ipRange.startAddress - 1 )
                  {
LABEL_28:
                    while ( true )
                    {
                      end_2 = std::vector_IPRange::end(&this_->m_addresses);
                      if ( first == end_2 || first->value.startAddress > ipRange.endAddress )
                        break;
                      if ( first->value.startAddress != ipRange.endAddress )
                        LogWindow::Add(
                          &g_LogWindow,
                          3,
                          aIplistAddres_0,
                          (unsigned __int16)(first->value.startAddress >> 16) >> 16,
                          (first->value.startAddress >> 16) & 0xFF,
                          (first->value.startAddress >> 8) & 0xFF,
                          first->value.startAddress & 0xFF,
                          (unsigned __int16)((first->value.endAddress - 1) >> 16) >> 16,
                          ((first->value.endAddress - 1) >> 16) & 0xFF,
                          ((first->value.endAddress - 1) >> 8) & 0xFF,
                          (unsigned __int8)(first->value.endAddress - 1),
                          readLine);
                      if ( ipRange.endAddress < first->value.endAddress )
                        ipRange.endAddress = first->value.endAddress;
                      first = std::vector_IPRange::erase(&this_->m_addresses, first);
                    }
                    std::vector_IPRange::insert(&this_->m_addresses, first, &ipRange);
                  }
                  else
                  {
                    if ( first->value.endAddress != ipRange.startAddress )
                      LogWindow::Add(
                        &g_LogWindow,
                        3,
                        aIplistAddressI,
                        (unsigned __int16)(first->value.startAddress >> 16) >> 16,
                        (first->value.startAddress >> 16) & 0xFF,
                        (first->value.startAddress >> 8) & 0xFF,
                        first->value.startAddress & 0xFF,
                        (unsigned __int16)((first->value.endAddress - 1) >> 16) >> 16,
                        ((first->value.endAddress - 1) >> 16) & 0xFF,
                        ((first->value.endAddress - 1) >> 8) & 0xFF,
                        (unsigned __int8)(first->value.endAddress - 1),
                        readLine);
                    symbol = first->value.endAddress;
                    if ( symbol < ipRange.endAddress )
                    {
                      ipRange.startAddress = first->value.startAddress;
                      first = std::vector_IPRange::erase(&this_->m_addresses, first);
                      goto LABEL_28;
                    }
                  }
                }
                else
                {
                  LogWindow::Add(&g_LogWindow, 3, aIplistStartAdd, readLine);
                }
              }
            }
          }
        }
      }
    }
  }
  ReadWriteLock::releaseWriteLock(&this_->m_lock);
  LogWindow::Add(&g_LogWindow, 0, aIplistLoadedFr, fileName);
  unused = -1;
  std::istrstream::`vbase destructor((int)&reader);
  return 1;
}

//----- (0041ECDF) --------------------------------------------------------
BOOL __thiscall IPList::contains(IPList *this, unsigned int ipAddress)
{
  std::vector_IPRange::iterator *end; // ST04_4@1
  std::vector_IPRange::iterator *begin; // eax@1
  int result_1; // [sp+0h] [bp-14h]@3
  IPList *this_; // [sp+4h] [bp-10h]@1
  std::vector_IPRange::iterator *found; // [sp+8h] [bp-Ch]@1
  unsigned int ipAddressSmallEndian; // [sp+Ch] [bp-8h]@1
  int result_2; // [sp+10h] [bp-4h]@5

  this_ = this;
  ReadWriteLock::readLock(&this->m_lock);
  ipAddressSmallEndian = _byteswap_ulong(ipAddress);
  end = std::vector_IPRange::end(&this_->m_addresses);
  begin = std::vector_IPRange::begin(&this_->m_addresses);
  found = std::algorithm::lower_bound(begin, end, &ipAddressSmallEndian);// lower_bounds looking for endAddress, so it checks is ipAddress in one of the range
  result_1 = found != std::vector_IPRange::end(&this_->m_addresses) && found->value.startAddress <= ipAddressSmallEndian;
  result_2 = result_1;
  ReadWriteLock::releaseReadLock(&this_->m_lock);
  return result_2;
}

//----- (0041EDA3) --------------------------------------------------------
int sub_41EDA3()
{
  return atexit(emptystub);
}

//----- (0041EDB5) --------------------------------------------------------
int sub_41EDB5()
{
  return atexit(sub_4242C0);
}

//----- (0041EDD0) --------------------------------------------------------
void *__thiscall sub_41EDD0(void *this, char a2)
{
  void *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  IpRegistry::Destructor((IpRegistry *)this);
  if ( a2 & 1 )
    _delete_table(v3);
  return v3;
}

//----- (0041EE00) --------------------------------------------------------
#1023 *__thiscall sub_41EE00(#1023 *this)
{
  char v2; // [sp+4h] [bp-8h]@1
  char v3; // [sp+8h] [bp-4h]@1

  return sub_41EF20(this, &v2, &v3);
}

//----- (0041EE60) --------------------------------------------------------
std::vector_IPRange *__thiscall IPList::Destructor(IPList *this)
{
  IPList *v1; // ST00_4@1

  v1 = this;
  ReadWriteLock::Destructor(&this->m_lock);
  return std::vector_IPRange::Destructor(&v1->m_addresses);
}

//----- (0041EEE0) --------------------------------------------------------
int __fastcall std::basic_istream::getline(int a1, int a2, _BYTE *a3, int a4)
{
  int v4; // ST0C_4@1
  unsigned __int8 v5; // cf@1
  char v6; // al@1
  int v7; // edx@1

  v4 = a1;
  v5 = __CFADD__(*(_DWORD *)(*(_DWORD *)a1 + 4), a1);
  v6 = Myios::widen(10);                        // \n
  return sub_4200F0(v4, v7, a3, a4, v6);
}

//----- (0041EF20) --------------------------------------------------------
#1023 *__thiscall sub_41EF20(#1023 *this, _BYTE *a2, _BYTE *a3)
{
  #1023 *v3; // ST08_4@1

  v3 = this;
  sub_4207F0((void *)this, a2, a3);
  return v3;
}

//----- (0041EF40) --------------------------------------------------------
std::_tree_int_int::iterator *__thiscall std::map_ip::end(std::map_int_int *this, std::_tree_int_int::iterator *a2)
{
  sub_420850(&this->_Tr, a2);
  return a2;
}

//----- (0041EF60) --------------------------------------------------------
int __thiscall std::map_ip::insert(std::map_int_int *this, int a2, std::pair_int_int *a3)
{
  int v4; // [sp+4h] [bp-8h]@1
  char v5; // [sp+8h] [bp-4h]@1

  sub_420870(this, (int)&v4, (struct Concurrency::IExecutionContext *)a3);
  sub_421830(a2, &v4, &v5);
  return a2;
}

//----- (0041EFA0) --------------------------------------------------------
_DWORD *__thiscall std::map_ip::erase(std::map_int_int *this, _DWORD *a2, int a3)
{
  sub_420A80((std::_tree *)this, a2, a3);
  return a2;
}

//----- (0041EFC0) --------------------------------------------------------
std::_tree_int_int::iterator *__thiscall std::map_ip::find(std::map_int_int *this, _DWORD *a2, _DWORD *a3)
{
  sub_421460(this, a2, a3);
  return (std::_tree_int_int::iterator *)a2;
}

//----- (0041EFE0) --------------------------------------------------------
void __thiscall sub_41EFE0(std::_tree *this)
{
  std::_tree_int_int::_Node *v1; // ST08_4@1
  int *v2; // eax@1
  std::_tree *v3; // [sp+0h] [bp-18h]@1
  char v4; // [sp+4h] [bp-14h]@1
  char v5; // [sp+8h] [bp-10h]@1
  char v6; // [sp+Ch] [bp-Ch]@1
  char v7; // [sp+10h] [bp-8h]@1
  void *v8; // [sp+14h] [bp-4h]@1

  v3 = this;
  v1 = sub_420850((std::_tree_int_int *)this, (std::_tree_int_int::iterator *)&v6)->_Ptr;
  v2 = (int *)sub_420820(v3, (int)&v5);
  sub_421360(v3, &v4, *v2, (char)v1);
  Concurrency::details::_NonReentrantPPLLock::_Acquire(v3, v3->_Head);
  v3->_Head = 0;
  v3->_Size = 0;
  v8 = 0;
  std::_Lockit::_Lockit((std::_Lockit *)&v7);
  if ( !--dword_47F52C )
  {
    v8 = (void *)dword_47F528;
    dword_47F528 = 0;
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v7);
  if ( v8 )
    Concurrency::details::_NonReentrantPPLLock::_Acquire(v3, v8);
}
// 47F528: using guessed type int dword_47F528;
// 47F52C: using guessed type int dword_47F52C;

//----- (0041F090) --------------------------------------------------------
std::pair_int_int *__thiscall std::pair_unt_int(std::pair_int_int *this, _DWORD *a2, _DWORD *a3)
{
  this->first = *a2;
  this->second = *a3;
  return this;
}

//----- (0041F100) --------------------------------------------------------
BOOL __thiscall std::map_ip::iterator::not_equal(void *this, _DWORD *a2)
{
  return (unsigned __int8)sub_421550(this, a2) == 0;
}

//----- (0041F130) --------------------------------------------------------
std::vector_IPRange *__thiscall std::vector_IPRange::vector_IPRange(std::vector_IPRange *this, _BYTE *a2)
{
  this->allocator = *a2;
  this->_First = 0;
  this->_Last = 0;
  this->_End = 0;
  return this;
}

//----- (0041F170) --------------------------------------------------------
std::vector_IPRange *__thiscall std::vector_IPRange::Destructor(std::vector_IPRange *this)
{
  std::vector_IPRange *v1; // ST08_4@1
  std::vector_IPRange *result; // eax@1

  v1 = this;
  std::vector_IPRange::Destroy(this->_First, this->_Last);
  std::vector_IPRange::allocator_deallocate(v1->_First, v1->_End - v1->_First);
  result = v1;
  v1->_First = 0;
  v1->_Last = 0;
  v1->_End = 0;
  return result;
}

//----- (0041F210) --------------------------------------------------------
std::vector_IPRange::iterator *__thiscall std::vector_IPRange::insert(std::vector_IPRange *this, std::vector_IPRange::iterator *a2, IPRange *value)
{
  std::vector_IPRange *v3; // ST0C_4@1
  signed int v4; // ST10_4@1

  v3 = this;
  v4 = a2 - std::vector_IPRange::begin(this);
  std::vector_IPRange::insert_2(v3, a2, 1u, value);
  return &std::vector_IPRange::begin(v3)[v4];
}

//----- (0041F260) --------------------------------------------------------
std::vector_IPRange::iterator *__thiscall std::vector_IPRange::erase(std::vector_IPRange *this, std::vector_IPRange::iterator *a3)
{
  std::vector_IPRange *v2; // ST0C_4@1
  std::vector_IPRange::iterator *v3; // eax@1

  v2 = this;
  v3 = std::vector_IPRange::end(this);
  sub_423930(a3 + 1, v3, a3);
  std::vector_IPRange::Destroy(v2->_Last - 1, v2->_Last);
  --v2->_Last;
  return a3;
}

//----- (0041F2C0) --------------------------------------------------------
std::vector_IPRange::iterator *__thiscall std::vector_IPRange::clear(std::vector_IPRange *this)
{
  std::vector_IPRange *v1; // ST08_4@1
  std::vector_IPRange::iterator *v2; // ST04_4@1
  std::vector_IPRange::iterator *v3; // eax@1

  v1 = this;
  v2 = std::vector_IPRange::end(this);
  v3 = std::vector_IPRange::begin(v1);
  return std::vector_IPRange::erase_3(v1, v3, v2);
}

//----- (0041F2F0) --------------------------------------------------------
int __thiscall sub_41F2F0(int this, char *a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-14h]@1

  v5 = this;
  if ( a4 )
  {
    *(_DWORD *)this = &unk_45F614;
    std::basic_ios::basic_ios((std::ios_base *)(this + 92));
  }
  sub_40B240((int *)v5, v5 + 8, v5 + 8, 0, 0);
  sub_421860((void *)(v5 + 8), 0);
  *(_DWORD *)(v5 + *(_DWORD *)(*(_DWORD *)v5 + 4)) = &off_45F610;
  if ( !sub_4218D0(v5 + 8, a2, a3 | 1) )
    I_setstate((void *)(*(_DWORD *)(*(_DWORD *)v5 + 4) + v5), 2, 0);
  return v5;
}
// 45F610: using guessed type int (__stdcall *off_45F610)(int);

//----- (0041F440) --------------------------------------------------------
int __thiscall sub_41F440(__int32 this)
{
  __int32 v2; // [sp+4h] [bp-18h]@1
  void *v3; // [sp+Ch] [bp-10h]@3

  v2 = this;
  *(_DWORD *)this = off_45F61C;
  if ( *(_BYTE *)(this + 72) )
    std::basic_filebuf<char,std::char_traits<char>>::close(this);
  v3 = *(void **)(v2 + 68);
  if ( v3 )
    sub_41FD20(v3, 1);
  std::locale::~locale((std::locale *)(v2 + 76));
  return sub_40B490(v2);
}
// 421920: using guessed type int __thiscall std::basic_filebuf<char,std::char_traits<char>>::close(_DWORD);
// 45F61C: using guessed type int (__stdcall *off_45F61C[3])(int);

//----- (0041F8C0) --------------------------------------------------------
int __thiscall sub_41F8C0(void *this)
{
  unsigned int v1; // esi@2
  int v2; // eax@3
  int result; // eax@3
  int v4; // eax@4
  void *v5; // [sp+4h] [bp-4h]@1

  v5 = this;
  if ( std::basic_streambuf<wchar_t,std::char_traits<wchar_t>>::gptr(this)
    && (v1 = std::basic_streambuf<wchar_t,std::char_traits<wchar_t>>::gptr(v5),
        v1 < std::basic_streambuf<char,std::char_traits<char>>::egptr(v5)) )
  {
    v2 = std::basic_streambuf<wchar_t,std::char_traits<wchar_t>>::gptr(v5);
    result = std::char_traits<char>::to_int_type(v2);
  }
  else
  {
    v4 = (*(int (__thiscall **)(void *))(*(_DWORD *)v5 + 20))(v5);
    result = (*(int (__thiscall **)(void *, int))(*(_DWORD *)v5 + 8))(v5, v4);
  }
  return result;
}
// 40B580: using guessed type _DWORD __cdecl std::char_traits<char>::to_int_type(_DWORD);
// 40B6E0: using guessed type int __thiscall std::basic_streambuf<wchar_t,std::char_traits<wchar_t>>::gptr(_DWORD);
// 40BD70: using guessed type int __thiscall std::basic_streambuf<char,std::char_traits<char>>::egptr(_DWORD);

//----- (0041FCF0) --------------------------------------------------------
void *__thiscall sub_41FCF0(void *this, char a2)
{
  void *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  sub_41F440((__int32)this);
  if ( a2 & 1 )
    _delete_table(v3);
  return v3;
}

//----- (0041FD20) --------------------------------------------------------
void *__thiscall sub_41FD20(void *this, char a2)
{
  void *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  sub_41FD50();
  if ( a2 & 1 )
    _delete_table(v3);
  return v3;
}

//----- (0041FD50) --------------------------------------------------------
int sub_41FD50()
{
  return std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(1);
}
// 41FF10: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(_DWORD);

//----- (0041FEC0) --------------------------------------------------------
int __thiscall sub_41FEC0(_DWORD *this)
{
  _DWORD *v1; // ST00_4@1

  v1 = this;
  sub_421A20((int)this);
  return v1[1];
}

//----- (0041FEE0) --------------------------------------------------------
int __thiscall sub_41FEE0(_DWORD *this)
{
  _DWORD *v1; // ST08_4@1

  v1 = this;
  sub_421A20((int)this);
  return std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Psum(v1[1], v1[2]);
}
// 421BE0: using guessed type _DWORD __cdecl std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Psum(_DWORD, _DWORD);

//----- (0041FFD0) --------------------------------------------------------
int __stdcall Myios::widen(char a1)
{
  std::locale *v1; // eax@1
  char v3; // [sp+Ch] [bp-14h]@1
  int v4; // [sp+10h] [bp-10h]@1
  int v5; // [sp+1Ch] [bp-4h]@1

  v1 = (std::locale *)std::ios_base::getloc(&v3);
  v5 = 0;
  v4 = std::use_facet(v1, 0, 1);
  v5 = -1;
  std::locale::~locale((std::locale *)&v3);
  return std::ctype<char>::do_widen(a1);
}
// 420760: using guessed type _DWORD __stdcall std::ctype<char>::do_widen(char);
// 4212F0: using guessed type int __stdcall std::ios_base::getloc(_DWORD);

//----- (004200F0) --------------------------------------------------------
int __fastcall sub_4200F0(int a1, int a2, _BYTE *a3, int a4, char a5)
{
  int v6; // [sp+0h] [bp-58h]@1
  int v7; // [sp+Ch] [bp-4Ch]@13
  char v8; // [sp+13h] [bp-45h]@10
  void *v9; // [sp+14h] [bp-44h]@7
  int v10; // [sp+18h] [bp-40h]@4
  int v11; // [sp+1Ch] [bp-3Ch]@4
  int v12; // [sp+20h] [bp-38h]@10
  void *v13; // [sp+24h] [bp-34h]@10
  int v14; // [sp+28h] [bp-30h]@3
  int v15; // [sp+2Ch] [bp-2Ch]@3
  int v16; // [sp+30h] [bp-28h]@1
  int v17; // [sp+34h] [bp-24h]@4
  int i; // [sp+38h] [bp-20h]@3
  int v19; // [sp+3Ch] [bp-1Ch]@3
  char v20; // [sp+40h] [bp-18h]@1
  int v21; // [sp+44h] [bp-14h]@1
  int *v22; // [sp+48h] [bp-10h]@1
  int v23; // [sp+54h] [bp-4h]@3

  v22 = &v6;
  v16 = a1;
  v21 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  Myis::sentry(&v20, a2, v16, 1);
  if ( sub_420340(&v20) && a4 > 0 )
  {
    v19 = std::char_traits<char>::to_int_type(&a5);
    v23 = 0;
    v15 = unknown_libname_110(*(_DWORD *)(*(_DWORD *)v16 + 4) + v16);
    v14 = std::basic_streambuf<char,std::char_traits<char>>::sgetc(v15);
    for ( i = v14; ; i = v12 )
    {
      v11 = std::char_traits<char>::eof();
      v17 = v11;
      LOBYTE(v10) = std::char_traits<char>::eq_int_type(&v17, &i);
      if ( (_BYTE)v10 )
      {
        v21 |= 1u;
        goto LABEL_11;
      }
      if ( i == v19 )
      {
        ++*(_DWORD *)(v16 + 4);
        v9 = (void *)unknown_libname_110(*(_DWORD *)(*(_DWORD *)v16 + 4) + v16);
        sub_421D60(v9);
        goto LABEL_11;
      }
      if ( --a4 <= 0 )
        break;
      ++*(_DWORD *)(v16 + 4);
      v8 = std::char_traits<char>::to_char_type(&i);
      *a3++ = v8;
      v13 = (void *)unknown_libname_110(*(_DWORD *)(*(_DWORD *)v16 + 4) + v16);
      v12 = sub_4203B0(v13);
    }
    v21 |= 2u;
LABEL_11:
    v23 = -1;
  }
  *a3 = 0;
  if ( *(_DWORD *)(v16 + 4) )
    v7 = v21;
  else
    v7 = v21 | 2;
  I_setstate((void *)(*(_DWORD *)(*(_DWORD *)v16 + 4) + v16), v7, 0);
  return v16;
}
// 40B4D0: using guessed type int std::char_traits<char>::eof(void);
// 40B580: using guessed type _DWORD __cdecl std::char_traits<char>::to_int_type(_DWORD);
// 40B590: using guessed type _DWORD __cdecl std::char_traits<char>::eq_int_type(_DWORD, _DWORD);
// 40B6D0: using guessed type _DWORD __cdecl std::char_traits<char>::to_char_type(_DWORD);
// 4202F0: using guessed type int __thiscall unknown_libname_110(_DWORD);
// 420350: using guessed type int __thiscall std::basic_streambuf<char,std::char_traits<char>>::sgetc(_DWORD);

//----- (00420310) --------------------------------------------------------
char *__fastcall Myis::sentry(char *a1, int a2, int a3, char a4)
{
  char *v4; // ST04_4@1

  v4 = a1;
  *a1 = sub_420410(a3, a2, a4);
  return v4;
}

//----- (00420340) --------------------------------------------------------
char __thiscall sub_420340(void *this)
{
  return *(_BYTE *)this;
}

//----- (004203B0) --------------------------------------------------------
int __thiscall sub_4203B0(void *this)
{
  int v2; // [sp+0h] [bp-10h]@2
  void *v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1
  int v5; // [sp+Ch] [bp-4h]@1

  v3 = this;
  v5 = std::basic_streambuf<char,std::char_traits<char>>::sbumpc(this);
  v4 = std::char_traits<char>::eof();
  if ( (unsigned __int8)std::char_traits<char>::eq_int_type(&v4, &v5) )
    v2 = std::char_traits<char>::eof();
  else
    v2 = std::basic_streambuf<char,std::char_traits<char>>::sgetc(v3);
  return v2;
}
// 40B4D0: using guessed type int std::char_traits<char>::eof(void);
// 40B590: using guessed type _DWORD __cdecl std::char_traits<char>::eq_int_type(_DWORD, _DWORD);
// 420350: using guessed type int __thiscall std::basic_streambuf<char,std::char_traits<char>>::sgetc(_DWORD);
// 4206E0: using guessed type int __thiscall std::basic_streambuf<char,std::char_traits<char>>::sbumpc(_DWORD);

//----- (00420410) --------------------------------------------------------
char __fastcall sub_420410(int a1, int a2, char a3)
{
  char *v3; // eax@3
  unsigned __int8 v4; // cf@6
  int v5; // ecx@8
  char result; // al@12
  int v7; // [sp+0h] [bp-58h]@1
  int v8; // [sp+Ch] [bp-4Ch]@9
  void *v9; // [sp+10h] [bp-48h]@9
  int v10; // [sp+14h] [bp-44h]@8
  char v11; // [sp+1Bh] [bp-3Dh]@8
  int v12; // [sp+1Ch] [bp-3Ch]@7
  int v13; // [sp+20h] [bp-38h]@7
  int v14; // [sp+24h] [bp-34h]@6
  int v15; // [sp+28h] [bp-30h]@6
  std::locale *v16; // [sp+2Ch] [bp-2Ch]@6
  std::locale *v17; // [sp+30h] [bp-28h]@6
  int v18; // [sp+34h] [bp-24h]@1
  int v19; // [sp+38h] [bp-20h]@7
  char v20; // [sp+3Ch] [bp-1Ch]@6
  int i; // [sp+40h] [bp-18h]@6
  int v22; // [sp+44h] [bp-14h]@6
  int *v23; // [sp+48h] [bp-10h]@1
  int v24; // [sp+54h] [bp-4h]@6

  v23 = &v7;
  v18 = a1;
  if ( !(unsigned __int8)sub_420A40((void *)(*(_DWORD *)(*(_DWORD *)a1 + 4) + a1)) )
    goto LABEL_16;
  if ( unknown_libname_116(*(_DWORD *)(*(_DWORD *)v18 + 4) + v18) )
  {
    v3 = (char *)unknown_libname_116(*(_DWORD *)(*(_DWORD *)v18 + 4) + v18);
    sub_420620(v3);
  }
  if ( !a3 && unknown_libname_111(*(_DWORD *)(*(_DWORD *)v18 + 4) + v18) & 1 )
  {
    v4 = __CFADD__(*(_DWORD *)(*(_DWORD *)v18 + 4), v18);
    v17 = (std::locale *)std::ios_base::getloc(&v20);
    v16 = v17;
    v24 = 0;
    v22 = std::use_facet(v17, 0, 1);
    v24 = -1;
    std::locale::~locale((std::locale *)&v20);
    v24 = 1;
    v15 = unknown_libname_110(*(_DWORD *)(*(_DWORD *)v18 + 4) + v18);
    v14 = std::basic_streambuf<char,std::char_traits<char>>::sgetc(v15);
    for ( i = v14; ; i = v8 )
    {
      v13 = std::char_traits<char>::eof();
      v19 = v13;
      LOBYTE(v12) = std::char_traits<char>::eq_int_type(&v19, &i);
      if ( (_BYTE)v12 )
        break;
      v11 = std::char_traits<char>::to_char_type(&i);
      LOBYTE(v5) = v11;
      LOBYTE(v10) = std::ctype<char>::is(72, v5);
      if ( !(_BYTE)v10 )
        break;
      v9 = (void *)unknown_libname_110(*(_DWORD *)(*(_DWORD *)v18 + 4) + v18);
      v8 = sub_4203B0(v9);
    }
    v24 = -1;
  }
  if ( (unsigned __int8)sub_420A40((void *)(*(_DWORD *)(*(_DWORD *)v18 + 4) + v18)) )
  {
    result = 1;
  }
  else
  {
LABEL_16:
    I_setstate((void *)(*(_DWORD *)(*(_DWORD *)v18 + 4) + v18), 2, 0);
    result = 0;
  }
  return result;
}
// 40B4D0: using guessed type int std::char_traits<char>::eof(void);
// 40B590: using guessed type _DWORD __cdecl std::char_traits<char>::eq_int_type(_DWORD, _DWORD);
// 40B6D0: using guessed type _DWORD __cdecl std::char_traits<char>::to_char_type(_DWORD);
// 4202F0: using guessed type int __thiscall unknown_libname_110(_DWORD);
// 420350: using guessed type int __thiscall std::basic_streambuf<char,std::char_traits<char>>::sgetc(_DWORD);
// 420690: using guessed type _DWORD __stdcall std::ctype<char>::is(__int16, _DWORD);
// 4212D0: using guessed type int __thiscall unknown_libname_111(_DWORD);
// 4212F0: using guessed type int __stdcall std::ios_base::getloc(_DWORD);
// 421D40: using guessed type int __thiscall unknown_libname_116(_DWORD);

//----- (00420620) --------------------------------------------------------
char *__thiscall sub_420620(char *this)
{
  int v1; // eax@2
  char *v3; // [sp+0h] [bp-8h]@1
  int v4; // [sp+4h] [bp-4h]@1

  v3 = this;
  v4 = 0;
  if ( !(unsigned __int8)std::ios_base::fail((std::ios_base *)&this[*(_DWORD *)(*(_DWORD *)this + 4)]) )
  {
    v1 = unknown_libname_110(&v3[*(_DWORD *)(*(_DWORD *)v3 + 4)]);
    if ( sub_4206C0(v1) == -1 )
      v4 = 4;
  }
  I_setstate(&v3[*(_DWORD *)(*(_DWORD *)v3 + 4)], v4, 0);
  return v3;
}
// 4202F0: using guessed type int __thiscall unknown_libname_110(_DWORD);
// 4206C0: using guessed type int __thiscall sub_4206C0(_DWORD);

//----- (004207F0) --------------------------------------------------------
void *__thiscall sub_4207F0(void *this, _BYTE *a2, _BYTE *a3)
{
  void *v3; // ST0C_4@1

  v3 = this;
  sub_421E80((int)this, a2, 0, a3);
  return v3;
}

//----- (00420820) --------------------------------------------------------
int __thiscall sub_420820(void *this, int a2)
{
  int *v2; // eax@1

  v2 = (int *)sub_422470((int)this);
  unknown_libname_123((void *)a2, *v2);
  return a2;
}

//----- (00420850) --------------------------------------------------------
std::_tree_int_int::iterator *__thiscall sub_420850(std::_tree_int_int *this, std::_tree_int_int::iterator *a2)
{
  unknown_libname_123(a2, (int)this->_Head);
  return a2;
}

//----- (00420870) --------------------------------------------------------
int __thiscall sub_420870(void *this, int a2, struct Concurrency::IExecutionContext *a3)
{
  struct Concurrency::details::InternalContextBase *v3; // ST10_4@3
  struct Concurrency::details::InternalContextBase *v4; // eax@3
  _DWORD *v5; // eax@8
  int result; // eax@8
  _DWORD *v7; // eax@10
  _DWORD *v8; // eax@11
  struct Concurrency::details::InternalContextBase *v9; // ST10_4@13
  int v10; // eax@13
  struct Concurrency::details::InternalContextBase *v11; // eax@13
  _DWORD *v12; // eax@14
  int v13; // [sp+0h] [bp-40h]@4
  void *v14; // [sp+4h] [bp-3Ch]@1
  char v15; // [sp+8h] [bp-38h]@15
  int v16; // [sp+Ch] [bp-34h]@14
  char v17; // [sp+10h] [bp-30h]@14
  char v18; // [sp+14h] [bp-2Ch]@13
  int v19; // [sp+18h] [bp-28h]@11
  char v20; // [sp+1Ch] [bp-24h]@11
  char v21; // [sp+20h] [bp-20h]@10
  int v22; // [sp+24h] [bp-1Ch]@8
  char v23; // [sp+28h] [bp-18h]@8
  char v24; // [sp+2Ch] [bp-14h]@3
  int v25; // [sp+30h] [bp-10h]@1
  int v26; // [sp+34h] [bp-Ch]@1
  int v27; // [sp+38h] [bp-8h]@1
  char v28; // [sp+3Ch] [bp-4h]@9

  v14 = this;
  v26 = *(_DWORD *)sub_422660((int)this);
  v25 = *((_DWORD *)v14 + 1);
  LOBYTE(v27) = 1;
  while ( v26 != dword_47F528 )
  {
    v25 = v26;
    v3 = sub_421DF0(v26);
    v4 = Concurrency::details::VirtualProcessor::ToInternalContext((Concurrency::details::VirtualProcessor *)&v24, a3);
    LOBYTE(v27) = sub_41AD90(v4, v3);
    if ( (_BYTE)v27 )
      v13 = *(_DWORD *)unknown_libname_118(v26);
    else
      v13 = *(_DWORD *)sub_421E60(v26);
    v26 = v13;
  }
  if ( *((_BYTE *)v14 + 8) )
  {
    v23 = 1;
    v5 = (_DWORD *)sub_421FE0(v14, (int)&v22, v26, v25, a3);
    sub_421830(a2, v5, &v23);
    return a2;
  }
  unknown_libname_123(&v28, v25);
  if ( (_BYTE)v27 )
  {
    v7 = (_DWORD *)sub_420820(v14, (int)&v21);
    if ( (unsigned __int8)sub_421550(&v28, v7) )
    {
      v20 = 1;
      v8 = (_DWORD *)sub_421FE0(v14, (int)&v19, v26, v25, a3);
      sub_421830(a2, v8, &v20);
      return a2;
    }
    unknown_libname_124(&v28);
  }
  v9 = Concurrency::details::VirtualProcessor::ToInternalContext((Concurrency::details::VirtualProcessor *)&v18, a3);
  v10 = unknown_libname_122(&v28);
  v11 = sub_421DF0(v10);
  if ( (unsigned __int8)sub_41AD90(v11, v9) )
  {
    v17 = 1;
    v12 = (_DWORD *)sub_421FE0(v14, (int)&v16, v26, v25, a3);
    sub_421830(a2, v12, &v17);
    result = a2;
  }
  else
  {
    v15 = 0;
    sub_421830(a2, &v28, &v15);
    result = a2;
  }
  return result;
}
// 421E10: using guessed type _DWORD __cdecl unknown_libname_118(_DWORD);
// 4227D0: using guessed type int __thiscall unknown_libname_122(_DWORD);
// 422830: using guessed type int __thiscall unknown_libname_124(_DWORD);
// 47F528: using guessed type int dword_47F528;

//----- (00420A40) --------------------------------------------------------
BOOL __thiscall sub_420A40(void *this)
{
  return unknown_libname_29((int)this) == 0;
}

//----- (00420A80) --------------------------------------------------------
_DWORD *__thiscall sub_420A80(std::_tree *this, _DWORD *a2, int a3)
{
  _DWORD *v3; // eax@1
  int *v4; // eax@5
  int *v5; // eax@7
  void **v6; // eax@7
  _DWORD *v7; // esi@7
  void **v8; // eax@7
  void **v9; // eax@8
  _DWORD *v10; // esi@9
  _DWORD *v11; // eax@9
  _DWORD *v12; // eax@9
  _DWORD *v13; // esi@9
  int *v14; // eax@9
  void **v15; // eax@9
  void **v16; // eax@10
  void **v17; // eax@11
  _DWORD *v18; // eax@12
  void **v19; // eax@12
  _DWORD *v20; // eax@13
  void **v21; // eax@13
  int *v22; // eax@14
  void **v23; // eax@14
  _DWORD *v24; // esi@15
  int *v25; // ST04_4@15
  int *v26; // eax@15
  _DWORD *v27; // esi@16
  void **v28; // eax@16
  _DWORD *v29; // eax@17
  _DWORD *v30; // eax@18
  void **v31; // eax@18
  _DWORD *v32; // eax@19
  _DWORD *v33; // eax@19
  int *v34; // eax@20
  _DWORD *v35; // eax@20
  void **v36; // eax@21
  _DWORD *v37; // esi@23
  int v38; // esi@24
  void **v39; // eax@25
  _DWORD *v40; // esi@27
  int v41; // esi@28
  _DWORD *v42; // eax@30
  _DWORD *v43; // eax@32
  _DWORD *v44; // eax@32
  int *v45; // eax@33
  int *v46; // eax@34
  int *v47; // eax@34
  int *v48; // eax@34
  int *v49; // eax@35
  int *v50; // eax@36
  int *v51; // eax@38
  int *v52; // eax@39
  int *v53; // eax@39
  int *v54; // eax@40
  _DWORD *v55; // esi@40
  int *v56; // eax@40
  int *v57; // eax@40
  int *v58; // eax@40
  _DWORD *v59; // eax@41
  int *v60; // eax@42
  int *v61; // eax@42
  _DWORD *v62; // eax@42
  int *v63; // eax@43
  int *v64; // eax@44
  int *v65; // eax@46
  int *v66; // eax@47
  _DWORD *v67; // eax@47
  int *v68; // eax@48
  _DWORD *v69; // esi@48
  int *v70; // eax@48
  int *v71; // eax@48
  int *v72; // eax@48
  int v73; // eax@51
  std::_tree *v75; // [sp+4h] [bp-2Ch]@1
  char v76; // [sp+8h] [bp-28h]@1
  int v77; // [sp+Ch] [bp-24h]@41
  int v78; // [sp+10h] [bp-20h]@33
  char v79; // [sp+14h] [bp-1Ch]@6
  void *v80; // [sp+18h] [bp-18h]@1
  void *v81; // [sp+1Ch] [bp-14h]@1
  int v82; // [sp+20h] [bp-10h]@2
  int v83; // [sp+2Ch] [bp-4h]@6

  v75 = this;
  v3 = sub_422800(&a3, &v76, 0);
  v81 = (void *)unknown_libname_122(v3);
  v80 = v81;
  if ( *(_DWORD *)unknown_libname_118(v81) == dword_47F528 )
  {
    v82 = *(_DWORD *)sub_421E60((int)v81);
  }
  else if ( *(_DWORD *)sub_421E60((int)v81) == dword_47F528 )
  {
    v82 = *(_DWORD *)unknown_libname_118(v81);
  }
  else
  {
    v4 = (int *)sub_421E60((int)v81);
    v81 = (void *)sub_422600(*v4);
    v82 = *(_DWORD *)sub_421E60((int)v81);
  }
  std::_Lockit::_Lockit((std::_Lockit *)&v79);
  v83 = 0;
  if ( v81 == v80 )
  {
    v27 = (_DWORD *)sub_421E50((int)v81);
    *(_DWORD *)sub_421E50(v82) = *v27;
    v28 = (void **)sub_422660((int)v75);
    if ( *v28 == v80 )
    {
      v29 = (_DWORD *)sub_422660((int)v75);
      *v29 = v82;
    }
    else
    {
      v30 = (_DWORD *)sub_421E50((int)v80);
      v31 = (void **)unknown_libname_118(*v30);
      if ( *v31 == v80 )
      {
        v32 = (_DWORD *)sub_421E50((int)v80);
        v33 = (_DWORD *)unknown_libname_118(*v32);
        *v33 = v82;
      }
      else
      {
        v34 = (int *)sub_421E50((int)v80);
        v35 = (_DWORD *)sub_421E60(*v34);
        *v35 = v82;
      }
    }
    v36 = (void **)sub_422470((int)v75);
    if ( *v36 == v80 )
    {
      if ( *(_DWORD *)sub_421E60((int)v80) == dword_47F528 )
      {
        v37 = (_DWORD *)sub_421E50((int)v80);
        *(_DWORD *)sub_422470((int)v75) = *v37;
      }
      else
      {
        v38 = sub_422600(v82);
        *(_DWORD *)sub_422470((int)v75) = v38;
      }
    }
    v39 = (void **)sub_422640((int)v75);
    if ( *v39 == v80 )
    {
      if ( *(_DWORD *)unknown_libname_118(v80) == dword_47F528 )
      {
        v40 = (_DWORD *)sub_421E50((int)v80);
        *(_DWORD *)sub_422640((int)v75) = *v40;
      }
      else
      {
        v41 = sub_4225C0(v82);
        *(_DWORD *)sub_422640((int)v75) = v41;
      }
    }
  }
  else
  {
    v5 = (int *)unknown_libname_118(v80);
    v6 = (void **)sub_421E50(*v5);
    *v6 = v81;
    v7 = (_DWORD *)unknown_libname_118(v80);
    *(_DWORD *)unknown_libname_118(v81) = *v7;
    v8 = (void **)sub_421E60((int)v80);
    if ( v81 == *v8 )
    {
      v9 = (void **)sub_421E50(v82);
      *v9 = v81;
    }
    else
    {
      v10 = (_DWORD *)sub_421E50((int)v81);
      *(_DWORD *)sub_421E50(v82) = *v10;
      v11 = (_DWORD *)sub_421E50((int)v81);
      v12 = (_DWORD *)unknown_libname_118(*v11);
      *v12 = v82;
      v13 = (_DWORD *)sub_421E60((int)v80);
      *(_DWORD *)sub_421E60((int)v81) = *v13;
      v14 = (int *)sub_421E60((int)v80);
      v15 = (void **)sub_421E50(*v14);
      *v15 = v81;
    }
    v16 = (void **)sub_422660((int)v75);
    if ( *v16 == v80 )
    {
      v17 = (void **)sub_422660((int)v75);
      *v17 = v81;
    }
    else
    {
      v18 = (_DWORD *)sub_421E50((int)v80);
      v19 = (void **)unknown_libname_118(*v18);
      if ( *v19 == v80 )
      {
        v20 = (_DWORD *)sub_421E50((int)v80);
        v21 = (void **)unknown_libname_118(*v20);
        *v21 = v81;
      }
      else
      {
        v22 = (int *)sub_421E50((int)v80);
        v23 = (void **)sub_421E60(*v22);
        *v23 = v81;
      }
    }
    v24 = (_DWORD *)sub_421E50((int)v80);
    *(_DWORD *)sub_421E50((int)v81) = *v24;
    v25 = (int *)sub_421DE0((int)v80);
    v26 = (int *)sub_421DE0((int)v81);
    sub_4239F0(v26, v25);
    v81 = v80;
  }
  if ( *(_DWORD *)sub_421DE0((int)v81) == 1 )
  {
    while ( 1 )
    {
      v42 = (_DWORD *)sub_422660((int)v75);
      if ( v82 == *v42 || *(_DWORD *)sub_421DE0(v82) != 1 )
        break;
      v43 = (_DWORD *)sub_421E50(v82);
      v44 = (_DWORD *)unknown_libname_118(*v43);
      if ( v82 == *v44 )
      {
        v45 = (int *)sub_421E50(v82);
        v78 = *(_DWORD *)sub_421E60(*v45);
        if ( !*(_DWORD *)sub_421DE0(v78) )
        {
          *(_DWORD *)sub_421DE0(v78) = 1;
          v46 = (int *)sub_421E50(v82);
          *(_DWORD *)sub_421DE0(*v46) = 0;
          v47 = (int *)sub_421E50(v82);
          sub_422490(v75, *v47);
          v48 = (int *)sub_421E50(v82);
          v78 = *(_DWORD *)sub_421E60(*v48);
        }
        v49 = (int *)unknown_libname_118(v78);
        if ( *(_DWORD *)sub_421DE0(*v49) != 1 || (v50 = (int *)sub_421E60(v78), *(_DWORD *)sub_421DE0(*v50) != 1) )
        {
          v51 = (int *)sub_421E60(v78);
          if ( *(_DWORD *)sub_421DE0(*v51) == 1 )
          {
            v52 = (int *)unknown_libname_118(v78);
            *(_DWORD *)sub_421DE0(*v52) = 1;
            *(_DWORD *)sub_421DE0(v78) = 0;
            sub_422680(v75, v78);
            v53 = (int *)sub_421E50(v82);
            v78 = *(_DWORD *)sub_421E60(*v53);
          }
          v54 = (int *)sub_421E50(v82);
          v55 = (_DWORD *)sub_421DE0(*v54);
          *(_DWORD *)sub_421DE0(v78) = *v55;
          v56 = (int *)sub_421E50(v82);
          *(_DWORD *)sub_421DE0(*v56) = 1;
          v57 = (int *)sub_421E60(v78);
          *(_DWORD *)sub_421DE0(*v57) = 1;
          v58 = (int *)sub_421E50(v82);
          sub_422490(v75, *v58);
          break;
        }
        *(_DWORD *)sub_421DE0(v78) = 0;
        v82 = *(_DWORD *)sub_421E50(v82);
      }
      else
      {
        v59 = (_DWORD *)sub_421E50(v82);
        v77 = *(_DWORD *)unknown_libname_118(*v59);
        if ( !*(_DWORD *)sub_421DE0(v77) )
        {
          *(_DWORD *)sub_421DE0(v77) = 1;
          v60 = (int *)sub_421E50(v82);
          *(_DWORD *)sub_421DE0(*v60) = 0;
          v61 = (int *)sub_421E50(v82);
          sub_422680(v75, *v61);
          v62 = (_DWORD *)sub_421E50(v82);
          v77 = *(_DWORD *)unknown_libname_118(*v62);
        }
        v63 = (int *)sub_421E60(v77);
        if ( *(_DWORD *)sub_421DE0(*v63) != 1
          || (v64 = (int *)unknown_libname_118(v77), *(_DWORD *)sub_421DE0(*v64) != 1) )
        {
          v65 = (int *)unknown_libname_118(v77);
          if ( *(_DWORD *)sub_421DE0(*v65) == 1 )
          {
            v66 = (int *)sub_421E60(v77);
            *(_DWORD *)sub_421DE0(*v66) = 1;
            *(_DWORD *)sub_421DE0(v77) = 0;
            sub_422490(v75, v77);
            v67 = (_DWORD *)sub_421E50(v82);
            v77 = *(_DWORD *)unknown_libname_118(*v67);
          }
          v68 = (int *)sub_421E50(v82);
          v69 = (_DWORD *)sub_421DE0(*v68);
          *(_DWORD *)sub_421DE0(v77) = *v69;
          v70 = (int *)sub_421E50(v82);
          *(_DWORD *)sub_421DE0(*v70) = 1;
          v71 = (int *)unknown_libname_118(v77);
          *(_DWORD *)sub_421DE0(*v71) = 1;
          v72 = (int *)sub_421E50(v82);
          sub_422680(v75, *v72);
          break;
        }
        *(_DWORD *)sub_421DE0(v77) = 0;
        v82 = *(_DWORD *)sub_421E50(v82);
      }
    }
    *(_DWORD *)sub_421DE0(v82) = 1;
  }
  v83 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v79);
  v73 = sub_421E70((int)v81);
  sub_4227B0(v73);
  Concurrency::details::_NonReentrantPPLLock::_Acquire(v75, v81);
  --v75->_Size;
  *a2 = a3;
  return a2;
}
// 421E10: using guessed type _DWORD __cdecl unknown_libname_118(_DWORD);
// 4227D0: using guessed type int __thiscall unknown_libname_122(_DWORD);
// 47F528: using guessed type int dword_47F528;

//----- (00421360) --------------------------------------------------------
_DWORD *__thiscall sub_421360(void *this, _DWORD *a2, int a3, char a4)
{
  _DWORD *v4; // eax@2
  std::_tree_int_int::iterator *v5; // eax@3
  int *v6; // eax@5
  _DWORD *result; // eax@6
  void **v8; // eax@7
  std::_tree *v9; // [sp+0h] [bp-14h]@1
  char v10; // [sp+4h] [bp-10h]@5
  char v11; // [sp+8h] [bp-Ch]@5
  char v12; // [sp+Ch] [bp-8h]@3
  char v13; // [sp+10h] [bp-4h]@2

  v9 = (std::_tree *)this;
  if ( !unknown_libname_121()
    || (v4 = (_DWORD *)sub_420820(v9, (int)&v13), (unsigned __int8)std::map_ip::iterator::not_equal(&a3, v4))
    || (v5 = sub_420850((std::_tree_int_int *)v9, (std::_tree_int_int::iterator *)&v12),
        (unsigned __int8)std::map_ip::iterator::not_equal(&a4, v5)) )
  {
    while ( (unsigned __int8)std::map_ip::iterator::not_equal(&a3, &a4) )
    {
      v6 = sub_422800(&a3, &v11, 0);
      sub_420A80(v9, &v10, *v6);
    }
    *a2 = a3;
    result = a2;
  }
  else
  {
    v8 = (void **)sub_422660((int)v9);
    sub_421F60(v9, *v8);
    *(_DWORD *)sub_422660((int)v9) = dword_47F528;
    v9->_Size = 0;
    *(_DWORD *)sub_422470((int)v9) = v9->_Head;
    *(_DWORD *)sub_422640((int)v9) = v9->_Head;
    sub_420820(v9, (int)a2);
    result = a2;
  }
  return result;
}
// 421EE0: using guessed type int unknown_libname_121(void);
// 47F528: using guessed type int dword_47F528;

//----- (00421460) --------------------------------------------------------
_DWORD *__thiscall sub_421460(void *this, _DWORD *a2, _DWORD *a3)
{
  std::_tree_int_int::iterator *v3; // eax@1
  int v4; // eax@2
  struct Concurrency::details::InternalContextBase *v5; // eax@2
  std::_tree_int_int::iterator *v7; // [sp+0h] [bp-18h]@3
  std::_tree_int_int *v8; // [sp+4h] [bp-14h]@1
  char v9; // [sp+8h] [bp-10h]@4
  char v10; // [sp+Ch] [bp-Ch]@1
  std::_tree_int_int::iterator *v11; // [sp+10h] [bp-8h]@5
  char v12; // [sp+14h] [bp-4h]@1

  v8 = (std::_tree_int_int *)this;
  sub_421F30(this, (int)&v12, a3);
  v3 = sub_420850(v8, (std::_tree_int_int::iterator *)&v10);
  if ( (unsigned __int8)sub_421550(&v12, v3)
    || (v4 = unknown_libname_122(&v12), v5 = sub_421DF0(v4), (unsigned __int8)sub_41AD90(a3, v5)) )
  {
    v7 = sub_420850(v8, (std::_tree_int_int::iterator *)&v9);
  }
  else
  {
    v7 = (std::_tree_int_int::iterator *)&v12;
  }
  v11 = v7;
  *a2 = v7->_Ptr;
  return a2;
}
// 4227D0: using guessed type int __thiscall unknown_libname_122(_DWORD);

//----- (00421530) --------------------------------------------------------
int __thiscall sub_421530(int *this)
{
  return sub_421E70(*this);
}

//----- (00421550) --------------------------------------------------------
BOOL __thiscall sub_421550(void *this, _DWORD *a2)
{
  return *(_DWORD *)this == *a2;
}

//----- (00421570) --------------------------------------------------------
std::vector_IPRange *__thiscall std::vector_IPRange::insert_2(std::vector_IPRange *this, std::vector_IPRange::iterator *a2, unsigned int a3, IPRange *a4)
{
  int v4; // ST14_4@5
  void *v5; // ST18_4@5
  void *v6; // ST1C_4@5
  std::vector_IPRange *result; // eax@5
  unsigned int v8; // [sp+0h] [bp-14h]@3
  std::vector_IPRange *v9; // [sp+4h] [bp-10h]@1

  v9 = this;
  if ( this->_End - this->_Last >= a3 )
  {
    result = (std::vector_IPRange *)(this->_Last - a2);
    if ( (unsigned int)result >= a3 )
    {
      if ( a3 )
      {
        sub_422890((int)&this->_Last[-a3], (int)this->_Last, this->_Last);
        sub_423A50((int)a2, (int)&v9->_Last[-a3], (int)v9->_Last);
        sub_423A20((int)a2, (int)&a2[a3], (int)a4);
        result = (std::vector_IPRange *)a3;
        v9->_Last += a3;
      }
    }
    else
    {
      sub_422890((int)a2, (int)this->_Last, &a2[a3]);
      sub_4228D0(v9->_Last, a3 - (v9->_Last - a2), (int)a4);
      sub_423A20((int)a2, (int)v9->_Last, (int)a4);
      result = v9;
      v9->_Last += a3;
    }
  }
  else
  {
    if ( a3 >= std::vector_IPRange::size(this) )
      v8 = a3;
    else
      v8 = std::vector_IPRange::size(v9);
    v4 = v8 + std::vector_IPRange::size(v9);
    v5 = sub_422910(v4, 0);
    v6 = sub_422890((int)v9->_First, (int)a2, v5);
    sub_4228D0(v6, a3, (int)a4);
    sub_422890((int)a2, (int)v9->_Last, (char *)v6 + 8 * a3);
    std::vector_IPRange::Destroy(v9->_First, v9->_Last);
    std::vector_IPRange::allocator_deallocate(v9->_First, v9->_End - v9->_First);
    v9->_End = (std::vector_IPRange::iterator *)((char *)v5 + 8 * v4);
    v9->_Last = (std::vector_IPRange::iterator *)((char *)v5 + 8 * std::vector_IPRange::size(v9) + 8 * a3);
    result = v9;
    v9->_First = (std::vector_IPRange::iterator *)v5;
  }
  return result;
}

//----- (00421790) --------------------------------------------------------
std::vector_IPRange::iterator *__thiscall std::vector_IPRange::erase_3(std::vector_IPRange *this, std::vector_IPRange::iterator *a2, std::vector_IPRange::iterator *a3)
{
  std::vector_IPRange *v3; // ST0C_4@1
  std::vector_IPRange::iterator *v4; // eax@1
  std::vector_IPRange::iterator *a1; // ST10_4@1
  std::vector_IPRange::iterator *v6; // eax@1

  v3 = this;
  v4 = std::vector_IPRange::end(this);
  a1 = sub_423930(a3, v4, a2);
  v6 = std::vector_IPRange::end(v3);
  std::vector_IPRange::Destroy(a1, v6);
  v3->_Last = a1;
  return a2;
}

//----- (004217E0) --------------------------------------------------------
std::vector_IPRange::iterator *__stdcall std::vector_IPRange::Destroy(std::vector_IPRange::iterator *a1, std::vector_IPRange::iterator *a2)
{
  std::vector_IPRange::iterator *result; // eax@2

  while ( a1 != a2 )
  {
    some_stub((int)a1);
    result = a1 + 1;
    ++a1;
  }
  return result;
}

//----- (00421830) --------------------------------------------------------
int __thiscall sub_421830(int this, _DWORD *a2, _BYTE *a3)
{
  *(_DWORD *)this = *a2;
  *(_BYTE *)(this + 4) = *a3;
  return this;
}

//----- (00421860) --------------------------------------------------------
void *__thiscall sub_421860(void *this, int a2)
{
  void *v2; // ST08_4@1

  v2 = this;
  sub_40B300((int)this);
  std::locale::locale((std::locale *)((char *)v2 + 76));
  *(_DWORD *)v2 = off_45F61C;
  std::basic_filebuf<char,std::char_traits<char>>::_Init(a2, 0);
  return v2;
}
// 422950: using guessed type _DWORD __stdcall std::basic_filebuf<char,std::char_traits<char>>::_Init(_DWORD, _DWORD);
// 45F61C: using guessed type int (__stdcall *off_45F61C[3])(int);

//----- (004218D0) --------------------------------------------------------
void *__thiscall sub_4218D0(int this, char *a2, int a3)
{
  void *result; // eax@3
  void *v4; // [sp+0h] [bp-8h]@1
  struct _iobuf *v5; // [sp+4h] [bp-4h]@2

  v4 = (void *)this;
  if ( !*(_DWORD *)(this + 80) && (v5 = std::__Fiopen(a2, a3)) != 0 )
  {
    std::basic_filebuf<char,std::char_traits<char>>::_Init(v5, 1);
    sub_422A30(v4);
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 422950: using guessed type _DWORD __stdcall std::basic_filebuf<char,std::char_traits<char>>::_Init(_DWORD, _DWORD);

//----- (00421A20) --------------------------------------------------------
_BYTE *__thiscall sub_421A20(int this)
{
  _BYTE *result; // eax@1
  int v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  result = (_BYTE *)this;
  if ( *(_DWORD *)(this + 4) )
  {
    result = (_BYTE *)sub_421C10(*(_DWORD *)(this + 4));
    if ( *result )
    {
      result = (_BYTE *)sub_421C10(*(_DWORD *)(v2 + 4));
      if ( *result != 255 )
        result = (_BYTE *)std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(
                            *(_DWORD *)(v2 + 8),
                            0);
    }
  }
  if ( *(_DWORD *)(v2 + 4) )
  {
    result = (_BYTE *)sub_421C10(*(_DWORD *)(v2 + 4));
    *result = -1;
  }
  return result;
}
// 421AA0: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(_DWORD, _DWORD);
// 421C10: using guessed type _DWORD __stdcall sub_421C10(_DWORD);

//----- (00421C30) --------------------------------------------------------
_BYTE *__thiscall sub_421C30(int this)
{
  _BYTE *result; // eax@1
  char *v2; // ST08_4@4
  int v3; // [sp+0h] [bp-8h]@1

  v3 = this;
  result = (_BYTE *)this;
  if ( *(_DWORD *)(this + 4) )
  {
    result = (_BYTE *)sub_421C10(*(_DWORD *)(this + 4));
    if ( *result )
    {
      result = (_BYTE *)sub_421C10(*(_DWORD *)(v3 + 4));
      if ( *result != 255 )
      {
        v2 = *(char **)(v3 + 4);
        std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(1);
        result = (_BYTE *)std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(v2);
      }
    }
  }
  return result;
}
// 41FF10: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(_DWORD);
// 421C10: using guessed type _DWORD __stdcall sub_421C10(_DWORD);

//----- (00421D60) --------------------------------------------------------
int __thiscall sub_421D60(void *this)
{
  unsigned int v1; // esi@2
  int result; // eax@3
  void *v3; // [sp+4h] [bp-4h]@1

  v3 = this;
  if ( std::basic_streambuf<wchar_t,std::char_traits<wchar_t>>::gptr(this)
    && (v1 = std::basic_streambuf<wchar_t,std::char_traits<wchar_t>>::gptr(v3),
        v1 < std::basic_streambuf<char,std::char_traits<char>>::egptr(v3)) )
  {
    result = std::basic_streambuf<char,std::char_traits<char>>::_Gninc(v3);
  }
  else
  {
    result = (*(int (__thiscall **)(void *))(*(_DWORD *)v3 + 20))(v3);
  }
  return result;
}
// 40B6E0: using guessed type int __thiscall std::basic_streambuf<wchar_t,std::char_traits<wchar_t>>::gptr(_DWORD);
// 40BD70: using guessed type int __thiscall std::basic_streambuf<char,std::char_traits<char>>::egptr(_DWORD);
// 40BDF0: using guessed type int __thiscall std::basic_streambuf<char,std::char_traits<char>>::_Gninc(_DWORD);

//----- (00421DE0) --------------------------------------------------------
int __cdecl sub_421DE0(int a1)
{
  return a1 + 20;
}

//----- (00421DF0) --------------------------------------------------------
struct Concurrency::details::InternalContextBase *__cdecl sub_421DF0(int a1)
{
  int v1; // ecx@0
  struct Concurrency::IExecutionContext *v2; // eax@1
  int v4; // [sp+0h] [bp-4h]@1

  v4 = v1;
  v2 = (struct Concurrency::IExecutionContext *)sub_421E70(a1);
  return Concurrency::details::VirtualProcessor::ToInternalContext((Concurrency::details::VirtualProcessor *)&v4, v2);
}

//----- (00421E50) --------------------------------------------------------
int __cdecl sub_421E50(int a1)
{
  return a1 + 4;
}

//----- (00421E60) --------------------------------------------------------
int __cdecl sub_421E60(int a1)
{
  return a1 + 8;
}

//----- (00421E70) --------------------------------------------------------
int __cdecl sub_421E70(int a1)
{
  return a1 + 12;
}

//----- (00421E80) --------------------------------------------------------
int __thiscall sub_421E80(int this, _BYTE *a2, char a3, _BYTE *a4)
{
  int v4; // ST00_4@1

  v4 = this;
  *(_BYTE *)this = *a4;
  *(_BYTE *)(this + 1) = *a2;
  *(_BYTE *)(this + 8) = a3;
  sub_422E30((std::_tree *)this);
  return v4;
}

//----- (00421F30) --------------------------------------------------------
int __thiscall sub_421F30(void *this, int a2, _DWORD *a3)
{
  int v3; // eax@1

  v3 = sub_422F30(this, a3);
  unknown_libname_123((void *)a2, v3);
  return a2;
}

//----- (00421F60) --------------------------------------------------------
void *__thiscall sub_421F60(std::_tree *this, void *a2)
{
  void *result; // eax@1
  void **v3; // eax@3
  int v4; // eax@3
  std::_tree *v5; // [sp+0h] [bp-8h]@1
  void *i; // [sp+4h] [bp-4h]@1

  v5 = this;
  result = a2;
  for ( i = a2; i != (void *)dword_47F528; a2 = i )
  {
    v3 = (void **)sub_421E60((int)i);
    sub_421F60(v5, *v3);
    i = *(void **)unknown_libname_118(i);
    v4 = sub_421E70((int)a2);
    sub_4227B0(v4);
    Concurrency::details::_NonReentrantPPLLock::_Acquire(v5, a2);
  }
  return result;
}
// 421E10: using guessed type _DWORD __cdecl unknown_libname_118(_DWORD);
// 47F528: using guessed type int dword_47F528;

//----- (00421FE0) --------------------------------------------------------
int __thiscall sub_421FE0(void *this, int a2, int a3, int a4, struct Concurrency::IExecutionContext *a5)
{
  void *v5; // eax@1
  struct Concurrency::details::InternalContextBase *v6; // ST04_4@3
  struct Concurrency::details::InternalContextBase *v7; // eax@3
  char **v8; // eax@4
  char **v9; // eax@5
  char **v10; // eax@5
  char **v11; // eax@7
  char **v12; // eax@9
  char **v13; // eax@10
  int *v14; // eax@13
  _DWORD *v15; // esi@14
  int *v16; // eax@14
  _DWORD *v17; // eax@14
  int *v18; // eax@15
  int *v19; // eax@15
  int *v20; // eax@15
  int *v21; // eax@16
  int *v22; // eax@16
  int *v23; // eax@16
  int *v24; // eax@16
  int *v25; // eax@17
  int *v26; // eax@19
  int *v27; // eax@19
  int *v28; // eax@19
  int *v29; // eax@19
  int *v30; // eax@19
  int *v31; // eax@21
  _DWORD *v32; // eax@21
  int *v33; // eax@21
  int *v34; // eax@22
  int *v35; // eax@22
  int *v36; // eax@22
  int *v37; // eax@22
  _DWORD *v38; // eax@23
  int *v39; // eax@25
  int *v40; // eax@25
  int *v41; // eax@25
  int *v42; // eax@25
  int *v43; // eax@25
  int *v44; // eax@27
  _DWORD *v46; // [sp+4h] [bp-Ch]@1
  char v47; // [sp+8h] [bp-8h]@3
  char *v48; // [sp+Ch] [bp-4h]@1
  char *v49; // [sp+1Ch] [bp+Ch]@11
  int v50; // [sp+20h] [bp+10h]@15
  int v51; // [sp+20h] [bp+10h]@21

  v46 = this;
  v48 = sub_422FC0(a4, 0);
  *(_DWORD *)unknown_libname_118(v48) = dword_47F528;
  *(_DWORD *)sub_421E60((int)v48) = dword_47F528;
  v5 = (void *)sub_421E70((int)v48);
  sub_423010(v5, (int)a5);
  ++v46[3];
  if ( a4 == v46[1]
    || a3 != dword_47F528
    || (v6 = sub_421DF0(a4),
        v7 = Concurrency::details::VirtualProcessor::ToInternalContext(
               (Concurrency::details::VirtualProcessor *)&v47,
               a5),
        (unsigned __int8)sub_41AD90(v7, v6)) )
  {
    v8 = (char **)unknown_libname_118(a4);
    *v8 = v48;
    if ( a4 == v46[1] )
    {
      v9 = (char **)sub_422660((int)v46);
      *v9 = v48;
      v10 = (char **)sub_422640((int)v46);
      *v10 = v48;
    }
    else if ( a4 == *(_DWORD *)sub_422470((int)v46) )
    {
      v11 = (char **)sub_422470((int)v46);
      *v11 = v48;
    }
  }
  else
  {
    v12 = (char **)sub_421E60(a4);
    *v12 = v48;
    if ( a4 == *(_DWORD *)sub_422640((int)v46) )
    {
      v13 = (char **)sub_422640((int)v46);
      *v13 = v48;
    }
  }
  v49 = v48;
  while ( v49 != *(char **)sub_422660((int)v46) )
  {
    v14 = (int *)sub_421E50((int)v49);
    if ( *(_DWORD *)sub_421DE0(*v14) )
      break;
    v15 = (_DWORD *)sub_421E50((int)v49);
    v16 = (int *)sub_421E50((int)v49);
    v17 = (_DWORD *)sub_421E50(*v16);
    if ( *v15 == *(_DWORD *)unknown_libname_118(*v17) )
    {
      v18 = (int *)sub_421E50((int)v49);
      v19 = (int *)sub_421E50(*v18);
      v20 = (int *)sub_421E60(*v19);
      v50 = *v20;
      if ( *(_DWORD *)sub_421DE0(*v20) )
      {
        v25 = (int *)sub_421E50((int)v49);
        if ( v49 == *(char **)sub_421E60(*v25) )
        {
          v49 = *(char **)sub_421E50((int)v49);
          sub_422490(v46, (int)v49);
        }
        v26 = (int *)sub_421E50((int)v49);
        *(_DWORD *)sub_421DE0(*v26) = 1;
        v27 = (int *)sub_421E50((int)v49);
        v28 = (int *)sub_421E50(*v27);
        *(_DWORD *)sub_421DE0(*v28) = 0;
        v29 = (int *)sub_421E50((int)v49);
        v30 = (int *)sub_421E50(*v29);
        sub_422680(v46, *v30);
      }
      else
      {
        v21 = (int *)sub_421E50((int)v49);
        *(_DWORD *)sub_421DE0(*v21) = 1;
        *(_DWORD *)sub_421DE0(v50) = 1;
        v22 = (int *)sub_421E50((int)v49);
        v23 = (int *)sub_421E50(*v22);
        *(_DWORD *)sub_421DE0(*v23) = 0;
        v24 = (int *)sub_421E50((int)v49);
        v49 = *(char **)sub_421E50(*v24);
      }
    }
    else
    {
      v31 = (int *)sub_421E50((int)v49);
      v32 = (_DWORD *)sub_421E50(*v31);
      v33 = (int *)unknown_libname_118(*v32);
      v51 = *v33;
      if ( *(_DWORD *)sub_421DE0(*v33) )
      {
        v38 = (_DWORD *)sub_421E50((int)v49);
        if ( v49 == *(char **)unknown_libname_118(*v38) )
        {
          v49 = *(char **)sub_421E50((int)v49);
          sub_422680(v46, (int)v49);
        }
        v39 = (int *)sub_421E50((int)v49);
        *(_DWORD *)sub_421DE0(*v39) = 1;
        v40 = (int *)sub_421E50((int)v49);
        v41 = (int *)sub_421E50(*v40);
        *(_DWORD *)sub_421DE0(*v41) = 0;
        v42 = (int *)sub_421E50((int)v49);
        v43 = (int *)sub_421E50(*v42);
        sub_422490(v46, *v43);
      }
      else
      {
        v34 = (int *)sub_421E50((int)v49);
        *(_DWORD *)sub_421DE0(*v34) = 1;
        *(_DWORD *)sub_421DE0(v51) = 1;
        v35 = (int *)sub_421E50((int)v49);
        v36 = (int *)sub_421E50(*v35);
        *(_DWORD *)sub_421DE0(*v36) = 0;
        v37 = (int *)sub_421E50((int)v49);
        v49 = *(char **)sub_421E50(*v37);
      }
    }
  }
  v44 = (int *)sub_422660((int)v46);
  *(_DWORD *)sub_421DE0(*v44) = 1;
  unknown_libname_123((void *)a2, (int)v48);
  return a2;
}
// 421E10: using guessed type _DWORD __cdecl unknown_libname_118(_DWORD);
// 47F528: using guessed type int dword_47F528;

//----- (00422470) --------------------------------------------------------
int __thiscall sub_422470(int this)
{
  return unknown_libname_118(*(_DWORD *)(this + 4));
}
// 421E10: using guessed type _DWORD __cdecl unknown_libname_118(_DWORD);

//----- (00422490) --------------------------------------------------------
int *__thiscall sub_422490(void *this, int a2)
{
  _DWORD *v2; // esi@1
  int *v3; // eax@2
  _DWORD *v4; // esi@3
  _DWORD *v5; // eax@5
  _DWORD *v6; // eax@6
  int *v7; // eax@7
  int *result; // eax@8
  void *v9; // [sp+4h] [bp-8h]@1
  int v10; // [sp+8h] [bp-4h]@1

  v9 = this;
  v10 = *(_DWORD *)sub_421E60(a2);
  v2 = (_DWORD *)unknown_libname_118(v10);
  *(_DWORD *)sub_421E60(a2) = *v2;
  if ( *(_DWORD *)unknown_libname_118(v10) != dword_47F528 )
  {
    v3 = (int *)unknown_libname_118(v10);
    *(_DWORD *)sub_421E50(*v3) = a2;
  }
  v4 = (_DWORD *)sub_421E50(a2);
  *(_DWORD *)sub_421E50(v10) = *v4;
  if ( a2 == *(_DWORD *)sub_422660((int)v9) )
  {
    *(_DWORD *)sub_422660((int)v9) = v10;
  }
  else
  {
    v5 = (_DWORD *)sub_421E50(a2);
    if ( a2 == *(_DWORD *)unknown_libname_118(*v5) )
    {
      v6 = (_DWORD *)sub_421E50(a2);
      *(_DWORD *)unknown_libname_118(*v6) = v10;
    }
    else
    {
      v7 = (int *)sub_421E50(a2);
      *(_DWORD *)sub_421E60(*v7) = v10;
    }
  }
  *(_DWORD *)unknown_libname_118(v10) = a2;
  result = (int *)sub_421E50(a2);
  *result = v10;
  return result;
}
// 421E10: using guessed type _DWORD __cdecl unknown_libname_118(_DWORD);
// 47F528: using guessed type int dword_47F528;

//----- (004225C0) --------------------------------------------------------
int __cdecl sub_4225C0(int a1)
{
  while ( *(_DWORD *)sub_421E60(a1) != dword_47F528 )
    a1 = *(_DWORD *)sub_421E60(a1);
  return a1;
}
// 47F528: using guessed type int dword_47F528;

//----- (00422600) --------------------------------------------------------
int __cdecl sub_422600(int a1)
{
  while ( *(_DWORD *)unknown_libname_118(a1) != dword_47F528 )
    a1 = *(_DWORD *)unknown_libname_118(a1);
  return a1;
}
// 421E10: using guessed type _DWORD __cdecl unknown_libname_118(_DWORD);
// 47F528: using guessed type int dword_47F528;

//----- (00422640) --------------------------------------------------------
int __thiscall sub_422640(int this)
{
  return sub_421E60(*(_DWORD *)(this + 4));
}

//----- (00422660) --------------------------------------------------------
int __thiscall sub_422660(int this)
{
  return sub_421E50(*(_DWORD *)(this + 4));
}

//----- (00422680) --------------------------------------------------------
int *__thiscall sub_422680(void *this, int a2)
{
  _DWORD *v2; // esi@1
  int *v3; // eax@2
  _DWORD *v4; // esi@3
  int *v5; // eax@5
  int *v6; // eax@6
  _DWORD *v7; // eax@7
  int *result; // eax@8
  void *v9; // [sp+4h] [bp-8h]@1
  int v10; // [sp+8h] [bp-4h]@1

  v9 = this;
  v10 = *(_DWORD *)unknown_libname_118(a2);
  v2 = (_DWORD *)sub_421E60(v10);
  *(_DWORD *)unknown_libname_118(a2) = *v2;
  if ( *(_DWORD *)sub_421E60(v10) != dword_47F528 )
  {
    v3 = (int *)sub_421E60(v10);
    *(_DWORD *)sub_421E50(*v3) = a2;
  }
  v4 = (_DWORD *)sub_421E50(a2);
  *(_DWORD *)sub_421E50(v10) = *v4;
  if ( a2 == *(_DWORD *)sub_422660((int)v9) )
  {
    *(_DWORD *)sub_422660((int)v9) = v10;
  }
  else
  {
    v5 = (int *)sub_421E50(a2);
    if ( a2 == *(_DWORD *)sub_421E60(*v5) )
    {
      v6 = (int *)sub_421E50(a2);
      *(_DWORD *)sub_421E60(*v6) = v10;
    }
    else
    {
      v7 = (_DWORD *)sub_421E50(a2);
      *(_DWORD *)unknown_libname_118(*v7) = v10;
    }
  }
  *(_DWORD *)sub_421E60(v10) = a2;
  result = (int *)sub_421E50(a2);
  *result = v10;
  return result;
}
// 421E10: using guessed type _DWORD __cdecl unknown_libname_118(_DWORD);
// 47F528: using guessed type int dword_47F528;

//----- (004227B0) --------------------------------------------------------
void __stdcall sub_4227B0(int a1)
{
  sub_423A90();
}

//----- (00422800) --------------------------------------------------------
_DWORD *__thiscall sub_422800(void *this, _DWORD *a2, int a3)
{
  int v3; // ST04_4@1

  v3 = *(_DWORD *)this;
  unknown_libname_127(this);
  *a2 = v3;
  return a2;
}
// 423120: using guessed type int __cdecl unknown_libname_127(_DWORD);

//----- (00422850) --------------------------------------------------------
int __thiscall std::vector_IPRange::size(std::vector_IPRange *this)
{
  signed int v2; // [sp+0h] [bp-8h]@2

  if ( this->_First )
    v2 = this->_Last - this->_First;
  else
    v2 = 0;
  return v2;
}

//----- (00422890) --------------------------------------------------------
void *__stdcall sub_422890(int a1, int a2, void *a3)
{
  while ( a1 != a2 )
  {
    sub_423140(a3, a1);
    a3 = (char *)a3 + 8;
    a1 += 8;
  }
  return a3;
}

//----- (004228D0) --------------------------------------------------------
int __stdcall sub_4228D0(void *a1, int a2, int a3)
{
  int result; // eax@2

  while ( a2 )
  {
    sub_423140(a1, a3);
    result = a2-- - 1;
    a1 = (char *)a1 + 8;
  }
  return result;
}

//----- (00422910) --------------------------------------------------------
void *__stdcall sub_422910(int a1, int a2)
{
  return sub_423AA0(a1);
}

//----- (00422930) --------------------------------------------------------
void __stdcall some_stub(int a1)
{
  some_empty();
}

//----- (00422A30) --------------------------------------------------------
void *__thiscall sub_422A30(void *this)
{
  std::locale *v1; // eax@1
  std::locale *v2; // eax@1
  void *result; // eax@1
  int v4; // [sp-8h] [bp-48h]@1
  int v5; // [sp-4h] [bp-44h]@1
  void *v6; // [sp+0h] [bp-40h]@5
  std::locale *v7; // [sp+4h] [bp-3Ch]@1
  std::locale *v8; // [sp+8h] [bp-38h]@1
  int v9; // [sp+Ch] [bp-34h]@1
  std::locale *v10; // [sp+10h] [bp-30h]@1
  std::locale *v11; // [sp+14h] [bp-2Ch]@1
  void *v12; // [sp+18h] [bp-28h]@1
  char v13; // [sp+1Ch] [bp-24h]@5
  void *v14; // [sp+20h] [bp-20h]@4
  char v15; // [sp+28h] [bp-18h]@1
  int *v16; // [sp+2Ch] [bp-14h]@1
  char v17; // [sp+30h] [bp-10h]@1
  int v18; // [sp+3Ch] [bp-4h]@1

  v12 = this;
  v1 = sub_422DA0((int)this, (std::locale *)&v17);
  v11 = v1;
  v10 = v1;
  v18 = 0;
  *((_DWORD *)v12 + 14) = sub_423AE0(v1, 0, 1);
  v18 = -1;
  std::locale::~locale((std::locale *)&v17);
  v5 = *((_DWORD *)v12 + 14);
  v4 = (int)v12 + 76;
  v16 = &v4;
  v9 = std::locale::locale((std::locale *)&v4, (const struct std::locale *)((char *)v12 + 76));
  v2 = sub_423C00((std::locale *)&v15, v4, v5);
  v8 = v2;
  v7 = v2;
  std::locale::operator=(v2);
  std::locale::~locale((std::locale *)&v15);
  result = (void *)(unsigned __int8)sub_422BD0(*((_DWORD *)v12 + 14));
  if ( result )
    *((_DWORD *)v12 + 14) = 0;
  if ( !*((_DWORD *)v12 + 17) )
  {
    v14 = operator new(0x10u);
    v18 = 1;
    if ( v14 )
      v6 = sub_422BF0(v14, &v13);
    else
      v6 = 0;
    result = v6;
    *((_DWORD *)v12 + 17) = v6;
  }
  return result;
}
// 422B60: using guessed type _DWORD __stdcall std::locale::operator=(_DWORD);
// 422BD0: using guessed type int __thiscall sub_422BD0(_DWORD);

//----- (00422BF0) --------------------------------------------------------
void *__thiscall sub_422BF0(void *this, _BYTE *a2)
{
  void *v2; // ST04_4@1

  v2 = this;
  *(_BYTE *)this = *a2;
  std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(0);
  return v2;
}
// 41FF10: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(_DWORD);

//----- (00422DA0) --------------------------------------------------------
std::locale *__thiscall sub_422DA0(int this, std::locale *a2)
{
  std::locale::locale(a2, (const struct std::locale *)(this + 52));
  return a2;
}

//----- (00422E30) --------------------------------------------------------
std::_tree::_Node **__thiscall sub_422E30(std::_tree *this)
{
  std::_tree::_Node **result; // eax@5
  std::_tree *v2; // [sp+0h] [bp-18h]@1
  char v3; // [sp+4h] [bp-14h]@1
  void *v4; // [sp+8h] [bp-10h]@1
  int v5; // [sp+14h] [bp-4h]@1

  v2 = this;
  v4 = sub_422FC0(0, 1);
  std::_Lockit::_Lockit((std::_Lockit *)&v3);
  v5 = 0;
  if ( !dword_47F528 )
  {
    dword_47F528 = (int)v4;
    v4 = 0;
    *(_DWORD *)unknown_libname_118(dword_47F528) = 0;
    *(_DWORD *)sub_421E60(dword_47F528) = 0;
  }
  ++dword_47F52C;
  v5 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v3);
  if ( v4 )
    Concurrency::details::_NonReentrantPPLLock::_Acquire(v2, v4);
  v2->_Head = (std::_tree::_Node *)sub_422FC0(dword_47F528, 0);
  v2->_Size = 0;
  *(_DWORD *)sub_422470((int)v2) = v2->_Head;
  result = (std::_tree::_Node **)sub_422640((int)v2);
  *result = v2->_Head;
  return result;
}
// 421E10: using guessed type _DWORD __cdecl unknown_libname_118(_DWORD);
// 47F528: using guessed type int dword_47F528;
// 47F52C: using guessed type int dword_47F52C;

//----- (00422F30) --------------------------------------------------------
int __thiscall sub_422F30(void *this, _DWORD *a2)
{
  _DWORD *v2; // ST08_4@1
  struct Concurrency::details::InternalContextBase *v3; // eax@3
  int v5; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v2 = this;
  v6 = *(_DWORD *)sub_4231A0((int)this);
  v5 = v2[1];
  while ( v6 != dword_47F528 )
  {
    v3 = sub_421DF0(v6);
    if ( (unsigned __int8)sub_41AD90(v3, a2) )
    {
      v6 = *(_DWORD *)sub_421E60(v6);
    }
    else
    {
      v5 = v6;
      v6 = *(_DWORD *)unknown_libname_118(v6);
    }
  }
  return v5;
}
// 421E10: using guessed type _DWORD __cdecl unknown_libname_118(_DWORD);
// 47F528: using guessed type int dword_47F528;

//----- (00422FC0) --------------------------------------------------------
char *__stdcall sub_422FC0(int a1, int a2)
{
  char *result; // eax@1

  result = sub_423180(0x18u);
  *(_DWORD *)sub_421E50((int)result) = a1;
  *(_DWORD *)sub_421DE0((int)result) = a2;
  return result;
}

//----- (00423010) --------------------------------------------------------
_DWORD *__stdcall sub_423010(void *a1, int a2)
{
  return sub_423C90(a1, a2);
}

//----- (00423050) --------------------------------------------------------
int *__thiscall sub_423050(int *this)
{
  int *v1; // eax@2
  int *result; // eax@3
  int *v3; // eax@5
  int **v4; // eax@6
  int *v5; // [sp+0h] [bp-8h]@1
  int *v6; // [sp+4h] [bp-4h]@6

  v5 = this;
  if ( *(_DWORD *)sub_421DE0(*this) || (v1 = (int *)sub_421E50(*v5), *(_DWORD *)sub_421E50(*v1) != *v5) )
  {
    if ( *(_DWORD *)unknown_libname_118(*v5) == dword_47F528 )
    {
      while ( 1 )
      {
        v4 = (int **)sub_421E50(*v5);
        v6 = *v4;
        if ( *v5 != *(_DWORD *)unknown_libname_118(*v4) )
          break;
        *v5 = (int)v6;
      }
      result = v6;
      *v5 = (int)v6;
    }
    else
    {
      v3 = (int *)unknown_libname_118(*v5);
      result = (int *)sub_4225C0(*v3);
      *v5 = (int)result;
    }
  }
  else
  {
    result = (int *)sub_421E60(*v5);
    *v5 = *result;
  }
  return result;
}
// 421E10: using guessed type _DWORD __cdecl unknown_libname_118(_DWORD);
// 47F528: using guessed type int dword_47F528;

//----- (00423140) --------------------------------------------------------
_DWORD *__stdcall sub_423140(void *a1, int a2)
{
  return sub_423CD0(a1, a2);
}

//----- (00423160) --------------------------------------------------------
char *__stdcall sub_423160(int a1, int a2)
{
  return std::_Allocate(a1, 0);
}

//----- (00423180) --------------------------------------------------------
char *__stdcall sub_423180(size_t a1)
{
  return std::_Allocate(a1);
}

//----- (004231A0) --------------------------------------------------------
int __thiscall sub_4231A0(int this)
{
  return sub_421E50(*(_DWORD *)(this + 4));
}

//----- (004231C0) --------------------------------------------------------
_DWORD *__thiscall sub_4231C0(int *this)
{
  int *v1; // eax@2
  _DWORD *result; // eax@2
  int *v3; // eax@3
  int *v4; // [sp+0h] [bp-8h]@1
  _DWORD *v5; // [sp+4h] [bp-4h]@3

  v4 = this;
  if ( *(_DWORD *)sub_421E60(*this) == dword_47F528 )
  {
    while ( 1 )
    {
      v3 = (int *)sub_421E50(*v4);
      v5 = (_DWORD *)*v3;
      if ( *v4 != *(_DWORD *)sub_421E60(*v3) )
        break;
      *v4 = (int)v5;
    }
    result = (_DWORD *)sub_421E60(*v4);
    if ( (_DWORD *)*result != v5 )
    {
      result = v5;
      *v4 = (int)v5;
    }
  }
  else
  {
    v1 = (int *)sub_421E60(*v4);
    result = (_DWORD *)sub_422600(*v1);
    *v4 = (int)result;
  }
  return result;
}
// 47F528: using guessed type int dword_47F528;

//----- (00423380) --------------------------------------------------------
_DWORD *__thiscall sub_423380(_DWORD *this, char a2)
{
  _DWORD *v2; // ST04_4@1

  v2 = this;
  exception::exception(this, (const char **)&a2);
  *v2 = &std::bad_cast::`vftable';
  return v2;
}
// 45FD64: using guessed type int (__stdcall *std::bad_cast::`vftable')(int);

//----- (004233B0) --------------------------------------------------------
void __thiscall sub_4233B0(void *this)
{
  *(_DWORD *)this = &std::bad_cast::`vftable';
  sub_44DCB0((int)this);
}
// 45FD64: using guessed type int (__stdcall *std::bad_cast::`vftable')(int);

//----- (004233D0) --------------------------------------------------------
void __thiscall __noreturn sub_4233D0(void *this)
{
  char v1; // [sp+4h] [bp-Ch]@1

  unknown_libname_128(&v1, (int)this);
  _CxxThrowException(&v1, &unk_462ED8);
}
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);

//----- (00423400) --------------------------------------------------------
void *__thiscall sub_423400(void *this, char a2)
{
  void *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  sub_4233B0(this);
  if ( a2 & 1 )
    _delete_table(v3);
  return v3;
}

//----- (00423600) --------------------------------------------------------
void *__thiscall sub_423600(void *this, char a2)
{
  void *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  sub_423630(this);
  if ( a2 & 1 )
    _delete_table(v3);
  return v3;
}

//----- (00423630) --------------------------------------------------------
void *__thiscall sub_423630(void *this)
{
  void *result; // eax@1

  result = this;
  *(_DWORD *)this = &std::locale::facet::`vftable';
  return result;
}
// 45FBB0: using guessed type int (__stdcall *std::locale::facet::`vftable')(int);

//----- (00423650) --------------------------------------------------------
void *__thiscall sub_423650(void *this, char a2)
{
  void *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  unknown_libname_130(this);
  if ( a2 & 1 )
    _delete_table(v3);
  return v3;
}
// 423680: using guessed type int __thiscall unknown_libname_130(_DWORD);

//----- (00423790) --------------------------------------------------------
void __cdecl sub_423790()
{
  _Free(dword_481A28);
}

//----- (00423890) --------------------------------------------------------
void *__thiscall sub_423890(void *this, char a2)
{
  void *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  sub_4238C0((int)this);
  if ( a2 & 1 )
    _delete_table(v3);
  return v3;
}

//----- (004238C0) --------------------------------------------------------
int __thiscall sub_4238C0(int this)
{
  int v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  *(_DWORD *)this = &std::ctype<char>::`vftable';
  if ( *(_DWORD *)(this + 20) )
    _Free(*(LPVOID *)(this + 16));
  return unknown_libname_130(v2);
}
// 423680: using guessed type int __thiscall unknown_libname_130(_DWORD);
// 45FD14: using guessed type int (__stdcall *std::ctype<char>::`vftable')(int);

//----- (00423900) --------------------------------------------------------
std::vector_IPRange::iterator *__cdecl std::algorithm::lower_bound(std::vector_IPRange::iterator *_First, std::vector_IPRange::iterator *_Last, unsigned int *_Val)
{
  sub_4241C0();
  return std::algorithm::_Lower_bound(_First, _Last, _Val);
}

//----- (00423930) --------------------------------------------------------
std::vector_IPRange::iterator *__cdecl sub_423930(std::vector_IPRange::iterator *a1, std::vector_IPRange::iterator *a2, std::vector_IPRange::iterator *a3)
{
  unsigned int v3; // edx@2

  while ( a1 != a2 )
  {
    v3 = a1->value.endAddress;
    a3->value.startAddress = a1->value.startAddress;
    a3->value.endAddress = v3;
    ++a3;
    ++a1;
  }
  return a3;
}

//----- (004239F0) --------------------------------------------------------
int __cdecl sub_4239F0(int *a1, int *a2)
{
  int v2; // ST00_4@1
  int result; // eax@1

  v2 = *a1;
  *a1 = *a2;
  result = v2;
  *a2 = v2;
  return result;
}

//----- (00423A20) --------------------------------------------------------
int __cdecl sub_423A20(int a1, int a2, int a3)
{
  int result; // eax@2
  int v4; // ecx@2

  while ( a1 != a2 )
  {
    v4 = *(_DWORD *)(a3 + 4);
    *(_DWORD *)a1 = *(_DWORD *)a3;
    *(_DWORD *)(a1 + 4) = v4;
    result = a1 + 8;
    a1 += 8;
  }
  return result;
}

//----- (00423A50) --------------------------------------------------------
int __cdecl sub_423A50(int a1, int a2, int a3)
{
  int v3; // ecx@2

  while ( a1 != a2 )
  {
    a2 -= 8;
    v3 = *(_DWORD *)(a2 + 4);
    a3 -= 8;
    *(_DWORD *)a3 = *(_DWORD *)a2;
    *(_DWORD *)(a3 + 4) = v3;
  }
  return a3;
}

//----- (00423A90) --------------------------------------------------------
void sub_423A90()
{
  ;
}

//----- (00423AA0) --------------------------------------------------------
void *__cdecl sub_423AA0(int a1)
{
  if ( a1 < 0 )
    a1 = 0;
  return operator new(8 * a1);
}

//----- (00423AD0) --------------------------------------------------------
void some_empty()
{
  ;
}

//----- (00423AE0) --------------------------------------------------------
const struct std::locale::facet *__cdecl sub_423AE0(std::locale *a1, int a2, int a3)
{
  const struct std::locale::facet *v3; // ST0C_4@12
  std::locale::facet *v5; // [sp+0h] [bp-34h]@8
  _DWORD *v6; // [sp+8h] [bp-2Ch]@7
  char v7; // [sp+10h] [bp-24h]@4
  char v8; // [sp+1Ch] [bp-18h]@1
  unsigned int v9; // [sp+20h] [bp-14h]@1
  const struct std::locale::facet *v10; // [sp+24h] [bp-10h]@1
  int v11; // [sp+30h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v8);
  v11 = 0;
  v9 = std::locale::id::operator unsigned int(&unk_481A2C);
  v10 = std::locale::_Getfacet(a1, v9, 1);
  if ( !v10 )
  {
    if ( !(_BYTE)a3 || !std::locale::_Iscloc(a1) )
    {
      sub_423380(&v7, (unsigned int)aMissingLocaleF);
      _CxxThrowException(&v7, &unk_462ED8);
    }
    if ( dword_47F534 )
    {
      v10 = (const struct std::locale::facet *)dword_47F534;
    }
    else
    {
      v6 = operator new(0x10u);
      LOBYTE(v11) = 1;
      if ( v6 )
        v5 = (std::locale::facet *)sub_423D30(v6, 0);
      else
        v5 = 0;
      LOBYTE(v11) = 0;
      dword_47F534 = (int)sub_423FD0(v5);
      v10 = (const struct std::locale::facet *)dword_47F534;
    }
  }
  v3 = v10;
  v11 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v8);
  return v3;
}
// 423460: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 47F534: using guessed type int dword_47F534;

//----- (00423C00) --------------------------------------------------------
std::locale *__cdecl sub_423C00(std::locale *a1, char a2, int a3)
{
  struct Concurrency::details::_CancellationTokenState *v3; // ST08_4@1
  unsigned int v4; // eax@1
  const struct std::locale *v5; // eax@1
  char v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+10h] [bp-4h]@1

  v8 = 1;
  std::_Lockit::_Lockit((std::_Lockit *)&v7);
  LOBYTE(v8) = 2;
  v3 = Concurrency::details::_CancellationTokenState::_None();
  v4 = std::locale::id::operator unsigned int(&unk_481A2C);
  v5 = std::locale::_Addfac((std::locale *)&a2, (struct std::locale::facet *)a3, v4, (unsigned int)v3);
  std::locale::locale(a1, v5);
  LOBYTE(v8) = 1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v7);
  LOBYTE(v8) = 0;
  std::locale::~locale((std::locale *)&a2);
  return a1;
}
// 423460: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);

//----- (00423C90) --------------------------------------------------------
_DWORD *__cdecl sub_423C90(void *a1, int a2)
{
  _DWORD *result; // eax@1
  _DWORD *v3; // [sp+4h] [bp-4h]@1

  result = operator new(8u, a1);
  v3 = result;
  if ( result )
  {
    result = *(_DWORD **)(a2 + 4);
    *v3 = *(_DWORD *)a2;
    v3[1] = result;
  }
  return result;
}

//----- (00423CD0) --------------------------------------------------------
_DWORD *__cdecl sub_423CD0(void *a1, int a2)
{
  _DWORD *result; // eax@1
  _DWORD *v3; // [sp+4h] [bp-4h]@1

  result = operator new(8u, a1);
  v3 = result;
  if ( result )
  {
    result = *(_DWORD **)(a2 + 4);
    *v3 = *(_DWORD *)a2;
    v3[1] = result;
  }
  return result;
}

//----- (00423D30) --------------------------------------------------------
_DWORD *__thiscall sub_423D30(_DWORD *this, unsigned int a2)
{
  _DWORD *v2; // ST0C_4@1
  int v3; // eax@1
  char v5; // [sp+Ch] [bp-4Ch]@1
  int v6; // [sp+54h] [bp-4h]@1

  v2 = this;
  unknown_libname_131(a2);
  v6 = 0;
  *v2 = &std::codecvt<char,char,int>::`vftable';
  v3 = std::_Locinfo::_Locinfo((std::_Locinfo *)&v5, aC_0);
  LOBYTE(v6) = 1;
  sub_424040(v2, v3);
  LOBYTE(v6) = 0;
  std::_Locinfo::~_Locinfo((std::_Locinfo *)&v5);
  return v2;
}
// 423DC0: using guessed type _DWORD __stdcall unknown_libname_131(unsigned int);
// 45FC8C: using guessed type int (__stdcall *std::codecvt<char,char,int>::`vftable')(int);

//----- (00423E20) --------------------------------------------------------
void *__thiscall sub_423E20(void *this, char a2)
{
  void *v3; // [sp+0h] [bp-4h]@1

  unknown_libname_135(this);
  if ( a2 & 1 )
    _delete_table(v3);
  return v3;
}
// 423E50: using guessed type int __cdecl unknown_libname_135(_DWORD);

//----- (00423F00) --------------------------------------------------------
void *__thiscall sub_423F00(void *this, char a2)
{
  void *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  sub_423F30(this);
  if ( a2 & 1 )
    _delete_table(v3);
  return v3;
}

//----- (00423F30) --------------------------------------------------------
int __thiscall sub_423F30(void *this)
{
  *(_DWORD *)this = &std::codecvt<char,char,int>::`vftable';
  return unknown_libname_135(this);
}
// 423E50: using guessed type int __cdecl unknown_libname_135(_DWORD);
// 45FC8C: using guessed type int (__stdcall *std::codecvt<char,char,int>::`vftable')(int);

//----- (00423F60) --------------------------------------------------------
std::locale::facet *__cdecl sub_423F60(std::locale::facet *a1)
{
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+10h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  dword_47F538 = a1;
  std::locale::facet::_Incref(a1);
  atexit(sub_4240A0);
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
  return a1;
}

//----- (00423FD0) --------------------------------------------------------
std::locale::facet *__cdecl sub_423FD0(std::locale::facet *a1)
{
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+10h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  dword_47F53C = a1;
  std::locale::facet::_Incref(a1);
  atexit(sub_424130);
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
  return a1;
}

//----- (00424040) --------------------------------------------------------
_DWORD *__thiscall sub_424040(_DWORD *this, int a2)
{
  _DWORD *v2; // ST04_4@1
  int v3; // eax@1
  int v4; // ecx@1
  int v5; // edx@1
  _DWORD *result; // eax@1
  char v7; // [sp+4h] [bp-8h]@1

  v2 = this;
  v3 = sub_424070((int)&v7);
  v4 = *(_DWORD *)v3;
  v5 = *(_DWORD *)(v3 + 4);
  result = v2;
  v2[2] = v4;
  v2[3] = v5;
  return result;
}

//----- (00424070) --------------------------------------------------------
int __stdcall sub_424070(int a1)
{
  int v1; // edx@1

  *(_DWORD *)a1 = sub_44134E();
  *(_DWORD *)(a1 + 4) = v1;
  return a1;
}

//----- (004240A0) --------------------------------------------------------
void __cdecl sub_4240A0()
{
  struct std::locale::facet *v0; // [sp+8h] [bp-14h]@1
  char v1; // [sp+Ch] [bp-10h]@1
  int v2; // [sp+18h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v1);
  v2 = 0;
  v0 = std::locale::facet::_Decref(dword_47F538);
  if ( v0 )
    (**(void (__thiscall ***)(struct std::locale::facet *, signed int))v0)(v0, 1);
  dword_47F538 = 0;
  v2 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v1);
}

//----- (00424130) --------------------------------------------------------
void __cdecl sub_424130()
{
  struct std::locale::facet *v0; // [sp+8h] [bp-14h]@1
  char v1; // [sp+Ch] [bp-10h]@1
  int v2; // [sp+18h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v1);
  v2 = 0;
  v0 = std::locale::facet::_Decref(dword_47F53C);
  if ( v0 )
    (**(void (__thiscall ***)(struct std::locale::facet *, signed int))v0)(v0, 1);
  dword_47F53C = 0;
  v2 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v1);
}

//----- (004241C0) --------------------------------------------------------
int sub_4241C0()
{
  return 0;
}

//----- (004241D0) --------------------------------------------------------
std::vector_IPRange::iterator *__cdecl std::algorithm::_Lower_bound(std::vector_IPRange::iterator *_First, std::vector_IPRange::iterator *_Last, unsigned int *_Val)
{
  std::vector_IPRange::iterator *_Mid; // [sp+0h] [bp-Ch]@3
  int _Count2; // [sp+4h] [bp-8h]@3
  int _Count; // [sp+8h] [bp-4h]@1

  _Count = 0;
  std::algorithm::_Distance(_First, _Last, &_Count);
  while ( _Count > 0 )
  {
    _Count2 = _Count / 2;
    _Mid = _First;
    std::algorithm::advance((std::vector_IPRange::iterator *)&_Mid, _Count / 2);
    if ( (unsigned __int8)IPList::IPRange::operator_less(*_Val, &_Mid->value) )
    {
      _Count = _Count2;
    }
    else
    {
      ++_Mid;
      _First = _Mid;
      _Count -= _Count2 + 1;
    }
  }
  return _First;
}

//----- (00424270) --------------------------------------------------------
BOOL __cdecl IPList::IPRange::operator_less(int ipAddress, IPRange *this_)
{
  return ipAddress < this_->endAddress;
}

//----- (00424290) --------------------------------------------------------
int sub_424290()
{
  int result; // eax@1

  result = byte_481F34 & 1;
  if ( !(byte_481F34 & 1) )
    byte_481F34 |= 1u;
  return result;
}
// 481F34: using guessed type char byte_481F34;

//----- (004242C0) --------------------------------------------------------
void __cdecl sub_4242C0()
{
  ;
}

//----- (004242D0) --------------------------------------------------------
_DWORD *__cdecl std::algorithm::_Distance(std::vector_IPRange::iterator *a1, std::vector_IPRange::iterator *a2, _DWORD *a3)
{
  int v3; // ecx@0
  char v4; // dl@1
  int v6; // [sp+0h] [bp-4h]@1

  v6 = v3;
  v4 = *sub_424330(&v6);
  return sub_424350(a1, a2, a3);
}

//----- (00424300) --------------------------------------------------------
u_long __cdecl std::algorithm::advance(std::vector_IPRange::iterator *a1, int a2)
{
  int v2; // ecx@0
  unsigned int v3; // ST08_4@1
  char v4; // al@1
  int v6; // [sp+0h] [bp-4h]@1

  v6 = v2;
  v3 = a1->value.startAddress;
  v4 = *sub_424330(&v6);
  return unknown_libname_137(a1, a2);
}

//----- (00424330) --------------------------------------------------------
_BYTE *__cdecl sub_424330(_BYTE *a1)
{
  char v2; // [sp+0h] [bp-8h]@1

  *a1 = v2;
  return a1;
}

//----- (00424350) --------------------------------------------------------
_DWORD *__cdecl sub_424350(std::vector_IPRange::iterator *a1, std::vector_IPRange::iterator *a2, _DWORD *a3)
{
  _DWORD *result; // eax@1

  result = a3;
  *a3 += a2 - a1;
  return result;
}

//----- (00424390) --------------------------------------------------------
int SaticInit_FroIPSocket_ReadWriteLock()
{
  CallReadWriteLockCtor();
  return RegisterReadWriteLockDtor();
}

//----- (0042439F) --------------------------------------------------------
ReadWriteLock *CallReadWriteLockCtor()
{
  return ReadWriteLock::ReadWriteLock(&IPSocket::s_lock);
}

//----- (004243AE) --------------------------------------------------------
int RegisterReadWriteLockDtor()
{
  return atexit(CallReadWriteLockDtor);
}

//----- (004243C0) --------------------------------------------------------
void __cdecl CallReadWriteLockDtor()
{
  ReadWriteLock::Destructor(&IPSocket::s_lock);
}

//----- (004243CF) --------------------------------------------------------
int StaticInit_IPSessionDB()
{
  CallStaticCtorForIPSessionDB();
  return RegisterDtorForIPSessionDB();
}

//----- (004243DE) --------------------------------------------------------
IPSessionDB *CallStaticCtorForIPSessionDB()
{
  return IPSessionDB::IPSessionDB(&g_IPSessionDB);
}

//----- (004243ED) --------------------------------------------------------
int RegisterDtorForIPSessionDB()
{
  return atexit(CallStaticDestructorForIPSessionDB);
}

//----- (004243FF) --------------------------------------------------------
void __cdecl CallStaticDestructorForIPSessionDB()
{
  IPSessionDB::Destructor(&g_IPSessionDB);
}

//----- (0042440E) --------------------------------------------------------
void __stdcall IPSocket::onTimeout(PVOID a1, BOOLEAN a2)
{
  SOCKET ipSocket_1; // ST10_4@4
  int result; // ST18_4@4
  IPSocket *old; // ST0C_4@6
  IPSocket *ipSocket; // [sp+8h] [bp-18h]@4
  sockaddr_in name; // [sp+10h] [bp-10h]@4

  LogWindow::Add(&g_LogWindow, 1, aIpsockettimerr);
  if ( IPSocket::s_timer )
    DeleteTimerQueueTimer(0, IPSocket::s_timer, 0);
  IPSocket::s_timer = 0;
  if ( IPSocket::isReconnecting == true )
  {
    ipSocket_1 = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
    name.sin_family = AF_INET;
    name.sin_addr.S_un.S_addr = g_Config.IpServer;
    name.sin_port = htons(g_Config.IpPort);
    result = connect(ipSocket_1, (const struct sockaddr *)&name, 16);
    ipSocket = IPSocket::Create(ipSocket_1);
    IPSocket::setIPAddress(ipSocket, g_Config.IpServer);
    if ( result == SOCKET_ERROR )
    {
      CIOSocket::Close(&ipSocket->base);
      MemoryObject::Release(&ipSocket->base.base);
    }
    else
    {
      ReadWriteLock::writeLock(&IPSocket::s_lock);
      old = g_IPSocket;
      g_IPSocket = ipSocket;
      IPSocket::isReconnecting = false;
      g_Config.Useipserver = true;
      CIOSocket::Initialize(&ipSocket->base, Threading::g_hCompletionPort);
      ReadWriteLock::releaseWriteLock(&IPSocket::s_lock);
      MemoryObject::Release(&old->base.base);
    }
  }
}
// 47F811: using guessed type char IPSocket::isReconnecting;

//----- (00424527) --------------------------------------------------------
int IPPacketPool::g_slot_statis_init()
{
  IPPacketPool::g_slot_construction();
  return IPPacketPool::Call_g_slot_destruction();
}

//----- (00424536) --------------------------------------------------------
int IPPacketPool::g_slot_construction()
{
  return `eh vector constructor iterator'(
           IPPacketPool::g_slot,
           0x24u,
           16,
           (int)IPSlot::IPSlot,
           (void (__thiscall *)(void *))IPSlot::Destructor);
}

//----- (00424553) --------------------------------------------------------
int IPPacketPool::Call_g_slot_destruction()
{
  return atexit(IPPacketPool::g_slot_destruction);
}

//----- (00424565) --------------------------------------------------------
void __cdecl IPPacketPool::g_slot_destruction()
{
  if ( !(byte_47F810 & 1) )
  {
    byte_47F810 |= 1u;
    `eh vector destructor iterator'(IPPacketPool::g_slot, 0x24u, 16, (void (__thiscall *)(void *))IPSlot::Destructor);
  }
}
// 47F810: using guessed type char byte_47F810;

//----- (0042459A) --------------------------------------------------------
int StaticInitForIPPacketPool()
{
  StaticCallFor_IPPacketPoolCtor();
  return Register_StaticCallFor_IPPacketPoolDestructor();
}

//----- (004245A9) --------------------------------------------------------
void StaticCallFor_IPPacketPoolCtor()
{
  ;
}

//----- (004245AE) --------------------------------------------------------
int Register_StaticCallFor_IPPacketPoolDestructor()
{
  return atexit(StaticCallFor_IPPacketPoolDestructor);
}

//----- (004245C0) --------------------------------------------------------
void __cdecl StaticCallFor_IPPacketPoolDestructor()
{
  IPPacketPool::Destructor();
}

//----- (004245CF) --------------------------------------------------------
IPPacket *__cdecl IPPacket::Alloc()
{
  IPPacket *v1; // [sp+0h] [bp-20h]@4
  IPPacket *v2; // [sp+4h] [bp-1Ch]@3
  IPSlot *slot; // [sp+Ch] [bp-14h]@1
  IPPacket *packet; // [sp+10h] [bp-10h]@1

  slot = &IPPacketPool::g_slot[InterlockedIncrement(&IPPacketPool::g_nAlloc) & 0xF];
  SpinLock::Enter(&slot->m_lock);
  packet = slot->m_pPacket;
  if ( slot->m_pPacket )
  {
    slot->m_pPacket = (IPPacket *)packet->base.m_pSocket;
    SpinLock::Leave(&slot->m_lock);
  }
  else
  {
    SpinLock::Leave(&slot->m_lock);
    v2 = (IPPacket *)operator_new(0x14u);
    if ( v2 )
      v1 = IPPacket::IPPacket(v2);
    else
      v1 = 0;
    packet = v1;
  }
  return packet;
}

//----- (00424691) --------------------------------------------------------
void IPPacket::FreeAll()
{
  IPSlot *slot; // [sp+Ch] [bp-Ch]@3
  IPPacket *packet; // [sp+10h] [bp-8h]@4
  signed int i; // [sp+14h] [bp-4h]@1

  for ( i = 0; i < 16; ++i )
  {
    slot = &IPPacketPool::g_slot[i];
    SpinLock::Enter(&IPPacketPool::g_slot[i].m_lock);
    while ( 1 )
    {
      packet = slot->m_pPacket;
      if ( !slot->m_pPacket )
        break;
      slot->m_pPacket = (IPPacket *)packet->base.m_pSocket;
      if ( packet )
        packet->base.base.vftbl_0_45F520->DestructorCall((MemoryObject *)packet, 1);
    }
    SpinLock::Leave(&slot->m_lock);
  }
}

//----- (0042471F) --------------------------------------------------------
void __thiscall IPPacket::Free(IPPacket *this)
{
  IPPacket *this_; // ST04_4@1
  IPSlot *slot; // ST08_4@1

  this_ = this;
  slot = &IPPacketPool::g_slot[InterlockedDecrement(&IPPacketPool::g_nFree) & 0xF];
  SpinLock::Enter(&slot->m_lock);
  this_->base.m_pSocket = (CIOSocket *)slot->m_pPacket;
  slot->m_pPacket = this_;
  SpinLock::Leave(&slot->m_lock);
}

//----- (0042476E) --------------------------------------------------------
void __thiscall IPPacket::OnIOCallback(IPPacket *this, BOOL bSuccess, DWORD dwTransferred, LPOVERLAPPED lpOverlapped)
{
  IPPacket *this_; // [sp+Ch] [bp-20h]@1

  this_ = this;
  if ( ((int (__cdecl *)(_DWORD, _DWORD))this->base.m_pFunc)(
         this->base.m_pSocket,
         &this->base.m_pBuf->m_Buffer[dwTransferred + 1]) & 0xFF )
    CIOSocket::Close(this_->base.m_pSocket);
  MemoryObject::Release(&this_->base.m_pSocket->base);
  CIOBuffer::Release(this_->base.m_pBuf);
  InterlockedDecrement(&IPPacket::g_nPendingPacket);
  IPPacket::Free(this_);
}

//----- (0042485B) --------------------------------------------------------
IPSessionDB *__thiscall IPSessionDB::IPSessionDB(IPSessionDB *this)
{
  IPSessionDB *this_; // ST08_4@1
  char v3; // [sp+4h] [bp-1Ch]@1
  char v4; // [sp+8h] [bp-18h]@1
  char v5; // [sp+Ch] [bp-14h]@1
  char v6; // [sp+10h] [bp-10h]@1
  int unused; // [sp+1Ch] [bp-4h]@1

  this_ = this;
  std::map_int_int::map_int_int(&this->m_sessionKeys, &v5, &v6);
  unused = 0;
  std::map_int_sockid::map_int_sockid(&this_->m_users, &v3, &v4);
  LOBYTE(unused) = 1;
  SpinLock::SpinLock(&this_->m_usersLock, LockType_CritSection, 0);
  LOBYTE(unused) = 2;
  SpinLock::SpinLock(&this_->m_sessionsLock, LockType_CritSection, 0);
  this_->vftable = (int)IPSessionDB_vtable_offset_45F7DC;
  return this_;
}
// 45F7DC: using guessed type int (__stdcall *IPSessionDB_vtable_offset_45F7DC[2])(int);

//----- (004248ED) --------------------------------------------------------
int __thiscall IPSessionDB::Destructor(IPSessionDB *this)
{
  IPSessionDB *this_; // ST00_4@1

  this_ = this;
  this->vftable = (int)IPSessionDB_vtable_offset_45F7DC;
  SpinLock::Destructor(&this->m_sessionsLock);
  SpinLock::Destructor(&this_->m_usersLock);
  std::map_int_sockid::Destructor(&this_->m_users);
  return std::map_int_int::Destructor(&this_->m_sessionKeys);
}
// 45F7DC: using guessed type int (__stdcall *IPSessionDB_vtable_offset_45F7DC[2])(int);

//----- (00424962) --------------------------------------------------------
char __thiscall IPSessionDB::takeWaitingAcc(IPSessionDB *this, int uid, UserInfo **account)
{
  std::_tree_int_acc::iterator *end; // eax@1
  std::pair_int_acc *pair; // eax@2
  IPSessionDB *this_; // [sp+Ch] [bp-30h]@1
  int v7; // [sp+10h] [bp-2Ch]@2
  std::_tree_int_acc::iterator v8; // [sp+14h] [bp-28h]@1
  int a2; // [sp+18h] [bp-24h]@1
  std::_tree_int_acc::iterator *it; // [sp+1Ch] [bp-20h]@1
  char result_1; // [sp+20h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+24h] [bp-18h]@1

  this_ = this;
  result_1 = false;
  ms_exc.registration.TryLevel = 0;
  std::_tree_int_acc::iterator::iterator2((std::_tree_int_acc::iterator *)&it);
  SpinLock::Enter(&this_->m_usersLock);
  it = (std::_tree_int_acc::iterator *)std::map_int_acc::find(&this_->m_users, &a2, &uid)->_Ptr;
  end = std::map_int_acc::end(&this_->m_users, &v8);
  if ( (unsigned __int8)std::map_int_acc::iterator::not_eq((std::_tree_int_acc::iterator *)&it, end) )
  {
    pair = std::_tree_int_acc::iterator::value((std::_tree_int_acc::iterator *)&it);
    *account = pair->second;
    std::map_int_acc::erase(&this_->m_users, &v7, it);
    SpinLock::Leave(&this_->m_usersLock);
    result_1 = true;
  }
  else
  {
    SpinLock::Leave(&this_->m_usersLock);
  }
  return result_1;
}

//----- (00424A7D) --------------------------------------------------------
char __thiscall IPSessionDB::addAccInfo(IPSessionDB *this, int uid, UserInfo *accInfo)
{
  std::pair_int_acc *pair_; // eax@1
  IPSessionDB *this_; // [sp+Ch] [bp-34h]@1
  std::pair_int_acc pair; // [sp+10h] [bp-30h]@1
  UserInfo *account; // [sp+18h] [bp-28h]@2
  std::pair_bool_acc a2; // [sp+1Ch] [bp-24h]@1
  int inserted; // [sp+24h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+28h] [bp-18h]@1

  this_ = this;
  LOBYTE(inserted) = 0;
  ms_exc.registration.TryLevel = 0;
  SpinLock::Enter(&this->m_usersLock);
  pair_ = std::pair_int_acc::pair_int_acc(&pair, &uid, &accInfo);
  std::map_int_acc::insert(&this_->m_users, &a2, pair_);
  LOBYTE(inserted) = a2.second;
  SpinLock::Leave(&this_->m_usersLock);
  if ( !(_BYTE)inserted )
  {
    account = 0;
    IPSessionDB::takeWaitingAcc(this_, uid, &account);// mem leak
  }
  return inserted;
}

//----- (00424B6D) --------------------------------------------------------
int __thiscall IPSessionDB::getSessionKey(IPSessionDB *this, int uid)
{
  std::_tree_int_int::iterator *end; // eax@1
  IPSessionDB *this_; // [sp+Ch] [bp-28h]@1
  std::_tree_int_int::iterator a2; // [sp+10h] [bp-24h]@1
  std::_tree_int_int::iterator it; // [sp+14h] [bp-20h]@1
  int sessionKey; // [sp+18h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+1Ch] [bp-18h]@1

  this_ = this;
  sessionKey = 0;
  ms_exc.registration.TryLevel = 0;
  SpinLock::Enter(&this->m_sessionsLock);
  std::map_int_int::find(&this_->m_sessionKeys, &it, &uid);
  end = std::map_int_int::end(&this_->m_sessionKeys, &a2);
  if ( (unsigned __int8)std::_tree_int_int::iterator::not_eq(&it, end) )
    sessionKey = std::_tree_int_int::iterator::value(&it)->second;
  SpinLock::Leave(&this_->m_sessionsLock);
  return sessionKey;
}

//----- (00424C58) --------------------------------------------------------
int __thiscall IPSessionDB::takeSessionKey(IPSessionDB *this, int uid)
{
  std::_tree_int_int::iterator *end; // eax@1
  IPSessionDB *this_; // [sp+Ch] [bp-2Ch]@1
  int v5; // [sp+10h] [bp-28h]@2
  std::_tree_int_int::iterator v6; // [sp+14h] [bp-24h]@1
  std::_tree_int_int::iterator it; // [sp+18h] [bp-20h]@1
  int sessionKey; // [sp+1Ch] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+20h] [bp-18h]@1

  this_ = this;
  sessionKey = 0;
  ms_exc.registration.TryLevel = 0;
  SpinLock::Enter(&this->m_sessionsLock);
  std::map_int_int::find(&this_->m_sessionKeys, &it, &uid);
  end = std::map_int_int::end(&this_->m_sessionKeys, &v6);
  if ( (unsigned __int8)std::_tree_int_int::iterator::not_eq(&it, end) )
  {
    sessionKey = std::_tree_int_int::iterator::value(&it)->second;
    std::map_int_int::erase(&this_->m_sessionKeys, &v5, (std::_tree_int_int::iterator *)it._Ptr);
  }
  SpinLock::Leave(&this_->m_sessionsLock);
  return sessionKey;
}

//----- (00424D56) --------------------------------------------------------
char __thiscall IPSessionDB::clearWaitinAccs(IPSessionDB *this)
{
  std::_tree_int_acc::iterator *end; // eax@2
  IPSessionDB *this_; // [sp+Ch] [bp-30h]@1
  int v4; // [sp+10h] [bp-2Ch]@3
  UserInfo *account; // [sp+14h] [bp-28h]@3
  std::_tree_int_acc::iterator end_; // [sp+18h] [bp-24h]@2
  std::_tree_int_acc::iterator a2; // [sp+1Ch] [bp-20h]@1
  std::_tree_int_acc::iterator it; // [sp+20h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+24h] [bp-18h]@1

  this_ = this;
  ms_exc.registration.TryLevel = 0;
  std::_tree_int_acc::iterator::iterator2(&it);
  SpinLock::Enter(&this_->m_usersLock);
  for ( it._Ptr = std::map_int_acc::begin(&this_->m_users, &a2)->_Ptr;
        ;
        it._Ptr = (std::_tree_int_acc::_Node *)*std::map_int_acc::erase(
                                                  &this_->m_users,
                                                  &v4,
                                                  (std::_tree_int_acc::iterator *)it._Ptr) )
  {
    end = std::map_int_acc::end(&this_->m_users, &end_);
    if ( !(unsigned __int8)std::map_int_acc::iterator::not_eq(&it, end) )
      break;
    account = std::_tree_int_acc::iterator::value(&it)->second;
    _delete_table(account);
  }
  SpinLock::Leave(&this_->m_usersLock);
  return 1;
}

//----- (00424E66) --------------------------------------------------------
int __thiscall IPSessionDB::registerSessionKey(IPSessionDB *this, int uid, int sessionKey)
{
  int result; // eax@2
  std::pair_int_int *pair; // eax@3
  IPSessionDB *this_; // [sp+18h] [bp-30h]@1
  std::pair_int_int pair_; // [sp+1Ch] [bp-2Ch]@3
  std::pair_bool_int res; // [sp+24h] [bp-24h]@3
  int inserted; // [sp+2Ch] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+30h] [bp-18h]@1

  this_ = this;
  ms_exc.registration.TryLevel = 0;
  LOBYTE(inserted) = 0;
  if ( sessionKey )
  {
    SpinLock::Enter(&this->m_sessionsLock);
    pair = std::pair_int_int::pair_int_int(&pair_, &uid, &sessionKey);
    std::map_int_int::insert(&this_->m_sessionKeys, &res, pair);
    LOBYTE(inserted) = res.second;
    SpinLock::Leave(&this_->m_sessionsLock);
    if ( (unsigned __int8)inserted == true )
    {
      ms_exc.registration.TryLevel = -1;
      result = sessionKey;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    ms_exc.registration.TryLevel = -1;
    result = 0;
  }
  return result;
}

//----- (00424F76) --------------------------------------------------------
char __thiscall IPSessionDB::registerWaitingAcc(IPSessionDB *this, UserInfo *accInfo, int uid)
{
  IPSessionDB *this_; // [sp+Ch] [bp-2Ch]@1
  char errorCode; // [sp+1Ch] [bp-1Ch]@1

  this_ = this;
  errorCode = 0;
  if ( IPSessionDB::addAccInfo(this, uid, accInfo) )
  {
    if ( g_IPSocket && !IPSocket::isReconnecting && g_Config.Useipserver )
    {
      if ( !IPSocket::send(g_IPSocket, aCsddd, 2, accInfo->accountName, accInfo->connectedIP, g_Config.GameID, uid) )
      {
        errorCode = 10;                         // success
        IPSessionDB::takeWaitingAcc(this_, uid, 0);
      }
    }
    else
    {
      errorCode = 10;                           // success
      IPSessionDB::takeWaitingAcc(this_, uid, 0);
    }
  }
  else
  {
    errorCode = 11;                             // fail
  }
  return errorCode;
}
// 47F811: using guessed type char IPSocket::isReconnecting;

//----- (004250BF) --------------------------------------------------------
char __thiscall IPSessionDB::sendPayStats(IPSessionDB *this, int sessionKey, int clientIP, int payStat)
{
  char result; // al@2

  if ( sessionKey )
  {
    if ( g_Config.Useipserver && !IPSocket::isReconnecting )
    {
      if ( g_IPSocket )
      {
        ReadWriteLock::readLock(&IPSocket::s_lock);
        IPSocket::send(g_IPSocket, aCddddd, 3, sessionKey, g_IPSocket->m_field_2, g_Config.GameID, clientIP, payStat);
        ReadWriteLock::releaseReadLock(&IPSocket::s_lock);
      }
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 47F811: using guessed type char IPSocket::isReconnecting;

//----- (004251D0) --------------------------------------------------------
char __thiscall IPSessionDB::handleAuthLogin(IPSessionDB *this, int uid, int sessionKey, bool defaultResut, int totalTime, int payStat)
{
  char result; // al@2
  IPSessionDB *this_; // [sp+10h] [bp-38h]@1
  CAuthSocket *gameClient; // [sp+24h] [bp-24h]@3
  UserInfo *accInfo; // [sp+28h] [bp-20h]@1
  char result_1; // [sp+2Ch] [bp-1Ch]@2
  CPPEH_RECORD ms_exc; // [sp+30h] [bp-18h]@1

  this_ = this;
  ms_exc.registration.TryLevel = 0;
  accInfo = 0;
  IPSessionDB::takeWaitingAcc(this, uid, &accInfo);
  if ( accInfo )
  {
    gameClient = CAuthServer::getIOSocket(&g_authServer, accInfo->gameSocket);
    if ( gameClient )
    {
      accInfo->payStat = payStat;
      if ( UserManager::authenticateUser(&g_userManager, accInfo, uid, gameClient, totalTime, 0) )
      {
        if ( !IPSessionDB::registerSessionKey(this_, uid, sessionKey) )
        {
          UserManager::removeUser(&g_userManager, uid);
          IPSessionDB::sendPayStats(this_, sessionKey, accInfo->connectedIP, payStat);
        }
      }
      else
      {
        IPSessionDB::sendPayStats(this_, sessionKey, accInfo->connectedIP, payStat);
      }
      MemoryObject::Release(&gameClient->base.base);
      _delete_table(accInfo);
      result = defaultResut;
    }
    else
    {
      IPSessionDB::sendPayStats(this_, sessionKey, accInfo->connectedIP, payStat);
      _delete_table(accInfo);
      ms_exc.registration.TryLevel = -1;
      result = false;
    }
  }
  else
  {
    result_1 = true;
    IPSessionDB::sendPayStats(this_, sessionKey, 0, payStat);
    ms_exc.registration.TryLevel = -1;
    result = result_1;
  }
  return result;
}

//----- (004253A2) --------------------------------------------------------
char __thiscall IPSessionDB::continueLogIn(IPSessionDB *this, int uid, int a3, char status)
{
  char result; // al@2
  CAuthSocket *gameClient; // [sp+14h] [bp-Ch]@3
  UserInfo *account; // [sp+18h] [bp-8h]@1
  char errorCode; // [sp+1Ch] [bp-4h]@7

  account = 0;
  IPSessionDB::takeWaitingAcc(this, uid, &account);
  if ( account )
  {
    gameClient = CAuthServer::getIOSocket(&g_authServer, account->gameSocket);
    if ( gameClient )
    {
      if ( status == REASON_PASS_WRONG )
      {
        CAuthSocket::assembleAndSend(gameClient, aCc_23, LS_KickedFromGS, REASON_ACCESS_FAILED);
        _delete_table(account);
        MemoryObject::Release(&gameClient->base.base);
        result = status;
      }
      else
      {
        errorCode = CAuthSocket::authenticateUser(gameClient, account, uid);
        MemoryObject::Release(&gameClient->base.base);
        _delete_table(account);
        result = errorCode;
      }
    }
    else
    {
      _delete_table(account);
      result = status;
    }
  }
  else
  {
    result = REASON_SYSTEM_ERROR_LOGIN_LATER;
  }
  return result;
}

//----- (00425485) --------------------------------------------------------
bool __cdecl IPSocket::packet_dummy_handler(CIOSocket *this, unsigned __int8 *buffer)
{
  LogWindow::Add(&g_LogWindow, 2, aCallDummypacke);
  return 0;
}

//----- (004254A0) --------------------------------------------------------
char __cdecl IPSocket::packet4_handler(IPSocket *this, unsigned __int8 *buffer)
{
  int uid; // [sp+1Ch] [bp-30h]@1
  char accName[15]; // [sp+20h] [bp-2Ch]@1
  int v5; // [sp+30h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+34h] [bp-18h]@1

  ms_exc.registration.TryLevel = 0;
  v5 = 0;
  memset(accName, 0, 15u);
  uid = BufferReader::ReadInt((char **)&buffer);
  BufferReader::ReadByte((char **)&buffer);
  v5 = BufferReader::ReadInt((char **)&buffer);
  BufferReader::ReadInt((char **)&buffer);
  BufferReader::ReadUInt((char **)&buffer);
  BufferReader::ReadString((char **)&buffer, 15, accName);
  accName[14] = 0;
  if ( uid )
    UserManager::removeUser(&g_userManager, uid);
  return 0;
}

//----- (004255CA) --------------------------------------------------------
char __cdecl IPSocket::packet3_handler(IPSocket *this, unsigned __int8 *buffer)
{
  char result; // al@2
  char result_1; // ST34_1@4
  char serverId_; // ST1C_1@5
  time_t time_; // eax@5
  int payStat; // [sp+14h] [bp-54h]@1
  CAuthSocket *gameClient; // [sp+18h] [bp-50h]@3
  int warnFlag; // [sp+1Ch] [bp-4Ch]@1
  int connectedIp; // [sp+20h] [bp-48h]@1
  int gameSocket; // [sp+24h] [bp-44h]@1
  int sessionKey; // [sp+28h] [bp-40h]@1
  int uid; // [sp+2Ch] [bp-3Ch]@1
  char accountName[15]; // [sp+30h] [bp-38h]@1
  signed int serverId; // [sp+40h] [bp-28h]@1
  int totalTime; // [sp+44h] [bp-24h]@1
  int loginFlag; // [sp+48h] [bp-20h]@1
  int success; // [sp+4Ch] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+50h] [bp-18h]@1

  ms_exc.registration.TryLevel = 0;
  uid = BufferReader::ReadInt((char **)&buffer);
  serverId = BufferReader::ReadByte((char **)&buffer);
  totalTime = BufferReader::ReadInt((char **)&buffer);
  payStat = BufferReader::ReadInt((char **)&buffer);
  connectedIp = BufferReader::ReadInt((char **)&buffer);
  loginFlag = 0;
  warnFlag = 0;
  sessionKey = 0;
  LOBYTE(success) = UserManager::userReadyForGS_IP_Session(
                      &g_userManager,
                      uid,
                      accountName,
                      &loginFlag,
                      &warnFlag,
                      &sessionKey,
                      (SOCKET *)&gameSocket);
  if ( (_BYTE)success )
  {
    accountName[14] = 0;
    gameClient = CAuthServer::getIOSocket(&g_authServer, gameSocket);
    if ( gameClient )
    {
      result_1 = UserManager::forwardUserToGS(
                   &g_userManager,
                   uid,
                   accountName,
                   totalTime,
                   loginFlag,
                   warnFlag,
                   sessionKey,
                   gameClient,
                   serverId,
                   payStat);
      MemoryObject::Release(&gameClient->base.base);
      if ( result_1 )
      {
        serverId_ = serverId;
        time_ = time(0);
        IPSessionDB::sendSomethingToIPSocket(
          &g_IPSessionDB,
          uid,
          connectedIp,
          payStat,
          0,
          time_,
          serverId_,
          accountName);
      }
    }
    result = 0;
  }
  else
  {
    ms_exc.registration.TryLevel = -1;
    result = 0;
  }
  return result;
}

//----- (004257A1) --------------------------------------------------------
char __cdecl IPSocket::packet2_handler(IPSocket *this, unsigned __int8 *buffer)
{
  int uid; // ST24_4@1
  char payStat; // ST20_1@1
  int totalTime; // ST28_4@1
  int sessionKey; // ST2C_4@1

  uid = BufferReader::ReadInt((char **)&buffer);
  payStat = BufferReader::ReadByte((char **)&buffer);
  totalTime = BufferReader::ReadInt((char **)&buffer);
  sessionKey = BufferReader::ReadInt((char **)&buffer);
  IPSessionDB::handleAuthLogin(&g_IPSessionDB, uid, sessionKey, false, totalTime, payStat);
  return 0;
}

//----- (00425880) --------------------------------------------------------
char __cdecl IPSocket::packet5_handler(IPSocket *this, unsigned __int8 *buffer)
{
  char status; // [sp+Ch] [bp-20h]@1
  int uid; // [sp+10h] [bp-1Ch]@1

  uid = BufferReader::ReadInt((char **)&buffer);
  status = BufferReader::ReadByte((char **)&buffer);
  if ( uid > 0 )
    IPSessionDB::continueLogIn(&g_IPSessionDB, uid, 0, status);
  return 0;
}

//----- (0042593E) --------------------------------------------------------
char __cdecl IPSocket::packet0_handler(IPSocket *this, unsigned __int8 *buffer)
{
  int field_2; // ST1C_4@1

  field_2 = BufferReader::ReadInt((char **)&buffer);
  IPSocket::set_field_2(this, field_2);
  return 0;
}

//----- (004259DF) --------------------------------------------------------
char __cdecl IPSocket::packet9_handler(IPSocket *this, unsigned __int8 *buffer)
{
  int uid; // ST2C_4@1
  char accountName[16]; // [sp+20h] [bp-28h]@1
  CPPEH_RECORD ms_exc; // [sp+30h] [bp-18h]@1

  ms_exc.registration.TryLevel = 0;
  BufferReader::ReadUInt((char **)&buffer);
  BufferReader::ReadInt((char **)&buffer);
  BufferReader::ReadInt((char **)&buffer);
  memset(accountName, 0, 16u);
  BufferReader::ReadString((char **)&buffer, 16, accountName);
  uid = BufferReader::ReadInt((char **)&buffer);
  accountName[14] = 0;
  UserManager::kickUser(&g_userManager, uid, 21, 1);
  return 0;
}

//----- (00425ADF) --------------------------------------------------------
char __cdecl IPSocket::packet11_handler(IPSocket *this, unsigned __int8 *buffer)
{
  char result; // al@2
  char result_2; // ST34_1@4
  char serverId_; // ST1C_1@5
  int loginTime; // eax@5
  int payStatus; // [sp+14h] [bp-54h]@1
  CAuthSocket *gameClient; // [sp+18h] [bp-50h]@3
  int warnFlag; // [sp+1Ch] [bp-4Ch]@1
  int connectedIp; // [sp+20h] [bp-48h]@1
  SOCKET socket; // [sp+24h] [bp-44h]@1
  int sessionKey; // [sp+28h] [bp-40h]@1
  int uid; // [sp+2Ch] [bp-3Ch]@1
  char accName[15]; // [sp+30h] [bp-38h]@1
  signed int serverId; // [sp+40h] [bp-28h]@1
  int totalTime; // [sp+44h] [bp-24h]@1
  int loginFlag; // [sp+48h] [bp-20h]@1
  int result_1; // [sp+4Ch] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+50h] [bp-18h]@1

  ms_exc.registration.TryLevel = 0;
  uid = BufferReader::ReadInt((char **)&buffer);
  serverId = BufferReader::ReadByte((char **)&buffer);
  totalTime = BufferReader::ReadInt((char **)&buffer);
  payStatus = BufferReader::ReadInt((char **)&buffer);
  connectedIp = BufferReader::ReadInt((char **)&buffer);
  memset(accName, 0, 15u);
  loginFlag = 0;
  warnFlag = 0;
  sessionKey = 0;
  LOBYTE(result_1) = UserManager::userReadyForGS_IP_Session(
                       &g_userManager,
                       uid,
                       accName,
                       &loginFlag,
                       &warnFlag,
                       &sessionKey,
                       &socket);
  if ( (_BYTE)result_1 )
  {
    accName[14] = 0;
    gameClient = CAuthServer::getIOSocket(&g_authServer, socket);
    if ( gameClient )
    {
      result_2 = UserManager::forwardUserToGS(
                   &g_userManager,
                   uid,
                   accName,
                   totalTime,
                   loginFlag,
                   warnFlag,
                   sessionKey,
                   gameClient,
                   serverId,
                   payStatus);
      MemoryObject::Release(&gameClient->base.base);
      if ( result_2 )
      {
        serverId_ = serverId;
        loginTime = time(0);
        IPSessionDB::sendSomethingToIPSocket(
          &g_IPSessionDB,
          uid,
          connectedIp,
          payStatus,
          0,
          loginTime,
          serverId_,
          accName);
      }
    }
    result = 0;
  }
  else
  {
    ms_exc.registration.TryLevel = -1;
    result = 0;
  }
  return result;
}

//----- (00425CC7) --------------------------------------------------------
char __cdecl IPSocket::packet10_handler(IPSocket *this, unsigned __int8 *buffer)
{
  int uid; // [sp+10h] [bp-1Ch]@1

  uid = BufferReader::ReadInt((char **)&buffer);
  BufferReader::ReadByte((char **)&buffer);
  if ( uid > 0 )
    UserManager::removeUser(&g_userManager, uid);
  return 0;
}

//----- (00425D86) --------------------------------------------------------
char __cdecl IPSocket::packet13_handler(IPSocket *this, unsigned __int8 *buffer)
{
  int uid; // [sp+0h] [bp-4h]@1

  uid = BufferReader::ReadInt((char **)&buffer);
  if ( uid > 0 )
    UserManager::removeUser(&g_userManager, uid);
  return 0;
}

//----- (00425DBA) --------------------------------------------------------
char __cdecl IPSocket::packet15_handler(IPSocket *this, unsigned __int8 *buffer)
{
  int payStat; // [sp+0h] [bp-20h]@1
  int clientIP; // [sp+4h] [bp-1Ch]@1
  int uid; // [sp+8h] [bp-18h]@1
  char accName[16]; // [sp+Ch] [bp-14h]@1
  int sessionKey; // [sp+1Ch] [bp-4h]@1

  uid = BufferReader::ReadInt((char **)&buffer);
  sessionKey = BufferReader::ReadInt((char **)&buffer);
  clientIP = BufferReader::ReadInt((char **)&buffer);
  payStat = BufferReader::ReadInt((char **)&buffer);
  if ( UserManager::userAuthed(&g_userManager, uid, accName) <= 0 )
    IPSessionDB::sendPayStats(&g_IPSessionDB, sessionKey, clientIP, payStat);
  else
    IPSessionDB::registerSessionKey(&g_IPSessionDB, uid, sessionKey);
  return 0;
}

//----- (00425E53) --------------------------------------------------------
char __cdecl IPSocket::packet14_handler(IPSocket *this, unsigned __int8 *buffer)
{
  BufferReader::ReadInt((char **)&buffer);
  BufferReader::ReadInt((char **)&buffer);
  return 0;
}

//----- (00425E8B) --------------------------------------------------------
IPSocket *__cdecl IPSocket::Create(SOCKET socket)
{
  IPSocket *v2; // [sp+0h] [bp-18h]@2
  IPSocket *v3; // [sp+4h] [bp-14h]@1

  v3 = (IPSocket *)operator_new(0x88u);
  if ( v3 )
    v2 = IPSocket::IPSocket(v3, socket);
  else
    v2 = 0;
  return v2;
}

//----- (00425EF9) --------------------------------------------------------
IPSocket *__thiscall IPSocket::IPSocket(IPSocket *this, SOCKET socket)
{
  IPSocket *this_; // ST04_4@1

  this_ = this;
  CIOSocket::CIOSocket(&this->base, socket);
  this_->base.base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&IPSocket_vtable_off_45F7E0;
  this_->m_serverIP.S_un.S_addr = g_Config.IpServer;
  this_->m_field_11 = 0;
  this_->m_status = SocketStatus_Init;
  this_->m_packetHandlers = IPSocket::handlers;
  this_->m_field_1 = 0;
  MemoryObject::AddRef(&this_->base.base);
  this_->m_socketFamily = AF_INET;
  this_->m_ipsocIP.S_un.S_addr = g_Config.IpServer;
  this_->m_port = htons(g_Config.IpPort);
  this_->m_field_2 = 0;
  IPSocket::isReconnecting = false;
  return this_;
}
// 45F7E0: using guessed type int (__stdcall *IPSocket_vtable_off_45F7E0)(int);
// 47F811: using guessed type char IPSocket::isReconnecting;

//----- (00425FC4) --------------------------------------------------------
MemoryObject *__fastcall IPSocket::Destructor(IPSocket *this)
{
  IPSocket *v1; // ST0C_4@1

  v1 = this;
  this->base.base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&IPSocket_vtable_off_45F7E0;
  LogWindow::Add(&g_LogWindow, 3, aIpsocketDelete);
  return CIOSocket::Destructor(&v1->base);
}
// 45F7E0: using guessed type int (__stdcall *IPSocket_vtable_off_45F7E0)(int);

//----- (00426021) --------------------------------------------------------
BOOL __thiscall IPSocket::OnClose(IPSocket *this)
{
  IPSocket *this_; // ST1C_4@1
  IPSocket *v2; // ST18_4@1
  SOCKET v3; // ST14_4@1
  char *v4; // eax@1

  this_ = this;
  this->m_status = SocketStatus_Closed;
  IPSocket::isReconnecting = true;
  g_Config.Useipserver = false;
  v2 = this;
  v3 = this->base.m_hSocket;
  v4 = IPSocket::addrToStr(this);
  LogWindow::Add(&g_LogWindow, 3, aCloseConnect_1, v4, v3, v2);
  IPSessionDB::clearWaitinAccs(&g_IPSessionDB);
  MemoryObject::AddRef(&this_->base.base);
  return CreateTimerQueueTimer(&IPSocket::s_timer, 0, IPSocket::onTimeout, this_, g_Config.IpInterval, 0, 0);
}
// 47F811: using guessed type char IPSocket::isReconnecting;

//----- (0042609F) --------------------------------------------------------
void IPSocket::OnTimerCallback()
{
  ;
}

//----- (004260AA) --------------------------------------------------------
char *__thiscall IPSocket::addrToStr(IPSocket *this)
{
  return inet_ntoa(this->m_serverIP);
}

//----- (004260C2) --------------------------------------------------------
char __thiscall IPSocket::OnCreate(IPSocket *this)
{
  IPSocket *this_; // ST14_4@1

  this_ = this;
  MemoryObject::AddRef(&this->base.base);
  this_->base.base.vftbl_0_45F520->derived_func_9((CIOSocket *)this_);// OnRead
  return IPSocket::send(this_, aCdc, 0, g_buildNumber, g_Config.GameID);
}

//----- (00426100) --------------------------------------------------------
LONG __thiscall IPSocket::OnRead(IPSocket *this)
{
  LONG result; // eax@2
  IPPacket *packet; // ST18_4@16
  IPSocket *this_; // [sp+0h] [bp-14h]@1
  unsigned __int8 *buffer; // [sp+8h] [bp-Ch]@1
  signed __int32 buffSize; // [sp+Ch] [bp-8h]@1
  signed __int32 dwRead; // [sp+10h] [bp-4h]@1

  this_ = this;
  dwRead = 0;
  buffSize = this->base.m_pReadBuf->m_dwSize;
  buffer = this->base.m_pReadBuf->m_Buffer;
  if ( this->m_status == SocketStatus_Closed )
  {
    result = CIOSocket::Close(&this->base);
  }
  else
  {
    while ( 1 )
    {
      while ( 1 )
      {
        if ( dwRead >= buffSize )
          return CIOSocket::Read(&this_->base, 0);
        if ( this_->m_status )
          break;
        if ( dwRead + 3 > buffSize )
          return CIOSocket::Read(&this_->base, buffSize - dwRead);
        this_->m_packetSize = buffer[dwRead] + (buffer[dwRead + 1] << 8) + 1;
        if ( this_->m_packetSize <= 0 || this_->m_packetSize > 8192 )
        {
          LogWindow::Add(&g_LogWindow, 3, aDBadPacketSi_0, this_->base.m_hSocket, this_->m_packetSize);
          goto LABEL_20;
        }
        dwRead += 2;
        this_->m_status = SocketStatus_BytesRead;
      }
      if ( this_->m_status != SocketStatus_BytesRead )
        goto LABEL_20;
      if ( this_->m_packetSize + dwRead > buffSize )
        return CIOSocket::Read(&this_->base, buffSize - dwRead);
      if ( (signed int)buffer[dwRead] >= 16 )
        break;
      packet = IPPacket::Alloc();
      packet->base.m_pSocket = (CIOSocket *)this_;
      packet->base.m_pBuf = this_->base.m_pReadBuf;
      packet->base.m_pFunc = (void (__cdecl *)(CAuthSocket *, char *))this_->m_packetHandlers[buffer[dwRead]];
      MemoryObject::AddRef(&this_->base.base);
      CIOBuffer::AddRef(this_->base.m_pReadBuf);
      InterlockedIncrement(&IPPacket::g_nPendingPacket);
      CPacket::PostObject(&packet->base, dwRead, Threading::g_hCompletionPort);
      dwRead += this_->m_packetSize;
      this_->m_status = SocketStatus_Init;
    }
    LogWindow::Add(&g_LogWindow, 3, aUnknownProto_0, buffer[dwRead]);
LABEL_20:
    result = CIOSocket::Close(&this_->base);
  }
  return result;
}

//----- (004262FA) --------------------------------------------------------
char IPSocket::send(IPSocket *this, char *format, ...)
{
  char result; // al@4
  int packetSize; // [sp+4h] [bp-Ch]@5
  CIOBuffer *buff; // [sp+Ch] [bp-4h]@5
  va_list va; // [sp+20h] [bp+10h]@1

  va_start(va, format);
  MemoryObject::AddRef(&this->base.base);
  if ( this->m_status != SocketStatus_Closed && !IPSocket::isReconnecting && g_Config.Useipserver )
  {
    buff = CIOBuffer::Alloc();
    packetSize = PacketUtils::VAssemble((char *)&buff->m_Buffer[2], 8190, format, va);
    if ( packetSize )
    {
      buff->m_Buffer[0] = --packetSize;
      buff->m_Buffer[1] = BYTE1(packetSize);
    }
    else
    {
      LogWindow::Add(&g_LogWindow, 3, aDAssembleToo_1, this->base.m_hSocket, format);
    }
    buff->m_dwSize = packetSize + 3;
    CIOSocket::Write(&this->base, buff);
    MemoryObject::Release(&this->base.base);
    result = true;
  }
  else
  {
    MemoryObject::Release(&this->base.base);
    result = false;
  }
  return result;
}
// 47F811: using guessed type char IPSocket::isReconnecting;

//----- (004263E8) --------------------------------------------------------
char __thiscall IPSessionDB::unused(IPSessionDB *this, int uid, int a2, int a3, char a4)
{
  char result; // al@5
  char result_1; // ST3C_1@6
  int sessionKey; // [sp+14h] [bp-24h]@1
  char result_2; // [sp+1Ch] [bp-1Ch]@1

  result_2 = 0;
  sessionKey = IPSessionDB::getSessionKey(this, uid);
  if ( g_IPSocket && !IPSocket::isReconnecting && g_Config.Useipserver && sessionKey )
  {
    ReadWriteLock::readLock(&IPSocket::s_lock);
    result_1 = IPSocket::send(g_IPSocket, aCdddcdd, 4, sessionKey, g_IPSocket->m_field_2, uid, a4, a2, a3);
    ReadWriteLock::releaseReadLock(&IPSocket::s_lock);
    if ( !result_1 )
      result_2 = 10;
    result = result_2;
  }
  else
  {
    result = 10;
  }
  return result;
}
// 47F811: using guessed type char IPSocket::isReconnecting;

//----- (0042651E) --------------------------------------------------------
char __thiscall IPSessionDB::sendSomethingToIPSocket(IPSessionDB *this, int uid, int connectedIp, int payStatus, int a5, int loginTime, char serverId, char *accName)
{
  char errorCode_1; // al@2
  int sessionKey1; // [sp+14h] [bp-24h]@1
  char success; // [sp+18h] [bp-20h]@1
  char errorCode; // [sp+1Ch] [bp-1Ch]@1

  errorCode = 0;
  sessionKey1 = IPSessionDB::getSessionKey(this, uid);
  success = true;
  if ( sessionKey1 )
  {
    if ( g_Config.Useipserver && sessionKey1 && g_IPSocket && !IPSocket::isReconnecting )
    {
      ReadWriteLock::readLock(&IPSocket::s_lock);
      success = IPSocket::send(
                  g_IPSocket,
                  aCddddcddsd,
                  5,
                  g_IPSocket->m_field_2,
                  sessionKey1,
                  connectedIp,
                  payStatus,
                  serverId,
                  a5,
                  loginTime,
                  accName,
                  g_Config.GameID);
      ReadWriteLock::releaseReadLock(&IPSocket::s_lock);
    }
    if ( !success )
      errorCode = 10;
    errorCode_1 = errorCode;
  }
  else
  {
    errorCode_1 = 10;
  }
  return errorCode_1;
}
// 47F811: using guessed type char IPSocket::isReconnecting;

//----- (0042666C) --------------------------------------------------------
char __thiscall IPSessionDB::sendServerLoginRequested(IPSessionDB *this, int uid, int ipAddress, int payStat, char serverId)
{
  char errorCode_1; // al@5
  char result_2; // ST3C_1@6
  int sessionKey1; // [sp+14h] [bp-24h]@1
  char errorCode; // [sp+1Ch] [bp-1Ch]@1

  errorCode = 0;
  sessionKey1 = IPSessionDB::getSessionKey(this, uid);
  if ( g_IPSocket && !IPSocket::isReconnecting && g_Config.Useipserver && sessionKey1 )
  {
    ReadWriteLock::readLock(&IPSocket::s_lock);
    result_2 = IPSocket::send(
                 g_IPSocket,
                 aCdddcdd_0,
                 9,
                 sessionKey1,
                 g_IPSocket->m_field_2,
                 uid,
                 serverId,
                 ipAddress,
                 payStat);
    ReadWriteLock::releaseReadLock(&IPSocket::s_lock);
    if ( !result_2 )
      errorCode = 10;
    errorCode_1 = errorCode;
  }
  else
  {
    errorCode_1 = 10;
  }
  return errorCode_1;
}
// 47F811: using guessed type char IPSocket::isReconnecting;

//----- (004267A2) --------------------------------------------------------
char __thiscall IPSessionDB::sendUserLoggedIn(IPSessionDB *this, int uid, int connectedIP, int payStat, char serverId)
{
  char errorCode; // al@5
  char v6; // ST3C_1@6
  int sessionKey; // [sp+14h] [bp-24h]@1
  char errorCode_1; // [sp+1Ch] [bp-1Ch]@1

  errorCode_1 = 0;
  sessionKey = IPSessionDB::getSessionKey(this, uid);
  if ( g_IPSocket && !IPSocket::isReconnecting && g_Config.Useipserver && sessionKey )
  {
    ReadWriteLock::readLock(&IPSocket::s_lock);
    v6 = IPSocket::send(
           g_IPSocket,
           aCdddcdd_1,
           10,
           sessionKey,
           g_IPSocket->m_field_2,
           uid,
           serverId,
           connectedIP,
           payStat);
    ReadWriteLock::releaseReadLock(&IPSocket::s_lock);
    if ( !v6 )
      errorCode_1 = 10;
    errorCode = errorCode_1;
  }
  else
  {
    errorCode = 10;
  }
  return errorCode;
}
// 47F811: using guessed type char IPSocket::isReconnecting;

//----- (004268D8) --------------------------------------------------------
int SomeStaticInit41()
{
  SomeBitsInit();
  return sub_4268E7();
}

//----- (004268E7) --------------------------------------------------------
int sub_4268E7()
{
  return atexit(emptystub);
}

//----- (00426900) --------------------------------------------------------
IPSlot *__thiscall IPSlot::IPSlot(IPSlot *this)
{
  IPSlot *v1; // ST08_4@1

  v1 = this;
  this->m_pPacket = 0;
  SpinLock::SpinLock(&this->m_lock, LockType_WaitLock, 0);
  return v1;
}

//----- (00426950) --------------------------------------------------------
void IPPacketPool::Destructor()
{
  IPPacket::FreeAll();
}

//----- (00426960) --------------------------------------------------------
IPPacket *__thiscall IPPacket::IPPacket(IPPacket *this)
{
  IPPacket *v1; // ST00_4@1

  v1 = this;
  MemoryObject::MemoryObject(&this->base.base);
  v1->base.base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&IPPacket_vtable_off_45F668;
  return v1;
}
// 45F668: using guessed type int (__stdcall *IPPacket_vtable_off_45F668)(int);

//----- (00426980) --------------------------------------------------------
IPPacket *__thiscall IPPacket::DeletingDestructor(IPPacket *this, char a2)
{
  IPPacket *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  IPPacket::Destructor(this);
  if ( a2 & 1 )
    operator_delete(v3);
  return v3;
}

//----- (004269B0) --------------------------------------------------------
MemoryObject *__thiscall IPPacket::Destructor(IPPacket *this)
{
  return MemoryObject::Destructor(&this->base.base);
}

//----- (004269D0) --------------------------------------------------------
IPSessionDB *__thiscall IPSessionDB::DestructorCall(IPSessionDB *this, char a2)
{
  IPSessionDB *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  IPSessionDB::Destructor(this);
  if ( a2 & 1 )
    _delete_table(v3);
  return v3;
}

//----- (00426A80) --------------------------------------------------------
IPSocket *__thiscall IPSocket::DeletingDestructor(IPSocket *this, char a2)
{
  IPSocket *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  IPSocket::Destructor(this);
  if ( a2 & 1 )
    operator_delete(v3);
  return v3;
}

//----- (00426AB0) --------------------------------------------------------
std::map_int_int *__thiscall std::map_int_int::map_int_int(std::map_int_int *this, _BYTE *a2, _BYTE *a3)
{
  std::map_int_int *v3; // ST08_4@1

  v3 = this;
  std::map_int_int::map_int_int_2(this, a2, a3);
  return v3;
}

//----- (00426AD0) --------------------------------------------------------
std::_tree_int_int::iterator *__thiscall std::map_int_int::end(std::map_int_int *this, std::_tree_int_int::iterator *a2)
{
  std::_tree_int_int::end(&this->_Tr, a2);
  return a2;
}

//----- (00426AF0) --------------------------------------------------------
std::pair_bool_int *__thiscall std::map_int_int::insert(std::map_int_int *this, std::pair_bool_int *res, std::pair_int_int *a3)
{
  int v4; // [sp+4h] [bp-8h]@1
  char v5; // [sp+8h] [bp-4h]@1

  std::_tree_int_int::insert(&this->_Tr, (int)&v4, (struct Concurrency::IExecutionContext *)a3);
  sub_428890((std::map_int_int *)res, &v4, &v5);
  return res;
}

//----- (00426B30) --------------------------------------------------------
_DWORD *__thiscall std::map_int_int::erase(std::map_int_int *this, _DWORD *a2, std::_tree_int_int::iterator *_P)
{
  std::_tree_int_int::erase2(&this->_Tr, a2, _P);
  return a2;
}

//----- (00426B50) --------------------------------------------------------
_DWORD *__thiscall std::map_int_int::find(std::map_int_int *this, _DWORD *a2, _DWORD *a3)
{
  std::_tree_int_int::find(&this->_Tr, a2, a3);
  return a2;
}

//----- (00426B70) --------------------------------------------------------
void __thiscall sub_426B70(std::_tree *this)
{
  std::_tree *v1; // ST0C_4@1
  std::_tree_int_int::_Node *v2; // ST08_4@1
  int *v3; // eax@1
  char v4; // [sp+4h] [bp-14h]@1
  char v5; // [sp+8h] [bp-10h]@1
  char v6; // [sp+Ch] [bp-Ch]@1
  char v7; // [sp+10h] [bp-8h]@1
  void *v8; // [sp+14h] [bp-4h]@1

  v1 = this;
  v2 = std::_tree_int_int::end((std::_tree_int_int *)this, (std::_tree_int_int::iterator *)&v6)->_Ptr;
  v3 = (int *)sub_426F00(v1, (int)&v5);
  sub_427970(v1, &v4, *v3, (char)v2);
  std::_tree_int_int::_Freenode((std::_tree_int_int::_Node *)v1->_Head);
  v1->_Head = 0;
  v1->_Size = 0;
  v8 = 0;
  std::_Lockit::_Lockit((std::_Lockit *)&v7);
  if ( !--std::_tree_int_int::_Nilrefs )
  {
    v8 = std::_tree_int_int::_Nil;
    std::_tree_int_int::_Nil = 0;
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v7);
  if ( v8 )
    std::_tree_int_int::_Freenode((std::_tree_int_int::_Node *)v8);
}
// 47F820: using guessed type int std::_tree_int_int::_Nilrefs;

//----- (00426C20) --------------------------------------------------------
std::pair_int_int *__thiscall std::pair_int_int::pair_int_int(std::pair_int_int *this, _DWORD *a2, _DWORD *a3)
{
  this->first = *a2;
  this->second = *a3;
  return this;
}

//----- (00426C70) --------------------------------------------------------
BOOL __thiscall std::_tree_int_int::iterator::not_eq(std::_tree_int_int::iterator *this, std::_tree_int_int::iterator *a2)
{
  return (unsigned __int8)std::_tree_int_int::iterator_operator_eq(this, a2) == 0;
}

//----- (00426CA0) --------------------------------------------------------
std::map_int_acc *__thiscall std::map_int_sockid::map_int_sockid(std::map_int_acc *this, _BYTE *a2, _BYTE *a3)
{
  std::map_int_acc *v3; // ST08_4@1

  v3 = this;
  std::map_int_sockid::map_int_sockid2(this, a2, a3);
  return v3;
}

//----- (00426CC0) --------------------------------------------------------
std::_tree_int_acc::iterator *__thiscall std::map_int_acc::begin(std::map_int_acc *this, std::_tree_int_acc::iterator *a2)
{
  std::_tree_int_acc::begin(&this->_Tr, a2);
  return a2;
}

//----- (00426CE0) --------------------------------------------------------
std::_tree_int_acc::iterator *__thiscall std::map_int_acc::end(std::map_int_acc *this, std::_tree_int_acc::iterator *a2)
{
  std::_tree_int_acc::end(&this->_Tr, a2);
  return a2;
}

//----- (00426D00) --------------------------------------------------------
std::pair_bool_acc *__thiscall std::map_int_acc::insert(std::map_int_acc *this, std::pair_bool_acc *a2, std::pair_int_acc *pair)
{
  int v4; // [sp+4h] [bp-8h]@1
  char v5; // [sp+8h] [bp-4h]@1

  sub_427BF0(this, (int)&v4, (struct Concurrency::IExecutionContext *)pair);
  sub_428860((int)a2, &v4, &v5);
  return a2;
}

//----- (00426D40) --------------------------------------------------------
_DWORD *__thiscall std::map_int_acc::erase(std::map_int_acc *this, _DWORD *a2, std::_tree_int_acc::iterator *a3)
{
  std::_tree_int_sockid::erase2(&this->_Tr, a2, a3);
  return a2;
}

//----- (00426D60) --------------------------------------------------------
std::_tree_int_acc::iterator *__thiscall std::map_int_acc::find(std::map_int_acc *this, _DWORD *a2, _DWORD *a3)
{
  std::_tree_int_sockid::find(&this->_Tr, a2, a3);
  return (std::_tree_int_acc::iterator *)a2;
}

//----- (00426D80) --------------------------------------------------------
void __thiscall sub_426D80(std::_tree *this)
{
  std::_tree *v1; // ST0C_4@1
  std::_tree_int_acc::_Node *v2; // ST08_4@1
  int *v3; // eax@1
  char v4; // [sp+4h] [bp-14h]@1
  char v5; // [sp+8h] [bp-10h]@1
  char v6; // [sp+Ch] [bp-Ch]@1
  char v7; // [sp+10h] [bp-8h]@1
  void *v8; // [sp+14h] [bp-4h]@1

  v1 = this;
  v2 = std::_tree_int_acc::end((std::_tree_int_acc *)this, (std::_tree_int_acc::iterator *)&v6)->_Ptr;
  v3 = (int *)std::_tree_int_acc::begin((std::_tree_int_acc *)v1, (std::_tree_int_acc::iterator *)&v5);
  sub_428650(v1, &v4, *v3, (char)v2);
  std::_tree_int_sockid::_Freenode((#548 *)v1->_Head);
  v1->_Head = 0;
  v1->_Size = 0;
  v8 = 0;
  std::_Lockit::_Lockit((std::_Lockit *)&v7);
  if ( !--std::_tree_int_sockid::_Nilrefs )
  {
    v8 = (void *)std::_tree_int_sockid::_Nil;
    std::_tree_int_sockid::_Nil = 0;
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v7);
  if ( v8 )
    std::_tree_int_sockid::_Freenode((#548 *)v8);
}
// 47F828: using guessed type int std::_tree_int_sockid::_Nilrefs;

//----- (00426E30) --------------------------------------------------------
std::pair_int_acc *__thiscall std::pair_int_acc::pair_int_acc(std::pair_int_acc *this, _DWORD *a2, UserInfo **a3)
{
  this->first = *a2;
  this->second = *a3;
  return this;
}

//----- (00426EA0) --------------------------------------------------------
BOOL __thiscall std::map_int_acc::iterator::not_eq(std::_tree_int_acc::iterator *this, std::_tree_int_acc::iterator *a2)
{
  return (unsigned __int8)std::map_int_acc::iterator::operator_eq(this, a2) == 0;
}

//----- (00426ED0) --------------------------------------------------------
std::map_int_int *__thiscall std::map_int_int::map_int_int_2(std::map_int_int *this, _BYTE *a2, _BYTE *a3)
{
  std::map_int_int *v3; // ST0C_4@1

  v3 = this;
  std::_tree_int_int::_tree_int_int(&this->_Tr, a2, 0, a3);
  return v3;
}

//----- (00426F00) --------------------------------------------------------
int __thiscall sub_426F00(void *this, int a2)
{
  std::_tree_int_int::_Node **v2; // eax@1

  v2 = std::_tree_int_int::_Lmost((std::_tree_int_int *)this);
  std::_tree_int_int::iterator::iterator((std::_tree_int_int::iterator *)a2, *v2);
  return a2;
}

//----- (00426F30) --------------------------------------------------------
std::_tree_int_int::iterator *__thiscall std::_tree_int_int::end(std::_tree_int_int *this, std::_tree_int_int::iterator *a2)
{
  std::_tree_int_int::iterator::iterator(a2, this->_Head);
  return a2;
}

//----- (00426F50) --------------------------------------------------------
int __thiscall std::_tree_int_int::insert(std::_tree_int_int *this, int a2, struct Concurrency::IExecutionContext *a3)
{
  struct Concurrency::details::InternalContextBase *v3; // ST10_4@3
  struct Concurrency::details::InternalContextBase *v4; // eax@3
  _DWORD *v5; // eax@8
  int result; // eax@8
  std::_tree_int_int::iterator *v7; // eax@10
  _DWORD *v8; // eax@11
  struct Concurrency::details::InternalContextBase *v9; // ST10_4@13
  std::_tree_int_int::_Node *v10; // eax@13
  struct Concurrency::details::InternalContextBase *v11; // eax@13
  _DWORD *v12; // eax@14
  std::_tree_int_int::_Node *v13; // [sp+0h] [bp-40h]@4
  std::_tree_int_int *v14; // [sp+4h] [bp-3Ch]@1
  char v15; // [sp+8h] [bp-38h]@15
  int v16; // [sp+Ch] [bp-34h]@14
  char v17; // [sp+10h] [bp-30h]@14
  char v18; // [sp+14h] [bp-2Ch]@13
  int v19; // [sp+18h] [bp-28h]@11
  char v20; // [sp+1Ch] [bp-24h]@11
  char v21; // [sp+20h] [bp-20h]@10
  int v22; // [sp+24h] [bp-1Ch]@8
  char a3a; // [sp+28h] [bp-18h]@8
  char v24; // [sp+2Ch] [bp-14h]@3
  std::_tree_int_int::_Node *a2a; // [sp+30h] [bp-10h]@1
  std::_tree_int_int::_Node *a1; // [sp+34h] [bp-Ch]@1
  int v27; // [sp+38h] [bp-8h]@1
  std::_tree_int_int::iterator v28; // [sp+3Ch] [bp-4h]@9

  v14 = this;
  a1 = *std::_tree_int_int::_Root(this);
  a2a = v14->_Head;
  LOBYTE(v27) = 1;
  while ( a1 != std::_tree_int_int::_Nil )
  {
    a2a = a1;
    v3 = std::_tree_int_int::_Key((int)a1);
    v4 = Concurrency::details::VirtualProcessor::ToInternalContext((Concurrency::details::VirtualProcessor *)&v24, a3);
    LOBYTE(v27) = std::_tree::key_compare(v4, v3);
    if ( (_BYTE)v27 )
      v13 = *std::_tree_int_int::_Left(a1);
    else
      v13 = *std::_tree_int_int::_Right(a1);
    a1 = v13;
  }
  if ( v14->_Multi )
  {
    a3a = 1;
    v5 = (_DWORD *)sub_428A50(v14, (int)&v22, (int)a1, (int)a2a, a3);
    sub_428890((std::map_int_int *)a2, v5, &a3a);
    return a2;
  }
  std::_tree_int_int::iterator::iterator(&v28, a2a);
  if ( (_BYTE)v27 )
  {
    v7 = (std::_tree_int_int::iterator *)sub_426F00(v14, (int)&v21);
    if ( (unsigned __int8)std::_tree_int_int::iterator_operator_eq(&v28, v7) )
    {
      v20 = 1;
      v8 = (_DWORD *)sub_428A50(v14, (int)&v19, (int)a1, (int)a2a, a3);
      sub_428890((std::map_int_int *)a2, v8, &v20);
      return a2;
    }
    unknown_libname_153(&v28);
  }
  v9 = Concurrency::details::VirtualProcessor::ToInternalContext((Concurrency::details::VirtualProcessor *)&v18, a3);
  v10 = std::_tree_int_int::iterator::_Mynode2(&v28);
  v11 = std::_tree_int_int::_Key((int)v10);
  if ( (unsigned __int8)std::_tree::key_compare(v11, v9) )
  {
    v17 = 1;
    v12 = (_DWORD *)sub_428A50(v14, (int)&v16, (int)a1, (int)a2a, a3);
    sub_428890((std::map_int_int *)a2, v12, &v17);
    result = a2;
  }
  else
  {
    v15 = 0;
    sub_428890((std::map_int_int *)a2, &v28, &v15);
    result = a2;
  }
  return result;
}
// 4292A0: using guessed type int __thiscall unknown_libname_153(_DWORD);

//----- (00427120) --------------------------------------------------------
_DWORD *__thiscall std::_tree_int_int::erase2(std::_tree_int_int *this, _DWORD *a2, std::_tree_int_int::iterator *_P)
{
  std::_tree_int_int::iterator *v3; // eax@1
  std::_tree_int_int::_Node *v4; // eax@5
  std::_tree_int_int::_Node **v5; // eax@7
  std::_tree_int_int::_Node **v6; // eax@7
  std::_tree_int_int::_Node **v7; // esi@7
  std::_tree_int_int::_Node **v8; // eax@7
  std::_tree_int_int::_Node **v9; // eax@8
  std::_tree_int_int::_Node **v10; // esi@9
  std::_tree_int_int::_Node **v11; // eax@9
  std::_tree_int_int::_Node **v12; // eax@9
  std::_tree_int_int::_Node **v13; // esi@9
  std::_tree_int_int::_Node **v14; // eax@9
  std::_tree_int_int::_Node **v15; // eax@9
  std::_tree_int_int::_Node **v16; // eax@10
  std::_tree_int_int::_Node **v17; // eax@11
  std::_tree_int_int::_Node **v18; // eax@12
  std::_tree_int_int::_Node **v19; // eax@12
  std::_tree_int_int::_Node **v20; // eax@13
  std::_tree_int_int::_Node **v21; // eax@13
  std::_tree_int_int::_Node **v22; // eax@14
  std::_tree_int_int::_Node **v23; // eax@14
  std::_tree_int_int::_Node **v24; // esi@15
  int *v25; // ST04_4@15
  int *v26; // eax@15
  std::_tree_int_int::_Node **v27; // esi@16
  std::_tree_int_int::_Node **v28; // eax@16
  std::_tree_int_int::_Node **v29; // eax@17
  std::_tree_int_int::_Node **v30; // eax@18
  std::_tree_int_int::_Node **v31; // eax@18
  std::_tree_int_int::_Node **v32; // eax@19
  std::_tree_int_int::_Node **v33; // eax@19
  std::_tree_int_int::_Node **v34; // eax@20
  std::_tree_int_int::_Node **v35; // eax@20
  std::_tree_int_int::_Node **v36; // eax@21
  std::_tree_int_int::_Node **v37; // esi@23
  std::_tree_int_int::_Node *v38; // esi@24
  std::_tree_int_int::_Node **v39; // eax@25
  std::_tree_int_int::_Node **v40; // esi@27
  std::_tree_int_int::_Node *v41; // esi@28
  std::_tree_int_int::_Node **v42; // eax@30
  std::_tree_int_int::_Node **v43; // eax@32
  std::_tree_int_int::_Node **v44; // eax@32
  std::_tree_int_int::_Node **v45; // eax@33
  std::_tree_int_int::_Node **v46; // eax@34
  int *v47; // eax@34
  std::_tree_int_int::_Node **v48; // eax@34
  std::_tree_int_int::_Node **v49; // eax@35
  std::_tree_int_int::_Node **v50; // eax@36
  std::_tree_int_int::_Node **v51; // eax@38
  std::_tree_int_int::_Node **v52; // eax@39
  std::_tree_int_int::_Node **v53; // eax@39
  std::_tree_int_int::_Node **v54; // eax@40
  _DWORD *v55; // esi@40
  std::_tree_int_int::_Node **v56; // eax@40
  std::_tree_int_int::_Node **v57; // eax@40
  int *v58; // eax@40
  std::_tree_int_int::_Node **v59; // eax@41
  std::_tree_int_int::_Node **v60; // eax@42
  int *v61; // eax@42
  std::_tree_int_int::_Node **v62; // eax@42
  std::_tree_int_int::_Node **v63; // eax@43
  std::_tree_int_int::_Node **v64; // eax@44
  std::_tree_int_int::_Node **v65; // eax@46
  std::_tree_int_int::_Node **v66; // eax@47
  std::_tree_int_int::_Node **v67; // eax@47
  std::_tree_int_int::_Node **v68; // eax@48
  _DWORD *v69; // esi@48
  std::_tree_int_int::_Node **v70; // eax@48
  std::_tree_int_int::_Node **v71; // eax@48
  int *v72; // eax@48
  void **v73; // eax@51
  std::_tree_int_int *this_; // [sp+4h] [bp-2Ch]@1
  int a2a; // [sp+8h] [bp-28h]@1
  std::_tree_int_int::_Node *v77; // [sp+Ch] [bp-24h]@41
  std::_tree_int_int::_Node *a1; // [sp+10h] [bp-20h]@33
  char v79; // [sp+14h] [bp-1Ch]@6
  std::_tree_int_int::_Node *_Z; // [sp+18h] [bp-18h]@1
  std::_tree_int_int::_Node *_Y; // [sp+1Ch] [bp-14h]@1
  std::_tree_int_int::_Node *_X; // [sp+20h] [bp-10h]@2
  int v83; // [sp+2Ch] [bp-4h]@6

  this_ = this;
  v3 = std::_tree_int_int::iterator::post_increment((std::_tree_int_int::iterator *)&_P, &a2a, 0);
  _Y = std::_tree_int_int::iterator::_Mynode2(v3);
  _Z = _Y;
  if ( *std::_tree_int_int::_Left(_Y) == std::_tree_int_int::_Nil )
  {
    _X = *std::_tree_int_int::_Right(_Y);
  }
  else if ( *std::_tree_int_int::_Right(_Y) == std::_tree_int_int::_Nil )
  {
    _X = *std::_tree_int_int::_Left(_Y);
  }
  else
  {
    v4 = (std::_tree_int_int::_Node *)std::_tree_int_int::_Right(_Y);
    _Y = std::_tree_int_int::_Min(v4->_Left);
    _X = *std::_tree_int_int::_Right(_Y);
  }
  std::_Lockit::_Lockit((std::_Lockit *)&v79);
  v83 = 0;
  if ( _Y == _Z )
  {
    v27 = std::_tree_int_int::_Parent(_Y);
    *std::_tree_int_int::_Parent(_X) = *v27;
    v28 = std::_tree_int_int::_Root(this_);
    if ( *v28 == _Z )
    {
      v29 = std::_tree_int_int::_Root(this_);
      *v29 = _X;
    }
    else
    {
      v30 = std::_tree_int_int::_Parent(_Z);
      v31 = std::_tree_int_int::_Left(*v30);
      if ( *v31 == _Z )
      {
        v32 = std::_tree_int_int::_Parent(_Z);
        v33 = std::_tree_int_int::_Left(*v32);
        *v33 = _X;
      }
      else
      {
        v34 = std::_tree_int_int::_Parent(_Z);
        v35 = std::_tree_int_int::_Right(*v34);
        *v35 = _X;
      }
    }
    v36 = std::_tree_int_int::_Lmost(this_);
    if ( *v36 == _Z )
    {
      if ( *std::_tree_int_int::_Right(_Z) == std::_tree_int_int::_Nil )
      {
        v37 = std::_tree_int_int::_Parent(_Z);
        *std::_tree_int_int::_Lmost(this_) = *v37;
      }
      else
      {
        v38 = std::_tree_int_int::_Min(_X);
        *std::_tree_int_int::_Lmost(this_) = v38;
      }
    }
    v39 = std::_tree_int_int::_Rmost(this_);
    if ( *v39 == _Z )
    {
      if ( *std::_tree_int_int::_Left(_Z) == std::_tree_int_int::_Nil )
      {
        v40 = std::_tree_int_int::_Parent(_Z);
        *std::_tree_int_int::_Rmost(this_) = *v40;
      }
      else
      {
        v41 = (std::_tree_int_int::_Node *)sub_429030((int)_X);
        *std::_tree_int_int::_Rmost(this_) = v41;
      }
    }
  }
  else
  {
    v5 = std::_tree_int_int::_Left(_Z);
    v6 = std::_tree_int_int::_Parent(*v5);
    *v6 = _Y;
    v7 = std::_tree_int_int::_Left(_Z);
    *std::_tree_int_int::_Left(_Y) = *v7;
    v8 = std::_tree_int_int::_Right(_Z);
    if ( _Y == *v8 )
    {
      v9 = std::_tree_int_int::_Parent(_X);
      *v9 = _Y;
    }
    else
    {
      v10 = std::_tree_int_int::_Parent(_Y);
      *std::_tree_int_int::_Parent(_X) = *v10;
      v11 = std::_tree_int_int::_Parent(_Y);
      v12 = std::_tree_int_int::_Left(*v11);
      *v12 = _X;
      v13 = std::_tree_int_int::_Right(_Z);
      *std::_tree_int_int::_Right(_Y) = *v13;
      v14 = std::_tree_int_int::_Right(_Z);
      v15 = std::_tree_int_int::_Parent(*v14);
      *v15 = _Y;
    }
    v16 = std::_tree_int_int::_Root(this_);
    if ( *v16 == _Z )
    {
      v17 = std::_tree_int_int::_Root(this_);
      *v17 = _Y;
    }
    else
    {
      v18 = std::_tree_int_int::_Parent(_Z);
      v19 = std::_tree_int_int::_Left(*v18);
      if ( *v19 == _Z )
      {
        v20 = std::_tree_int_int::_Parent(_Z);
        v21 = std::_tree_int_int::_Left(*v20);
        *v21 = _Y;
      }
      else
      {
        v22 = std::_tree_int_int::_Parent(_Z);
        v23 = std::_tree_int_int::_Right(*v22);
        *v23 = _Y;
      }
    }
    v24 = std::_tree_int_int::_Parent(_Z);
    *std::_tree_int_int::_Parent(_Y) = *v24;
    v25 = (int *)std::_tree_int_int::_Color(_Z);
    v26 = (int *)std::_tree_int_int::_Color(_Y);
    sub_42A4A0(v26, v25);
    _Y = _Z;
  }
  if ( *(_DWORD *)std::_tree_int_int::_Color(_Y) == 1 )
  {
    while ( 1 )
    {
      v42 = std::_tree_int_int::_Root(this_);
      if ( _X == *v42 || *(_DWORD *)std::_tree_int_int::_Color(_X) != 1 )
        break;
      v43 = std::_tree_int_int::_Parent(_X);
      v44 = std::_tree_int_int::_Left(*v43);
      if ( _X == *v44 )
      {
        v45 = std::_tree_int_int::_Parent(_X);
        a1 = *std::_tree_int_int::_Right(*v45);
        if ( !*(_DWORD *)std::_tree_int_int::_Color(a1) )
        {
          *(_DWORD *)std::_tree_int_int::_Color(a1) = 1;
          v46 = std::_tree_int_int::_Parent(_X);
          *(_DWORD *)std::_tree_int_int::_Color(*v46) = 0;
          v47 = (int *)std::_tree_int_int::_Parent(_X);
          sub_428F00(this_, *v47);
          v48 = std::_tree_int_int::_Parent(_X);
          a1 = *std::_tree_int_int::_Right(*v48);
        }
        v49 = std::_tree_int_int::_Left(a1);
        if ( *(_DWORD *)std::_tree_int_int::_Color(*v49) != 1
          || (v50 = std::_tree_int_int::_Right(a1), *(_DWORD *)std::_tree_int_int::_Color(*v50) != 1) )
        {
          v51 = std::_tree_int_int::_Right(a1);
          if ( *(_DWORD *)std::_tree_int_int::_Color(*v51) == 1 )
          {
            v52 = std::_tree_int_int::_Left(a1);
            *(_DWORD *)std::_tree_int_int::_Color(*v52) = 1;
            *(_DWORD *)std::_tree_int_int::_Color(a1) = 0;
            sub_4290F0(this_, (int)a1);
            v53 = std::_tree_int_int::_Parent(_X);
            a1 = *std::_tree_int_int::_Right(*v53);
          }
          v54 = std::_tree_int_int::_Parent(_X);
          v55 = (_DWORD *)std::_tree_int_int::_Color(*v54);
          *(_DWORD *)std::_tree_int_int::_Color(a1) = *v55;
          v56 = std::_tree_int_int::_Parent(_X);
          *(_DWORD *)std::_tree_int_int::_Color(*v56) = 1;
          v57 = std::_tree_int_int::_Right(a1);
          *(_DWORD *)std::_tree_int_int::_Color(*v57) = 1;
          v58 = (int *)std::_tree_int_int::_Parent(_X);
          sub_428F00(this_, *v58);
          break;
        }
        *(_DWORD *)std::_tree_int_int::_Color(a1) = 0;
        _X = *std::_tree_int_int::_Parent(_X);
      }
      else
      {
        v59 = std::_tree_int_int::_Parent(_X);
        v77 = *std::_tree_int_int::_Left(*v59);
        if ( !*(_DWORD *)std::_tree_int_int::_Color(v77) )
        {
          *(_DWORD *)std::_tree_int_int::_Color(v77) = 1;
          v60 = std::_tree_int_int::_Parent(_X);
          *(_DWORD *)std::_tree_int_int::_Color(*v60) = 0;
          v61 = (int *)std::_tree_int_int::_Parent(_X);
          sub_4290F0(this_, *v61);
          v62 = std::_tree_int_int::_Parent(_X);
          v77 = *std::_tree_int_int::_Left(*v62);
        }
        v63 = std::_tree_int_int::_Right(v77);
        if ( *(_DWORD *)std::_tree_int_int::_Color(*v63) != 1
          || (v64 = std::_tree_int_int::_Left(v77), *(_DWORD *)std::_tree_int_int::_Color(*v64) != 1) )
        {
          v65 = std::_tree_int_int::_Left(v77);
          if ( *(_DWORD *)std::_tree_int_int::_Color(*v65) == 1 )
          {
            v66 = std::_tree_int_int::_Right(v77);
            *(_DWORD *)std::_tree_int_int::_Color(*v66) = 1;
            *(_DWORD *)std::_tree_int_int::_Color(v77) = 0;
            sub_428F00(this_, (int)v77);
            v67 = std::_tree_int_int::_Parent(_X);
            v77 = *std::_tree_int_int::_Left(*v67);
          }
          v68 = std::_tree_int_int::_Parent(_X);
          v69 = (_DWORD *)std::_tree_int_int::_Color(*v68);
          *(_DWORD *)std::_tree_int_int::_Color(v77) = *v69;
          v70 = std::_tree_int_int::_Parent(_X);
          *(_DWORD *)std::_tree_int_int::_Color(*v70) = 1;
          v71 = std::_tree_int_int::_Left(v77);
          *(_DWORD *)std::_tree_int_int::_Color(*v71) = 1;
          v72 = (int *)std::_tree_int_int::_Parent(_X);
          sub_4290F0(this_, *v72);
          break;
        }
        *(_DWORD *)std::_tree_int_int::_Color(v77) = 0;
        _X = *std::_tree_int_int::_Parent(_X);
      }
    }
    *(_DWORD *)std::_tree_int_int::_Color(_X) = 1;
  }
  v83 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v79);
  v73 = std::_tree_int_int::Node::_Value2(_Y);
  sub_429220((int)v73);
  std::_tree_int_int::_Freenode(_Y);
  --this_->_Size;
  *a2 = _P;
  return a2;
}

//----- (00427970) --------------------------------------------------------
_DWORD *__thiscall sub_427970(void *this, _DWORD *a2, int a3, char a4)
{
  std::_tree_int_int::iterator *v4; // eax@2
  std::_tree_int_int::iterator *v5; // eax@3
  std::_tree_int_int::iterator **v6; // eax@5
  _DWORD *result; // eax@6
  void **v8; // eax@7
  std::_tree_int_int *v9; // [sp+0h] [bp-14h]@1
  char v10; // [sp+4h] [bp-10h]@5
  int a2a; // [sp+8h] [bp-Ch]@5
  char v12; // [sp+Ch] [bp-8h]@3
  char v13; // [sp+10h] [bp-4h]@2

  v9 = (std::_tree_int_int *)this;
  if ( !unknown_libname_150()
    || (v4 = (std::_tree_int_int::iterator *)sub_426F00(v9, (int)&v13),
        (unsigned __int8)std::_tree_int_int::iterator::not_eq((std::_tree_int_int::iterator *)&a3, v4))
    || (v5 = std::_tree_int_int::end(v9, (std::_tree_int_int::iterator *)&v12),
        (unsigned __int8)std::_tree_int_int::iterator::not_eq((std::_tree_int_int::iterator *)&a4, v5)) )
  {
    while ( (unsigned __int8)std::_tree_int_int::iterator::not_eq(
                               (std::_tree_int_int::iterator *)&a3,
                               (std::_tree_int_int::iterator *)&a4) )
    {
      v6 = (std::_tree_int_int::iterator **)std::_tree_int_int::iterator::post_increment(
                                              (std::_tree_int_int::iterator *)&a3,
                                              &a2a,
                                              0);
      std::_tree_int_int::erase2(v9, &v10, *v6);
    }
    *a2 = a3;
    result = a2;
  }
  else
  {
    v8 = (void **)std::_tree_int_int::_Root(v9);
    sub_4289D0((std::_tree *)v9, *v8);
    *std::_tree_int_int::_Root(v9) = std::_tree_int_int::_Nil;
    v9->_Size = 0;
    *std::_tree_int_int::_Lmost(v9) = v9->_Head;
    *std::_tree_int_int::_Rmost(v9) = v9->_Head;
    sub_426F00(v9, (int)a2);
    result = a2;
  }
  return result;
}
// 428980: using guessed type int unknown_libname_150(void);

//----- (00427A70) --------------------------------------------------------
_DWORD *__thiscall std::_tree_int_int::find(std::_tree_int_int *this, _DWORD *a2, _DWORD *a3)
{
  std::_tree_int_int::iterator *v3; // eax@1
  std::_tree_int_int::_Node *v4; // eax@2
  struct Concurrency::details::InternalContextBase *v5; // eax@2
  std::_tree_int_int::iterator *v7; // [sp+0h] [bp-18h]@3
  std::_tree_int_int *this_; // [sp+4h] [bp-14h]@1
  std::_tree_int_int::iterator v9; // [sp+8h] [bp-10h]@4
  std::_tree_int_int::iterator v10; // [sp+Ch] [bp-Ch]@1
  std::_tree_int_int::iterator *v11; // [sp+10h] [bp-8h]@5
  std::_tree_int_int::iterator a2a; // [sp+14h] [bp-4h]@1

  this_ = this;
  std::_tree_int_int::lower_bound(this, &a2a, a3);
  v3 = std::_tree_int_int::end(this_, &v10);
  if ( (unsigned __int8)std::_tree_int_int::iterator_operator_eq(&a2a, v3)
    || (v4 = std::_tree_int_int::iterator::_Mynode2(&a2a),
        v5 = std::_tree_int_int::_Key((int)v4),
        (unsigned __int8)std::_tree::key_compare(a3, v5)) )
  {
    v7 = std::_tree_int_int::end(this_, &v9);
  }
  else
  {
    v7 = &a2a;
  }
  v11 = v7;
  *a2 = v7->_Ptr;
  return a2;
}

//----- (00427B30) --------------------------------------------------------
void **__thiscall std::_tree_int_int::iterator::_Mynode(std::_tree_int_int::iterator *this)
{
  return std::_tree_int_int::Node::_Value2(this->_Ptr);
}

//----- (00427B50) --------------------------------------------------------
BOOL __thiscall std::_tree_int_int::iterator_operator_eq(std::_tree_int_int::iterator *this, std::_tree_int_int::iterator *a2)
{
  return this->_Ptr == a2->_Ptr;
}

//----- (00427B70) --------------------------------------------------------
std::map_int_acc *__thiscall std::map_int_sockid::map_int_sockid2(std::map_int_acc *this, _BYTE *a2, _BYTE *a3)
{
  std::map_int_acc *v3; // ST0C_4@1

  v3 = this;
  std::_tree_int_sockid::_tree_int_sockid(&this->_Tr, a2, 0, a3);
  return v3;
}

//----- (00427BA0) --------------------------------------------------------
std::_tree_int_acc::iterator *__thiscall std::_tree_int_acc::begin(std::_tree_int_acc *this, std::_tree_int_acc::iterator *a2)
{
  #548 **v2; // eax@1

  v2 = std::_tree_int_acc::_Lmost(this);
  std::_tree_int_acc::iterator::iterator(a2, *v2);
  return a2;
}

//----- (00427BD0) --------------------------------------------------------
std::_tree_int_acc::iterator *__thiscall std::_tree_int_acc::end(std::_tree_int_acc *this, std::_tree_int_acc::iterator *a2)
{
  std::_tree_int_acc::iterator::iterator(a2, (#548 *)this->_Head);
  return a2;
}

//----- (00427BF0) --------------------------------------------------------
int __thiscall sub_427BF0(void *this, int a2, struct Concurrency::IExecutionContext *a3)
{
  struct Concurrency::details::InternalContextBase *v3; // ST10_4@3
  struct Concurrency::details::InternalContextBase *v4; // eax@3
  _DWORD *v5; // eax@8
  int result; // eax@8
  std::_tree_int_acc::iterator *v7; // eax@10
  _DWORD *v8; // eax@11
  struct Concurrency::details::InternalContextBase *v9; // ST10_4@13
  #548 *v10; // eax@13
  struct Concurrency::details::InternalContextBase *v11; // eax@13
  _DWORD *v12; // eax@14
  #548 *v13; // [sp+0h] [bp-40h]@4
  void *v14; // [sp+4h] [bp-3Ch]@1
  char v15; // [sp+8h] [bp-38h]@15
  int v16; // [sp+Ch] [bp-34h]@14
  char v17; // [sp+10h] [bp-30h]@14
  char v18; // [sp+14h] [bp-2Ch]@13
  int v19; // [sp+18h] [bp-28h]@11
  char v20; // [sp+1Ch] [bp-24h]@11
  char v21; // [sp+20h] [bp-20h]@10
  int v22; // [sp+24h] [bp-1Ch]@8
  char v23; // [sp+28h] [bp-18h]@8
  char v24; // [sp+2Ch] [bp-14h]@3
  int v25; // [sp+30h] [bp-10h]@1
  #548 *a1; // [sp+34h] [bp-Ch]@1
  int v27; // [sp+38h] [bp-8h]@1
  std::_tree_int_acc::iterator v28; // [sp+3Ch] [bp-4h]@9

  v14 = this;
  a1 = *(#548 **)std::_tree_int_sockid::_Root((int)this);
  v25 = *((_DWORD *)v14 + 1);
  LOBYTE(v27) = 1;
  while ( a1 != std::_tree_int_sockid::_Nil )
  {
    v25 = (int)a1;
    v3 = std::_tree_int_sockid::_Key((int)a1);
    v4 = Concurrency::details::VirtualProcessor::ToInternalContext((Concurrency::details::VirtualProcessor *)&v24, a3);
    LOBYTE(v27) = std::_tree::key_compare(v4, v3);
    if ( (_BYTE)v27 )
      v13 = *std::_tree_int_sockid::_Left(a1);
    else
      v13 = *std::_tree_int_sockid::_Right(a1);
    a1 = v13;
  }
  if ( *((_BYTE *)v14 + 8) )
  {
    v23 = 1;
    v5 = (_DWORD *)sub_429470(v14, (int)&v22, (int)a1, v25, a3);
    sub_428860(a2, v5, &v23);
    return a2;
  }
  std::_tree_int_acc::iterator::iterator(&v28, (#548 *)v25);
  if ( (_BYTE)v27 )
  {
    v7 = std::_tree_int_acc::begin((std::_tree_int_acc *)v14, (std::_tree_int_acc::iterator *)&v21);
    if ( (unsigned __int8)std::map_int_acc::iterator::operator_eq(&v28, v7) )
    {
      v20 = 1;
      v8 = (_DWORD *)sub_429470(v14, (int)&v19, (int)a1, v25, a3);
      sub_428860(a2, v8, &v20);
      return a2;
    }
    unknown_libname_159(&v28);
  }
  v9 = Concurrency::details::VirtualProcessor::ToInternalContext((Concurrency::details::VirtualProcessor *)&v18, a3);
  v10 = std::_tree_int_sockid::iterator::_Mynode2(&v28);
  v11 = std::_tree_int_sockid::_Key((int)v10);
  if ( (unsigned __int8)std::_tree::key_compare(v11, v9) )
  {
    v17 = 1;
    v12 = (_DWORD *)sub_429470(v14, (int)&v16, (int)a1, v25, a3);
    sub_428860(a2, v12, &v17);
    result = a2;
  }
  else
  {
    v15 = 0;
    sub_428860(a2, &v28, &v15);
    result = a2;
  }
  return result;
}
// 429CC0: using guessed type int __thiscall unknown_libname_159(_DWORD);

//----- (00427DC0) --------------------------------------------------------
_DWORD *__thiscall std::_tree_int_sockid::erase2(std::_tree_int_acc *this, _DWORD *a2, std::_tree_int_acc::iterator *_P)
{
  std::_tree_int_acc::iterator *v3; // eax@1
  int *v4; // eax@5
  int *v5; // eax@7
  #548 **v6; // eax@7
  #548 **v7; // esi@7
  #548 **v8; // eax@7
  #548 **v9; // eax@8
  _DWORD *v10; // esi@9
  #548 **v11; // eax@9
  #548 **v12; // eax@9
  #548 **v13; // esi@9
  int *v14; // eax@9
  #548 **v15; // eax@9
  #548 **v16; // eax@10
  #548 **v17; // eax@11
  #548 **v18; // eax@12
  #548 **v19; // eax@12
  #548 **v20; // eax@13
  #548 **v21; // eax@13
  #548 **v22; // eax@14
  #548 **v23; // eax@14
  _DWORD *v24; // esi@15
  int *v25; // ST04_4@15
  int *v26; // eax@15
  _DWORD *v27; // esi@16
  #548 **v28; // eax@16
  #548 **v29; // eax@17
  #548 **v30; // eax@18
  #548 **v31; // eax@18
  #548 **v32; // eax@19
  #548 **v33; // eax@19
  #548 **v34; // eax@20
  #548 **v35; // eax@20
  #548 **v36; // eax@21
  #548 **v37; // esi@23
  #548 *v38; // esi@24
  #548 **v39; // eax@25
  #548 **v40; // esi@27
  #548 *v41; // esi@28
  #548 **v42; // eax@30
  #548 **v43; // eax@32
  #548 **v44; // eax@32
  #548 **v45; // eax@33
  int *v46; // eax@34
  int *v47; // eax@34
  #548 **v48; // eax@34
  int *v49; // eax@35
  int *v50; // eax@36
  int *v51; // eax@38
  int *v52; // eax@39
  #548 **v53; // eax@39
  int *v54; // eax@40
  _DWORD *v55; // esi@40
  int *v56; // eax@40
  int *v57; // eax@40
  int *v58; // eax@40
  #548 **v59; // eax@41
  int *v60; // eax@42
  int *v61; // eax@42
  #548 **v62; // eax@42
  int *v63; // eax@43
  int *v64; // eax@44
  int *v65; // eax@46
  int *v66; // eax@47
  #548 **v67; // eax@47
  int *v68; // eax@48
  _DWORD *v69; // esi@48
  int *v70; // eax@48
  int *v71; // eax@48
  int *v72; // eax@48
  std::pair_int_acc **v73; // eax@51
  std::_tree_int_acc *v75; // [sp+4h] [bp-2Ch]@1
  char v76; // [sp+8h] [bp-28h]@1
  #548 *v77; // [sp+Ch] [bp-24h]@41
  #548 *v78; // [sp+10h] [bp-20h]@33
  char v79; // [sp+14h] [bp-1Ch]@6
  #548 *v80; // [sp+18h] [bp-18h]@1
  #548 *a1; // [sp+1Ch] [bp-14h]@1
  #548 *v82; // [sp+20h] [bp-10h]@2
  int v83; // [sp+2Ch] [bp-4h]@6

  v75 = this;
  v3 = (std::_tree_int_acc::iterator *)std::_tree_int_sockid::iterator::post_increment(&_P, &v76, 0);
  a1 = std::_tree_int_sockid::iterator::_Mynode2(v3);
  v80 = a1;
  if ( *std::_tree_int_sockid::_Left(a1) == std::_tree_int_sockid::_Nil )
  {
    v82 = *std::_tree_int_sockid::_Right(a1);
  }
  else if ( *std::_tree_int_sockid::_Right(a1) == std::_tree_int_sockid::_Nil )
  {
    v82 = *std::_tree_int_sockid::_Left(a1);
  }
  else
  {
    v4 = (int *)std::_tree_int_sockid::_Right(a1);
    a1 = (#548 *)std::_tree_int_sockid::_Min(*v4);
    v82 = *std::_tree_int_sockid::_Right(a1);
  }
  std::_Lockit::_Lockit((std::_Lockit *)&v79);
  v83 = 0;
  if ( a1 == v80 )
  {
    v27 = (_DWORD *)std::_tree_int_sockid::_Parent((int)a1);
    *(_DWORD *)std::_tree_int_sockid::_Parent((int)v82) = *v27;
    v28 = (#548 **)std::_tree_int_sockid::_Root((int)v75);
    if ( *v28 == v80 )
    {
      v29 = (#548 **)std::_tree_int_sockid::_Root((int)v75);
      *v29 = v82;
    }
    else
    {
      v30 = (#548 **)std::_tree_int_sockid::_Parent((int)v80);
      v31 = std::_tree_int_sockid::_Left(*v30);
      if ( *v31 == v80 )
      {
        v32 = (#548 **)std::_tree_int_sockid::_Parent((int)v80);
        v33 = std::_tree_int_sockid::_Left(*v32);
        *v33 = v82;
      }
      else
      {
        v34 = (#548 **)std::_tree_int_sockid::_Parent((int)v80);
        v35 = std::_tree_int_sockid::_Right(*v34);
        *v35 = v82;
      }
    }
    v36 = std::_tree_int_acc::_Lmost(v75);
    if ( *v36 == v80 )
    {
      if ( *std::_tree_int_sockid::_Right(v80) == std::_tree_int_sockid::_Nil )
      {
        v37 = (#548 **)std::_tree_int_sockid::_Parent((int)v80);
        *std::_tree_int_acc::_Lmost(v75) = *v37;
      }
      else
      {
        v38 = (#548 *)std::_tree_int_sockid::_Min((int)v82);
        *std::_tree_int_acc::_Lmost(v75) = v38;
      }
    }
    v39 = std::_tree_int_sockid::_Rmost(v75);
    if ( *v39 == v80 )
    {
      if ( *std::_tree_int_sockid::_Left(v80) == std::_tree_int_sockid::_Nil )
      {
        v40 = (#548 **)std::_tree_int_sockid::_Parent((int)v80);
        *std::_tree_int_sockid::_Rmost(v75) = *v40;
      }
      else
      {
        v41 = (#548 *)sub_429A50((int)v82);
        *std::_tree_int_sockid::_Rmost(v75) = v41;
      }
    }
  }
  else
  {
    v5 = (int *)std::_tree_int_sockid::_Left(v80);
    v6 = (#548 **)std::_tree_int_sockid::_Parent(*v5);
    *v6 = a1;
    v7 = std::_tree_int_sockid::_Left(v80);
    *std::_tree_int_sockid::_Left(a1) = *v7;
    v8 = std::_tree_int_sockid::_Right(v80);
    if ( a1 == *v8 )
    {
      v9 = (#548 **)std::_tree_int_sockid::_Parent((int)v82);
      *v9 = a1;
    }
    else
    {
      v10 = (_DWORD *)std::_tree_int_sockid::_Parent((int)a1);
      *(_DWORD *)std::_tree_int_sockid::_Parent((int)v82) = *v10;
      v11 = (#548 **)std::_tree_int_sockid::_Parent((int)a1);
      v12 = std::_tree_int_sockid::_Left(*v11);
      *v12 = v82;
      v13 = std::_tree_int_sockid::_Right(v80);
      *std::_tree_int_sockid::_Right(a1) = *v13;
      v14 = (int *)std::_tree_int_sockid::_Right(v80);
      v15 = (#548 **)std::_tree_int_sockid::_Parent(*v14);
      *v15 = a1;
    }
    v16 = (#548 **)std::_tree_int_sockid::_Root((int)v75);
    if ( *v16 == v80 )
    {
      v17 = (#548 **)std::_tree_int_sockid::_Root((int)v75);
      *v17 = a1;
    }
    else
    {
      v18 = (#548 **)std::_tree_int_sockid::_Parent((int)v80);
      v19 = std::_tree_int_sockid::_Left(*v18);
      if ( *v19 == v80 )
      {
        v20 = (#548 **)std::_tree_int_sockid::_Parent((int)v80);
        v21 = std::_tree_int_sockid::_Left(*v20);
        *v21 = a1;
      }
      else
      {
        v22 = (#548 **)std::_tree_int_sockid::_Parent((int)v80);
        v23 = std::_tree_int_sockid::_Right(*v22);
        *v23 = a1;
      }
    }
    v24 = (_DWORD *)std::_tree_int_sockid::_Parent((int)v80);
    *(_DWORD *)std::_tree_int_sockid::_Parent((int)a1) = *v24;
    v25 = (int *)sub_4292F0((int)v80);
    v26 = (int *)sub_4292F0((int)a1);
    sub_42A4D0(v26, v25);
    a1 = v80;
  }
  if ( *(_DWORD *)sub_4292F0((int)a1) == 1 )
  {
    while ( 1 )
    {
      v42 = (#548 **)std::_tree_int_sockid::_Root((int)v75);
      if ( v82 == *v42 || *(_DWORD *)sub_4292F0((int)v82) != 1 )
        break;
      v43 = (#548 **)std::_tree_int_sockid::_Parent((int)v82);
      v44 = std::_tree_int_sockid::_Left(*v43);
      if ( v82 == *v44 )
      {
        v45 = (#548 **)std::_tree_int_sockid::_Parent((int)v82);
        v78 = *std::_tree_int_sockid::_Right(*v45);
        if ( !*(_DWORD *)sub_4292F0((int)v78) )
        {
          *(_DWORD *)sub_4292F0((int)v78) = 1;
          v46 = (int *)std::_tree_int_sockid::_Parent((int)v82);
          *(_DWORD *)sub_4292F0(*v46) = 0;
          v47 = (int *)std::_tree_int_sockid::_Parent((int)v82);
          sub_429920(v75, *v47);
          v48 = (#548 **)std::_tree_int_sockid::_Parent((int)v82);
          v78 = *std::_tree_int_sockid::_Right(*v48);
        }
        v49 = (int *)std::_tree_int_sockid::_Left(v78);
        if ( *(_DWORD *)sub_4292F0(*v49) != 1
          || (v50 = (int *)std::_tree_int_sockid::_Right(v78), *(_DWORD *)sub_4292F0(*v50) != 1) )
        {
          v51 = (int *)std::_tree_int_sockid::_Right(v78);
          if ( *(_DWORD *)sub_4292F0(*v51) == 1 )
          {
            v52 = (int *)std::_tree_int_sockid::_Left(v78);
            *(_DWORD *)sub_4292F0(*v52) = 1;
            *(_DWORD *)sub_4292F0((int)v78) = 0;
            sub_429B10(v75, (int)v78);
            v53 = (#548 **)std::_tree_int_sockid::_Parent((int)v82);
            v78 = *std::_tree_int_sockid::_Right(*v53);
          }
          v54 = (int *)std::_tree_int_sockid::_Parent((int)v82);
          v55 = (_DWORD *)sub_4292F0(*v54);
          *(_DWORD *)sub_4292F0((int)v78) = *v55;
          v56 = (int *)std::_tree_int_sockid::_Parent((int)v82);
          *(_DWORD *)sub_4292F0(*v56) = 1;
          v57 = (int *)std::_tree_int_sockid::_Right(v78);
          *(_DWORD *)sub_4292F0(*v57) = 1;
          v58 = (int *)std::_tree_int_sockid::_Parent((int)v82);
          sub_429920(v75, *v58);
          break;
        }
        *(_DWORD *)sub_4292F0((int)v78) = 0;
        v82 = *(#548 **)std::_tree_int_sockid::_Parent((int)v82);
      }
      else
      {
        v59 = (#548 **)std::_tree_int_sockid::_Parent((int)v82);
        v77 = *std::_tree_int_sockid::_Left(*v59);
        if ( !*(_DWORD *)sub_4292F0((int)v77) )
        {
          *(_DWORD *)sub_4292F0((int)v77) = 1;
          v60 = (int *)std::_tree_int_sockid::_Parent((int)v82);
          *(_DWORD *)sub_4292F0(*v60) = 0;
          v61 = (int *)std::_tree_int_sockid::_Parent((int)v82);
          sub_429B10(v75, *v61);
          v62 = (#548 **)std::_tree_int_sockid::_Parent((int)v82);
          v77 = *std::_tree_int_sockid::_Left(*v62);
        }
        v63 = (int *)std::_tree_int_sockid::_Right(v77);
        if ( *(_DWORD *)sub_4292F0(*v63) != 1
          || (v64 = (int *)std::_tree_int_sockid::_Left(v77), *(_DWORD *)sub_4292F0(*v64) != 1) )
        {
          v65 = (int *)std::_tree_int_sockid::_Left(v77);
          if ( *(_DWORD *)sub_4292F0(*v65) == 1 )
          {
            v66 = (int *)std::_tree_int_sockid::_Right(v77);
            *(_DWORD *)sub_4292F0(*v66) = 1;
            *(_DWORD *)sub_4292F0((int)v77) = 0;
            sub_429920(v75, (int)v77);
            v67 = (#548 **)std::_tree_int_sockid::_Parent((int)v82);
            v77 = *std::_tree_int_sockid::_Left(*v67);
          }
          v68 = (int *)std::_tree_int_sockid::_Parent((int)v82);
          v69 = (_DWORD *)sub_4292F0(*v68);
          *(_DWORD *)sub_4292F0((int)v77) = *v69;
          v70 = (int *)std::_tree_int_sockid::_Parent((int)v82);
          *(_DWORD *)sub_4292F0(*v70) = 1;
          v71 = (int *)std::_tree_int_sockid::_Left(v77);
          *(_DWORD *)sub_4292F0(*v71) = 1;
          v72 = (int *)std::_tree_int_sockid::_Parent((int)v82);
          sub_429B10(v75, *v72);
          break;
        }
        *(_DWORD *)sub_4292F0((int)v77) = 0;
        v82 = *(#548 **)std::_tree_int_sockid::_Parent((int)v82);
      }
    }
    *(_DWORD *)sub_4292F0((int)v82) = 1;
  }
  v83 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v79);
  v73 = std::_tree_int_sockid::_Node::Valu2(a1);
  sub_429C40((int)v73);
  std::_tree_int_sockid::_Freenode(a1);
  --v75->_Size;
  *a2 = _P;
  return a2;
}

//----- (00428610) --------------------------------------------------------
IPSocket *__thiscall IPSocket::setIPAddress(IPSocket *this, int ipAddress)
{
  IPSocket *result; // eax@1

  result = this;
  this->m_serverIP.S_un.S_addr = ipAddress;
  return result;
}

//----- (00428630) --------------------------------------------------------
IPSocket *__thiscall IPSocket::set_field_2(IPSocket *this, int a2)
{
  IPSocket *result; // eax@1

  result = this;
  this->m_field_2 = a2;
  return result;
}

//----- (00428650) --------------------------------------------------------
_DWORD *__thiscall sub_428650(void *this, _DWORD *a2, int a3, char a4)
{
  std::_tree_int_acc::iterator *v4; // eax@2
  std::_tree_int_acc::iterator *v5; // eax@3
  std::_tree_int_acc::iterator **v6; // eax@5
  _DWORD *result; // eax@6
  void **v8; // eax@7
  std::_tree_int_acc *v9; // [sp+0h] [bp-14h]@1
  char v10; // [sp+4h] [bp-10h]@5
  char v11; // [sp+8h] [bp-Ch]@5
  char v12; // [sp+Ch] [bp-8h]@3
  char v13; // [sp+10h] [bp-4h]@2

  v9 = (std::_tree_int_acc *)this;
  if ( !unknown_libname_156()
    || (v4 = std::_tree_int_acc::begin(v9, (std::_tree_int_acc::iterator *)&v13),
        (unsigned __int8)std::map_int_acc::iterator::not_eq((std::_tree_int_acc::iterator *)&a3, v4))
    || (v5 = std::_tree_int_acc::end(v9, (std::_tree_int_acc::iterator *)&v12),
        (unsigned __int8)std::map_int_acc::iterator::not_eq((std::_tree_int_acc::iterator *)&a4, v5)) )
  {
    while ( (unsigned __int8)std::map_int_acc::iterator::not_eq(
                               (std::_tree_int_acc::iterator *)&a3,
                               (std::_tree_int_acc::iterator *)&a4) )
    {
      v6 = (std::_tree_int_acc::iterator **)std::_tree_int_sockid::iterator::post_increment(&a3, &v11, 0);
      std::_tree_int_sockid::erase2(v9, &v10, *v6);
    }
    *a2 = a3;
    result = a2;
  }
  else
  {
    v8 = (void **)std::_tree_int_sockid::_Root((int)v9);
    sub_4293F0((std::_tree *)v9, *v8);
    *(_DWORD *)std::_tree_int_sockid::_Root((int)v9) = std::_tree_int_sockid::_Nil;
    v9->_Size = 0;
    *std::_tree_int_acc::_Lmost(v9) = (#548 *)v9->_Head;
    *std::_tree_int_sockid::_Rmost(v9) = (#548 *)v9->_Head;
    std::_tree_int_acc::begin(v9, (std::_tree_int_acc::iterator *)a2);
    result = a2;
  }
  return result;
}
// 4293A0: using guessed type int unknown_libname_156(void);

//----- (00428750) --------------------------------------------------------
_DWORD *__thiscall std::_tree_int_sockid::find(std::_tree_int_acc *this, _DWORD *a2, _DWORD *a3)
{
  std::_tree_int_acc::iterator *v3; // eax@1
  #548 *v4; // eax@2
  struct Concurrency::details::InternalContextBase *v5; // eax@2
  std::_tree_int_acc::iterator *v7; // [sp+0h] [bp-18h]@3
  std::_tree_int_acc *this_; // [sp+4h] [bp-14h]@1
  std::_tree_int_acc::iterator v9; // [sp+8h] [bp-10h]@4
  std::_tree_int_acc::iterator a2a; // [sp+Ch] [bp-Ch]@1
  std::_tree_int_acc::iterator *v11; // [sp+10h] [bp-8h]@5
  std::_tree_int_acc::iterator v12; // [sp+14h] [bp-4h]@1

  this_ = this;
  std::_tree_int_sockid::lower_bound(this, &v12, a3);
  v3 = std::_tree_int_acc::end(this_, &a2a);
  if ( (unsigned __int8)std::map_int_acc::iterator::operator_eq(&v12, v3)
    || (v4 = std::_tree_int_sockid::iterator::_Mynode2(&v12),
        v5 = std::_tree_int_sockid::_Key((int)v4),
        (unsigned __int8)std::_tree::key_compare(a3, v5)) )
  {
    v7 = std::_tree_int_acc::end(this_, &v9);
  }
  else
  {
    v7 = &v12;
  }
  v11 = v7;
  *a2 = v7->_Ptr;
  return a2;
}

//----- (00428820) --------------------------------------------------------
std::pair_int_acc **__thiscall std::_tree_int_sockid::iterator::_Mynode(std::_tree_int_acc::iterator *this)
{
  return std::_tree_int_sockid::_Node::Valu2((#548 *)this->_Ptr);
}

//----- (00428840) --------------------------------------------------------
BOOL __thiscall std::map_int_acc::iterator::operator_eq(std::_tree_int_acc::iterator *this, std::_tree_int_acc::iterator *a2)
{
  return this->_Ptr == a2->_Ptr;
}

//----- (00428860) --------------------------------------------------------
int __thiscall sub_428860(int this, _DWORD *a2, _BYTE *a3)
{
  *(_DWORD *)this = *a2;
  *(_BYTE *)(this + 4) = *a3;
  return this;
}

//----- (00428890) --------------------------------------------------------
std::map_int_int *__thiscall sub_428890(std::map_int_int *this, _DWORD *a2, _BYTE *a3)
{
  *(_DWORD *)&this->_Tr.allocator = *a2;
  LOBYTE(this->_Tr._Head) = *a3;
  return this;
}

//----- (004288D0) --------------------------------------------------------
int __cdecl std::_tree_int_int::_Color(std::_tree_int_int::_Node *a1)
{
  return (int)&a1[1];
}

//----- (004288E0) --------------------------------------------------------
struct Concurrency::details::InternalContextBase *__cdecl std::_tree_int_int::_Key(int a1)
{
  int v1; // ecx@0
  struct Concurrency::IExecutionContext *v2; // eax@1
  int v4; // [sp+0h] [bp-4h]@1

  v4 = v1;
  v2 = (struct Concurrency::IExecutionContext *)std::_tree_int_int::Node::_Value2((std::_tree_int_int::_Node *)a1);
  return Concurrency::details::VirtualProcessor::ToInternalContext((Concurrency::details::VirtualProcessor *)&v4, v2);
}

//----- (00428910) --------------------------------------------------------
std::_tree_int_int::_Node **__cdecl std::_tree_int_int::_Parent(std::_tree_int_int::_Node *a1)
{
  return &a1->_Parent;
}

//----- (00428920) --------------------------------------------------------
std::_tree_int_int::_Node **__cdecl std::_tree_int_int::_Right(std::_tree_int_int::_Node *a1)
{
  return &a1->_Right;
}

//----- (00428930) --------------------------------------------------------
void **__cdecl std::_tree_int_int::Node::_Value2(std::_tree_int_int::_Node *a1)
{
  return &a1->_Value;
}

//----- (00428940) --------------------------------------------------------
std::_tree_int_int *__thiscall std::_tree_int_int::_tree_int_int(std::_tree_int_int *this, _BYTE *a2, char a3, _BYTE *a4)
{
  std::_tree_int_int *v4; // ST00_4@1

  v4 = this;
  this->allocator = *a4;
  this->keyComparer = *a2;
  this->_Multi = a3;
  std::_tree_int_int::_Init(this);
  return v4;
}

//----- (004289A0) --------------------------------------------------------
std::_tree_int_int::iterator *__thiscall std::_tree_int_int::lower_bound(std::_tree_int_int *this, std::_tree_int_int::iterator *a2, _DWORD *a3)
{
  std::_tree_int_int::_Node *v3; // eax@1

  v3 = std::_tree_int_int::_Lbound(this, a3);
  std::_tree_int_int::iterator::iterator(a2, v3);
  return a2;
}

//----- (004289D0) --------------------------------------------------------
void *__thiscall sub_4289D0(std::_tree *this, void *a2)
{
  void *result; // eax@1
  void **v3; // eax@3
  void **v4; // eax@3
  std::_tree *v5; // [sp+0h] [bp-8h]@1
  std::_tree_int_int::_Node *a1; // [sp+4h] [bp-4h]@1

  v5 = this;
  result = a2;
  for ( a1 = (std::_tree_int_int::_Node *)a2; a1 != std::_tree_int_int::_Nil; a2 = a1 )
  {
    v3 = (void **)std::_tree_int_int::_Right(a1);
    sub_4289D0(v5, *v3);
    a1 = *std::_tree_int_int::_Left(a1);
    v4 = std::_tree_int_int::Node::_Value2((std::_tree_int_int::_Node *)a2);
    sub_429220((int)v4);
    std::_tree_int_int::_Freenode((std::_tree_int_int::_Node *)a2);
  }
  return result;
}

//----- (00428A50) --------------------------------------------------------
int __thiscall sub_428A50(void *this, int a2, int a3, int a4, struct Concurrency::IExecutionContext *a5)
{
  void **v5; // eax@1
  struct Concurrency::details::InternalContextBase *v6; // ST04_4@3
  struct Concurrency::details::InternalContextBase *v7; // eax@3
  std::_tree_int_int::_Node **v8; // eax@4
  std::_tree_int_int::_Node **v9; // eax@5
  std::_tree_int_int::_Node **v10; // eax@5
  std::_tree_int_int::_Node **v11; // eax@7
  std::_tree_int_int::_Node **v12; // eax@9
  std::_tree_int_int::_Node **v13; // eax@10
  std::_tree_int_int::_Node **v14; // eax@13
  std::_tree_int_int::_Node **v15; // esi@14
  std::_tree_int_int::_Node **v16; // eax@14
  std::_tree_int_int::_Node **v17; // eax@14
  std::_tree_int_int::_Node **v18; // eax@15
  std::_tree_int_int::_Node **v19; // eax@15
  std::_tree_int_int::_Node **v20; // eax@15
  std::_tree_int_int::_Node **v21; // eax@16
  std::_tree_int_int::_Node **v22; // eax@16
  std::_tree_int_int::_Node **v23; // eax@16
  std::_tree_int_int::_Node **v24; // eax@16
  std::_tree_int_int::_Node **v25; // eax@17
  std::_tree_int_int::_Node **v26; // eax@19
  std::_tree_int_int::_Node **v27; // eax@19
  std::_tree_int_int::_Node **v28; // eax@19
  std::_tree_int_int::_Node **v29; // eax@19
  int *v30; // eax@19
  std::_tree_int_int::_Node **v31; // eax@21
  std::_tree_int_int::_Node **v32; // eax@21
  std::_tree_int_int::_Node **v33; // eax@21
  std::_tree_int_int::_Node **v34; // eax@22
  std::_tree_int_int::_Node **v35; // eax@22
  std::_tree_int_int::_Node **v36; // eax@22
  std::_tree_int_int::_Node **v37; // eax@22
  std::_tree_int_int::_Node **v38; // eax@23
  std::_tree_int_int::_Node **v39; // eax@25
  std::_tree_int_int::_Node **v40; // eax@25
  std::_tree_int_int::_Node **v41; // eax@25
  std::_tree_int_int::_Node **v42; // eax@25
  int *v43; // eax@25
  std::_tree_int_int::_Node **v44; // eax@27
  std::_tree_int_int *v46; // [sp+4h] [bp-Ch]@1
  char v47; // [sp+8h] [bp-8h]@3
  std::_tree_int_int::_Node *a1; // [sp+Ch] [bp-4h]@1
  std::_tree_int_int::_Node *v49; // [sp+1Ch] [bp+Ch]@11
  std::_tree_int_int::_Node *v50; // [sp+20h] [bp+10h]@15
  std::_tree_int_int::_Node *v51; // [sp+20h] [bp+10h]@21

  v46 = (std::_tree_int_int *)this;
  a1 = std::_tree_int_int::_Buynode((std::_tree_int_int::_Node *)a4, 0);
  *std::_tree_int_int::_Left(a1) = std::_tree_int_int::_Nil;
  *std::_tree_int_int::_Right(a1) = std::_tree_int_int::_Nil;
  v5 = std::_tree_int_int::Node::_Value2(a1);
  sub_429EC0(v5, (int)a5);
  ++v46->_Size;
  if ( (std::_tree_int_int::_Node *)a4 == v46->_Head
    || (std::_tree_int_int::_Node *)a3 != std::_tree_int_int::_Nil
    || (v6 = std::_tree_int_int::_Key(a4),
        v7 = Concurrency::details::VirtualProcessor::ToInternalContext(
               (Concurrency::details::VirtualProcessor *)&v47,
               a5),
        (unsigned __int8)std::_tree::key_compare(v7, v6)) )
  {
    v8 = std::_tree_int_int::_Left((std::_tree_int_int::_Node *)a4);
    *v8 = a1;
    if ( (std::_tree_int_int::_Node *)a4 == v46->_Head )
    {
      v9 = std::_tree_int_int::_Root(v46);
      *v9 = a1;
      v10 = std::_tree_int_int::_Rmost(v46);
      *v10 = a1;
    }
    else if ( (std::_tree_int_int::_Node *)a4 == *std::_tree_int_int::_Lmost(v46) )
    {
      v11 = std::_tree_int_int::_Lmost(v46);
      *v11 = a1;
    }
  }
  else
  {
    v12 = std::_tree_int_int::_Right((std::_tree_int_int::_Node *)a4);
    *v12 = a1;
    if ( (std::_tree_int_int::_Node *)a4 == *std::_tree_int_int::_Rmost(v46) )
    {
      v13 = std::_tree_int_int::_Rmost(v46);
      *v13 = a1;
    }
  }
  v49 = a1;
  while ( v49 != *std::_tree_int_int::_Root(v46) )
  {
    v14 = std::_tree_int_int::_Parent(v49);
    if ( *(_DWORD *)std::_tree_int_int::_Color(*v14) )
      break;
    v15 = std::_tree_int_int::_Parent(v49);
    v16 = std::_tree_int_int::_Parent(v49);
    v17 = std::_tree_int_int::_Parent(*v16);
    if ( *v15 == *std::_tree_int_int::_Left(*v17) )
    {
      v18 = std::_tree_int_int::_Parent(v49);
      v19 = std::_tree_int_int::_Parent(*v18);
      v20 = std::_tree_int_int::_Right(*v19);
      v50 = *v20;
      if ( *(_DWORD *)std::_tree_int_int::_Color(*v20) )
      {
        v25 = std::_tree_int_int::_Parent(v49);
        if ( v49 == *std::_tree_int_int::_Right(*v25) )
        {
          v49 = *std::_tree_int_int::_Parent(v49);
          sub_428F00(v46, (int)v49);
        }
        v26 = std::_tree_int_int::_Parent(v49);
        *(_DWORD *)std::_tree_int_int::_Color(*v26) = 1;
        v27 = std::_tree_int_int::_Parent(v49);
        v28 = std::_tree_int_int::_Parent(*v27);
        *(_DWORD *)std::_tree_int_int::_Color(*v28) = 0;
        v29 = std::_tree_int_int::_Parent(v49);
        v30 = (int *)std::_tree_int_int::_Parent(*v29);
        sub_4290F0(v46, *v30);
      }
      else
      {
        v21 = std::_tree_int_int::_Parent(v49);
        *(_DWORD *)std::_tree_int_int::_Color(*v21) = 1;
        *(_DWORD *)std::_tree_int_int::_Color(v50) = 1;
        v22 = std::_tree_int_int::_Parent(v49);
        v23 = std::_tree_int_int::_Parent(*v22);
        *(_DWORD *)std::_tree_int_int::_Color(*v23) = 0;
        v24 = std::_tree_int_int::_Parent(v49);
        v49 = *std::_tree_int_int::_Parent(*v24);
      }
    }
    else
    {
      v31 = std::_tree_int_int::_Parent(v49);
      v32 = std::_tree_int_int::_Parent(*v31);
      v33 = std::_tree_int_int::_Left(*v32);
      v51 = *v33;
      if ( *(_DWORD *)std::_tree_int_int::_Color(*v33) )
      {
        v38 = std::_tree_int_int::_Parent(v49);
        if ( v49 == *std::_tree_int_int::_Left(*v38) )
        {
          v49 = *std::_tree_int_int::_Parent(v49);
          sub_4290F0(v46, (int)v49);
        }
        v39 = std::_tree_int_int::_Parent(v49);
        *(_DWORD *)std::_tree_int_int::_Color(*v39) = 1;
        v40 = std::_tree_int_int::_Parent(v49);
        v41 = std::_tree_int_int::_Parent(*v40);
        *(_DWORD *)std::_tree_int_int::_Color(*v41) = 0;
        v42 = std::_tree_int_int::_Parent(v49);
        v43 = (int *)std::_tree_int_int::_Parent(*v42);
        sub_428F00(v46, *v43);
      }
      else
      {
        v34 = std::_tree_int_int::_Parent(v49);
        *(_DWORD *)std::_tree_int_int::_Color(*v34) = 1;
        *(_DWORD *)std::_tree_int_int::_Color(v51) = 1;
        v35 = std::_tree_int_int::_Parent(v49);
        v36 = std::_tree_int_int::_Parent(*v35);
        *(_DWORD *)std::_tree_int_int::_Color(*v36) = 0;
        v37 = std::_tree_int_int::_Parent(v49);
        v49 = *std::_tree_int_int::_Parent(*v37);
      }
    }
  }
  v44 = std::_tree_int_int::_Root(v46);
  *(_DWORD *)std::_tree_int_int::_Color(*v44) = 1;
  std::_tree_int_int::iterator::iterator((std::_tree_int_int::iterator *)a2, a1);
  return a2;
}

//----- (00428EE0) --------------------------------------------------------
std::_tree_int_int::_Node **__thiscall std::_tree_int_int::_Lmost(std::_tree_int_int *this)
{
  return std::_tree_int_int::_Left(this->_Head);
}

//----- (00428F00) --------------------------------------------------------
std::_tree_int_int::_Node **__thiscall sub_428F00(void *this, int a2)
{
  std::_tree_int_int::_Node **v2; // esi@1
  std::_tree_int_int::_Node **v3; // eax@2
  std::_tree_int_int::_Node **v4; // esi@3
  std::_tree_int_int::_Node **v5; // eax@5
  std::_tree_int_int::_Node **v6; // eax@6
  std::_tree_int_int::_Node **v7; // eax@7
  std::_tree_int_int::_Node **result; // eax@8
  std::_tree_int_int *v9; // [sp+4h] [bp-8h]@1
  std::_tree_int_int::_Node *a1; // [sp+8h] [bp-4h]@1

  v9 = (std::_tree_int_int *)this;
  a1 = *std::_tree_int_int::_Right((std::_tree_int_int::_Node *)a2);
  v2 = std::_tree_int_int::_Left(a1);
  *std::_tree_int_int::_Right((std::_tree_int_int::_Node *)a2) = *v2;
  if ( *std::_tree_int_int::_Left(a1) != std::_tree_int_int::_Nil )
  {
    v3 = std::_tree_int_int::_Left(a1);
    *std::_tree_int_int::_Parent(*v3) = (std::_tree_int_int::_Node *)a2;
  }
  v4 = std::_tree_int_int::_Parent((std::_tree_int_int::_Node *)a2);
  *std::_tree_int_int::_Parent(a1) = *v4;
  if ( (std::_tree_int_int::_Node *)a2 == *std::_tree_int_int::_Root(v9) )
  {
    *std::_tree_int_int::_Root(v9) = a1;
  }
  else
  {
    v5 = std::_tree_int_int::_Parent((std::_tree_int_int::_Node *)a2);
    if ( (std::_tree_int_int::_Node *)a2 == *std::_tree_int_int::_Left(*v5) )
    {
      v6 = std::_tree_int_int::_Parent((std::_tree_int_int::_Node *)a2);
      *std::_tree_int_int::_Left(*v6) = a1;
    }
    else
    {
      v7 = std::_tree_int_int::_Parent((std::_tree_int_int::_Node *)a2);
      *std::_tree_int_int::_Right(*v7) = a1;
    }
  }
  *std::_tree_int_int::_Left(a1) = (std::_tree_int_int::_Node *)a2;
  result = std::_tree_int_int::_Parent((std::_tree_int_int::_Node *)a2);
  *result = a1;
  return result;
}

//----- (00429030) --------------------------------------------------------
int __cdecl sub_429030(int a1)
{
  while ( *std::_tree_int_int::_Right((std::_tree_int_int::_Node *)a1) != std::_tree_int_int::_Nil )
    a1 = (int)*std::_tree_int_int::_Right((std::_tree_int_int::_Node *)a1);
  return a1;
}

//----- (00429070) --------------------------------------------------------
std::_tree_int_int::_Node *__cdecl std::_tree_int_int::_Min(std::_tree_int_int::_Node *a1)
{
  while ( *std::_tree_int_int::_Left(a1) != std::_tree_int_int::_Nil )
    a1 = *std::_tree_int_int::_Left(a1);
  return a1;
}

//----- (004290B0) --------------------------------------------------------
std::_tree_int_int::_Node **__thiscall std::_tree_int_int::_Rmost(std::_tree_int_int *this)
{
  return std::_tree_int_int::_Right(this->_Head);
}

//----- (004290D0) --------------------------------------------------------
std::_tree_int_int::_Node **__thiscall std::_tree_int_int::_Root(std::_tree_int_int *this)
{
  return std::_tree_int_int::_Parent(this->_Head);
}

//----- (004290F0) --------------------------------------------------------
std::_tree_int_int::_Node **__thiscall sub_4290F0(void *this, int a2)
{
  std::_tree_int_int::_Node **v2; // esi@1
  std::_tree_int_int::_Node **v3; // eax@2
  std::_tree_int_int::_Node **v4; // esi@3
  std::_tree_int_int::_Node **v5; // eax@5
  std::_tree_int_int::_Node **v6; // eax@6
  std::_tree_int_int::_Node **v7; // eax@7
  std::_tree_int_int::_Node **result; // eax@8
  std::_tree_int_int *v9; // [sp+4h] [bp-8h]@1
  std::_tree_int_int::_Node *v10; // [sp+8h] [bp-4h]@1

  v9 = (std::_tree_int_int *)this;
  v10 = *std::_tree_int_int::_Left((std::_tree_int_int::_Node *)a2);
  v2 = std::_tree_int_int::_Right(v10);
  *std::_tree_int_int::_Left((std::_tree_int_int::_Node *)a2) = *v2;
  if ( *std::_tree_int_int::_Right(v10) != std::_tree_int_int::_Nil )
  {
    v3 = std::_tree_int_int::_Right(v10);
    *std::_tree_int_int::_Parent(*v3) = (std::_tree_int_int::_Node *)a2;
  }
  v4 = std::_tree_int_int::_Parent((std::_tree_int_int::_Node *)a2);
  *std::_tree_int_int::_Parent(v10) = *v4;
  if ( (std::_tree_int_int::_Node *)a2 == *std::_tree_int_int::_Root(v9) )
  {
    *std::_tree_int_int::_Root(v9) = v10;
  }
  else
  {
    v5 = std::_tree_int_int::_Parent((std::_tree_int_int::_Node *)a2);
    if ( (std::_tree_int_int::_Node *)a2 == *std::_tree_int_int::_Right(*v5) )
    {
      v6 = std::_tree_int_int::_Parent((std::_tree_int_int::_Node *)a2);
      *std::_tree_int_int::_Right(*v6) = v10;
    }
    else
    {
      v7 = std::_tree_int_int::_Parent((std::_tree_int_int::_Node *)a2);
      *std::_tree_int_int::_Left(*v7) = v10;
    }
  }
  *std::_tree_int_int::_Right(v10) = (std::_tree_int_int::_Node *)a2;
  result = std::_tree_int_int::_Parent((std::_tree_int_int::_Node *)a2);
  *result = v10;
  return result;
}

//----- (00429220) --------------------------------------------------------
void __stdcall sub_429220(int a1)
{
  sub_42A500();
}

//----- (00429270) --------------------------------------------------------
std::_tree_int_int::iterator *__thiscall std::_tree_int_int::iterator::post_increment(std::_tree_int_int::iterator *this, _DWORD *a2, int a3)
{
  std::_tree_int_int::_Node *v3; // ST04_4@1

  v3 = this->_Ptr;
  unknown_libname_161((int *)this);
  *a2 = v3;
  return (std::_tree_int_int::iterator *)a2;
}

//----- (004292F0) --------------------------------------------------------
int __cdecl sub_4292F0(int a1)
{
  return a1 + 20;
}

//----- (00429300) --------------------------------------------------------
struct Concurrency::details::InternalContextBase *__cdecl std::_tree_int_sockid::_Key(int a1)
{
  int v1; // ecx@0
  std::pair_int_acc **v2; // eax@1
  int v4; // [sp+0h] [bp-4h]@1

  v4 = v1;
  v2 = std::_tree_int_sockid::_Node::Valu2((#548 *)a1);
  return Concurrency::details::VirtualProcessor::ToInternalContext(
           (Concurrency::details::VirtualProcessor *)&v4,
           (struct Concurrency::IExecutionContext *)v2);
}

//----- (00429330) --------------------------------------------------------
int __cdecl std::_tree_int_sockid::_Parent(int a1)
{
  return a1 + 4;
}

//----- (00429340) --------------------------------------------------------
#548 **__cdecl std::_tree_int_sockid::_Right(#548 *a1)
{
  return (#548 **)((char *)a1 + 8);
}

//----- (00429350) --------------------------------------------------------
std::pair_int_acc **__cdecl std::_tree_int_sockid::_Node::Valu2(#548 *a1)
{
  return (std::pair_int_acc **)((char *)a1 + 12);
}

//----- (00429360) --------------------------------------------------------
std::_tree_int_acc *__thiscall std::_tree_int_sockid::_tree_int_sockid(std::_tree_int_acc *this, _BYTE *a2, char a3, _BYTE *a4)
{
  std::_tree_int_acc *v4; // ST00_4@1

  v4 = this;
  this->allocator = *a4;
  this->keyComparer = *a2;
  this->_Multi = a3;
  std::_tree_int_sockid::_Init(this);
  return v4;
}

//----- (004293C0) --------------------------------------------------------
std::_tree_int_acc::iterator *__thiscall std::_tree_int_sockid::lower_bound(std::_tree_int_acc *this, std::_tree_int_acc::iterator *a2, _DWORD *a3)
{
  #548 *v3; // eax@1

  v3 = std::_tree_int_sockid::_Lbound(this, a3);
  std::_tree_int_acc::iterator::iterator(a2, v3);
  return a2;
}

//----- (004293F0) --------------------------------------------------------
void *__thiscall sub_4293F0(std::_tree *this, void *a2)
{
  void *result; // eax@1
  void **v3; // eax@3
  std::pair_int_acc **v4; // eax@3
  std::_tree *v5; // [sp+0h] [bp-8h]@1
  #548 *a1; // [sp+4h] [bp-4h]@1

  v5 = this;
  result = a2;
  for ( a1 = (#548 *)a2; a1 != std::_tree_int_sockid::_Nil; a2 = (void *)a1 )
  {
    v3 = (void **)std::_tree_int_sockid::_Right(a1);
    sub_4293F0(v5, *v3);
    a1 = *std::_tree_int_sockid::_Left(a1);
    v4 = std::_tree_int_sockid::_Node::Valu2((#548 *)a2);
    sub_429C40((int)v4);
    std::_tree_int_sockid::_Freenode((#548 *)a2);
  }
  return result;
}

//----- (00429470) --------------------------------------------------------
int __thiscall sub_429470(void *this, int a2, int a3, int a4, struct Concurrency::IExecutionContext *a5)
{
  std::pair_int_acc **v5; // eax@1
  struct Concurrency::details::InternalContextBase *v6; // ST04_4@3
  struct Concurrency::details::InternalContextBase *v7; // eax@3
  #548 **v8; // eax@4
  #548 **v9; // eax@5
  #548 **v10; // eax@5
  #548 **v11; // eax@7
  #548 **v12; // eax@9
  #548 **v13; // eax@10
  int *v14; // eax@13
  #548 **v15; // esi@14
  int *v16; // eax@14
  #548 **v17; // eax@14
  int *v18; // eax@15
  #548 **v19; // eax@15
  int *v20; // eax@15
  int *v21; // eax@16
  int *v22; // eax@16
  int *v23; // eax@16
  int *v24; // eax@16
  #548 **v25; // eax@17
  int *v26; // eax@19
  int *v27; // eax@19
  int *v28; // eax@19
  int *v29; // eax@19
  int *v30; // eax@19
  int *v31; // eax@21
  #548 **v32; // eax@21
  int *v33; // eax@21
  int *v34; // eax@22
  int *v35; // eax@22
  int *v36; // eax@22
  int *v37; // eax@22
  #548 **v38; // eax@23
  int *v39; // eax@25
  int *v40; // eax@25
  int *v41; // eax@25
  int *v42; // eax@25
  int *v43; // eax@25
  int *v44; // eax@27
  std::_tree_int_acc *v46; // [sp+4h] [bp-Ch]@1
  char v47; // [sp+8h] [bp-8h]@3
  #548 *a1; // [sp+Ch] [bp-4h]@1
  #548 *v49; // [sp+1Ch] [bp+Ch]@11
  #548 *v50; // [sp+20h] [bp+10h]@15
  #548 *v51; // [sp+20h] [bp+10h]@21

  v46 = (std::_tree_int_acc *)this;
  a1 = std::_tree_int_sockid::_Buynode((#548 *)a4, 0);
  *std::_tree_int_sockid::_Left(a1) = std::_tree_int_sockid::_Nil;
  *std::_tree_int_sockid::_Right(a1) = std::_tree_int_sockid::_Nil;
  v5 = std::_tree_int_sockid::_Node::Valu2(a1);
  sub_42A1D0(v5, (int)a5);
  ++v46->_Size;
  if ( (std::_tree_int_acc::_Node *)a4 == v46->_Head
    || (#548 *)a3 != std::_tree_int_sockid::_Nil
    || (v6 = std::_tree_int_sockid::_Key(a4),
        v7 = Concurrency::details::VirtualProcessor::ToInternalContext(
               (Concurrency::details::VirtualProcessor *)&v47,
               a5),
        (unsigned __int8)std::_tree::key_compare(v7, v6)) )
  {
    v8 = std::_tree_int_sockid::_Left((#548 *)a4);
    *v8 = a1;
    if ( (std::_tree_int_acc::_Node *)a4 == v46->_Head )
    {
      v9 = (#548 **)std::_tree_int_sockid::_Root((int)v46);
      *v9 = a1;
      v10 = std::_tree_int_sockid::_Rmost(v46);
      *v10 = a1;
    }
    else if ( (#548 *)a4 == *std::_tree_int_acc::_Lmost(v46) )
    {
      v11 = std::_tree_int_acc::_Lmost(v46);
      *v11 = a1;
    }
  }
  else
  {
    v12 = std::_tree_int_sockid::_Right((#548 *)a4);
    *v12 = a1;
    if ( (#548 *)a4 == *std::_tree_int_sockid::_Rmost(v46) )
    {
      v13 = std::_tree_int_sockid::_Rmost(v46);
      *v13 = a1;
    }
  }
  v49 = a1;
  while ( v49 != *(#548 **)std::_tree_int_sockid::_Root((int)v46) )
  {
    v14 = (int *)std::_tree_int_sockid::_Parent((int)v49);
    if ( *(_DWORD *)sub_4292F0(*v14) )
      break;
    v15 = (#548 **)std::_tree_int_sockid::_Parent((int)v49);
    v16 = (int *)std::_tree_int_sockid::_Parent((int)v49);
    v17 = (#548 **)std::_tree_int_sockid::_Parent(*v16);
    if ( *v15 == *std::_tree_int_sockid::_Left(*v17) )
    {
      v18 = (int *)std::_tree_int_sockid::_Parent((int)v49);
      v19 = (#548 **)std::_tree_int_sockid::_Parent(*v18);
      v20 = (int *)std::_tree_int_sockid::_Right(*v19);
      v50 = (#548 *)*v20;
      if ( *(_DWORD *)sub_4292F0(*v20) )
      {
        v25 = (#548 **)std::_tree_int_sockid::_Parent((int)v49);
        if ( v49 == *std::_tree_int_sockid::_Right(*v25) )
        {
          v49 = *(#548 **)std::_tree_int_sockid::_Parent((int)v49);
          sub_429920(v46, (int)v49);
        }
        v26 = (int *)std::_tree_int_sockid::_Parent((int)v49);
        *(_DWORD *)sub_4292F0(*v26) = 1;
        v27 = (int *)std::_tree_int_sockid::_Parent((int)v49);
        v28 = (int *)std::_tree_int_sockid::_Parent(*v27);
        *(_DWORD *)sub_4292F0(*v28) = 0;
        v29 = (int *)std::_tree_int_sockid::_Parent((int)v49);
        v30 = (int *)std::_tree_int_sockid::_Parent(*v29);
        sub_429B10(v46, *v30);
      }
      else
      {
        v21 = (int *)std::_tree_int_sockid::_Parent((int)v49);
        *(_DWORD *)sub_4292F0(*v21) = 1;
        *(_DWORD *)sub_4292F0((int)v50) = 1;
        v22 = (int *)std::_tree_int_sockid::_Parent((int)v49);
        v23 = (int *)std::_tree_int_sockid::_Parent(*v22);
        *(_DWORD *)sub_4292F0(*v23) = 0;
        v24 = (int *)std::_tree_int_sockid::_Parent((int)v49);
        v49 = *(#548 **)std::_tree_int_sockid::_Parent(*v24);
      }
    }
    else
    {
      v31 = (int *)std::_tree_int_sockid::_Parent((int)v49);
      v32 = (#548 **)std::_tree_int_sockid::_Parent(*v31);
      v33 = (int *)std::_tree_int_sockid::_Left(*v32);
      v51 = (#548 *)*v33;
      if ( *(_DWORD *)sub_4292F0(*v33) )
      {
        v38 = (#548 **)std::_tree_int_sockid::_Parent((int)v49);
        if ( v49 == *std::_tree_int_sockid::_Left(*v38) )
        {
          v49 = *(#548 **)std::_tree_int_sockid::_Parent((int)v49);
          sub_429B10(v46, (int)v49);
        }
        v39 = (int *)std::_tree_int_sockid::_Parent((int)v49);
        *(_DWORD *)sub_4292F0(*v39) = 1;
        v40 = (int *)std::_tree_int_sockid::_Parent((int)v49);
        v41 = (int *)std::_tree_int_sockid::_Parent(*v40);
        *(_DWORD *)sub_4292F0(*v41) = 0;
        v42 = (int *)std::_tree_int_sockid::_Parent((int)v49);
        v43 = (int *)std::_tree_int_sockid::_Parent(*v42);
        sub_429920(v46, *v43);
      }
      else
      {
        v34 = (int *)std::_tree_int_sockid::_Parent((int)v49);
        *(_DWORD *)sub_4292F0(*v34) = 1;
        *(_DWORD *)sub_4292F0((int)v51) = 1;
        v35 = (int *)std::_tree_int_sockid::_Parent((int)v49);
        v36 = (int *)std::_tree_int_sockid::_Parent(*v35);
        *(_DWORD *)sub_4292F0(*v36) = 0;
        v37 = (int *)std::_tree_int_sockid::_Parent((int)v49);
        v49 = *(#548 **)std::_tree_int_sockid::_Parent(*v37);
      }
    }
  }
  v44 = (int *)std::_tree_int_sockid::_Root((int)v46);
  *(_DWORD *)sub_4292F0(*v44) = 1;
  std::_tree_int_acc::iterator::iterator((std::_tree_int_acc::iterator *)a2, a1);
  return a2;
}

//----- (00429900) --------------------------------------------------------
#548 **__thiscall std::_tree_int_acc::_Lmost(std::_tree_int_acc *this)
{
  return std::_tree_int_sockid::_Left((#548 *)this->_Head);
}

//----- (00429920) --------------------------------------------------------
#548 **__thiscall sub_429920(void *this, int a2)
{
  #548 **v2; // esi@1
  int *v3; // eax@2
  _DWORD *v4; // esi@3
  #548 **v5; // eax@5
  #548 **v6; // eax@6
  #548 **v7; // eax@7
  #548 **result; // eax@8
  void *v9; // [sp+4h] [bp-8h]@1
  #548 *a1; // [sp+8h] [bp-4h]@1

  v9 = this;
  a1 = *std::_tree_int_sockid::_Right((#548 *)a2);
  v2 = std::_tree_int_sockid::_Left(a1);
  *std::_tree_int_sockid::_Right((#548 *)a2) = *v2;
  if ( *std::_tree_int_sockid::_Left(a1) != std::_tree_int_sockid::_Nil )
  {
    v3 = (int *)std::_tree_int_sockid::_Left(a1);
    *(_DWORD *)std::_tree_int_sockid::_Parent(*v3) = a2;
  }
  v4 = (_DWORD *)std::_tree_int_sockid::_Parent(a2);
  *(_DWORD *)std::_tree_int_sockid::_Parent((int)a1) = *v4;
  if ( a2 == *(_DWORD *)std::_tree_int_sockid::_Root((int)v9) )
  {
    *(_DWORD *)std::_tree_int_sockid::_Root((int)v9) = a1;
  }
  else
  {
    v5 = (#548 **)std::_tree_int_sockid::_Parent(a2);
    if ( (#548 *)a2 == *std::_tree_int_sockid::_Left(*v5) )
    {
      v6 = (#548 **)std::_tree_int_sockid::_Parent(a2);
      *std::_tree_int_sockid::_Left(*v6) = a1;
    }
    else
    {
      v7 = (#548 **)std::_tree_int_sockid::_Parent(a2);
      *std::_tree_int_sockid::_Right(*v7) = a1;
    }
  }
  *std::_tree_int_sockid::_Left(a1) = (#548 *)a2;
  result = (#548 **)std::_tree_int_sockid::_Parent(a2);
  *result = a1;
  return result;
}

//----- (00429A50) --------------------------------------------------------
int __cdecl sub_429A50(int a1)
{
  while ( *std::_tree_int_sockid::_Right((#548 *)a1) != std::_tree_int_sockid::_Nil )
    a1 = (int)*std::_tree_int_sockid::_Right((#548 *)a1);
  return a1;
}

//----- (00429A90) --------------------------------------------------------
int __cdecl std::_tree_int_sockid::_Min(int a1)
{
  while ( *std::_tree_int_sockid::_Left((#548 *)a1) != std::_tree_int_sockid::_Nil )
    a1 = (int)*std::_tree_int_sockid::_Left((#548 *)a1);
  return a1;
}

//----- (00429AD0) --------------------------------------------------------
#548 **__thiscall std::_tree_int_sockid::_Rmost(std::_tree_int_acc *this)
{
  return std::_tree_int_sockid::_Right((#548 *)this->_Head);
}

//----- (00429AF0) --------------------------------------------------------
int __thiscall std::_tree_int_sockid::_Root(int this)
{
  return std::_tree_int_sockid::_Parent(*(_DWORD *)(this + 4));
}

//----- (00429B10) --------------------------------------------------------
#548 **__thiscall sub_429B10(void *this, int a2)
{
  #548 **v2; // esi@1
  int *v3; // eax@2
  _DWORD *v4; // esi@3
  #548 **v5; // eax@5
  #548 **v6; // eax@6
  #548 **v7; // eax@7
  #548 **result; // eax@8
  void *v9; // [sp+4h] [bp-8h]@1
  #548 *v10; // [sp+8h] [bp-4h]@1

  v9 = this;
  v10 = *std::_tree_int_sockid::_Left((#548 *)a2);
  v2 = std::_tree_int_sockid::_Right(v10);
  *std::_tree_int_sockid::_Left((#548 *)a2) = *v2;
  if ( *std::_tree_int_sockid::_Right(v10) != std::_tree_int_sockid::_Nil )
  {
    v3 = (int *)std::_tree_int_sockid::_Right(v10);
    *(_DWORD *)std::_tree_int_sockid::_Parent(*v3) = a2;
  }
  v4 = (_DWORD *)std::_tree_int_sockid::_Parent(a2);
  *(_DWORD *)std::_tree_int_sockid::_Parent((int)v10) = *v4;
  if ( a2 == *(_DWORD *)std::_tree_int_sockid::_Root((int)v9) )
  {
    *(_DWORD *)std::_tree_int_sockid::_Root((int)v9) = v10;
  }
  else
  {
    v5 = (#548 **)std::_tree_int_sockid::_Parent(a2);
    if ( (#548 *)a2 == *std::_tree_int_sockid::_Right(*v5) )
    {
      v6 = (#548 **)std::_tree_int_sockid::_Parent(a2);
      *std::_tree_int_sockid::_Right(*v6) = v10;
    }
    else
    {
      v7 = (#548 **)std::_tree_int_sockid::_Parent(a2);
      *std::_tree_int_sockid::_Left(*v7) = v10;
    }
  }
  *std::_tree_int_sockid::_Right(v10) = (#548 *)a2;
  result = (#548 **)std::_tree_int_sockid::_Parent(a2);
  *result = v10;
  return result;
}

//----- (00429C40) --------------------------------------------------------
void __stdcall sub_429C40(int a1)
{
  sub_42A510();
}

//----- (00429C90) --------------------------------------------------------
_DWORD *__thiscall std::_tree_int_sockid::iterator::post_increment(void *this, _DWORD *a2, int a3)
{
  int v3; // ST04_4@1

  v3 = *(_DWORD *)this;
  unknown_libname_163(this);
  *a2 = v3;
  return a2;
}
// 42A2E0: using guessed type int __cdecl unknown_libname_163(_DWORD);

//----- (00429CE0) --------------------------------------------------------
std::_tree_int_int::_Node **__thiscall std::_tree_int_int::_Init(std::_tree_int_int *this)
{
  std::_tree_int_int::_Node **result; // eax@5
  std::_tree_int_int *v2; // [sp+0h] [bp-18h]@1
  char v3; // [sp+4h] [bp-14h]@1
  std::_tree_int_int::_Node *a2; // [sp+8h] [bp-10h]@1
  int v5; // [sp+14h] [bp-4h]@1

  v2 = this;
  a2 = std::_tree_int_int::_Buynode(0, 1);
  std::_Lockit::_Lockit((std::_Lockit *)&v3);
  v5 = 0;
  if ( !std::_tree_int_int::_Nil )
  {
    std::_tree_int_int::_Nil = a2;
    a2 = 0;
    *std::_tree_int_int::_Left(std::_tree_int_int::_Nil) = 0;
    *std::_tree_int_int::_Right(std::_tree_int_int::_Nil) = 0;
  }
  ++std::_tree_int_int::_Nilrefs;
  v5 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v3);
  if ( a2 )
    std::_tree_int_int::_Freenode(a2);
  v2->_Head = std::_tree_int_int::_Buynode(std::_tree_int_int::_Nil, 0);
  v2->_Size = 0;
  *std::_tree_int_int::_Lmost(v2) = v2->_Head;
  result = std::_tree_int_int::_Rmost(v2);
  *result = v2->_Head;
  return result;
}
// 47F820: using guessed type int std::_tree_int_int::_Nilrefs;

//----- (00429DE0) --------------------------------------------------------
std::_tree_int_int::_Node *__thiscall std::_tree_int_int::_Lbound(std::_tree_int_int *this, _DWORD *a2)
{
  std::_tree_int_int *v2; // ST08_4@1
  struct Concurrency::details::InternalContextBase *v3; // eax@3
  std::_tree_int_int::_Node *v5; // [sp+4h] [bp-8h]@1
  std::_tree_int_int::_Node *a1; // [sp+8h] [bp-4h]@1

  v2 = this;
  a1 = *sub_42A300((int)this);
  v5 = v2->_Head;
  while ( a1 != std::_tree_int_int::_Nil )
  {
    v3 = std::_tree_int_int::_Key((int)a1);
    if ( (unsigned __int8)std::_tree::key_compare(v3, a2) )
    {
      a1 = *std::_tree_int_int::_Right(a1);
    }
    else
    {
      v5 = a1;
      a1 = *std::_tree_int_int::_Left(a1);
    }
  }
  return v5;
}

//----- (00429E70) --------------------------------------------------------
std::_tree_int_int::_Node *__stdcall std::_tree_int_int::_Buynode(std::_tree_int_int::_Node *a1, int a2)
{
  std::_tree_int_int::_Node *result; // eax@1

  result = (std::_tree_int_int::_Node *)sub_423180(0x18u);
  *std::_tree_int_int::_Parent(result) = a1;
  *(_DWORD *)std::_tree_int_int::_Color(result) = a2;
  return result;
}

//----- (00429EC0) --------------------------------------------------------
_DWORD *__stdcall sub_429EC0(void *a1, int a2)
{
  return sub_42A520(a1, a2);
}

//----- (00429F00) --------------------------------------------------------
std::_tree_int_int::_Node **__thiscall sub_429F00(int *this)
{
  std::_tree_int_int::_Node **v1; // eax@2
  std::_tree_int_int::_Node **result; // eax@3
  int *v3; // eax@5
  std::_tree_int_int::_Node **v4; // eax@6
  int *v5; // [sp+0h] [bp-8h]@1
  std::_tree_int_int::_Node *a1; // [sp+4h] [bp-4h]@6

  v5 = this;
  if ( *(_DWORD *)std::_tree_int_int::_Color((std::_tree_int_int::_Node *)*this)
    || (v1 = std::_tree_int_int::_Parent((std::_tree_int_int::_Node *)*v5),
        *std::_tree_int_int::_Parent(*v1) != (std::_tree_int_int::_Node *)*v5) )
  {
    if ( *std::_tree_int_int::_Left((std::_tree_int_int::_Node *)*v5) == std::_tree_int_int::_Nil )
    {
      while ( 1 )
      {
        v4 = std::_tree_int_int::_Parent((std::_tree_int_int::_Node *)*v5);
        a1 = *v4;
        if ( (std::_tree_int_int::_Node *)*v5 != *std::_tree_int_int::_Left(*v4) )
          break;
        *v5 = (int)a1;
      }
      result = (std::_tree_int_int::_Node **)a1;
      *v5 = (int)a1;
    }
    else
    {
      v3 = (int *)std::_tree_int_int::_Left((std::_tree_int_int::_Node *)*v5);
      result = (std::_tree_int_int::_Node **)sub_429030(*v3);
      *v5 = (int)result;
    }
  }
  else
  {
    result = std::_tree_int_int::_Right((std::_tree_int_int::_Node *)*v5);
    *v5 = (int)*result;
  }
  return result;
}

//----- (00429FF0) --------------------------------------------------------
#548 **__thiscall std::_tree_int_sockid::_Init(std::_tree_int_acc *this)
{
  #548 **result; // eax@5
  std::_tree_int_acc *v2; // [sp+0h] [bp-18h]@1
  char v3; // [sp+4h] [bp-14h]@1
  #548 *v4; // [sp+8h] [bp-10h]@1
  int v5; // [sp+14h] [bp-4h]@1

  v2 = this;
  v4 = std::_tree_int_sockid::_Buynode(0, 1);
  std::_Lockit::_Lockit((std::_Lockit *)&v3);
  v5 = 0;
  if ( !std::_tree_int_sockid::_Nil )
  {
    std::_tree_int_sockid::_Nil = v4;
    v4 = 0;
    *std::_tree_int_sockid::_Left(std::_tree_int_sockid::_Nil) = 0;
    *std::_tree_int_sockid::_Right(std::_tree_int_sockid::_Nil) = 0;
  }
  ++std::_tree_int_sockid::_Nilrefs;
  v5 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v3);
  if ( v4 )
    std::_tree_int_sockid::_Freenode(v4);
  v2->_Head = (std::_tree_int_acc::_Node *)std::_tree_int_sockid::_Buynode(std::_tree_int_sockid::_Nil, 0);
  v2->_Size = 0;
  *std::_tree_int_acc::_Lmost(v2) = (#548 *)v2->_Head;
  result = std::_tree_int_sockid::_Rmost(v2);
  *result = (#548 *)v2->_Head;
  return result;
}
// 47F828: using guessed type int std::_tree_int_sockid::_Nilrefs;

//----- (0042A0F0) --------------------------------------------------------
#548 *__thiscall std::_tree_int_sockid::_Lbound(std::_tree_int_acc *this, _DWORD *a2)
{
  std::_tree_int_acc *v2; // ST08_4@1
  struct Concurrency::details::InternalContextBase *v3; // eax@3
  void *v5; // [sp+4h] [bp-8h]@1
  #548 *a1; // [sp+8h] [bp-4h]@1

  v2 = this;
  a1 = *(#548 **)sub_42A3E0((int)this);
  v5 = v2->_Head;
  while ( a1 != std::_tree_int_sockid::_Nil )
  {
    v3 = std::_tree_int_sockid::_Key((int)a1);
    if ( (unsigned __int8)std::_tree::key_compare(v3, a2) )
    {
      a1 = *std::_tree_int_sockid::_Right(a1);
    }
    else
    {
      v5 = (void *)a1;
      a1 = *std::_tree_int_sockid::_Left(a1);
    }
  }
  return (#548 *)v5;
}

//----- (0042A180) --------------------------------------------------------
#548 *__stdcall std::_tree_int_sockid::_Buynode(#548 *a1, int a2)
{
  #548 *result; // eax@1

  result = (#548 *)sub_42A3C0(0x18u);
  *(_DWORD *)std::_tree_int_sockid::_Parent((int)result) = a1;
  *(_DWORD *)sub_4292F0((int)result) = a2;
  return result;
}

//----- (0042A1D0) --------------------------------------------------------
_DWORD *__stdcall sub_42A1D0(void *a1, int a2)
{
  return sub_42A560(a1, a2);
}

//----- (0042A210) --------------------------------------------------------
#548 **__thiscall sub_42A210(int *this)
{
  int *v1; // eax@2
  #548 **result; // eax@3
  int *v3; // eax@5
  #548 **v4; // eax@6
  int *v5; // [sp+0h] [bp-8h]@1
  #548 *a1; // [sp+4h] [bp-4h]@6

  v5 = this;
  if ( *(_DWORD *)sub_4292F0(*this)
    || (v1 = (int *)std::_tree_int_sockid::_Parent(*v5), *(_DWORD *)std::_tree_int_sockid::_Parent(*v1) != *v5) )
  {
    if ( *std::_tree_int_sockid::_Left((#548 *)*v5) == std::_tree_int_sockid::_Nil )
    {
      while ( 1 )
      {
        v4 = (#548 **)std::_tree_int_sockid::_Parent(*v5);
        a1 = *v4;
        if ( (#548 *)*v5 != *std::_tree_int_sockid::_Left(*v4) )
          break;
        *v5 = (int)a1;
      }
      result = (#548 **)a1;
      *v5 = (int)a1;
    }
    else
    {
      v3 = (int *)std::_tree_int_sockid::_Left((#548 *)*v5);
      result = (#548 **)sub_429A50(*v3);
      *v5 = (int)result;
    }
  }
  else
  {
    result = std::_tree_int_sockid::_Right((#548 *)*v5);
    *v5 = (int)*result;
  }
  return result;
}

//----- (0042A300) --------------------------------------------------------
std::_tree_int_int::_Node **__thiscall sub_42A300(int this)
{
  return std::_tree_int_int::_Parent(*(std::_tree_int_int::_Node **)(this + 4));
}

//----- (0042A320) --------------------------------------------------------
std::_tree_int_int::_Node **__thiscall sub_42A320(int *this)
{
  std::_tree_int_int::_Node **v1; // eax@2
  std::_tree_int_int::_Node **result; // eax@2
  std::_tree_int_int::_Node **v3; // eax@3
  int *v4; // [sp+0h] [bp-8h]@1
  std::_tree_int_int::_Node *a1; // [sp+4h] [bp-4h]@3

  v4 = this;
  if ( *std::_tree_int_int::_Right((std::_tree_int_int::_Node *)*this) == std::_tree_int_int::_Nil )
  {
    while ( 1 )
    {
      v3 = std::_tree_int_int::_Parent((std::_tree_int_int::_Node *)*v4);
      a1 = *v3;
      if ( (std::_tree_int_int::_Node *)*v4 != *std::_tree_int_int::_Right(*v3) )
        break;
      *v4 = (int)a1;
    }
    result = std::_tree_int_int::_Right((std::_tree_int_int::_Node *)*v4);
    if ( *result != a1 )
    {
      result = (std::_tree_int_int::_Node **)a1;
      *v4 = (int)a1;
    }
  }
  else
  {
    v1 = std::_tree_int_int::_Right((std::_tree_int_int::_Node *)*v4);
    result = (std::_tree_int_int::_Node **)std::_tree_int_int::_Min(*v1);
    *v4 = (int)result;
  }
  return result;
}

//----- (0042A3C0) --------------------------------------------------------
char *__stdcall sub_42A3C0(size_t a1)
{
  return std::_Allocate(a1);
}

//----- (0042A3E0) --------------------------------------------------------
int __thiscall sub_42A3E0(int this)
{
  return std::_tree_int_sockid::_Parent(*(_DWORD *)(this + 4));
}

//----- (0042A400) --------------------------------------------------------
#548 **__thiscall sub_42A400(int *this)
{
  int *v1; // eax@2
  #548 **result; // eax@2
  #548 **v3; // eax@3
  int *v4; // [sp+0h] [bp-8h]@1
  #548 *v5; // [sp+4h] [bp-4h]@3

  v4 = this;
  if ( *std::_tree_int_sockid::_Right((#548 *)*this) == std::_tree_int_sockid::_Nil )
  {
    while ( 1 )
    {
      v3 = (#548 **)std::_tree_int_sockid::_Parent(*v4);
      v5 = *v3;
      if ( (#548 *)*v4 != *std::_tree_int_sockid::_Right(*v3) )
        break;
      *v4 = (int)v5;
    }
    result = std::_tree_int_sockid::_Right((#548 *)*v4);
    if ( *result != v5 )
    {
      result = (#548 **)v5;
      *v4 = (int)v5;
    }
  }
  else
  {
    v1 = (int *)std::_tree_int_sockid::_Right((#548 *)*v4);
    result = (#548 **)std::_tree_int_sockid::_Min(*v1);
    *v4 = (int)result;
  }
  return result;
}

//----- (0042A4A0) --------------------------------------------------------
int __cdecl sub_42A4A0(int *a1, int *a2)
{
  int v2; // ST00_4@1
  int result; // eax@1

  v2 = *a1;
  *a1 = *a2;
  result = v2;
  *a2 = v2;
  return result;
}

//----- (0042A4D0) --------------------------------------------------------
int __cdecl sub_42A4D0(int *a1, int *a2)
{
  int v2; // ST00_4@1
  int result; // eax@1

  v2 = *a1;
  *a1 = *a2;
  result = v2;
  *a2 = v2;
  return result;
}

//----- (0042A500) --------------------------------------------------------
void sub_42A500()
{
  ;
}

//----- (0042A510) --------------------------------------------------------
void sub_42A510()
{
  ;
}

//----- (0042A520) --------------------------------------------------------
_DWORD *__cdecl sub_42A520(void *a1, int a2)
{
  _DWORD *result; // eax@1
  _DWORD *v3; // [sp+4h] [bp-4h]@1

  result = operator new(8u, a1);
  v3 = result;
  if ( result )
  {
    result = *(_DWORD **)(a2 + 4);
    *v3 = *(_DWORD *)a2;
    v3[1] = result;
  }
  return result;
}

//----- (0042A560) --------------------------------------------------------
_DWORD *__cdecl sub_42A560(void *a1, int a2)
{
  _DWORD *result; // eax@1
  _DWORD *v3; // [sp+4h] [bp-4h]@1

  result = operator new(8u, a1);
  v3 = result;
  if ( result )
  {
    result = *(_DWORD **)(a2 + 4);
    *v3 = *(_DWORD *)a2;
    v3[1] = result;
  }
  return result;
}

//----- (0042A5A0) --------------------------------------------------------
int StaticInit_TimerQueue()
{
  CallStaticCtorForTimerQueue();
  return RegisterStatic_destructorForTimerQueue();
}

//----- (0042A5AF) --------------------------------------------------------
TimerQueue *CallStaticCtorForTimerQueue()
{
  return TimerQueue::TimerQueue(&g_timerQueue);
}

//----- (0042A5BE) --------------------------------------------------------
int RegisterStatic_destructorForTimerQueue()
{
  return atexit(CallTimerQueueDestructor);
}

//----- (0042A5D0) --------------------------------------------------------
void __cdecl CallTimerQueueDestructor()
{
  TimerQueue::Destructor(&g_timerQueue);
}

//----- (0042A5FC) --------------------------------------------------------
void __thiscall TimerQueue::TimerDispatch(TimerQueue *this)
{
  CIOTimer *next; // eax@4
  MemoryObject *nextObject; // edx@4
  CIOTimer *v3; // eax@10
  TimerQueue *this_; // [sp+Ch] [bp-38h]@1
  MemoryObject *obj; // [sp+10h] [bp-34h]@3
  CIOTimer *timer; // [sp+14h] [bp-30h]@3
  DWORD now; // [sp+18h] [bp-2Ch]@2
  int dwMilliseconds; // [sp+1Ch] [bp-28h]@2
  HANDLE Handles[2]; // [sp+24h] [bp-20h]@1
  CPPEH_RECORD ms_exc; // [sp+2Ch] [bp-18h]@1

  this_ = this;
  ms_exc.registration.TryLevel = 0;
  Handles[0] = this->manualResetEvent;
  Handles[1] = this->event1;
  do
  {
    now = GetTickCount();
    dwMilliseconds = this_->nextTimer - now;
    if ( dwMilliseconds <= 0 )
    {
      SpinLock::Enter(&this_->criticalSection);
      timer = queue::top(&this_->timerQueue);
      for ( obj = timer->m_pObject; ; obj = timer->m_pObject )
      {
        queue::pop(&this_->timerQueue);
        obj->vftbl_0_45F520->OnTimerCallback(obj);
        next = queue::top(&this_->timerQueue);
        nextObject = next->m_pObject;
        timer->m_dwTime = next->m_dwTime;
        timer->m_pObject = nextObject;
        dwMilliseconds = timer->m_dwTime - now;
        if ( dwMilliseconds > 0 )
          break;
      }
      this_->nextTimer = timer->m_dwTime;
      SpinLock::Leave(&this_->criticalSection);
    }
    WaitForMultipleObjects(2u, Handles, 0, dwMilliseconds);
  }
  while ( !this_->stopThread );
  SpinLock::Enter(&this_->criticalSection);
  while ( !std::priority_queue::empty(&this_->timerQueue) )
  {
    v3 = queue::top(&this_->timerQueue);
    MemoryObject::Release(v3->m_pObject);
    queue::pop(&this_->timerQueue);
  }
  SpinLock::Leave(&this_->criticalSection);
  ms_exc.registration.TryLevel = -1;
}

//----- (0042A7A4) --------------------------------------------------------
std::vector_MemoryObject::iterator *__thiscall TimerQueue::execWaitLoop(TimerQueue *this)
{
  std::vector_HANDLE::iterator *it; // ST04_4@2
  DWORD size; // eax@2
  std::vector_MemoryObject::iterator *result; // eax@4
  std::vector_MemoryObject::iterator *object; // eax@8
  TimerQueue *this_; // [sp+10h] [bp-24h]@1
  std::vector_MemoryObject::iterator *i; // [sp+14h] [bp-20h]@3
  unsigned int signaledIndex; // [sp+18h] [bp-1Ch]@2

  this_ = this;
  while ( true )
  {
    it = std::vector_HANDLE::begin(&this_->events);
    size = std::vector_HANDLE::size(&this_->events);
    signaledIndex = WaitForMultipleObjects(size, &it->value, 0, INFINITE);
    if ( this_->stopThread )
      break;
    if ( signaledIndex < std::vector_HANDLE::size(&this_->events) )
    {
      object = std::vector_DNameNode::operator[](&this_->clients, signaledIndex);
      object->value->vftbl_0_45F520->OnWaitCallback(object->value);
    }
  }
  for ( i = std::vector_DNameNode::begin(&this_->clients); ; i = std::vector_DNameNode::erase(&this_->clients, i) )
  {
    result = std::vector_DNameNode::end(&this_->clients);
    if ( i == result )
      break;
  }
  return result;
}

//----- (0042A8C8) --------------------------------------------------------
int __thiscall TimerQueue::AddTimer(TimerQueue *this, MemoryObject *timerInstance, unsigned int delay, int id)
{
  int result; // eax@2
  CIOTimer *timer; // eax@3
  TimerQueue *this_; // [sp+0h] [bp-Ch]@1
  CIOTimer v7; // [sp+4h] [bp-8h]@3
  DWORD nextTimer; // [sp+18h] [bp+Ch]@1

  this_ = this;
  nextTimer = GetTickCount() + delay;
  SpinLock::Enter(&this_->criticalSection);
  if ( this_->stopThread )
  {
    SpinLock::Leave(&this_->criticalSection);
    result = 0;
  }
  else
  {
    timer = CIOTimer::CIOTimer(&v7, timerInstance, nextTimer);
    std::priority_queue::push(&this_->timerQueue, timer);
    if ( (signed int)(this_->nextTimer - nextTimer) <= 0 )
    {
      SpinLock::Leave(&this_->criticalSection);
    }
    else
    {
      this_->nextTimer = nextTimer;
      SpinLock::Leave(&this_->criticalSection);
      if ( id )
        SetEvent(this_->event1);
    }
    result = 1;
  }
  return result;
}

//----- (0042A96A) --------------------------------------------------------
signed int __thiscall TimerQueue::RegisterWait(TimerQueue *this, HANDLE event, MemoryObject *client)
{
  signed int result; // eax@2
  TimerQueue *this_; // [sp+0h] [bp-8h]@1

  this_ = this;
  SpinLock::Enter(&this->criticalSection);
  if ( this_->stopThread )
  {
    SpinLock::Leave(&this_->criticalSection);
    result = 0;
  }
  else if ( std::vector_HANDLE::size(&this_->events) < 64 )
  {
    std::vector_HANDLE::push_back(&this_->events, &event);
    std::vector_DNameNode::push_back(&this_->clients, &client);
    SpinLock::Leave(&this_->criticalSection);
    std::vector_DNameNode::size(&this_->clients);
    result = 1;
  }
  else
  {
    SpinLock::Leave(&this_->criticalSection);
    result = 0;
  }
  return result;
}

//----- (0042A9F7) --------------------------------------------------------
TimerQueue *__thiscall TimerQueue::TimerQueue(TimerQueue *this)
{
  CIOTimer *timer_; // eax@4
  CIOTimerInstance *timerInstance_; // [sp+0h] [bp-38h]@2
  TimerQueue *this_; // [sp+4h] [bp-34h]@1
  CIOTimerInstance *timerInstance_2; // [sp+8h] [bp-30h]@4
  CIOTimer timer; // [sp+Ch] [bp-2Ch]@4
  CIOTimerInstance *timerInstance; // [sp+14h] [bp-24h]@1
  CIOTimerInstance *timerInstance_1; // [sp+18h] [bp-20h]@4
  char unused_3; // [sp+1Ch] [bp-1Ch]@1
  int unused_1; // [sp+20h] [bp-18h]@1
  char unused_2; // [sp+24h] [bp-14h]@1
  char unused_; // [sp+28h] [bp-10h]@1
  int unused; // [sp+34h] [bp-4h]@1

  this_ = this;
  SpinLock::SpinLock(&this->criticalSection, LockType_CritSection, 0);
  unused = 0;
  std::vector_HANDLE::vector_HANDLE(&this_->events, &unused_);
  LOBYTE(unused) = 1;
  std::vector_DNameNode::vector_DNameNode(&this_->clients, &unused_2);
  LOBYTE(unused) = 2;
  std::priority_queue::priority_queue(&this_->timerQueue, &unused_3, (int)&unused_1);
  LOBYTE(unused) = 3;
  this_->stopThread = 0;
  this_->event1 = CreateEventA(0, 0, 0, 0);
  this_->manualResetEvent = CreateEventA(0, 1, 0, 0);
  timerInstance = (CIOTimerInstance *)operator_new(8u);
  LOBYTE(unused) = 4;
  if ( timerInstance )
    timerInstance_ = CIOTimerInstance::CIOTimerInstance(timerInstance);
  else
    timerInstance_ = 0;
  timerInstance_1 = timerInstance_;
  LOBYTE(unused) = 3;
  this_->timerInstance = timerInstance_;
  this_->nextTimer = GetTickCount() + 86400000;
  timer_ = CIOTimer::CIOTimer(&timer, &this_->timerInstance->base, this_->nextTimer);
  std::priority_queue::push(&this_->timerQueue, timer_);
  std::vector_HANDLE::push_back(&this_->events, &this_->manualResetEvent);
  timerInstance_2 = this_->timerInstance;
  std::vector_DNameNode::push_back(&this_->clients, (MemoryObject **)&timerInstance_2);
  return this_;
}

//----- (0042AB4A) --------------------------------------------------------
void __thiscall TimerQueue::Destructor(TimerQueue *this)
{
  TimerQueue *this_; // ST04_4@1

  this_ = this;
  CloseHandle(this->event1);
  CloseHandle(this_->manualResetEvent);
  std::priority_queue::Destructor(&this_->timerQueue);
  std::vector_DNameNode::Destructor(&this_->clients);
  std::vector_HANDLE::Destructor(&this_->events);
  SpinLock::Destructor(&this_->criticalSection);
}

//----- (0042ABD0) --------------------------------------------------------
BOOL __thiscall TimerQueue::terminate(TimerQueue *this)
{
  TimerQueue *this_; // ST04_4@1

  this_ = this;
  this->stopThread = 1;
  SetEvent(this->manualResetEvent);
  return SetEvent(this_->event1);
}

//----- (0042ABFF) --------------------------------------------------------
int __thiscall CIOTimerInstance::OnTimerCallback(CIOTimerInstance *this)
{
  int result; // eax@1
  CIOTimerInstance *this_; // [sp+0h] [bp-4h]@1

  this_ = this;
  result = ((int (__stdcall *)(signed int, signed int))this->base.vftbl_0_45F520->AddTimer)(86400000, 1);// 24*3600*1000
  if ( result )
    result = MemoryObject::Release(&this_->base);
  return result;
}

//----- (0042AC28) --------------------------------------------------------
int SomeStaticInit43()
{
  SomeBitsInit();
  return sub_42AC37();
}

//----- (0042AC37) --------------------------------------------------------
int sub_42AC37()
{
  return atexit(emptystub);
}

//----- (0042ACF0) --------------------------------------------------------
std::vector_CIOTimer *__thiscall std::vector_CIOTimer::Destructor(std::vector_CIOTimer *this)
{
  std::vector_CIOTimer *v1; // ST08_4@1
  std::vector_CIOTimer *result; // eax@1

  v1 = this;
  std::vector_CIOTimer::_Destroy(this->_First, this->_Last);
  std::vector_CIOTimer::allocator_deallocate(v1->_First, (v1->_End - v1->_First) >> 3);
  result = v1;
  v1->_First = 0;
  v1->_Last = 0;
  v1->_End = 0;
  return result;
}

//----- (0042AD70) --------------------------------------------------------
std::vector_HANDLE *__thiscall std::vector_HANDLE::Destructor_2(std::vector_HANDLE *this)
{
  std::vector_HANDLE *v1; // ST08_4@1
  std::vector_HANDLE *result; // eax@1

  v1 = this;
  std::vector_HANDLE::_Destroy((int)this->_First, (int)this->_Last);
  std::vector_HANDLE::allocator_deallocate(v1->_First, v1->_End - v1->_First);
  result = v1;
  v1->_First = 0;
  v1->_Last = 0;
  v1->_End = 0;
  return result;
}
// 42B2F0: using guessed type _DWORD __stdcall std::vector_HANDLE::allocator_deallocate(LPVOID lpMem, _DWORD);

//----- (0042ADF0) --------------------------------------------------------
size_t __thiscall std::vector_HANDLE::size(std::vector_HANDLE *this)
{
  size_t v2; // [sp+0h] [bp-8h]@2

  if ( this->_First )
    v2 = this->_Last - this->_First;
  else
    v2 = 0;
  return v2;
}

//----- (0042AE30) --------------------------------------------------------
int __thiscall std::vector_HANDLE::push_back(std::vector_HANDLE *this, HANDLE event)
{
  std::vector_HANDLE *v2; // ST08_4@1
  std::vector_HANDLE::iterator *end; // eax@1

  v2 = this;
  end = std::vector_HANDLE::end(this);
  return (int)std::vector_HANDLE::insert(v2, end, (HANDLE *)event);
}

//----- (0042AE80) --------------------------------------------------------
std::vector_MemoryObject *__thiscall std::vector_DNameNode::Destructor_2(std::vector_MemoryObject *this)
{
  std::vector_MemoryObject *v1; // ST08_4@1
  std::vector_MemoryObject *result; // eax@1

  v1 = this;
  std::vector_DNameNode::_Destroy(this->_First, this->_Last);
  std::vector_DNameNode::allocator_deallocate(v1->_First, v1->_End - v1->_First);
  result = v1;
  v1->_First = 0;
  v1->_Last = 0;
  v1->_End = 0;
  return result;
}
// 42B3D0: using guessed type _DWORD __stdcall std::vector_DNameNode::allocator_deallocate(LPVOID lpMem, _DWORD);

//----- (0042AF20) --------------------------------------------------------
int __thiscall std::vector_DNameNode::size(std::vector_MemoryObject *this)
{
  signed int v2; // [sp+0h] [bp-8h]@2

  if ( this->_First )
    v2 = this->_Last - this->_First;
  else
    v2 = 0;
  return v2;
}

//----- (0042AF60) --------------------------------------------------------
std::vector_MemoryObject::iterator *__thiscall std::vector_DNameNode::operator[](std::vector_MemoryObject *this, int a2)
{
  return &std::vector_DNameNode::begin(this)[a2];
}

//----- (0042AF80) --------------------------------------------------------
int __thiscall std::vector_DNameNode::push_back(std::vector_MemoryObject *this, MemoryObject *a2)
{
  std::vector_MemoryObject *v2; // ST08_4@1
  std::vector_MemoryObject::iterator *v3; // eax@1

  v2 = this;
  v3 = std::vector_DNameNode::end(this);
  return (int)std::vector_DNameNode::insert(v2, v3, a2);
}

//----- (0042AFB0) --------------------------------------------------------
std::vector_MemoryObject::iterator *__thiscall std::vector_DNameNode::erase(std::vector_MemoryObject *this, std::vector_MemoryObject::iterator *a2)
{
  std::vector_MemoryObject *v2; // ST0C_4@1
  std::vector_MemoryObject::iterator *v3; // eax@1

  v2 = this;
  v3 = std::vector_DNameNode::end(this);
  sub_42BE70(a2 + 1, v3, a2);
  std::vector_DNameNode::_Destroy(v2->_Last - 1, v2->_Last);
  --v2->_Last;
  return a2;
}

//----- (0042B010) --------------------------------------------------------
std::priority_queue *__thiscall std::priority_queue::priority_queue(std::priority_queue *this, _BYTE *a2, int a3)
{
  std::priority_queue *v3; // ST08_4@1

  v3 = this;
  std::priority_queue::priority_queue_2(this, a2, a3);
  return v3;
}

//----- (0042B070) --------------------------------------------------------
std::vector_CIOTimer::iterator *__thiscall std::priority_queue::push(std::priority_queue *this, CIOTimer *value)
{
  std::priority_queue *v2; // ST0C_4@1
  char v3; // dl@1
  std::vector_CIOTimer::iterator *v4; // ST04_4@1
  std::vector_CIOTimer::iterator *v5; // eax@1

  v2 = this;
  std::vector_CIOTimer::push_back(&this->c, value);
  v3 = v2->comp;
  v4 = std::vector_CIOTimer::end(&v2->c);
  v5 = std::vector_CIOTimer::begin(&v2->c);
  return std::push_heap(v5, v4);
}

//----- (0042B0B0) --------------------------------------------------------
std::vector_CIOTimer::iterator *__thiscall queue::pop(std::priority_queue *this)
{
  std::priority_queue *v1; // ST0C_4@1
  char v2; // cl@1
  std::vector_CIOTimer::iterator *v3; // ST04_4@1
  std::vector_CIOTimer::iterator *v4; // eax@1

  v1 = this;
  v2 = this->comp;
  v3 = std::vector_CIOTimer::end(&v1->c);
  v4 = std::vector_CIOTimer::begin(&v1->c);
  std::pop_heap((int)v4, (int)v3);
  return std::vector_CIOTimer::pop_back(&v1->c);
}

//----- (0042B130) --------------------------------------------------------
BOOL __thiscall std::vector_CIOTimer::empty(std::vector_CIOTimer *this)
{
  return std::vector_CIOTimer::size(this) == 0;
}

//----- (0042B170) --------------------------------------------------------
std::vector_CIOTimer::iterator *__thiscall std::vector_CIOTimer::push_back(std::vector_CIOTimer *this, CIOTimer *a2)
{
  std::vector_CIOTimer *v2; // ST08_4@1
  std::vector_CIOTimer::iterator *v3; // eax@1

  v2 = this;
  v3 = std::vector_CIOTimer::end(this);
  return std::vector_CIOTimer::insert(v2, v3, (int)a2);
}

//----- (0042B1A0) --------------------------------------------------------
std::vector_CIOTimer::iterator *__thiscall std::vector_CIOTimer::pop_back(std::vector_CIOTimer *this)
{
  std::vector_CIOTimer *v1; // ST04_4@1
  std::vector_CIOTimer::iterator *this_; // eax@1

  v1 = this;
  this_ = std::vector_CIOTimer::end(this);
  return std::vector_CIOTimer::erase(v1, this_ - 1);
}

//----- (0042B1C0) --------------------------------------------------------
std::vector_CIOTimer::iterator *__stdcall std::vector_CIOTimer::_Destroy(std::vector_CIOTimer::iterator *a1, std::vector_CIOTimer::iterator *a2)
{
  std::vector_CIOTimer::iterator *result; // eax@2

  while ( a1 != a2 )
  {
    sub_42B530((int)a1);
    result = a1 + 1;
    ++a1;
  }
  return result;
}

//----- (0042B210) --------------------------------------------------------
std::vector_HANDLE *__thiscall std::vector_HANDLE::vector_HANDLE_2(std::vector_HANDLE *this, _BYTE *a2)
{
  this->allocator = *a2;
  this->_First = 0;
  this->_Last = 0;
  this->_End = 0;
  return this;
}

//----- (0042B270) --------------------------------------------------------
std::vector_HANDLE::iterator *__thiscall std::vector_HANDLE::insert(std::vector_HANDLE *this, std::vector_HANDLE::iterator *a2, HANDLE *handle)
{
  std::vector_HANDLE *v3; // ST0C_4@1
  signed int v4; // ST10_4@1

  v3 = this;
  v4 = a2 - std::vector_HANDLE::begin(this);
  std::vector_HANDLE::insert_2(v3, a2, 1u, handle);
  return &std::vector_HANDLE::begin(v3)[v4];
}

//----- (0042B2C0) --------------------------------------------------------
int __stdcall std::vector_HANDLE::_Destroy(int a1, int a2)
{
  int result; // eax@2

  while ( a1 != a2 )
  {
    sub_42B770(a1);
    result = a1 + 4;
    a1 += 4;
  }
  return result;
}

//----- (0042B310) --------------------------------------------------------
std::vector_MemoryObject *__thiscall std::vector_DNameNode::vector_DNameNode_2(std::vector_MemoryObject *this, _BYTE *a2)
{
  this->allocator = *a2;
  this->_First = 0;
  this->_Last = 0;
  this->_End = 0;
  return this;
}

//----- (0042B350) --------------------------------------------------------
std::vector_MemoryObject::iterator *__thiscall std::vector_DNameNode::insert(std::vector_MemoryObject *this, std::vector_MemoryObject::iterator *a2, MemoryObject *a3)
{
  std::vector_MemoryObject *v3; // ST0C_4@1
  signed int v4; // ST10_4@1

  v3 = this;
  v4 = a2 - std::vector_DNameNode::begin(this);
  std::vector_DNameNode::insert_2(v3, a2, 1u, a3);
  return &std::vector_DNameNode::begin(v3)[v4];
}

//----- (0042B3A0) --------------------------------------------------------
std::vector_MemoryObject::iterator *__stdcall std::vector_DNameNode::_Destroy(std::vector_MemoryObject::iterator *a1, std::vector_MemoryObject::iterator *a2)
{
  std::vector_MemoryObject::iterator *result; // eax@2

  while ( a1 != a2 )
  {
    sub_42B9B0((int)a1);
    result = a1 + 1;
    ++a1;
  }
  return result;
}

//----- (0042B3F0) --------------------------------------------------------
std::priority_queue *__thiscall std::priority_queue::priority_queue_2(std::priority_queue *this, _BYTE *a2, int a3)
{
  std::priority_queue *v3; // ST04_4@1

  v3 = this;
  std::vector_CIOTimer::vector_CIOTimer(&this->c, (_BYTE *)a3);
  v3->comp = *a2;
  return v3;
}

//----- (0042B440) --------------------------------------------------------
int __thiscall std::vector_CIOTimer::size(std::vector_CIOTimer *this)
{
  signed int v2; // [sp+0h] [bp-8h]@2

  if ( this->_First )
    v2 = this->_Last - this->_First;
  else
    v2 = 0;
  return v2;
}

//----- (0042B480) --------------------------------------------------------
std::vector_CIOTimer::iterator *__thiscall std::vector_CIOTimer::insert(std::vector_CIOTimer *this, std::vector_CIOTimer::iterator *a2, int a3)
{
  std::vector_CIOTimer *v3; // ST0C_4@1
  signed int v4; // ST10_4@1

  v3 = this;
  v4 = a2 - std::vector_CIOTimer::begin(this);
  std::vector_CIOTimer::insert_2(v3, (int)a2, 1u, a3);
  return &std::vector_CIOTimer::begin(v3)[v4];
}

//----- (0042B4D0) --------------------------------------------------------
std::vector_CIOTimer::iterator *__thiscall std::vector_CIOTimer::erase(std::vector_CIOTimer *this, std::vector_CIOTimer::iterator *a2)
{
  std::vector_CIOTimer *v2; // ST0C_4@1
  std::vector_CIOTimer::iterator *v3; // eax@1

  v2 = this;
  v3 = std::vector_CIOTimer::end(this);
  sub_42BF10(a2 + 1, v3, a2);
  std::vector_CIOTimer::_Destroy(v2->_Last - 1, v2->_Last);
  --v2->_Last;
  return a2;
}

//----- (0042B530) --------------------------------------------------------
void __stdcall sub_42B530(int a1)
{
  sub_42BF50();
}

//----- (0042B550) --------------------------------------------------------
std::vector_HANDLE *__thiscall std::vector_HANDLE::insert_2(std::vector_HANDLE *this, std::vector_HANDLE::iterator *a2, unsigned int a3, _DWORD *a4)
{
  int v4; // ST14_4@5
  void *v5; // ST18_4@5
  void *v6; // ST1C_4@5
  std::vector_HANDLE *result; // eax@5
  unsigned int v8; // [sp+0h] [bp-14h]@3
  std::vector_HANDLE *v9; // [sp+4h] [bp-10h]@1

  v9 = this;
  if ( this->_End - this->_Last >= a3 )
  {
    result = (std::vector_HANDLE *)(this->_Last - a2);
    if ( (unsigned int)result >= a3 )
    {
      if ( a3 )
      {
        sub_42BC30((int)&this->_Last[-a3], (int)this->_Last, this->_Last);
        sub_42BF90(a2, &v9->_Last[-a3], &v9->_Last->value);
        sub_42BF60(a2, &a2[a3], a4);
        result = (std::vector_HANDLE *)a3;
        v9->_Last += a3;
      }
    }
    else
    {
      sub_42BC30((int)a2, (int)this->_Last, &a2[a3]);
      sub_42BC70(v9->_Last, a3 - (v9->_Last - a2), (int)a4);
      sub_42BF60(a2, &v9->_Last->value, a4);
      result = v9;
      v9->_Last += a3;
    }
  }
  else
  {
    if ( a3 >= std::vector_HANDLE::size(this) )
      v8 = a3;
    else
      v8 = std::vector_HANDLE::size(v9);
    v4 = v8 + std::vector_HANDLE::size(v9);
    v5 = sub_42BCB0(v4, 0);
    v6 = sub_42BC30((int)v9->_First, (int)a2, v5);
    sub_42BC70(v6, a3, (int)a4);
    sub_42BC30((int)a2, (int)v9->_Last, (char *)v6 + 4 * a3);
    std::vector_HANDLE::_Destroy((int)v9->_First, (int)v9->_Last);
    std::vector_HANDLE::allocator_deallocate(v9->_First, v9->_End - v9->_First);
    v9->_End = (std::vector_HANDLE::iterator *)((char *)v5 + 4 * v4);
    v9->_Last = (std::vector_HANDLE::iterator *)((char *)v5 + 4 * std::vector_HANDLE::size(v9) + 4 * a3);
    result = v9;
    v9->_First = (std::vector_HANDLE::iterator *)v5;
  }
  return result;
}
// 42B2F0: using guessed type _DWORD __stdcall std::vector_HANDLE::allocator_deallocate(LPVOID lpMem, _DWORD);

//----- (0042B770) --------------------------------------------------------
void __stdcall sub_42B770(int a1)
{
  sub_42BFC0();
}

//----- (0042B790) --------------------------------------------------------
std::vector_MemoryObject *__thiscall std::vector_DNameNode::insert_2(std::vector_MemoryObject *this, _DWORD *a2, unsigned int a3, _DWORD *a4)
{
  int v4; // ST14_4@5
  void *v5; // ST18_4@5
  void *v6; // ST1C_4@5
  std::vector_MemoryObject *result; // eax@5
  unsigned int v8; // [sp+0h] [bp-14h]@3
  std::vector_MemoryObject *v9; // [sp+4h] [bp-10h]@1

  v9 = this;
  if ( this->_End - this->_Last >= a3 )
  {
    result = (std::vector_MemoryObject *)((signed int)((char *)this->_Last - (char *)a2) >> 2);
    if ( (unsigned int)result >= a3 )
    {
      if ( a3 )
      {
        sub_42BCD0((int)&this->_Last[-a3], (int)this->_Last, this->_Last);
        sub_42C000(a2, &v9->_Last[-a3], &v9->_Last->value);
        sub_42BFD0(a2, &a2[a3], a4);
        result = (std::vector_MemoryObject *)a3;
        v9->_Last += a3;
      }
    }
    else
    {
      sub_42BCD0((int)a2, (int)this->_Last, &a2[a3]);
      sub_42BD10(v9->_Last, a3 - ((signed int)((char *)v9->_Last - (char *)a2) >> 2), (int)a4);
      sub_42BFD0(a2, &v9->_Last->value, a4);
      result = v9;
      v9->_Last += a3;
    }
  }
  else
  {
    if ( a3 >= std::vector_DNameNode::size(this) )
      v8 = a3;
    else
      v8 = std::vector_DNameNode::size(v9);
    v4 = v8 + std::vector_DNameNode::size(v9);
    v5 = sub_42BD50(v4, 0);
    v6 = sub_42BCD0((int)v9->_First, (int)a2, v5);
    sub_42BD10(v6, a3, (int)a4);
    sub_42BCD0((int)a2, (int)v9->_Last, (char *)v6 + 4 * a3);
    std::vector_DNameNode::_Destroy(v9->_First, v9->_Last);
    std::vector_DNameNode::allocator_deallocate(v9->_First, v9->_End - v9->_First);
    v9->_End = (std::vector_MemoryObject::iterator *)((char *)v5 + 4 * v4);
    v9->_Last = (std::vector_MemoryObject::iterator *)((char *)v5 + 4 * std::vector_DNameNode::size(v9) + 4 * a3);
    result = v9;
    v9->_First = (std::vector_MemoryObject::iterator *)v5;
  }
  return result;
}
// 42B3D0: using guessed type _DWORD __stdcall std::vector_DNameNode::allocator_deallocate(LPVOID lpMem, _DWORD);

//----- (0042B9B0) --------------------------------------------------------
void __stdcall sub_42B9B0(int a1)
{
  sub_42C030();
}

//----- (0042B9D0) --------------------------------------------------------
std::vector_CIOTimer *__thiscall std::vector_CIOTimer::vector_CIOTimer_2(std::vector_CIOTimer *this, _BYTE *a2)
{
  this->allocator = *a2;
  this->_First = 0;
  this->_Last = 0;
  this->_End = 0;
  return this;
}

//----- (0042BA10) --------------------------------------------------------
std::vector_CIOTimer *__thiscall std::vector_CIOTimer::insert_2(std::vector_CIOTimer *this, int a2, unsigned int a3, int a4)
{
  int v4; // ST14_4@5
  void *v5; // ST18_4@5
  void *v6; // ST1C_4@5
  std::vector_CIOTimer *result; // eax@5
  unsigned int v8; // [sp+0h] [bp-14h]@3
  std::vector_CIOTimer *v9; // [sp+4h] [bp-10h]@1

  v9 = this;
  if ( (this->_End - this->_Last) >> 3 >= a3 )
  {
    result = (std::vector_CIOTimer *)(((signed int)this->_Last - a2) >> 3);
    if ( (unsigned int)result >= a3 )
    {
      if ( a3 )
      {
        sub_42BD70((int)&this->_Last[-a3].value.m_dwTime, (int)&this->_Last->value.m_dwTime, this->_Last);
        sub_42C070(a2, (int)&v9->_Last[-a3].value.m_dwTime, (int)&v9->_Last->value.m_dwTime);
        sub_42C040(a2, a2 + 8 * a3, a4);
        result = (std::vector_CIOTimer *)a3;
        v9->_Last += a3;
      }
    }
    else
    {
      sub_42BD70(a2, (int)&this->_Last->value.m_dwTime, (void *)(a2 + 8 * a3));
      sub_42BDB0(v9->_Last, a3 - (((signed int)v9->_Last - a2) >> 3), a4);
      sub_42C040(a2, (int)&v9->_Last->value.m_dwTime, a4);
      result = v9;
      v9->_Last += a3;
    }
  }
  else
  {
    if ( a3 >= std::vector_CIOTimer::size(this) )
      v8 = a3;
    else
      v8 = std::vector_CIOTimer::size(v9);
    v4 = v8 + std::vector_CIOTimer::size(v9);
    v5 = sub_42BDF0(v4, 0);
    v6 = sub_42BD70((int)&v9->_First->value.m_dwTime, a2, v5);
    sub_42BDB0(v6, a3, a4);
    sub_42BD70(a2, (int)&v9->_Last->value.m_dwTime, (char *)v6 + 8 * a3);
    std::vector_CIOTimer::_Destroy(v9->_First, v9->_Last);
    std::vector_CIOTimer::allocator_deallocate(v9->_First, (v9->_End - v9->_First) >> 3);
    v9->_End = (char *)v5 + 8 * v4;
    v9->_Last = (std::vector_CIOTimer::iterator *)((char *)v5 + 8 * std::vector_CIOTimer::size(v9) + 8 * a3);
    result = v9;
    v9->_First = (std::vector_CIOTimer::iterator *)v5;
  }
  return result;
}

//----- (0042BC30) --------------------------------------------------------
void *__stdcall sub_42BC30(int a1, int a2, void *a3)
{
  while ( a1 != a2 )
  {
    sub_42BE10(a3, a1);
    a3 = (char *)a3 + 4;
    a1 += 4;
  }
  return a3;
}

//----- (0042BC70) --------------------------------------------------------
int __stdcall sub_42BC70(void *a1, int a2, int a3)
{
  int result; // eax@2

  while ( a2 )
  {
    sub_42BE10(a1, a3);
    result = a2-- - 1;
    a1 = (char *)a1 + 4;
  }
  return result;
}

//----- (0042BCB0) --------------------------------------------------------
void *__stdcall sub_42BCB0(int a1, int a2)
{
  return sub_42C0B0(a1);
}

//----- (0042BCD0) --------------------------------------------------------
void *__stdcall sub_42BCD0(int a1, int a2, void *a3)
{
  while ( a1 != a2 )
  {
    sub_42BE30(a3, a1);
    a3 = (char *)a3 + 4;
    a1 += 4;
  }
  return a3;
}

//----- (0042BD10) --------------------------------------------------------
int __stdcall sub_42BD10(void *a1, int a2, int a3)
{
  int result; // eax@2

  while ( a2 )
  {
    sub_42BE30(a1, a3);
    result = a2-- - 1;
    a1 = (char *)a1 + 4;
  }
  return result;
}

//----- (0042BD50) --------------------------------------------------------
void *__stdcall sub_42BD50(int a1, int a2)
{
  return sub_42C0E0(a1);
}

//----- (0042BD70) --------------------------------------------------------
void *__stdcall sub_42BD70(int a1, int a2, void *a3)
{
  while ( a1 != a2 )
  {
    sub_42BE50(a3, a1);
    a3 = (char *)a3 + 8;
    a1 += 8;
  }
  return a3;
}

//----- (0042BDB0) --------------------------------------------------------
int __stdcall sub_42BDB0(void *a1, int a2, int a3)
{
  int result; // eax@2

  while ( a2 )
  {
    sub_42BE50(a1, a3);
    result = a2-- - 1;
    a1 = (char *)a1 + 8;
  }
  return result;
}

//----- (0042BDF0) --------------------------------------------------------
void *__stdcall sub_42BDF0(int a1, int a2)
{
  return sub_42C110(a1);
}

//----- (0042BE10) --------------------------------------------------------
_DWORD *__stdcall sub_42BE10(void *a1, int a2)
{
  return sub_42C140(a1, a2);
}

//----- (0042BE30) --------------------------------------------------------
_DWORD *__stdcall sub_42BE30(void *a1, int a2)
{
  return sub_42C180(a1, a2);
}

//----- (0042BE50) --------------------------------------------------------
_DWORD *__stdcall sub_42BE50(void *a1, int a2)
{
  return sub_42C1C0(a1, a2);
}

//----- (0042BE70) --------------------------------------------------------
std::vector_MemoryObject::iterator *__cdecl sub_42BE70(std::vector_MemoryObject::iterator *a1, std::vector_MemoryObject::iterator *a2, std::vector_MemoryObject::iterator *a3)
{
  while ( a1 != a2 )
  {
    a3->value = a1->value;
    ++a3;
    ++a1;
  }
  return a3;
}

//----- (0042BEA0) --------------------------------------------------------
std::vector_CIOTimer::iterator *__cdecl std::push_heap(std::vector_CIOTimer::iterator *_First, std::vector_CIOTimer::iterator *_Last)
{
  sub_42C210();
  sub_42C200();
  return std::_Push_heap_0(_First, _Last);
}

//----- (0042BEE0) --------------------------------------------------------
std::vector_CIOTimer::iterator *__cdecl std::pop_heap(int a1, int a2)
{
  sub_42C210();
  return sub_42C270(a1, a2);
}

//----- (0042BF10) --------------------------------------------------------
std::vector_CIOTimer::iterator *__cdecl sub_42BF10(std::vector_CIOTimer::iterator *a1, std::vector_CIOTimer::iterator *a2, std::vector_CIOTimer::iterator *a3)
{
  MemoryObject *v3; // edx@2

  while ( a1 != a2 )
  {
    v3 = a1->value.m_pObject;
    a3->value.m_dwTime = a1->value.m_dwTime;
    a3->value.m_pObject = v3;
    ++a3;
    ++a1;
  }
  return a3;
}

//----- (0042BF50) --------------------------------------------------------
void sub_42BF50()
{
  ;
}

//----- (0042BF60) --------------------------------------------------------
_DWORD *__cdecl sub_42BF60(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result; // eax@2

  while ( a1 != a2 )
  {
    *a1 = *a3;
    result = a1 + 1;
    ++a1;
  }
  return result;
}

//----- (0042BF90) --------------------------------------------------------
_DWORD *__cdecl sub_42BF90(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  while ( a1 != a2 )
  {
    --a2;
    --a3;
    *a3 = *a2;
  }
  return a3;
}

//----- (0042BFC0) --------------------------------------------------------
void sub_42BFC0()
{
  ;
}

//----- (0042BFD0) --------------------------------------------------------
_DWORD *__cdecl sub_42BFD0(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result; // eax@2

  while ( a1 != a2 )
  {
    *a1 = *a3;
    result = a1 + 1;
    ++a1;
  }
  return result;
}

//----- (0042C000) --------------------------------------------------------
_DWORD *__cdecl sub_42C000(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  while ( a1 != a2 )
  {
    --a2;
    --a3;
    *a3 = *a2;
  }
  return a3;
}

//----- (0042C030) --------------------------------------------------------
void sub_42C030()
{
  ;
}

//----- (0042C040) --------------------------------------------------------
int __cdecl sub_42C040(int a1, int a2, int a3)
{
  int result; // eax@2
  int v4; // ecx@2

  while ( a1 != a2 )
  {
    v4 = *(_DWORD *)(a3 + 4);
    *(_DWORD *)a1 = *(_DWORD *)a3;
    *(_DWORD *)(a1 + 4) = v4;
    result = a1 + 8;
    a1 += 8;
  }
  return result;
}

//----- (0042C070) --------------------------------------------------------
int __cdecl sub_42C070(int a1, int a2, int a3)
{
  int v3; // ecx@2

  while ( a1 != a2 )
  {
    a2 -= 8;
    v3 = *(_DWORD *)(a2 + 4);
    a3 -= 8;
    *(_DWORD *)a3 = *(_DWORD *)a2;
    *(_DWORD *)(a3 + 4) = v3;
  }
  return a3;
}

//----- (0042C0B0) --------------------------------------------------------
void *__cdecl sub_42C0B0(int a1)
{
  if ( a1 < 0 )
    a1 = 0;
  return malloc(4 * a1);
}

//----- (0042C0E0) --------------------------------------------------------
void *__cdecl sub_42C0E0(int a1)
{
  if ( a1 < 0 )
    a1 = 0;
  return malloc(4 * a1);
}

//----- (0042C110) --------------------------------------------------------
void *__cdecl sub_42C110(int a1)
{
  if ( a1 < 0 )
    a1 = 0;
  return malloc(8 * a1);
}

//----- (0042C140) --------------------------------------------------------
_DWORD *__cdecl sub_42C140(void *a1, int a2)
{
  _DWORD *result; // eax@1
  _DWORD *v3; // [sp+4h] [bp-4h]@1

  result = operator new(4u, a1);
  v3 = result;
  if ( result )
  {
    result = *(_DWORD **)a2;
    *v3 = *(_DWORD *)a2;
  }
  return result;
}

//----- (0042C180) --------------------------------------------------------
_DWORD *__cdecl sub_42C180(void *a1, int a2)
{
  _DWORD *result; // eax@1
  _DWORD *v3; // [sp+4h] [bp-4h]@1

  result = operator new(4u, a1);
  v3 = result;
  if ( result )
  {
    result = *(_DWORD **)a2;
    *v3 = *(_DWORD *)a2;
  }
  return result;
}

//----- (0042C1C0) --------------------------------------------------------
_DWORD *__cdecl sub_42C1C0(void *a1, int a2)
{
  _DWORD *result; // eax@1
  _DWORD *v3; // [sp+4h] [bp-4h]@1

  result = operator new(8u, a1);
  v3 = result;
  if ( result )
  {
    result = *(_DWORD **)(a2 + 4);
    *v3 = *(_DWORD *)a2;
    v3[1] = result;
  }
  return result;
}

//----- (0042C200) --------------------------------------------------------
int sub_42C200()
{
  return 0;
}

//----- (0042C210) --------------------------------------------------------
int sub_42C210()
{
  return 0;
}

//----- (0042C220) --------------------------------------------------------
std::vector_CIOTimer::iterator *__cdecl std::_Push_heap_0(std::vector_CIOTimer::iterator *_First, std::vector_CIOTimer::iterator *_Last)
{
  return std::_Push_heap(_First, _Last - _First - 1, 0, _Last[-1].value.m_dwTime, (int)_Last[-1].value.m_pObject);
}

//----- (0042C270) --------------------------------------------------------
std::vector_CIOTimer::iterator *__cdecl sub_42C270(int a1, int a2)
{
  sub_42C200();
  return sub_42C350(a1, a2 - 8, a2 - 8, *(_DWORD *)(a2 - 8), *(_DWORD *)(a2 - 8 + 4));
}

//----- (0042C2C0) --------------------------------------------------------
std::vector_CIOTimer::iterator *__cdecl std::_Push_heap(std::vector_CIOTimer::iterator *_First, int _Hole, int _Top, int _Val, int _Pred)
{
  MemoryObject *v5; // edx@4
  std::vector_CIOTimer::iterator *result; // eax@5
  int i; // [sp+4h] [bp-4h]@1

  for ( i = (_Hole - 1) / 2; _Top < _Hole && sub_42C390(&_First[i], &_Val); i = (i - 1) / 2 )
  {
    v5 = _First[i].value.m_pObject;
    _First[_Hole].value.m_dwTime = _First[i].value.m_dwTime;
    _First[_Hole].value.m_pObject = v5;
    _Hole = i;
  }
  result = _First;
  _First[_Hole].value.m_dwTime = _Val;
  _First[_Hole].value.m_pObject = (MemoryObject *)_Pred;
  return result;
}

//----- (0042C350) --------------------------------------------------------
std::vector_CIOTimer::iterator *__cdecl sub_42C350(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // edx@1

  v5 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a3 = *(_DWORD *)a1;
  *(_DWORD *)(a3 + 4) = v5;
  return sub_42C3B0(a1, 0, (a2 - a1) >> 3, a4, a5);
}

//----- (0042C390) --------------------------------------------------------
bool __stdcall sub_42C390(std::vector_CIOTimer::iterator *a1, _DWORD *a2)
{
  return CIOTimer::operator_less(&a1->value, (CIOTimer *)a2);
}

//----- (0042C3B0) --------------------------------------------------------
std::vector_CIOTimer::iterator *__cdecl sub_42C3B0(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // ecx@5
  int v6; // edx@7
  int i; // [sp+4h] [bp-8h]@1
  int v9; // [sp+8h] [bp-4h]@1

  v9 = a2;
  for ( i = 2 * a2 + 2; i < a3; i = 2 * i + 2 )
  {
    if ( sub_42C390((std::vector_CIOTimer::iterator *)(a1 + 8 * i), (_DWORD *)(a1 + 8 * i - 8)) )
      --i;
    v5 = *(_DWORD *)(a1 + 8 * i + 4);
    *(_DWORD *)(a1 + 8 * a2) = *(_DWORD *)(a1 + 8 * i);
    *(_DWORD *)(a1 + 8 * a2 + 4) = v5;
    a2 = i;
  }
  if ( i == a3 )
  {
    v6 = *(_DWORD *)(a1 + 8 * i - 4);
    *(_DWORD *)(a1 + 8 * a2) = *(_DWORD *)(a1 + 8 * i - 8);
    *(_DWORD *)(a1 + 8 * a2 + 4) = v6;
    a2 = i - 1;
  }
  return std::_Push_heap((std::vector_CIOTimer::iterator *)a1, a2, v9, a4, a5);
}

//----- (0042C480) --------------------------------------------------------
CIOTimer *__thiscall CIOTimer::CIOTimer(CIOTimer *this, MemoryObject *timerInstance, unsigned int delay)
{
  this->m_dwTime = delay;
  this->m_pObject = timerInstance;
  return this;
}

//----- (0042C4B0) --------------------------------------------------------
bool __thiscall CIOTimer::operator_less(CIOTimer *this, CIOTimer *other)
{
  return this->m_dwTime - other->m_dwTime > 0;
}

//----- (0042C4D0) --------------------------------------------------------
CIOTimerInstance *__thiscall CIOTimerInstance::CIOTimerInstance(CIOTimerInstance *this)
{
  CIOTimerInstance *this_; // ST00_4@1

  this_ = this;
  MemoryObject::MemoryObject(&this->base);
  this_->base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&CIOTimerInstance_vftable;
  this_->base.m_nRefCount = 1;
  return this_;
}
// 45F82C: using guessed type int (__stdcall *CIOTimerInstance_vftable)(int);

//----- (0042C500) --------------------------------------------------------
void CIOTimerInstance::OnWaitCallback()
{
  ;
}

//----- (0042C510) --------------------------------------------------------
void __stdcall CIOTimerInstance::vfunc7(CIOTimerInstance *this_, int a2, int a3)
{
  ;
}

//----- (0042C520) --------------------------------------------------------
CIOTimerInstance *__thiscall CIOTimerInstance::DeletingDestructor(CIOTimerInstance *this, char a2)
{
  CIOTimerInstance *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  CIOTimerInstance::Destructor(this);
  if ( a2 & 1 )
    operator_delete(v3);
  return v3;
}

//----- (0042C550) --------------------------------------------------------
MemoryObject *__thiscall CIOTimerInstance::Destructor(CIOTimerInstance *this)
{
  this->base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&CIOTimerInstance_vftable;
  return MemoryObject::Destructor(&this->base);
}
// 45F82C: using guessed type int (__stdcall *CIOTimerInstance_vftable)(int);

//----- (0042C570) --------------------------------------------------------
LRESULT __stdcall wndProc(HWND hWndParent, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  int serverNumber; // eax@32
  ServerInfo *serverInfo; // eax@34
  ServerInfo serverInfo_; // [sp+18h] [bp-8Ch]@34
  int param2; // [sp+70h] [bp-34h]@40
  WPARAM v9; // [sp+74h] [bp-30h]@40
  int v10; // [sp+78h] [bp-2Ch]@38
  int v11; // [sp+7Ch] [bp-28h]@38
  int serverId; // [sp+80h] [bp-24h]@31
  int nWidth; // [sp+84h] [bp-20h]@11
  unsigned int v14; // [sp+88h] [bp-1Ch]@11
  CPPEH_RECORD ms_exc; // [sp+8Ch] [bp-18h]@1

  ms_exc.registration.TryLevel = 0;
  if ( Msg > 0x10 )
  {
    if ( Msg == 0x111 )
    {
      v9 = wParam >> 16;
      param2 = (unsigned __int16)wParam;
      if ( !(wParam >> 16) && param2 != 1 && param2 == 2 )
      {
        ServerList::reload(&g_ServerList);
        ServerTable::reloadServerKindList(&g_serverTable);
      }
    }
    else if ( Msg == 0x113 )
    {
      switch ( wParam )
      {
        case WinParam_UpdateUserNumber:
          g_StatusLine.users = UserManager::getUsersNumber(&g_userManager);
          InvalidateRect(statusLineWindow, 0, 0);
          break;
        case WinParam_UpdateServerStatus:
          for ( serverId = 1; ; ++serverId )
          {
            serverNumber = ServerList::getServerCount(&g_ServerList);
            if ( serverId > serverNumber )
              break;
            if ( ServersProvider::isServerOn(serverId) )
            {
              serverInfo = ServerList::getServerInfo(&g_ServerList, &serverInfo_, serverId);
              WorldSrvServer::sendToWorldServer(serverInfo->ipAddress, aC_1, 2);// ping
            }
          }
          break;
        case WinParam_UpdateDisckFreeSpace:
          v10 = 400000000;
          v11 = 0;
          Utils::checkDiskFreeSpace(g_Config.logDirectory, 400000000, 0);
          break;
      }
    }
  }
  else
  {
    switch ( Msg )
    {
      case 0x10u:
        if ( hWndParent == hWnd )
        {
          someDialog = CreateDialogParamA(hInstance, (LPCSTR)0x68, hWndParent, wndProc::DialogFunc, 0);
          ShowWindow(someDialog, 5);
          ms_exc.registration.TryLevel = -1;
          return 0;
        }
        break;
      case 2u:
        if ( hWndParent == hWnd )
        {
          g_bTerminating = 1;
          LogWindow::InvalidateWindow(&g_LogWindow, 0);
          TimerQueue::terminate(&g_timerQueue);
          Sleep(2000u);
          PostQuitMessage(0);
        }
        break;
      case 5u:
        if ( hWndParent == hWnd )
        {
          nWidth = (unsigned __int16)lParam;
          v14 = (unsigned int)lParam >> 16;
          MoveWindow(statusLineWindow, 160, 0, (unsigned __int16)lParam - 160, 20, 1);
          MoveWindow(g_logHwnd, 0, 20, (unsigned __int16)lParam, ((unsigned int)lParam >> 16) - 20, 1);
          MoveWindow(resetBtn, 0, 0, 80, 20, 1);
          MoveWindow(reloadBtn, 80, 0, 80, 20, 1);
        }
        else if ( hWndParent == g_logHwnd )
        {
          LogWindow::Move(&g_LogWindow, (unsigned __int16)lParam, (unsigned int)lParam >> 16);
        }
        else
        {
          hWndParent = statusLineWindow;
          if ( statusLineWindow )
            StatusLine::Move(&g_StatusLine, (unsigned __int16)lParam, (unsigned int)lParam >> 16);
        }
        break;
      case 0xFu:
        if ( hWndParent == g_logHwnd )
        {
          LogWindow::Update(&g_LogWindow);
        }
        else if ( hWndParent == statusLineWindow )
        {
          StatusLine::Update(&g_StatusLine);
        }
        break;
    }
  }
  ms_exc.registration.TryLevel = -1;
  return DefWindowProcA(hWndParent, Msg, wParam, lParam);
}
// 4816F0: using guessed type char g_bTerminating;

//----- (0042C965) --------------------------------------------------------
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  int result; // eax@5
  HANDLE v5; // eax@6
  CWantedSocket *socketWanted; // [sp+0h] [bp-730h]@44
  IPSocket *ipSocket; // [sp+4h] [bp-72Ch]@37
  CWantedSocket *v8; // [sp+Ch] [bp-724h]@43
  IPSocket *v9; // [sp+14h] [bp-71Ch]@36
  int wantedSockHandler; // [sp+1Ch] [bp-714h]@43
  sockaddr_in wantedName; // [sp+20h] [bp-710h]@43
  SOCKET wantedSocket; // [sp+30h] [bp-700h]@43
  int result_1; // [sp+34h] [bp-6FCh]@36
  sockaddr_in ipSocketName; // [sp+38h] [bp-6F8h]@36
  SOCKET socket; // [sp+48h] [bp-6E8h]@36
  SOCKET socket_1; // [sp+4Ch] [bp-6E4h]@32
  int result_2; // [sp+50h] [bp-6E0h]@32
  sockaddr_in name; // [sp+54h] [bp-6DCh]@32
  SqlQuery sqlQuery; // [sp+64h] [bp-6CCh]@31
  char DesKey; // [sp+78h] [bp-6B8h]@8
  char mainWindowTitle[200]; // [sp+478h] [bp-2B8h]@6
  struct tagMSG Msg; // [sp+540h] [bp-1F0h]@50
  ATOM className; // [sp+55Ch] [bp-1D4h]@4
  HANDLE hObject; // [sp+560h] [bp-1D0h]@9
  DWORD ThreadId; // [sp+564h] [bp-1CCh]@49
  HWND mainWndHandler; // [sp+568h] [bp-1C8h]@1
  struct WSAData WSAData; // [sp+56Ch] [bp-1C4h]@4
  WNDCLASSEXA wndClass; // [sp+6FCh] [bp-34h]@4
  int wsaStartupResult; // [sp+72Ch] [bp-4h]@4

  mainWndHandler = FindWindowA(0, WindowName);
  if ( mainWndHandler )
  {
    MessageBoxA(0, Text, (LPCSTR)Caption, 16u);
    exit(0);
  }
  Blowfish::Initialize(g_C1_BF_Key, 21);
  DesFrontEnd2::initDesKey(&g_PwdCrypt, aNewCryptKey);
  wndClass.cbSize = 48;
  wndClass.style = 64;
  wndClass.lpfnWndProc = wndProc;
  wndClass.cbClsExtra = 0;
  wndClass.cbWndExtra = 0;
  wndClass.hInstance = hInstance;
  wndClass.hIcon = 0;
  wndClass.hCursor = LoadCursorA(0, (LPCSTR)0x7F00);
  wndClass.hbrBackground = 0;
  wndClass.lpszMenuName = 0;
  wndClass.lpszClassName = aAuthserver_0;
  wndClass.hIconSm = 0;
  className = RegisterClassExA(&wndClass);
  ::hInstance = hInstance;
  ExceptionHandler::sendLastCrashReport();
  wsaStartupResult = WSAStartup(514u, &WSAData);
  if ( wsaStartupResult )
  {
    LogWindow::Add(&g_LogWindow, 3, aWsastartupErro, wsaStartupResult);
    result = 0;
  }
  else
  {
    sprintf(mainWindowTitle, aAuthserverD, g_buildNumber);
    hWnd = CreateWindowExA(
             0,
             (LPCSTR)className,
             mainWindowTitle,
             0xCF0000u,
             0x80000000,
             0,
             600,
             440,
             0,
             0,
             hInstance,
             0);
    g_logHwnd = CreateWindowExA(
                  0x200u,
                  (LPCSTR)className,
                  byte_47F8BC,
                  0x40000000u,
                  0,
                  30,
                  640,
                  720,
                  hWnd,
                  0,
                  hInstance,
                  0);
    statusLineWindow = CreateWindowExA(
                         0x200u,
                         (LPCSTR)className,
                         byte_47F8C0,
                         0x40000000u,
                         0,
                         0,
                         640,
                         30,
                         hWnd,
                         0,
                         hInstance,
                         0);
    resetBtn = CreateWindowExA(0, ClassName, aReset, 0x40000000u, 600, 0, 40, 30, hWnd, (HMENU)1, hInstance, 0);
    reloadBtn = CreateWindowExA(0, aButton_0, aReload, 0x40000000u, 600, 0, 40, 30, hWnd, (HMENU)2, hInstance, 0);
    LogWindow::SetWindow(&g_LogWindow, g_logHwnd);
    StatusLine::SetWindow(&g_StatusLine, statusLineWindow);
    v5 = GetCurrentProcess();
    SetProcessPriorityBoost(v5, 1);
    ShowWindow(hWnd, nShowCmd);
    UpdateWindow(hWnd);
    ShowWindow(g_logHwnd, 5);
    UpdateWindow(g_logHwnd);
    ShowWindow(statusLineWindow, 5);
    UpdateWindow(statusLineWindow);
    ShowWindow(resetBtn, 5);
    UpdateWindow(resetBtn);
    ShowWindow(reloadBtn, 5);
    UpdateWindow(reloadBtn);
    Config::Load(&g_Config, configFileName);
    if ( g_Config.DesKey )
    {
      memset(&DesKey, 0, 0x400u);
      strcpy(&DesKey, g_Config.DesKey);
      DesFrontEnd::initDesKey(&DesKey);
    }
    else
    {
      DesFrontEnd::initDesKey(stringKey);
    }
    hObject = 0;
    if ( strlen(g_Config.logDirectory) )
    {
      LogWindow::init(&g_LogWindow, g_Config.logDirectory);
      LogWindow::InvalidateWindow(&g_LogWindow, 1);
      FileLog::Init(&g_userLog, g_Config.logDirectory);
      FileLog::Init(&g_actLog, g_Config.logDirectory);
      FileLog::Init(&g_errLog, g_Config.logDirectory);
      GeneralLog::Init(&g_genLog, g_Config.logDirectory);
      SetTimer(hWnd, WinParam_UpdateUserNumber, 2000u, 0);
      SetTimer(hWnd, WinParam_UpdateServerStatus, 60000u, 0);
      switch ( g_Config.GameID )
      {
        case 4:
          UserInfoTable::pwdHash = Hash::hash_unusual;
          break;
        case 8:
        case 0x10:
        case 0x20:
          UserInfoTable::pwdHash = Hash::hash;
          break;
        default:
          UserInfoTable::pwdHash = (int (__cdecl *)(char *))Hash::hash_empty_stub;
          break;
      }
      LogWindow::Add(&g_LogWindow, 0, "Loading AuthExt.dll");
      LoadLibraryA("AuthExt.dll");
      LogWindow::Add(&g_LogWindow, 2, aLoadedConfig);
      LogWindow::Add(&g_LogWindow, 0, aBuildnumberD, g_buildNumber);
      if ( !g_Config.AcceptCallNum )
      {
        LogWindow::Add(&g_LogWindow, 3, aAcceptcallnull0SUM);
        g_Config.AcceptCallNum = 1;
      }
      if ( !g_Config.SocketTimeOut )
      {
        LogWindow::Add(&g_LogWindow, 3, aSockettimeout0SConnection);
        g_Config.SocketTimeOut = 180;
      }
      if ( !g_Config.WaitingUserLimit )
      {
        LogWindow::Add(&g_LogWindow, 3, aWaitinguserlimit);
        g_Config.WaitingUserLimit = 100;
      }
      if ( g_Config.Useforbiddenip )
      {
        if ( g_Config.CountryCode )
          LogWindow::Add(&g_LogWindow, 0, aLoadForbiddenIpList);
        else
          LogWindow::Add(&g_LogWindow, 0, byte_46C924);
        IPList::load(&g_blockedIPs, a2);
      }
      if ( g_Config.Mailserver && strlen(g_Config.Mailserver) )
      {
        if ( MailServer::Init(&g_mailServer) )
          SetTimer(hWnd, WinParam_UpdateDisckFreeSpace, 7200000u, 0);
        else
          LogWindow::Add(&g_LogWindow, 3, aSendmailInitia);
      }
      Database::init(&g_dbManager, g_Config.DBConnectionNum);
      ServerList::reload(&g_ServerList);
      SqlQuery::SqlQuery(&sqlQuery, &g_dbManager);
      SqlQuery::exec(&sqlQuery, aUpdateWorlds_3);
      SqlQuery::Destructor(&sqlQuery);
      Threading::prepareThreads();
      if ( LOBYTE(g_Config.UseLogD) )
      {
        socket_1 = ::socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
        name.sin_family = AF_INET;
        name.sin_addr.S_un.S_addr = g_Config.logdip;
        name.sin_port = htons(g_Config.logdport);
        result_2 = connect(socket_1, (const struct sockaddr *)&name, 16);
        g_LogDSocket = CLogSocket::Create(socket_1);
        CLogSocket::setIPAddress(g_LogDSocket, g_Config.logdip);
        if ( result_2 == SOCKET_ERROR )
          CIOSocket::Close(&g_LogDSocket->base);
        else
          CIOSocket::Initialize(&g_LogDSocket->base, Threading::g_hCompletionPortExtra);
      }
      if ( g_Config.Useipserver )
      {
        socket = ::socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
        ipSocketName.sin_family = AF_INET;
        ipSocketName.sin_addr.S_un.S_addr = g_Config.IpServer;
        ipSocketName.sin_port = htons(g_Config.IpPort);
        result_1 = connect(socket, (const struct sockaddr *)&ipSocketName, 16);
        v9 = (IPSocket *)operator_new(0x88u);
        if ( v9 )
          ipSocket = IPSocket::IPSocket(v9, socket);
        else
          ipSocket = 0;
        g_IPSocket = ipSocket;
        IPSocket::setIPAddress(ipSocket, g_Config.IpServer);
        if ( result_1 == SOCKET_ERROR )
          CIOSocket::Close(&g_IPSocket->base);
        else
          CIOSocket::Initialize(&g_IPSocket->base, Threading::g_hCompletionPort);
      }
      if ( LOBYTE(g_Config.UseWantedSystem) )
      {
        wantedSocket = ::socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
        wantedName.sin_family = AF_INET;
        wantedName.sin_addr.S_un.S_addr = g_Config.WantedIP;
        wantedName.sin_port = htons(g_Config.WantedPort);
        wantedSockHandler = connect(wantedSocket, (const struct sockaddr *)&wantedName, 16);
        v8 = (CWantedSocket *)operator_new(0x80u);
        if ( v8 )
          socketWanted = CWantedSocket::CWantedSocket(v8, wantedSocket);
        else
          socketWanted = 0;
        g_SocketWanted = socketWanted;
        CWantedSocket::setIPAddress(socketWanted, (in_addr)g_Config.WantedIP);
        if ( wantedSockHandler == SOCKET_ERROR )
          CIOSocket::Close(&g_SocketWanted->base);
        else
          CIOSocket::Initialize(&g_SocketWanted->base, Threading::g_hCompletionPortExtra);
      }
      hObject = (HANDLE)_beginthreadex(NULL, 0, (int)Threading::startServersLoop, 0, 0, &ThreadId);
      ServerTable::loadServerKindList(&g_serverTable);
    }
    else
    {
      LogWindow::init(&g_LogWindow, fileName);
      LogWindow::InvalidateWindow(&g_LogWindow, 1);
      FileLog::Init(&g_userLog, g_Config.logDirectory);
      FileLog::Init(&g_actLog, g_Config.logDirectory);
      GeneralLog::Init(&g_genLog, g_Config.logDirectory);
      LogWindow::Add(&g_LogWindow, 3, aErrorLoadConfi);
      GeneralLog::Init(&g_genLog, g_Config.logDirectory);
    }
    while ( GetMessageA(&Msg, 0, 0, 0) )
    {
      TranslateMessage(&Msg);
      DispatchMessageA(&Msg);
    }
    if ( hObject )
      CloseHandle(hObject);
    while ( !Threading::s_threadsClosed )
      Sleep(1000u);
    Sleep(2000u);
    WSACleanup();
    result = 0;
  }
  return result;
}
// 43A2F1: using guessed type int __stdcall Threading::startServersLoop(int);
// 47F8B8: using guessed type char Threading::s_threadsClosed;

//----- (0042D361) --------------------------------------------------------
BOOL __stdcall wndProc::DialogFunc(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4)
{
  if ( a2 == 273 )
  {
    if ( a3 == 1 )
    {
      DestroyWindow(hWnd);
      EndDialog(hDlg, 0);
    }
    else if ( a3 == 2 )
    {
      EndDialog(hDlg, 0);
    }
  }
  return 0;
}

//----- (0042D3B1) --------------------------------------------------------
int SomeStaticInit44()
{
  SomeBitsInit();
  return sub_42D3C0();
}

//----- (0042D3C0) --------------------------------------------------------
int sub_42D3C0()
{
  return atexit(emptystub);
}

//----- (0042D3E0) --------------------------------------------------------
CLogSocket *__thiscall CLogSocket::setIPAddress(CLogSocket *this, int ipAddress)
{
  CLogSocket *result; // eax@1

  result = this;
  this->m_logdServIp.S_un.S_addr = ipAddress;
  return result;
}

//----- (0042D400) --------------------------------------------------------
CWantedSocket *__thiscall CWantedSocket::setIPAddress(CWantedSocket *this, in_addr ipAddress)
{
  CWantedSocket *result; // eax@1

  result = this;
  this->m_ipAddress = ipAddress;
  return result;
}

//----- (0042D420) --------------------------------------------------------
SpinLock *__thiscall SpinLock::SpinLock(SpinLock *this, LockType lockType, DWORD dwSpinCount)
{
  SpinLock *lpCriticalSection; // [sp+0h] [bp-4h]@1

  lpCriticalSection = this;
  this->syncType = lockType;
  if ( lockType == LockType_WaitLock )
  {
    this->lock = 0;
  }
  else if ( lockType == LockType_Spin )
  {
    InitializeCriticalSectionAndSpinCount(&this->criticalSection, dwSpinCount);
  }
  else
  {
    InitializeCriticalSection(&this->criticalSection);
  }
  return lpCriticalSection;
}

//----- (0042D46B) --------------------------------------------------------
void __thiscall SpinLock::Destructor(SpinLock *this)
{
  if ( this->syncType != LockType_WaitLock )
    DeleteCriticalSection(&this->criticalSection);
}

//----- (0042D4B5) --------------------------------------------------------
void __thiscall SpinLock::Enter(SpinLock *this)
{
  SpinLock *lpCriticalSection; // [sp+0h] [bp-4h]@1

  lpCriticalSection = this;
  if ( this->syncType == LockType_WaitLock )
  {
    if ( InterlockedExchange(&this->lock, 1) )
      SpinLock::Wait(lpCriticalSection);
  }
  else
  {
    EnterCriticalSection(&this->criticalSection);
  }
}

//----- (0042D4F0) --------------------------------------------------------
void __thiscall SpinLock::Leave(SpinLock *this)
{
  if ( this->syncType == LockType_WaitLock )
    InterlockedExchange(&this->lock, 0);
  else
    LeaveCriticalSection(&this->criticalSection);
}

//----- (0042D51F) --------------------------------------------------------
void __thiscall SpinLock::Wait(SpinLock *this)
{
  SpinLock *v1; // [sp+Ch] [bp-8h]@1
  signed int count; // [sp+10h] [bp-4h]@2
  signed int counta; // [sp+10h] [bp-4h]@6

  v1 = this;
  if ( this->syncType == LockType_WaitLock )
  {
    count = 4000;
    while ( --count >= 0 )
    {
      if ( !InterlockedExchange(&v1->lock, 1) )
        return;
      _mm_pause();
    }
    counta = 4000;
    while ( --counta >= 0 )
    {
      SwitchToThread();
      if ( !InterlockedExchange(&v1->lock, 1) )
        return;
    }
    do
      Sleep(1000u);
    while ( InterlockedExchange(&v1->lock, 1) );
  }
}

//----- (0042D5C4) --------------------------------------------------------
ReadWriteLock *__thiscall ReadWriteLock::ReadWriteLock(ReadWriteLock *this)
{
  ReadWriteLock *lpCriticalSection; // ST10_4@1

  lpCriticalSection = this;
  this->readersCount = 0;
  this->semaphore = CreateSemaphoreA(0, 1, 1, 0);
  InitializeCriticalSection(&lpCriticalSection->critSection);
  return lpCriticalSection;
}

//----- (0042D5FA) --------------------------------------------------------
void __thiscall ReadWriteLock::Destructor(ReadWriteLock *this)
{
  ReadWriteLock *lpCriticalSection; // ST04_4@1

  lpCriticalSection = this;
  CloseHandle(this->semaphore);
  DeleteCriticalSection(&lpCriticalSection->critSection);
}

//----- (0042D61C) --------------------------------------------------------
void __fastcall ReadWriteLock::readLock(ReadWriteLock *this)
{
  ReadWriteLock *this_; // [sp+0h] [bp-4h]@1

  this_ = this;
  EnterCriticalSection(&this->critSection);
  if ( ++this_->readersCount == 1 && WaitForSingleObject(this_->semaphore, 0xFFFFFFFF) )
    LogWindow::Add(&g_LogWindow, 3, aReadlockFailed);
  LeaveCriticalSection(&this_->critSection);
}

//----- (0042D67A) --------------------------------------------------------
void __thiscall ReadWriteLock::releaseReadLock(ReadWriteLock *this)
{
  ReadWriteLock *lpCriticalSection; // [sp+0h] [bp-8h]@1
  __int32 PreviousCount; // [sp+4h] [bp-4h]@2

  lpCriticalSection = this;
  EnterCriticalSection(&this->critSection);
  if ( !--lpCriticalSection->readersCount )
    ReleaseSemaphore(lpCriticalSection->semaphore, 1, &PreviousCount);
  LeaveCriticalSection(&lpCriticalSection->critSection);
}

//----- (0042D6C6) --------------------------------------------------------
DWORD __thiscall ReadWriteLock::writeLock(ReadWriteLock *this)
{
  return WaitForSingleObject(this->semaphore, 0xFFFFFFFF);
}

//----- (0042D6FF) --------------------------------------------------------
LogWindow *__thiscall ReadWriteLock::releaseWriteLock(ReadWriteLock *this)
{
  LogWindow *result; // eax@1
  __int32 PreviousCount; // [sp+4h] [bp-4h]@1

  result = (LogWindow *)ReleaseSemaphore(this->semaphore, 1, &PreviousCount);
  if ( PreviousCount )
    result = LogWindow::Add(&g_LogWindow, 3, aWriteunlockSem);
  return result;
}

//----- (0042D739) --------------------------------------------------------
int SomeStaticInit45()
{
  SomeBitsInit();
  return sub_42D748();
}

//----- (0042D748) --------------------------------------------------------
int sub_42D748()
{
  return atexit(emptystub);
}

//----- (0042D760) --------------------------------------------------------
int StaticInit_LogWindow()
{
  CallLogWindowCtor();
  return RegisterDtorForLogWindow();
}

//----- (0042D76F) --------------------------------------------------------
LogWindow *CallLogWindowCtor()
{
  return LogWindow::LogWindow(&g_LogWindow, 128, aWinlog);
}

//----- (0042D788) --------------------------------------------------------
int RegisterDtorForLogWindow()
{
  return atexit(CallLogWindowDtor);
}

//----- (0042D79A) --------------------------------------------------------
void __cdecl CallLogWindowDtor()
{
  LogWindow::Destructor(&g_LogWindow);
}

//----- (0042D7A9) --------------------------------------------------------
int StaticInit_UserLog()
{
  CallUserLogCtor();
  return RegisterDtorForUserLog();
}

//----- (0042D7B8) --------------------------------------------------------
FileLog *CallUserLogCtor()
{
  return FileLog::FileLog(&g_userLog, aUse);
}

//----- (0042D7CC) --------------------------------------------------------
int RegisterDtorForUserLog()
{
  return atexit(CallUserLogDtor);
}

//----- (0042D7DE) --------------------------------------------------------
void __cdecl CallUserLogDtor()
{
  FileLog::Destructor(&g_userLog);
}

//----- (0042D7ED) --------------------------------------------------------
int StaticInit_ActLog()
{
  CallActLogCtor();
  return RegisterDtorForActLog();
}

//----- (0042D7FC) --------------------------------------------------------
FileLog *CallActLogCtor()
{
  return FileLog::FileLog(&g_actLog, aAct);
}

//----- (0042D810) --------------------------------------------------------
int RegisterDtorForActLog()
{
  return atexit(sub_42D822);
}

//----- (0042D822) --------------------------------------------------------
void __cdecl sub_42D822()
{
  FileLog::Destructor(&g_actLog);
}

//----- (0042D831) --------------------------------------------------------
int StaticInit_ErrLog()
{
  CallErrLogCtor();
  return RegisterDtorForErrLog();
}

//----- (0042D840) --------------------------------------------------------
FileLog *CallErrLogCtor()
{
  return FileLog::FileLog(&g_errLog, aErr);
}

//----- (0042D854) --------------------------------------------------------
int RegisterDtorForErrLog()
{
  return atexit(CallErrLogDtor);
}

//----- (0042D866) --------------------------------------------------------
void __cdecl CallErrLogDtor()
{
  FileLog::Destructor(&g_errLog);
}

//----- (0042D875) --------------------------------------------------------
int StaticInit_GeneralLog()
{
  CallGeneralLogCtor();
  return RegisterDtorForGeneralLog();
}

//----- (0042D884) --------------------------------------------------------
GeneralLog *CallGeneralLogCtor()
{
  return GeneralLog::GeneralLog(&g_genLog, aLog_0);
}

//----- (0042D898) --------------------------------------------------------
int RegisterDtorForGeneralLog()
{
  return atexit(CallGeneralLogDtor);
}

//----- (0042D8AA) --------------------------------------------------------
void __cdecl CallGeneralLogDtor()
{
  GeneralLog::Destructor(&g_genLog);
}

//----- (0042D8D0) --------------------------------------------------------
void __thiscall LogWindow::Destructor(LogWindow *this)
{
  LogWindow *this_; // [sp+0h] [bp-8h]@1

  this_ = this;
  this->vftable = (int)&LogWindow_vftable_off_45F854;
  _delete_table(this->outputBuffer);
  DeleteCriticalSection(&this_->criticalSection);
  if ( this_->logFile )
    fclose(this_->logFile);
}
// 45F854: using guessed type int (__stdcall *LogWindow_vftable_off_45F854)(int);

//----- (0042D920) --------------------------------------------------------
LogWindow *__thiscall LogWindow::LogWindow(LogWindow *this, int bufferLength, char *extension)
{
  LogWindow *this_; // ST0C_4@1

  this_ = this;
  this->vftable = (int)&LogWindow_vftable_off_45F854;
  this->bufferLength = bufferLength;
  this->outputBuffer = (LogEntry *)operator new(520 * bufferLength);
  memset(this_->outputBuffer, 0, 520 * bufferLength);
  this_->currentLine = 0;
  InitializeCriticalSectionAndSpinCount(&this_->criticalSection, 4000u);
  this_->font = 0;
  this_->hasWindow = 0;
  strcpy(this_->extension, extension);
  return this_;
}
// 45F854: using guessed type int (__stdcall *LogWindow_vftable_off_45F854)(int);

//----- (0042D9D3) --------------------------------------------------------
LogWindow *__thiscall LogWindow::Update(LogWindow *this)
{
  LogWindow *result; // eax@1
  LogWindow *this_; // [sp+0h] [bp-60h]@1
  struct tagPAINTSTRUCT Paint; // [sp+4h] [bp-5Ch]@2
  HDC hdc; // [sp+44h] [bp-1Ch]@2
  int y; // [sp+48h] [bp-18h]@5
  int curLine; // [sp+4Ch] [bp-14h]@5
  RECT rc; // [sp+50h] [bp-10h]@8

  this_ = this;
  result = this;
  if ( this->hasWindow )
  {
    hdc = BeginPaint(this->window, &Paint);
    if ( this_->font )
    {
      SelectObject(hdc, (HGDIOBJ)this_->font);
    }
    else
    {
      this_->font = (int)GetStockObject(16);
      SelectObject(hdc, (HGDIOBJ)this_->font);
      GetClientRect(this_->window, &this_->loginWndRect);
      this_->brush = (int)GetStockObject(0);
      GetTextExtentPoint32A(hdc, sizeString, 1, (LPSIZE)&this_->textSize);
    }
    y = this_->loginWndRect.bottom;
    curLine = this_->currentLine;
    do
    {
      y -= this_->lineHeight;
      curLine = (this_->bufferLength - 1) & (curLine - 1);
      if ( &this_->outputBuffer[curLine] != (LogEntry *)-4 )
      {
        SetTextColor(hdc, color[this_->outputBuffer[curLine].logType]);
        TextOutA(hdc, 0, y, this_->outputBuffer[curLine].log, this_->outputBuffer[curLine].logSize);
      }
      rc.left = this_->textSize * this_->outputBuffer[curLine].logSize;
      rc.right = this_->loginWndRect.right;
      rc.top = y;
      rc.bottom = this_->lineHeight + y;
      FillRect(hdc, &rc, (HBRUSH)this_->brush);
    }
    while ( y >= 0 );
    result = (LogWindow *)EndPaint(this_->window, &Paint);
  }
  return result;
}

//----- (0042DB8D) --------------------------------------------------------
BOOL __thiscall LogWindow::Move(LogWindow *this, int right, int botton)
{
  BOOL result; // eax@1

  this->loginWndRect.right = right;
  result = botton;
  this->loginWndRect.bottom = botton;
  if ( this->hasWindow )
    result = InvalidateRect(this->window, 0, 0);
  return result;
}

//----- (0042DBC9) --------------------------------------------------------
BOOL __thiscall LogWindow::InvalidateWindow(LogWindow *this, char hasWindow)
{
  BOOL result; // eax@1

  this->hasWindow = hasWindow;
  result = this->hasWindow;
  if ( this->hasWindow )
    result = InvalidateRect(this->window, 0, 0);
  return result;
}

//----- (0042DBFC) --------------------------------------------------------
LogWindow *LogWindow::Add(LogWindow *this, int log_type, char *format, ...)
{
  LogWindow *result; // eax@1
  char buffer[256]; // [sp+0h] [bp-510h]@5
  char logString[1020]; // [sp+100h] [bp-410h]@6
  int length; // [sp+500h] [bp-10h]@6
  va_list v7; // [sp+504h] [bp-Ch]@6
  time_t now; // [sp+508h] [bp-8h]@2
  struct tm *time_now; // [sp+50Ch] [bp-4h]@2
  va_list va; // [sp+524h] [bp+14h]@1

  va_start(va, format);
  result = this;
  if ( this->hasWindow )
  {
    now = time(0);
    time_now = localtime(&now);
    if ( (time_now->tm_mday != this->dayOfMonth || time_now->tm_hour != this->hour) && this->logFile )
    {
      fclose(this->logFile);
      sprintf(
        buffer,
        aS04d02d02d_02d,
        this->fileName,
        time_now->tm_year + 1900,
        time_now->tm_mon + 1,
        time_now->tm_mday,
        time_now->tm_hour,
        this->extension);
      this->logFile = fopen(buffer, aA);
      this->dayOfMonth = time_now->tm_mday;
      this->hour = time_now->tm_hour;
    }
    sprintf(
      logString,
      a02d_02d_02d02d,
      time_now->tm_year + 1900,
      time_now->tm_mon + 1,
      time_now->tm_mday,
      time_now->tm_hour,
      time_now->tm_min,
      time_now->tm_sec);
    v7 = va;
    result = (LogWindow *)vsprintf(&logString[20], format, va);
    length = (int)result;
    v7 = 0;
    if ( (signed int)result > 0 )
    {
      length += 20;
      if ( (unsigned int)length > 510 )
        length = 510;                           // 127*sizeof(char*)==510
      EnterCriticalSection(&this->criticalSection);
      this->outputBuffer[this->currentLine].logType = log_type;
      memcpy(this->outputBuffer[this->currentLine].log, logString, length + 1);
      this->outputBuffer[this->currentLine++].logSize = length;
      this->currentLine &= this->bufferLength - 1;
      LeaveCriticalSection(&this->criticalSection);
      if ( this->logFile )
        fprintf(this->logFile, aS_4, logString);
      result = (LogWindow *)this->hasWindow;
      if ( this->hasWindow )
        result = (LogWindow *)InvalidateRect(this->window, 0, 0);
    }
  }
  return result;
}

//----- (0042DE5D) --------------------------------------------------------
struct tm *__thiscall LogWindow::init(LogWindow *this, char *fileName)
{
  LogWindow *this_; // ST20_4@1
  struct tm *result; // eax@1
  time_t time_now; // [sp+4h] [bp-108h]@1
  struct tm *now; // [sp+8h] [bp-104h]@1
  char buffer[256]; // [sp+Ch] [bp-100h]@1

  this_ = this;
  time_now = time(0);
  now = localtime(&time_now);
  strcpy(this_->fileName, fileName);
  sprintf(
    buffer,
    aS04d02d02d_0_0,
    this_->fileName,
    now->tm_year + 1900,
    now->tm_mon + 1,
    now->tm_mday,
    now->tm_hour,
    this_->extension);
  this_->logFile = fopen(buffer, aA_0);
  this_->dayOfMonth = now->tm_mday;
  result = now;
  this_->hour = now->tm_hour;
  return result;
}

//----- (0042DF47) --------------------------------------------------------
FileLog *__thiscall FileLog::FileLog(FileLog *this, char *fileExtension)
{
  FileLog *this_; // ST08_4@1

  this_ = this;
  this->vftable = (int)FileLog_vtable_off_45F858;
  InitializeCriticalSectionAndSpinCount(&this->crit_section, 4000u);
  this_->fileHandler = (HANDLE)-1;
  strcpy(this_->extension, fileExtension);
  return this_;
}
// 45F858: using guessed type int (__cdecl *FileLog_vtable_off_45F858[2])(int, int, char *, char);

//----- (0042DF8F) --------------------------------------------------------
void __thiscall FileLog::Destructor(FileLog *this)
{
  FileLog *this_; // [sp+0h] [bp-4h]@1

  this_ = this;
  this->vftable = (int)FileLog_vtable_off_45F858;
  DeleteCriticalSection(&this->crit_section);
  if ( this_->fileHandler != (HANDLE)-1 )
    CloseHandle(this_->fileHandler);
}
// 45F858: using guessed type int (__cdecl *FileLog_vtable_off_45F858[2])(int, int, char *, char);

//----- (0042DFC6) --------------------------------------------------------
struct tm *__thiscall FileLog::Init(FileLog *this, char *aDirName)
{
  struct tm *result; // eax@3
  FileLog *this_; // [sp+0h] [bp-10Ch]@1
  time_t time_now; // [sp+4h] [bp-108h]@1
  struct tm *now; // [sp+8h] [bp-104h]@1
  char newFileName[256]; // [sp+Ch] [bp-100h]@1

  this_ = this;
  time_now = time(0);
  now = localtime(&time_now);
  strcpy(this_->dirName, aDirName);
  sprintf(
    newFileName,
    g_logFileNameFormat,
    this_->dirName,
    now->tm_year + 1900,
    now->tm_mon + 1,
    now->tm_mday,
    now->tm_hour,
    this_->extension);
  this_->fileHandler = CreateFileA(newFileName, 0x40000000u, 1u, 0, 4u, 0x80u, 0);
  if ( this_->fileHandler != (HANDLE)-1 )
    SetFilePointer(this_->fileHandler, 0, 0, 2u);
  this_->dayOfMonth = now->tm_mday;
  result = now;
  this_->hour = now->tm_hour;
  return result;
}

//----- (0042E0DD) --------------------------------------------------------
int FileLog::write(FileLog *this, int logType, char *format, ...)
{
  int result; // eax@7
  DWORD buffLen; // eax@9
  HANDLE oldFileHandler; // [sp+0h] [bp-51Ch]@4
  CHAR FileName[256]; // [sp+4h] [bp-518h]@4
  LONG newFileHandler; // [sp+104h] [bp-418h]@4
  char buffer[1024]; // [sp+108h] [bp-414h]@7
  int v9; // [sp+508h] [bp-14h]@7
  va_list v10; // [sp+50Ch] [bp-10h]@7
  DWORD NumberOfBytesWritten; // [sp+510h] [bp-Ch]@9
  time_t timeNow; // [sp+514h] [bp-8h]@1
  struct tm *now; // [sp+518h] [bp-4h]@1
  va_list va; // [sp+530h] [bp+14h]@1

  va_start(va, format);
  timeNow = time(0);
  now = localtime(&timeNow);
  EnterCriticalSection(&this->crit_section);
  if ( (now->tm_mday != this->dayOfMonth || now->tm_hour != this->hour) && this->fileHandler != (HANDLE)-1 )
  {
    sprintf(
      FileName,
      aS04d02d02d_0_2,
      this->dirName,
      now->tm_year + 1900,
      now->tm_mon + 1,
      now->tm_mday,
      now->tm_hour,
      this->extension);
    newFileHandler = (LONG)CreateFileA(FileName, 0x40000000u, 1u, 0, 2u, 0x80u, 0);
    oldFileHandler = (HANDLE)InterlockedExchange((volatile LONG *)&this->fileHandler, newFileHandler);
    if ( oldFileHandler )
      CloseHandle(oldFileHandler);
    this->dayOfMonth = now->tm_mday;
    this->hour = now->tm_hour;
  }
  LeaveCriticalSection(&this->crit_section);
  v10 = va;
  result = vsprintf(buffer, format, va);
  v9 = result;
  v10 = 0;
  if ( result > 0 && this->fileHandler != (HANDLE)-1 )
  {
    buffLen = strlen(buffer);
    result = WriteFile(this->fileHandler, buffer, buffLen, &NumberOfBytesWritten, 0);
  }
  return result;
}

//----- (0042E261) --------------------------------------------------------
GeneralLog *__thiscall GeneralLog::GeneralLog(GeneralLog *this, char *extension)
{
  GeneralLog *this_; // ST04_4@1
  struct tm *v3; // eax@1
  int v4; // ST08_4@1
  time_t v6; // [sp+8h] [bp-8h]@1
  struct tm *v7; // [sp+Ch] [bp-4h]@1

  this_ = this;
  FileLog::FileLog(&this->base, extension);
  this_->base.vftable = (int)&GeneralLog_vtable_off_45F85C;
  v6 = time(0);
  v3 = localtime(&v6);
  v7 = v3;
  v4 = v3->tm_min >= 30;
  return this_;
}
// 45F85C: using guessed type int (__cdecl *GeneralLog_vtable_off_45F85C)(int, int, char *, char);

//----- (0042E2C4) --------------------------------------------------------
void __thiscall GeneralLog::Destructor(GeneralLog *this)
{
  this->base.vftable = (int)&GeneralLog_vtable_off_45F85C;
  FileLog::Destructor(&this->base);
}
// 45F85C: using guessed type int (__cdecl *GeneralLog_vtable_off_45F85C)(int, int, char *, char);

//----- (0042E2E0) --------------------------------------------------------
int GeneralLog::write(GeneralLog *this_, int logType, char *format, ...)
{
  int result; // eax@8
  DWORD buffLen; // eax@10
  HANDLE oldFileHandler; // [sp+0h] [bp-520h]@4
  CHAR newFileName; // [sp+4h] [bp-51Ch]@4
  HANDLE newFileHandler; // [sp+104h] [bp-41Ch]@4
  char buffer[1024]; // [sp+108h] [bp-418h]@8
  int v9; // [sp+508h] [bp-18h]@8
  va_list v10; // [sp+50Ch] [bp-14h]@8
  DWORD NumberOfBytesWritten; // [sp+510h] [bp-10h]@10
  int isSecondHalfOfHour; // [sp+514h] [bp-Ch]@1 ???? Critical section ?????
  time_t timeNow; // [sp+518h] [bp-8h]@1
  struct tm *now; // [sp+51Ch] [bp-4h]@1
  va_list va; // [sp+534h] [bp+14h]@1

  va_start(va, format);
  timeNow = time(0);
  now = localtime(&timeNow);
  isSecondHalfOfHour = 0;
  isSecondHalfOfHour = now->tm_min >= 30;
  EnterCriticalSection(&this_->base.crit_section);
  if ( now->tm_mday != this_->base.dayOfMonth
    || now->tm_hour != this_->base.hour
    || isSecondHalfOfHour != this_->halfAnHour )
  {
    sprintf(
      &newFileName,
      aS04d02d02d1000,
      this_->base.dirName,
      now->tm_year + 1900,
      now->tm_mon + 1,
      now->tm_mday,
      now->tm_hour,
      isSecondHalfOfHour,
      this_->base.extension);
    newFileHandler = CreateFileA(&newFileName, 0x40000000u, 1u, 0, 2u, 0x80u, 0);
    oldFileHandler = (HANDLE)InterlockedExchange((volatile LONG *)&this_->base.fileHandler, (LONG)newFileHandler);
    if ( oldFileHandler && oldFileHandler != (HANDLE)-1 )
      CloseHandle(oldFileHandler);
    this_->base.dayOfMonth = now->tm_mday;
    this_->base.hour = now->tm_hour;
    this_->halfAnHour = isSecondHalfOfHour;
  }
  LeaveCriticalSection(&this_->base.crit_section);
  v10 = va;
  result = vsprintf(buffer, format, va);
  v9 = result;
  v10 = 0;
  if ( result > 0 && this_->base.fileHandler != (HANDLE)-1 )
  {
    buffLen = strlen(buffer);
    result = WriteFile(this_->base.fileHandler, buffer, buffLen, &NumberOfBytesWritten, 0);
  }
  return result;
}

//----- (0042E49E) --------------------------------------------------------
GeneralLog *__thiscall GeneralLog::Init(GeneralLog *this, char *aDirName)
{
  GeneralLog *result; // eax@6
  GeneralLog *this_; // [sp+0h] [bp-10Ch]@1
  time_t now_time; // [sp+4h] [bp-108h]@1
  struct tm *now; // [sp+8h] [bp-104h]@1
  char newFileName[256]; // [sp+Ch] [bp-100h]@2

  this_ = this;
  now_time = time(0);
  now = localtime(&now_time);
  strcpy(this_->base.dirName, aDirName);
  if ( now->tm_min >= 30 )
  {
    sprintf(
      newFileName,
      aS04d02d02d10_1,
      this_->base.dirName,
      now->tm_year + 1900,
      now->tm_mon + 1,
      now->tm_mday,
      now->tm_hour,
      this_->base.extension);
    this_->halfAnHour = 1;
  }
  else
  {
    sprintf(
      newFileName,
      aS04d02d02d10_0,
      this_->base.dirName,
      now->tm_year + 1900,
      now->tm_mon + 1,
      now->tm_mday,
      now->tm_hour,
      this_->base.extension);
    this_->halfAnHour = 0;
  }
  this_->base.fileHandler = CreateFileA(newFileName, 0x40000000u, 1u, 0, 4u, 0x80u, 0);
  if ( this_->base.fileHandler != (HANDLE)-1 )
    SetFilePointer(this_->base.fileHandler, 0, 0, 2u);
  this_->base.dayOfMonth = now->tm_mday;
  result = this_;
  this_->base.hour = now->tm_hour;
  return result;
}

//----- (0042E63A) --------------------------------------------------------
int sub_42E63A()
{
  SomeBitsInit();
  return sub_42E649();
}

//----- (0042E649) --------------------------------------------------------
int sub_42E649()
{
  return atexit(emptystub);
}

//----- (0042E660) --------------------------------------------------------
LogWindow *__thiscall LogWindow::DeletingDestructor(LogWindow *this, char a2)
{
  LogWindow *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  LogWindow::Destructor(this);
  if ( a2 & 1 )
    _delete_table(v3);
  return v3;
}

//----- (0042E690) --------------------------------------------------------
int StaticInitLogDLock()
{
  CallLogDLockConstructor();
  return RegisterLogDLockDestructor();
}

//----- (0042E69F) --------------------------------------------------------
ReadWriteLock *CallLogDLockConstructor()
{
  return ReadWriteLock::ReadWriteLock(&CLogSocket::s_lock);
}

//----- (0042E6AE) --------------------------------------------------------
int RegisterLogDLockDestructor()
{
  return atexit(CallLogDLockDestructor);
}

//----- (0042E6C0) --------------------------------------------------------
void __cdecl CallLogDLockDestructor()
{
  ReadWriteLock::Destructor(&CLogSocket::s_lock);
}

//----- (0042E6CF) --------------------------------------------------------
void __stdcall onTimeout(PVOID a1, BOOLEAN a2)
{
  SOCKET logdSocket; // ST10_4@4
  int result; // ST14_4@4
  CLogSocket *prevSocket; // ST0C_4@6
  CLogSocket *logSocket; // [sp+Ch] [bp-14h]@4
  sockaddr_in name; // [sp+10h] [bp-10h]@4

  if ( CLogSocket::s_timer )
    DeleteTimerQueueTimer(0, CLogSocket::s_timer, 0);
  CLogSocket::s_timer = 0;
  if ( CLogSocket::isReconnecting == true )
  {
    logdSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
    name.sin_family = AF_INET;
    name.sin_addr.S_un.S_addr = g_Config.logdip;
    name.sin_port = htons(g_Config.logdport);
    result = connect(logdSocket, (const struct sockaddr *)&name, 16);
    logSocket = CLogSocket::Create(logdSocket);
    CLogSocket::setIPAddress(logSocket, g_Config.logdip);
    if ( result == SOCKET_ERROR )
    {
      CIOSocket::Close(&logSocket->base);
      MemoryObject::Release(&logSocket->base.base);
    }
    else
    {
      ReadWriteLock::writeLock(&CLogSocket::s_lock);
      prevSocket = g_LogDSocket;
      g_LogDSocket = logSocket;
      CLogSocket::isReconnecting = false;
      LOBYTE(g_Config.UseLogD) = true;
      CIOSocket::Initialize(&logSocket->base, Threading::g_hCompletionPortExtra);
      MemoryObject::Release(&prevSocket->base.base);
      ReadWriteLock::releaseWriteLock(&CLogSocket::s_lock);
    }
  }
}
// 480179: using guessed type char CLogSocket::isReconnecting;

//----- (0042E7D4) --------------------------------------------------------
int StaticInitCLogPacketPool::g_slot()
{
  CLogPacketPool::g_slot::construction();
  return CLogPacketPool::g_slot::registerDtor();
}

//----- (0042E7E3) --------------------------------------------------------
int CLogPacketPool::g_slot::construction()
{
  return `eh vector constructor iterator'(
           CLogPacketPool::g_slot,
           0x24u,
           16,
           (int)CLogSlot::CLogSlot,
           (void (__thiscall *)(void *))CLogSlot::Destructor);
}

//----- (0042E800) --------------------------------------------------------
int CLogPacketPool::g_slot::registerDtor()
{
  return atexit(CLogPacketPool::g_slot::destruction);
}

//----- (0042E812) --------------------------------------------------------
void __cdecl CLogPacketPool::g_slot::destruction()
{
  if ( !(byte_480178 & 1) )
  {
    byte_480178 |= 1u;
    `eh vector destructor iterator'(
      CLogPacketPool::g_slot,
      0x24u,
      16,
      (void (__thiscall *)(void *))CLogSlot::Destructor);
  }
}
// 480178: using guessed type char byte_480178;

//----- (0042E847) --------------------------------------------------------
int StaticInitCLogPacketPool()
{
  CallCLogPacketPoolConstructor();
  return RegisterCLogPacketPoolDestructor();
}

//----- (0042E856) --------------------------------------------------------
void CallCLogPacketPoolConstructor()
{
  ;
}

//----- (0042E85B) --------------------------------------------------------
int RegisterCLogPacketPoolDestructor()
{
  return atexit(CallCLogPacketPoolDestructor);
}

//----- (0042E86D) --------------------------------------------------------
void __cdecl CallCLogPacketPoolDestructor()
{
  CLogPacketPool::Destructor((CLogPacketPool *)&g_LogPacketPool);
}

//----- (0042E87C) --------------------------------------------------------
CLogPacket *CLogPacket::Alloc()
{
  CLogPacket *v1; // [sp+0h] [bp-20h]@4
  CLogPacket *packet_; // [sp+4h] [bp-1Ch]@3
  CLogSlot *slot; // [sp+Ch] [bp-14h]@1
  CLogPacket *packet; // [sp+10h] [bp-10h]@1

  slot = &CLogPacketPool::g_slot[InterlockedIncrement(&CLogPacketPool::g_nAlloc) & 0xF];
  SpinLock::Enter(&slot->m_lock);
  packet = slot->m_pPacket;
  if ( slot->m_pPacket )
  {
    slot->m_pPacket = (CLogPacket *)packet->base.m_pSocket;
    SpinLock::Leave(&slot->m_lock);
  }
  else
  {
    SpinLock::Leave(&slot->m_lock);
    packet_ = (CLogPacket *)operator_new(0x14u);
    if ( packet_ )
      v1 = CLogPacket::CLogPacket(packet_);
    else
      v1 = 0;
    packet = v1;
  }
  return packet;
}

//----- (0042E93E) --------------------------------------------------------
void CLogPacket::FreeAll()
{
  CLogSlot *v0; // [sp+Ch] [bp-Ch]@3
  CLogPacket *v1; // [sp+10h] [bp-8h]@4
  signed int i; // [sp+14h] [bp-4h]@1

  for ( i = 0; i < 16; ++i )
  {
    v0 = &CLogPacketPool::g_slot[i];
    SpinLock::Enter(&CLogPacketPool::g_slot[i].m_lock);
    while ( 1 )
    {
      v1 = v0->m_pPacket;
      if ( !v0->m_pPacket )
        break;
      v0->m_pPacket = (CLogPacket *)v1->base.m_pSocket;
      if ( v1 )
        v1->base.base.vftbl_0_45F520->DestructorCall((MemoryObject *)v1, 1);
    }
    SpinLock::Leave(&v0->m_lock);
  }
}

//----- (0042E9CC) --------------------------------------------------------
void __thiscall CLogPacket::Free(CLogPacket *this)
{
  CLogPacket *this_; // ST04_4@1
  CLogSlot *v2; // ST08_4@1

  this_ = this;
  v2 = &CLogPacketPool::g_slot[InterlockedDecrement(&CLogPacketPool::g_nFree) & 0xF];
  SpinLock::Enter(&v2->m_lock);
  this_->base.m_pSocket = (CIOSocket *)v2->m_pPacket;
  v2->m_pPacket = this_;
  SpinLock::Leave(&v2->m_lock);
}

//----- (0042EA1B) --------------------------------------------------------
void __thiscall CLogPacket::OnIOCallback(CLogPacket *this, int bSuccess, int dwTransferred, int lpOverlapped)
{
  CLogPacket *this_; // [sp+Ch] [bp-20h]@1

  this_ = this;
  if ( ((int (__cdecl *)(_DWORD, _DWORD))this->base.m_pFunc)(
         this->base.m_pSocket,
         &this->base.m_pBuf->m_Buffer[dwTransferred + 1]) & 0xFF )
    CIOSocket::Close(this_->base.m_pSocket);
  MemoryObject::Release(&this_->base.m_pSocket->base);
  CIOBuffer::Release(this_->base.m_pBuf);
  InterlockedDecrement(&CLogPacket::g_nPendingPacket);
  CLogPacket::Free(this_);
}

//----- (0042EB08) --------------------------------------------------------
char CLogSocket::packet0_dummy_handler()
{
  LogWindow::Add(&g_LogWindow, 2, aCallDummypac_0);
  return 0;
}

//----- (0042EB23) --------------------------------------------------------
MemoryObject *__thiscall CLogSocket::Destructor(CLogSocket *this)
{
  CLogSocket *this_; // ST10_4@1

  this_ = this;
  this->base.base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&CLogSocket_VTABLE_off_45F8B4;
  LogWindow::Add(&g_LogWindow, 1, aDeleteLogsocke, this);
  return CIOSocket::Destructor(&this_->base);
}
// 45F8B4: using guessed type int (__stdcall *CLogSocket_VTABLE_off_45F8B4)(int);

//----- (0042EB84) --------------------------------------------------------
CLogSocket *__thiscall CLogSocket::CLogSocket(CLogSocket *this, int socket)
{
  CLogSocket *this_; // ST04_4@1

  this_ = this;
  CIOSocket::CIOSocket(&this->base, socket);
  this_->base.base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&CLogSocket_VTABLE_off_45F8B4;
  this_->m_logdServIp.S_un.S_addr = g_Config.logdip;
  this_->logDunused = 0;
  this_->m_status = SocketStatus_Init;
  MemoryObject::AddRef(&this_->base.base);
  this_->m_logDunused2 = 2;
  this_->m_logdIP.S_un.S_addr = g_Config.logdip;
  this_->m_logdport = htons(g_Config.logdport);
  this_->m_packetHandlers = (int)&CLogSocket::handlers;
  return this_;
}
// 45F8B4: using guessed type int (__stdcall *CLogSocket_VTABLE_off_45F8B4)(int);
// 46CB48: using guessed type void *CLogSocket::handlers;

//----- (0042EC33) --------------------------------------------------------
CLogSocket *__cdecl CLogSocket::Create(SOCKET socket)
{
  CLogSocket *logSocket; // [sp+0h] [bp-18h]@2
  CLogSocket *v3; // [sp+4h] [bp-14h]@1

  v3 = (CLogSocket *)operator_new(0x88u);
  if ( v3 )
    logSocket = CLogSocket::CLogSocket(v3, socket);
  else
    logSocket = 0;
  return logSocket;
}

//----- (0042ECA1) --------------------------------------------------------
LONG __thiscall CLogSocket::OnRead(CLogSocket *this)
{
  LONG result; // eax@2
  int v2; // ecx@14
  char *ipAddr; // eax@17
  CLogSocket *this_; // [sp+0h] [bp-18h]@1
  char *buffer; // [sp+8h] [bp-10h]@1
  signed __int32 buffSize; // [sp+Ch] [bp-Ch]@1
  signed int error; // [sp+10h] [bp-8h]@9
  signed __int32 dwRead; // [sp+14h] [bp-4h]@1

  this_ = this;
  dwRead = 0;
  buffSize = this->base.m_pReadBuf->m_dwSize;
  buffer = (char *)this->base.m_pReadBuf->m_Buffer;
  if ( this->m_status == SocketStatus_Closed )
  {
    result = CIOSocket::Close(&this->base);
  }
  else
  {
    while ( true )
    {
      if ( dwRead >= buffSize )
        return CIOSocket::Read(&this->base, 0);
      if ( this->m_status )
        break;
      if ( dwRead + 3 > buffSize )
        return CIOSocket::Read(&this->base, buffSize - dwRead);
      this->m_packetSize = (unsigned __int8)buffer[dwRead]
                         + ((unsigned __int8)buffer[dwRead + 1] << 8)
                         + 1
                         - g_Config.PacketSizeType;
      if ( this->m_packetSize <= 0 || this->m_packetSize > 8192 )
      {
        error = 1;
        LogWindow::Add(&g_LogWindow, 3, aDBadPacketSi_1, this->base.m_hSocket, this->m_packetSize);
        goto LABEL_17;
      }
      dwRead += 2;
      this->m_status = SocketStatus_BytesRead;
    }
    if ( this->m_status == SocketStatus_BytesRead )// TODO: manual disasembling is needed, check sub_42E87C
    {
      if ( this->m_packetSize + dwRead > buffSize )
        return CIOSocket::Read(&this->base, buffSize - dwRead);
      v2 = (unsigned __int8)buffer[dwRead];
      LogWindow::Add(&g_LogWindow, 3, aUnknownProto_1, v2);
      error = 2;
    }
    else
    {
      error = 3;
    }
LABEL_17:
    ipAddr = CLogSocket::addrToStr(this_);
    FileLog::write(&g_errLog, 0, aLogdServerConn, ipAddr, error);
    result = CIOSocket::Close(&this_->base);
  }
  return result;
}

//----- (0042EEE1) --------------------------------------------------------
int __thiscall CLogSocket::OnCreate(CLogSocket *this)
{
  CLogSocket *this_; // ST20_4@1

  this_ = this;
  CLogSocket::send2(this, aCd_0, 1, 0);
  CLogSocket::send2(this_, aCdd_0, 3, 201, 1);
  CLogSocket::created = true;
  return this_->base.base.vftbl_0_45F520->derived_func_9((CIOSocket *)this_);
}
// 48017A: using guessed type char CLogSocket::created;

//----- (0042EFA9) --------------------------------------------------------
LONG CLogSocket::send(CLogSocket *this, char *format, ...)
{
  LONG result; // eax@5
  int size; // [sp+10h] [bp-24h]@6
  CIOBuffer *buff; // [sp+18h] [bp-1Ch]@6
  va_list va; // [sp+44h] [bp+10h]@1

  va_start(va, format);
  MemoryObject::AddRef(&this->base.base);
  if ( this->m_status != SocketStatus_Closed
    && CLogSocket::isReconnecting != true
    && this->base.m_hSocket != INVALID_SOCKET
    && CLogSocket::created )
  {
    buff = CIOBuffer::Alloc();
    size = PacketUtils::VAssemble((char *)&buff->m_Buffer[2], 8190, format, va);
    if ( size )
    {
      size = size - 1 + 3;
      buff->m_Buffer[0] = size;
      buff->m_Buffer[1] = BYTE1(size);
    }
    else
    {
      LogWindow::Add(&g_LogWindow, 3, aDAssembleToo_2, this->base.m_hSocket, format);
    }
    buff->m_dwSize = size;
    CIOSocket::Write(&this->base, buff);
    result = MemoryObject::Release(&this->base.base);
  }
  else
  {
    LogWindow::Add(&g_LogWindow, 1, aLogdsocketCall);
    result = MemoryObject::Release(&this->base.base);
  }
  return result;
}
// 480179: using guessed type char CLogSocket::isReconnecting;
// 48017A: using guessed type char CLogSocket::created;

//----- (0042F131) --------------------------------------------------------
LONG CLogSocket::send2(CLogSocket *this_, char *format, ...)
{
  LONG result; // eax@4
  int size; // [sp+10h] [bp-24h]@5
  CIOBuffer *buff; // [sp+18h] [bp-1Ch]@5
  va_list va; // [sp+44h] [bp+10h]@1

  va_start(va, format);
  MemoryObject::AddRef(&this_->base.base);
  if ( this_->m_status != SocketStatus_Closed
    && CLogSocket::isReconnecting != true
    && this_->base.m_hSocket != INVALID_SOCKET )
  {
    buff = CIOBuffer::Alloc();
    size = PacketUtils::VAssemble((char *)&buff->m_Buffer[2], 8190, format, va);
    if ( size )
    {
      size = size - 1 + 3;
      buff->m_Buffer[0] = size;
      buff->m_Buffer[1] = BYTE1(size);
    }
    else
    {
      LogWindow::Add(&g_LogWindow, 3, aDAssembleToo_3, this_->base.m_hSocket, format);
    }
    buff->m_dwSize = size;
    CIOSocket::Write(&this_->base, buff);
    result = MemoryObject::Release(&this_->base.base);
  }
  else
  {
    LogWindow::Add(&g_LogWindow, 1, aLogdsocketCa_0);
    result = MemoryObject::Release(&this_->base.base);
  }
  return result;
}
// 480179: using guessed type char CLogSocket::isReconnecting;

//----- (0042F2AE) --------------------------------------------------------
char *__thiscall CLogSocket::addrToStr(CLogSocket *this)
{
  return inet_ntoa(this->m_logdServIp);
}

//----- (0042F2C6) --------------------------------------------------------
void CLogSocket::OnTimerCallback()
{
  ;
}

//----- (0042F2D1) --------------------------------------------------------
BOOL __thiscall CLogSocket::OnClose(CLogSocket *this)
{
  CLogSocket *this_; // ST34_4@1
  SOCKET socket; // ST24_4@1
  char *ipAddress; // eax@1
  SOCKET v4; // ST28_4@1
  char *v5; // eax@1
  tm timeNow; // [sp+Ch] [bp-28h]@1
  time_t now; // [sp+30h] [bp-4h]@1

  this_ = this;
  CLogSocket::isReconnecting = true;
  LOBYTE(g_Config.UseLogD) = false;
  this->m_status = SocketStatus_Closed;
  now = time(0);
  qmemcpy(&timeNow, localtime(&now), sizeof(timeNow));
  socket = this_->base.m_hSocket;
  ipAddress = CLogSocket::addrToStr(this_);
  LogWindow::Add(&g_LogWindow, 3, aCloseLogdConne, ipAddress, socket, this_);
  v4 = this_->base.m_hSocket;
  v5 = CLogSocket::addrToStr(this_);
  FileLog::write(
    &g_errLog,
    0,
    aDDDDDDMainSe_0,
    timeNow.tm_year + 1900,
    timeNow.tm_mon + 1,
    timeNow.tm_mday,
    timeNow.tm_hour,
    timeNow.tm_min,
    timeNow.tm_sec,
    v5,
    v4);
  MemoryObject::AddRef(&this_->base.base);
  return CreateTimerQueueTimer(&CLogSocket::s_timer, 0, onTimeout, this_, g_Config.logdconnectinterval, 0, 0);
}
// 480179: using guessed type char CLogSocket::isReconnecting;

//----- (0042F3B4) --------------------------------------------------------
int sub_42F3B4()
{
  SomeBitsInit();
  return sub_42F3C3();
}

//----- (0042F3C3) --------------------------------------------------------
int sub_42F3C3()
{
  return atexit(emptystub);
}

//----- (0042F3E0) --------------------------------------------------------
CLogSlot *__thiscall CLogSlot::CLogSlot(CLogSlot *this)
{
  CLogSlot *v1; // ST08_4@1

  v1 = this;
  this->m_pPacket = 0;
  SpinLock::SpinLock(&this->m_lock, LockType_WaitLock, 0);
  return v1;
}

//----- (0042F430) --------------------------------------------------------
void __thiscall CLogPacketPool::Destructor(CLogPacketPool *this)
{
  CLogPacket::FreeAll();
}

//----- (0042F440) --------------------------------------------------------
CLogPacket *__thiscall CLogPacket::CLogPacket(CLogPacket *this)
{
  CLogPacket *this_; // ST00_4@1

  this_ = this;
  MemoryObject::MemoryObject(&this->base.base);
  this_->base.base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&CLogPacket_vtable_off_45F860;
  return this_;
}
// 45F860: using guessed type int (__stdcall *CLogPacket_vtable_off_45F860)(int);

//----- (0042F460) --------------------------------------------------------
CLogPacket *__thiscall CLogPacket::DeletingDestructor(CLogPacket *this, char a2)
{
  CLogPacket *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  CLogPacket::Destructor(this);
  if ( a2 & 1 )
    operator_delete(v3);
  return v3;
}

//----- (0042F4B0) --------------------------------------------------------
CLogSocket *__thiscall CLogSocket::CallDtor(CLogSocket *this, char a2)
{
  CLogSocket *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  CLogSocket::Destructor(this);
  if ( a2 & 1 )
    operator_delete(v3);
  return v3;
}

//----- (0042F4E0) --------------------------------------------------------
int __thiscall SHA_1::SHA_1(int this)
{
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)this = 0x67452301;
  *(_DWORD *)(this + 4) = 0xEFCDAB89;
  *(_DWORD *)(this + 8) = 0x98BADCFE;
  *(_DWORD *)(this + 12) = 0x10325476;
  return this;
}

//----- (0042F529) --------------------------------------------------------
void __thiscall MD5::CallHash(int this, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *field; // [sp+0h] [bp-10h]@1
  int v4; // [sp+4h] [bp-Ch]@1
  int i; // [sp+Ch] [bp-4h]@4

  field = (unsigned __int8 *)this;
  v4 = (*(_DWORD *)(this + 16) >> 3) & 0x3F;
  *(_DWORD *)(this + 16) += 8 * a3;
  if ( *(_DWORD *)(this + 16) < (unsigned int)(8 * a3) )
    ++*(_DWORD *)(this + 20);
  *(_DWORD *)(this + 20) += (unsigned int)a3 >> 29;
  if ( a3 < (unsigned int)(64 - v4) )
  {
    i = 0;
  }
  else
  {
    und_memcpy((char *)(this + v4 + 24), (const char *)a2, 64 - v4);
    MD5::Hash(field, field + 24);
    for ( i = 64 - v4; i + 63 < (unsigned int)a3; i += 64 )
      MD5::Hash(field, &a2[i]);
    v4 = 0;
  }
  und_memcpy((char *)&field[v4 + 24], (const char *)&a2[i], a3 - i);
}

//----- (0042F62D) --------------------------------------------------------
unsigned int __thiscall MD5::sub_42F62D(void *this, int a2)
{
  int v3; // [sp+0h] [bp-18h]@2
  unsigned __int8 *this_; // [sp+4h] [bp-14h]@1
  unsigned int v5; // [sp+8h] [bp-10h]@1
  unsigned __int8 v6[12]; // [sp+Ch] [bp-Ch]@1

  this_ = (unsigned __int8 *)this;
  MD5::sub_43056E(v6, (unsigned __int8 *)this + 16, 8u);
  v5 = (*((_DWORD *)this_ + 4) >> 3) & 0x3F;
  if ( v5 >= 0x38 )
    v3 = 120 - v5;
  else
    v3 = 56 - v5;
  *(_DWORD *)&v6[8] = v3;
  MD5::CallHash((int)this_, aA_1, v3);
  MD5::CallHash((int)this_, v6, 8);
  MD5::sub_43056E((unsigned __int8 *)a2, this_, 0x10u);
  return MD5::sub_4306BB((int)this_, 0, 0x58u);
}

//----- (0042F6C5) --------------------------------------------------------
unsigned int __cdecl MD5::Hash(unsigned __int8 *field, unsigned __int8 *param)
{
  int v3[16]; // [sp+0h] [bp-50h]@1
  unsigned int d; // [sp+40h] [bp-10h]@1
  unsigned int c; // [sp+44h] [bp-Ch]@1
  unsigned int b; // [sp+48h] [bp-8h]@1
  unsigned int a; // [sp+4Ch] [bp-4h]@1

  a = *(_DWORD *)field;
  b = *((_DWORD *)field + 1);
  c = *((_DWORD *)field + 2);
  d = *((_DWORD *)field + 3);
  MD5::sub_43060E((unsigned __int8 *)v3, param, 0x40u);
  a = a + v3[0] + (d & ~b | c & b) - 0x28955B88;
  a = b + ((a >> 25) | (a << 7));
  d = d + v3[1] + (c & ~a | b & a) - 0x173848AA;
  d = a + ((d >> 20) | (d << 12));
  c += v3[2] + (b & ~d | a & d) + 0x242070DB;
  c = d + ((c >> 15) | (c << 17));
  b = b + v3[3] + (a & ~c | d & c) - 0x3E423112;
  b = c + ((b >> 10) | (b << 22));
  a = a + v3[4] + (d & ~b | c & b) - 0xA83F051;
  a = b + ((a >> 25) | (a << 7));
  d += v3[5] + (c & ~a | b & a) + 0x4787C62A;
  d = a + ((d >> 20) | (d << 12));
  c = c + v3[6] + (b & ~d | a & d) - 1473231341;
  c = d + ((c >> 15) | (c << 17));
  b = b + v3[7] + (a & ~c | d & c) - 45705983;
  b = c + ((b >> 10) | (b << 22));
  a += v3[8] + (d & ~b | c & b) + 1770035416;
  a = b + ((a >> 25) | (a << 7));
  d = d + v3[9] + (c & ~a | b & a) - 1958414417;
  d = a + ((d >> 20) | (d << 12));
  c = c + v3[10] + (b & ~d | a & d) - 42063;
  c = d + ((c >> 15) | (c << 17));
  b = b + v3[11] + (a & ~c | d & c) - 1990404162;
  b = c + ((b >> 10) | (b << 22));
  a += v3[12] + (d & ~b | c & b) + 1804603682;
  a = b + ((a >> 25) | (a << 7));
  d = d + v3[13] + (c & ~a | b & a) - 40341101;
  d = a + ((d >> 20) | (d << 12));
  c = c + v3[14] + (b & ~d | a & d) - 1502002290;
  c = d + ((c >> 15) | (c << 17));
  b += v3[15] + (a & ~c | d & c) + 1236535329;
  b = c + ((b >> 10) | (b << 22));
  a = a + v3[1] + (~d & c | d & b) - 165796510;
  a = b + ((a >> 27) | 32 * a);
  d = d + v3[6] + (~c & b | c & a) - 1069501632;
  d = a + ((d >> 23) | (d << 9));
  c += v3[11] + (~b & a | b & d) + 643717713;
  c = d + ((c >> 18) | (c << 14));
  b = b + v3[0] + (~a & d | a & c) - 373897302;
  b = c + ((b >> 12) | (b << 20));
  a = a + v3[5] + (~d & c | d & b) - 701558691;
  a = b + ((a >> 27) | 32 * a);
  d += v3[10] + (~c & b | c & a) + 38016083;
  d = a + ((d >> 23) | (d << 9));
  c = c + v3[15] + (~b & a | b & d) - 660478335;
  c = d + ((c >> 18) | (c << 14));
  b = b + v3[4] + (~a & d | a & c) - 405537848;
  b = c + ((b >> 12) | (b << 20));
  a += v3[9] + (~d & c | d & b) + 568446438;
  a = b + ((a >> 27) | 32 * a);
  d = d + v3[14] + (~c & b | c & a) - 1019803690;
  d = a + ((d >> 23) | (d << 9));
  c = c + v3[3] + (~b & a | b & d) - 187363961;
  c = d + ((c >> 18) | (c << 14));
  b += v3[8] + (~a & d | a & c) + 1163531501;
  b = c + ((b >> 12) | (b << 20));
  a = a + v3[13] + (~d & c | d & b) - 1444681467;
  a = b + ((a >> 27) | 32 * a);
  d = d + v3[2] + (~c & b | c & a) - 51403784;
  d = a + ((d >> 23) | (d << 9));
  c += v3[7] + (~b & a | b & d) + 1735328473;
  c = d + ((c >> 18) | (c << 14));
  b = b + v3[12] + (~a & d | a & c) - 1926607734;
  b = c + ((b >> 12) | (b << 20));
  a = a + v3[5] + (d ^ c ^ b) - 378558;
  a = b + ((a >> 28) | 16 * a);
  d = d + v3[8] + (c ^ b ^ a) - 2022574463;
  d = a + ((d >> 21) | (d << 11));
  c += v3[11] + (b ^ a ^ d) + 1839030562;
  c = d + ((c >> 16) | (c << 16));
  b = b + v3[14] + (a ^ d ^ c) - 35309556;
  b = c + ((b >> 9) | (b << 23));
  a = a + v3[1] + (d ^ c ^ b) - 1530992060;
  a = b + ((a >> 28) | 16 * a);
  d += v3[4] + (c ^ b ^ a) + 1272893353;
  d = a + ((d >> 21) | (d << 11));
  c = c + v3[7] + (b ^ a ^ d) - 155497632;
  c = d + ((c >> 16) | (c << 16));
  b = b + v3[10] + (a ^ d ^ c) - 1094730640;
  b = c + ((b >> 9) | (b << 23));
  a += v3[13] + (d ^ c ^ b) + 681279174;
  a = b + ((a >> 28) | 16 * a);
  d = d + v3[0] + (c ^ b ^ a) - 358537222;
  d = a + ((d >> 21) | (d << 11));
  c = c + v3[3] + (b ^ a ^ d) - 722521979;
  c = d + ((c >> 16) | (c << 16));
  b += v3[6] + (a ^ d ^ c) + 76029189;
  b = c + ((b >> 9) | (b << 23));
  a = a + v3[9] + (d ^ c ^ b) - 640364487;
  a = b + ((a >> 28) | 16 * a);
  d = d + v3[12] + (c ^ b ^ a) - 421815835;
  d = a + ((d >> 21) | (d << 11));
  c += v3[15] + (b ^ a ^ d) + 530742520;
  c = d + ((c >> 16) | (c << 16));
  b = b + v3[2] + (a ^ d ^ c) - 995338651;
  b = c + ((b >> 9) | (b << 23));
  a = a + v3[0] + ((~d | b) ^ c) - 198630844;
  a = b + ((a >> 26) | (a << 6));
  d += v3[7] + ((~c | a) ^ b) + 1126891415;
  d = a + ((d >> 22) | (d << 10));
  c = c + v3[14] + ((~b | d) ^ a) - 1416354905;
  c = d + ((c >> 17) | (c << 15));
  b = b + v3[5] + ((~a | c) ^ d) - 57434055;
  b = c + ((b >> 11) | (b << 21));
  a += v3[12] + ((~d | b) ^ c) + 1700485571;
  a = b + ((a >> 26) | (a << 6));
  d = d + v3[3] + ((~c | a) ^ b) - 1894986606;
  d = a + ((d >> 22) | (d << 10));
  c = c + v3[10] + ((~b | d) ^ a) - 1051523;
  c = d + ((c >> 17) | (c << 15));
  b = b + v3[1] + ((~a | c) ^ d) - 2054922799;
  b = c + ((b >> 11) | (b << 21));
  a += v3[8] + ((~d | b) ^ c) + 1873313359;
  a = b + ((a >> 26) | (a << 6));
  d = d + v3[15] + ((~c | a) ^ b) - 30611744;
  d = a + ((d >> 22) | (d << 10));
  c = c + v3[6] + ((~b | d) ^ a) - 1560198380;
  c = d + ((c >> 17) | (c << 15));
  b += v3[13] + ((~a | c) ^ d) + 1309151649;
  b = c + ((b >> 11) | (b << 21));
  a = a + v3[4] + ((~d | b) ^ c) - 145523070;
  a = b + ((a >> 26) | (a << 6));
  d = d + v3[11] + ((~c | a) ^ b) - 1120210379;
  d = a + ((d >> 22) | (d << 10));
  c += v3[2] + ((~b | d) ^ a) + 718787259;
  c = d + ((c >> 17) | (c << 15));
  b = b + v3[9] + ((~a | c) ^ d) - 343485551;
  b = c + ((b >> 11) | (b << 21));
  *(_DWORD *)field += a;
  *((_DWORD *)field + 1) += b;
  *((_DWORD *)field + 2) += c;
  *((_DWORD *)field + 3) += d;
  return MD5::sub_4306BB((int)v3, 0, 0x40u);
}

//----- (0043056E) --------------------------------------------------------
int __cdecl MD5::sub_43056E(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int size)
{
  int result; // eax@3
  unsigned int i; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v5 = 0;
  for ( i = 0; i < size; i += 4 )
  {
    a1[i] = *(_DWORD *)&a2[4 * v5];
    a1[i + 1] = *(_WORD *)&a2[4 * v5] >> 8;
    a1[i + 2] = *(_DWORD *)&a2[4 * v5] >> 16;
    a1[i + 3] = (unsigned __int16)(*(_DWORD *)&a2[4 * v5] >> 16) >> 16;
    result = v5++ + 1;
  }
  return result;
}

//----- (0043060E) --------------------------------------------------------
int __cdecl MD5::sub_43060E(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int size)
{
  int result; // eax@3
  unsigned int i; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v5 = 0;
  for ( i = 0; i < size; i += 4 )
  {
    *(_DWORD *)&a1[4 * v5] = (a2[i + 3] << 24) | (a2[i + 2] << 16) | (a2[i + 1] << 8) | a2[i];
    result = v5++ + 1;
  }
  return result;
}

//----- (004306BB) --------------------------------------------------------
unsigned int __cdecl MD5::sub_4306BB(int a1, char a2, unsigned int a3)
{
  unsigned int result; // eax@3
  unsigned int i; // [sp+0h] [bp-4h]@1

  for ( i = 0; i < a3; ++i )
  {
    *(_BYTE *)(i + a1) = a2;
    result = i + 1;
  }
  return result;
}

//----- (004306F0) --------------------------------------------------------
int Static_MemoryAllocatorsInitializer()
{
  CallStaticCtorForMemoryAllocatorsInitializer();
  return RegisterStatic_destructorForMemoryAllocatorsInitializer();
}

//----- (004306FF) --------------------------------------------------------
void *CallStaticCtorForMemoryAllocatorsInitializer()
{
  return MemoryAllocatorsInitializer::Ctor(&g_MemoryAllocatorsInitializer);
}

//----- (0043070E) --------------------------------------------------------
int RegisterStatic_destructorForMemoryAllocatorsInitializer()
{
  return atexit(CallDtorForMemoryAllocatorsInitializer);
}

//----- (00430720) --------------------------------------------------------
void __cdecl CallDtorForMemoryAllocatorsInitializer()
{
  MemoryAllocators::Destructor(&g_MemoryAllocatorsInitializer);
}

//----- (0043072F) --------------------------------------------------------
void *__thiscall MemoryAllocatorsInitializer::Ctor(void *this)
{
  int v2; // [sp+0h] [bp-20h]@4
  void *v3; // [sp+4h] [bp-1Ch]@1
  void *v4; // [sp+8h] [bp-18h]@3
  signed int i; // [sp+10h] [bp-10h]@1

  v3 = this;
  *(_DWORD *)this = off_45F8E0;
  for ( i = 0; i < 16; ++i )
  {
    v4 = operator new(0x38u);
    if ( v4 )
      v2 = sub_430828((int)v4);
    else
      v2 = 0;
    g_MemoryAllocators[i] = v2;
  }
  return v3;
}
// 45F8E0: using guessed type int (__stdcall *off_45F8E0[2])(int);
// 48018C: using guessed type int g_MemoryAllocators[];

//----- (004307C9) --------------------------------------------------------
void *__thiscall MemoryAllocators::Destructor(void *this)
{
  void *result; // eax@1
  void *v2; // [sp+Ch] [bp-8h]@3
  signed int i; // [sp+10h] [bp-4h]@1

  result = this;
  *(_DWORD *)this = off_45F8E0;
  for ( i = 0; i < 16; ++i )
  {
    result = (void *)g_MemoryAllocators[i];
    v2 = (void *)g_MemoryAllocators[i];
    if ( v2 )
      result = MemoryAllocators::Free(v2, 1);
  }
  return result;
}
// 45F8E0: using guessed type int (__stdcall *off_45F8E0[2])(int);
// 48018C: using guessed type int g_MemoryAllocators[];

//----- (00430828) --------------------------------------------------------
int __thiscall sub_430828(int this)
{
  int v1; // ST04_4@1

  v1 = this;
  InitializeCriticalSection((LPCRITICAL_SECTION)(this + 32));
  *(_DWORD *)(v1 + 28) = 0;
  sub_430875((HANDLE *)v1);
  return v1;
}

//----- (00430855) --------------------------------------------------------
void __thiscall sub_430855(void *this)
{
  void *v1; // ST04_4@1

  v1 = this;
  sub_4308CF((int)this);
  DeleteCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 32));
}

//----- (00430875) --------------------------------------------------------
signed int __thiscall sub_430875(HANDLE *this)
{
  signed int result; // eax@2
  HANDLE *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  *this = HeapCreate(1u, 0x2000u, 0);
  if ( *v2 )
  {
    if ( sub_43097B((int)v2, 1016) )
    {
      result = 1;
    }
    else
    {
      HeapDestroy(*v2);
      *v2 = 0;
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (004308CF) --------------------------------------------------------
BOOL __thiscall sub_4308CF(int this)
{
  BOOL result; // eax@1
  int v2; // [sp+0h] [bp-Ch]@1
  int v3; // [sp+4h] [bp-8h]@2
  int i; // [sp+8h] [bp-4h]@2

  v2 = this;
  result = this;
  if ( *(_DWORD *)this )
  {
    v3 = *(_DWORD *)(this + 8);
    for ( i = 0; i < *(_DWORD *)(v2 + 20); ++i )
    {
      VirtualFree(*(LPVOID *)(v3 + 12), 0x200000u, 0x4000u);
      VirtualFree(*(LPVOID *)(v3 + 12), 0, 0x8000u);
      HeapFree(*(HANDLE *)v2, 0, *(LPVOID *)(v3 + 16));
      v3 += 20;
    }
    HeapFree(*(HANDLE *)v2, 0, *(LPVOID *)(v2 + 8));
    result = HeapDestroy(*(HANDLE *)v2);
  }
  return result;
}

//----- (0043097B) --------------------------------------------------------
signed int __thiscall sub_43097B(int this, int a2)
{
  signed int result; // eax@2
  int v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  *(_DWORD *)(this + 8) = HeapAlloc(*(HANDLE *)this, 0, 0x140u);
  if ( *(_DWORD *)(v3 + 8) )
  {
    *(_DWORD *)(v3 + 4) = a2;
    *(_DWORD *)(v3 + 12) = *(_DWORD *)(v3 + 8);
    *(_DWORD *)(v3 + 24) = 0;
    *(_DWORD *)(v3 + 20) = 0;
    *(_DWORD *)(v3 + 16) = 16;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (004309E6) --------------------------------------------------------
_DWORD *__cdecl managed_New(int a1)
{
  int v2; // [sp+0h] [bp-8h]@1
  _DWORD *v3; // [sp+4h] [bp-4h]@1

  v2 = g_MemoryAllocators[InterlockedIncrement(&g_CurrentMemoryAllocator) & 0xF];
  v3 = MemoryAllocator::GetNewMemory(v2, a1 + 4);
  if ( v3 )
  {
    *v3 = v2;
    ++v3;
  }
  return v3;
}
// 48018C: using guessed type int g_MemoryAllocators[];

//----- (00430A34) --------------------------------------------------------
LPVOID __thiscall MemoryAllocator::GetNewMemory(int this, SIZE_T dwBytes)
{
  LPVOID result; // eax@3
  SIZE_T v3; // eax@4
  void *v4; // ST10_4@4
  HANDLE *v5; // [sp+0h] [bp-8h]@1
  _DWORD *v6; // [sp+4h] [bp-4h]@2
  SIZE_T dwBytesa; // [sp+10h] [bp+8h]@4

  v5 = (HANDLE *)this;
  if ( dwBytes <= *(_DWORD *)(this + 4)
    && (MemoryAllocator::lockGuardEnter(this),
        v6 = MemoryAllocator::New((int)v5, dwBytes),
        MemoryAllocator::lockGuardExit((int)v5),
        v6) )
  {
    result = v6;
  }
  else
  {
    v3 = dwBytes + 15;
    LOBYTE(v3) = (dwBytes + 15) & 0xF0;
    dwBytesa = v3;
    MemoryAllocator::lockGuardEnter((int)v5);
    v4 = HeapAlloc(*v5, 0, dwBytesa);
    MemoryAllocator::lockGuardExit((int)v5);
    result = v4;
  }
  return result;
}

//----- (00430AAB) --------------------------------------------------------
_DWORD *__thiscall MemoryAllocator::New(int this, int a2)
{
  _DWORD *result; // eax@24
  int v3; // ST38_4@47
  int v4; // edx@49
  int v5; // edx@52
  int v6; // edx@57
  int v7; // [sp+4h] [bp-3Ch]@1
  _DWORD *v8; // [sp+8h] [bp-38h]@27
  unsigned int v9; // [sp+Ch] [bp-34h]@2
  int j; // [sp+10h] [bp-30h]@27
  unsigned int v11; // [sp+14h] [bp-2Ch]@1
  signed int v12; // [sp+18h] [bp-28h]@1
  unsigned int v13; // [sp+1Ch] [bp-24h]@2
  int v14; // [sp+20h] [bp-20h]@1
  signed int v15; // [sp+20h] [bp-20h]@32
  int v16; // [sp+24h] [bp-1Ch]@32
  unsigned int i; // [sp+28h] [bp-18h]@4
  int v18; // [sp+2Ch] [bp-14h]@36
  int v19; // [sp+30h] [bp-10h]@36
  int v20; // [sp+30h] [bp-10h]@57
  signed int v21; // [sp+38h] [bp-8h]@36
  _DWORD *v22; // [sp+3Ch] [bp-4h]@32

  v7 = this;
  v11 = 20 * *(_DWORD *)(this + 20) + *(_DWORD *)(this + 8);
  v12 = (a2 + 23) & 0xFFFFFFF0;
  v14 = (v12 >> 4) - 1;
  if ( v14 >= 32 )
  {
    v13 = 0;
    v9 = 0xFFFFFFFF >> ((v12 >> 4) - 33);
  }
  else
  {
    v13 = 0xFFFFFFFF >> v14;
    v9 = -1;
  }
  for ( i = *(_DWORD *)(this + 12); i < v11 && !(*(_DWORD *)(i + 4) & v9 | *(_DWORD *)i & v13); i += 20 )
    ;
  if ( i != v11 )
    goto LABEL_64;
  for ( i = *(_DWORD *)(this + 8); i < *(_DWORD *)(this + 12) && !(*(_DWORD *)(i + 4) & v9 | *(_DWORD *)i & v13); i += 20 )
    ;
  if ( i != *(_DWORD *)(this + 12) )
    goto LABEL_64;
  while ( i < v11 && !*(_DWORD *)(i + 8) )
    i += 20;
  if ( i == v11 )
  {
    for ( i = *(_DWORD *)(this + 8); i < *(_DWORD *)(this + 12) && !*(_DWORD *)(i + 8); i += 20 )
      ;
    if ( i == *(_DWORD *)(this + 12) )
    {
      i = MemoryAllocator::Alloc(this);
      if ( !i )
        return 0;
    }
  }
  **(_DWORD **)(i + 16) = sub_431104(i);
  if ( **(_DWORD **)(i + 16) != -1 )
  {
LABEL_64:
    *(_DWORD *)(v7 + 12) = i;
    v8 = *(_DWORD **)(i + 16);
    j = *v8;
    if ( *v8 == -1 || !(v8[j + 49] & v9 | v8[j + 17] & v13) )
    {
      for ( j = 0; !(v8[j + 49] & v9 | v8[j + 17] & v13); ++j )
        ;
    }
    v22 = &v8[129 * j + 81];
    v15 = 0;
    v16 = v8[j + 17] & v13;
    if ( !v16 )
    {
      v15 = 32;
      v16 = v8[j + 49] & v9;
    }
    while ( v16 >= 0 )
    {
      v16 *= 2;
      ++v15;
    }
    v19 = v22[2 * v15 + 1];
    v21 = *(_DWORD *)v19 - v12;
    v18 = (v21 >> 4) - 1;
    if ( v18 > 63 )
      v18 = 63;
    if ( v18 != v15 )
    {
      if ( *(_DWORD *)(v19 + 4) == *(_DWORD *)(v19 + 8) )
      {
        if ( v15 >= 32 )
        {
          v8[j + 49] &= ~(0x80000000 >> (v15 - 32));
          if ( !--*((_BYTE *)v8 + v15 + 4) )
            *(_DWORD *)(i + 4) &= ~(0x80000000 >> (v15 - 32));
        }
        else
        {
          v8[j + 17] &= ~(0x80000000 >> v15);
          if ( !--*((_BYTE *)v8 + v15 + 4) )
            *(_DWORD *)i &= ~(0x80000000 >> v15);
        }
      }
      *(_DWORD *)(*(_DWORD *)(v19 + 8) + 4) = *(_DWORD *)(v19 + 4);
      *(_DWORD *)(*(_DWORD *)(v19 + 4) + 8) = *(_DWORD *)(v19 + 8);
      if ( v21 )
      {
        v3 = (int)&v22[2 * v18];
        *(_DWORD *)(v19 + 4) = v22[2 * v18 + 1];
        *(_DWORD *)(v19 + 8) = v3;
        *(_DWORD *)(v3 + 4) = v19;
        *(_DWORD *)(*(_DWORD *)(v19 + 4) + 8) = v19;
        if ( *(_DWORD *)(v19 + 4) == *(_DWORD *)(v19 + 8) )
        {
          if ( v18 >= 32 )
          {
            v5 = (*((_BYTE *)v8 + v18 + 4))++;
            if ( !v5 )
              *(_DWORD *)(i + 4) |= 0x80000000 >> (v18 - 32);
            v8[j + 49] |= 0x80000000 >> (v18 - 32);
          }
          else
          {
            v4 = (*((_BYTE *)v8 + v18 + 4))++;
            if ( !v4 )
              *(_DWORD *)i |= 0x80000000 >> v18;
            v8[j + 17] |= 0x80000000 >> v18;
          }
        }
      }
    }
    if ( v21 )
    {
      *(_DWORD *)v19 = v21;
      *(_DWORD *)(v21 + v19 - 4) = v21;
    }
    v20 = v21 + v19;
    *(_DWORD *)v20 = v12 + 1;
    *(_DWORD *)(v12 + v20 - 4) = v12 + 1;
    v6 = (*v22)++;
    if ( !v6 && i == *(_DWORD *)(v7 + 24) && j == *(_DWORD *)(v7 + 28) )
      *(_DWORD *)(v7 + 24) = 0;
    *v8 = j;
    result = (_DWORD *)(v20 + 4);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00430FEE) --------------------------------------------------------
int __thiscall MemoryAllocator::Alloc(int this)
{
  int result; // eax@3
  int v2; // [sp+0h] [bp-8h]@1
  LPVOID v3; // [sp+4h] [bp-4h]@2
  int v4; // [sp+4h] [bp-4h]@5

  v2 = this;
  if ( *(_DWORD *)(this + 20) == *(_DWORD *)(this + 16) )
  {
    v3 = HeapReAlloc(*(HANDLE *)this, 0, *(LPVOID *)(this + 8), 20 * (*(_DWORD *)(this + 16) + 16));
    if ( !v3 )
      return 0;
    *(_DWORD *)(v2 + 8) = v3;
    *(_DWORD *)(v2 + 16) += 16;
  }
  v4 = 20 * *(_DWORD *)(v2 + 20) + *(_DWORD *)(v2 + 8);
  *(_DWORD *)(v4 + 16) = HeapAlloc(*(HANDLE *)v2, 8u, 0x41C4u);
  if ( *(_DWORD *)(v4 + 16) )
  {
    *(_DWORD *)(v4 + 12) = VirtualAlloc(0, 0x200000u, 0x2000u, 4u);
    if ( *(_DWORD *)(v4 + 12) )
    {
      *(_DWORD *)v4 = 0;
      *(_DWORD *)(v4 + 4) = 0;
      *(_DWORD *)(v4 + 8) = -1;
      ++*(_DWORD *)(v2 + 20);
      **(_DWORD **)(v4 + 16) = -1;
      result = v4;
    }
    else
    {
      HeapFree(*(HANDLE *)v2, 0, *(LPVOID *)(v4 + 16));
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00431104) --------------------------------------------------------
signed int __stdcall sub_431104(int a1)
{
  signed int result; // eax@8
  int v2; // ST28_4@11
  int v3; // edx@12
  int v4; // [sp+4h] [bp-2Ch]@1
  signed int v5; // [sp+8h] [bp-28h]@1
  signed int i; // [sp+10h] [bp-20h]@4
  char *lpAddress; // [sp+20h] [bp-10h]@7
  int v8; // [sp+24h] [bp-Ch]@4
  int v9; // [sp+28h] [bp-8h]@1
  unsigned int j; // [sp+2Ch] [bp-4h]@9

  v4 = *(_DWORD *)(a1 + 16);
  v9 = *(_DWORD *)(a1 + 8);
  v5 = 0;
  while ( v9 >= 0 )
  {
    v9 *= 2;
    ++v5;
  }
  v8 = v4 + 516 * v5 + 324;
  for ( i = 0; i < 63; ++i )
  {
    *(_DWORD *)(v8 + 8 * i + 8) = v8 + 8 * i;
    *(_DWORD *)(v8 + 8 * i + 4) = v8 + 8 * i;
  }
  lpAddress = (char *)((v5 << 16) + *(_DWORD *)(a1 + 12));
  if ( VirtualAlloc(lpAddress, 0x10000u, 0x1000u, 4u) )
  {
    for ( j = (unsigned int)lpAddress; j <= (unsigned int)(lpAddress + 57344); j += 0x2000 )
    {
      *(_DWORD *)(j + 8) = -1;
      *(_DWORD *)(j + 8188) = -1;
      v2 = j + 12;
      *(_DWORD *)(j + 12) = 8176;
      *(_DWORD *)(v2 + 4) = v2 + 0x2000;
      *(_DWORD *)(v2 + 8) = v2 - 0x2000;
      *(_DWORD *)(v2 + 8172) = 8176;
    }
    *(_DWORD *)(v4 + 516 * v5 + 832) = lpAddress + 12;
    *(_DWORD *)(*(_DWORD *)(v4 + 516 * v5 + 832) + 8) = v4 + 516 * v5 + 828;
    *(_DWORD *)(v4 + 516 * v5 + 836) = lpAddress + 57356;
    *(_DWORD *)(*(_DWORD *)(v4 + 516 * v5 + 836) + 4) = v4 + 516 * v5 + 828;
    *(_DWORD *)(v4 + 4 * v5 + 68) = 0;
    *(_DWORD *)(v4 + 4 * v5 + 196) = 1;
    v3 = (*(_BYTE *)(v4 + 67))++;
    if ( !v3 )
      *(_DWORD *)(a1 + 4) |= 1u;
    *(_DWORD *)(a1 + 8) &= ~(0x80000000 >> v5);
    result = v5;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (004312F7) --------------------------------------------------------
void __cdecl delete_table(int a1)
{
  int v1; // [sp+4h] [bp-8h]@2
  LPVOID lpMem; // [sp+8h] [bp-4h]@2

  if ( a1 )
  {
    lpMem = (LPVOID)(a1 - 4);
    v1 = *(_DWORD *)(a1 - 4);
    if ( *(_DWORD *)(v1 + 4) != 1016 )
      v0 = 0;
    *(_DWORD *)lpMem = 0;
    sub_43134E((HANDLE *)v1, lpMem);
  }
}

//----- (0043134E) --------------------------------------------------------
void __thiscall sub_43134E(HANDLE *this, LPVOID lpMem)
{
  HANDLE *v2; // [sp+0h] [bp-8h]@1
  unsigned int v3; // [sp+4h] [bp-4h]@1

  v2 = this;
  MemoryAllocator::lockGuardEnter((int)this);
  v3 = sub_4313A6((int)v2, (int)lpMem);
  if ( v3 )
    sub_431401((int)v2, v3, (int)lpMem);
  else
    HeapFree(*v2, 0, lpMem);
  MemoryAllocator::lockGuardExit((int)v2);
}

//----- (004313A6) --------------------------------------------------------
unsigned int __thiscall sub_4313A6(int this, int a2)
{
  unsigned int i; // [sp+8h] [bp-8h]@1

  for ( i = *(_DWORD *)(this + 8); i < 20 * *(_DWORD *)(this + 20) + *(_DWORD *)(this + 8); i += 20 )
  {
    if ( (unsigned int)(a2 - *(_DWORD *)(i + 12)) < 0x200000 )
      return i;
  }
  return 0;
}

//----- (00431401) --------------------------------------------------------
int __thiscall sub_431401(int this, unsigned int a2, int a3)
{
  int result; // eax@1
  int v4; // ST30_4@32
  int v5; // edx@34
  int v6; // edx@37
  int v7; // [sp+4h] [bp-40h]@1
  int v8; // [sp+8h] [bp-3Ch]@1
  int v9; // [sp+Ch] [bp-38h]@2
  int v10; // [sp+10h] [bp-34h]@16
  signed int v11; // [sp+14h] [bp-30h]@1
  unsigned int v12; // [sp+18h] [bp-2Ch]@0
  unsigned int v13; // [sp+1Ch] [bp-28h]@13
  unsigned int v14; // [sp+20h] [bp-24h]@3
  int v15; // [sp+28h] [bp-1Ch]@1
  signed int v16; // [sp+30h] [bp-14h]@2
  signed int v17; // [sp+38h] [bp-Ch]@2
  _DWORD *v18; // [sp+3Ch] [bp-8h]@1
  unsigned int v19; // [sp+40h] [bp-4h]@1

  v7 = this;
  v8 = *(_DWORD *)(a2 + 16);
  v19 = (unsigned int)(a3 - *(_DWORD *)(a2 + 12)) >> 16;
  v18 = (_DWORD *)(v8 + 516 * v19 + 324);
  v15 = a3 - 4;
  result = a3 - 4;
  v11 = *(_DWORD *)(a3 - 4) - 1;
  if ( !(v11 & 1) )
  {
    v9 = v11 + v15;
    v16 = *(_DWORD *)(v11 + v15);
    v17 = *(_DWORD *)(a3 - 8);
    if ( !(v16 & 1) )
    {
      v14 = (v16 >> 4) - 1;
      if ( v14 > 0x3F )
        v14 = 63;
      if ( *(_DWORD *)(v9 + 4) == *(_DWORD *)(v9 + 8) )
      {
        if ( v14 >= 0x20 )
        {
          *(_DWORD *)(v8 + 4 * v19 + 196) &= ~(0x80000000 >> (v14 - 32));
          if ( !--*(_BYTE *)(v14 + v8 + 4) )
            *(_DWORD *)(a2 + 4) &= ~(0x80000000 >> (v14 - 32));
        }
        else
        {
          *(_DWORD *)(v8 + 4 * v19 + 68) &= ~(0x80000000 >> v14);
          if ( !--*(_BYTE *)(v14 + v8 + 4) )
            *(_DWORD *)a2 &= ~(0x80000000 >> v14);
        }
      }
      *(_DWORD *)(*(_DWORD *)(v9 + 8) + 4) = *(_DWORD *)(v9 + 4);
      *(_DWORD *)(*(_DWORD *)(v9 + 4) + 8) = *(_DWORD *)(v9 + 8);
      v11 += v16;
    }
    v13 = (v11 >> 4) - 1;
    if ( v13 > 0x3F )
      v13 = 63;
    if ( !(v17 & 1) )
    {
      v10 = v15 - v17;
      v12 = (v17 >> 4) - 1;
      if ( v12 > 0x3F )
        v12 = 63;
      v11 += v17;
      v13 = (v11 >> 4) - 1;
      if ( v13 > 0x3F )
        v13 = 63;
      if ( v12 != v13 )
      {
        if ( *(_DWORD *)(v10 + 4) == *(_DWORD *)(v10 + 8) )
        {
          if ( v12 >= 0x20 )
          {
            *(_DWORD *)(v8 + 4 * v19 + 196) &= ~(0x80000000 >> (v12 - 32));
            if ( !--*(_BYTE *)(v12 + v8 + 4) )
              *(_DWORD *)(a2 + 4) &= ~(0x80000000 >> (v12 - 32));
          }
          else
          {
            *(_DWORD *)(v8 + 4 * v19 + 68) &= ~(0x80000000 >> v12);
            if ( !--*(_BYTE *)(v12 + v8 + 4) )
              *(_DWORD *)a2 &= ~(0x80000000 >> v12);
          }
        }
        *(_DWORD *)(*(_DWORD *)(v10 + 8) + 4) = *(_DWORD *)(v10 + 4);
        *(_DWORD *)(*(_DWORD *)(v10 + 4) + 8) = *(_DWORD *)(v10 + 8);
      }
      v15 -= v17;
    }
    if ( v17 & 1 || v12 != v13 )
    {
      v4 = (int)&v18[2 * v13];
      *(_DWORD *)(v15 + 4) = v18[2 * v13 + 1];
      *(_DWORD *)(v15 + 8) = v4;
      *(_DWORD *)(v4 + 4) = v15;
      *(_DWORD *)(*(_DWORD *)(v15 + 4) + 8) = v15;
      if ( *(_DWORD *)(v15 + 4) == *(_DWORD *)(v15 + 8) )
      {
        if ( v13 >= 0x20 )
        {
          v6 = (*(_BYTE *)(v13 + v8 + 4))++;
          if ( !v6 )
            *(_DWORD *)(a2 + 4) |= 0x80000000 >> (v13 - 32);
          *(_DWORD *)(v8 + 4 * v19 + 196) |= 0x80000000 >> (v13 - 32);
        }
        else
        {
          v5 = (*(_BYTE *)(v13 + v8 + 4))++;
          if ( !v5 )
            *(_DWORD *)a2 |= 0x80000000 >> v13;
          *(_DWORD *)(v8 + 4 * v19 + 68) |= 0x80000000 >> v13;
        }
      }
    }
    *(_DWORD *)v15 = v11;
    *(_DWORD *)(v11 + v15 - 4) = v11;
    result = *v18 - 1;
    *v18 = result;
    if ( !*v18 )
    {
      if ( *(_DWORD *)(this + 24) )
      {
        VirtualFree(
          (LPVOID)((*(_DWORD *)(this + 28) << 16) + *(_DWORD *)(*(_DWORD *)(this + 24) + 12)),
          0x10000u,
          0x4000u);
        *(_DWORD *)(*(_DWORD *)(v7 + 24) + 8) |= 0x80000000 >> *(_DWORD *)(v7 + 28);
        *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v7 + 24) + 16) + 4 * *(_DWORD *)(v7 + 28) + 196) = 0;
        if ( !--*(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v7 + 24) + 16) + 67) )
          *(_DWORD *)(*(_DWORD *)(v7 + 24) + 4) &= 0xFFFFFFFE;
        if ( *(_DWORD *)(*(_DWORD *)(v7 + 24) + 8) == -1 )
        {
          VirtualFree(*(LPVOID *)(*(_DWORD *)(v7 + 24) + 12), 0, 0x8000u);
          HeapFree(*(HANDLE *)v7, 0, *(LPVOID *)(*(_DWORD *)(v7 + 24) + 16));
          memmove(
            *(void **)(v7 + 24),
            (const void *)(*(_DWORD *)(v7 + 24) + 20),
            20 * *(_DWORD *)(v7 + 20) + *(_DWORD *)(v7 + 8) - (*(_DWORD *)(v7 + 24) + 20));
          --*(_DWORD *)(v7 + 20);
          if ( a2 > *(_DWORD *)(v7 + 24) )
            a2 -= 20;
          *(_DWORD *)(v7 + 12) = *(_DWORD *)(v7 + 8);
        }
      }
      *(_DWORD *)(v7 + 24) = a2;
      result = v7;
      *(_DWORD *)(v7 + 28) = v19;
    }
  }
  return result;
}

//----- (004319EC) --------------------------------------------------------
int SomeStaticInit1()
{
  SomeBitsInit();
  return sub_4319FB();
}

//----- (004319FB) --------------------------------------------------------
int sub_4319FB()
{
  return atexit(emptystub);
}

//----- (00431A10) --------------------------------------------------------
void *__thiscall MemoryAllocatorsCallDestructor(void *this, char a2)
{
  void *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  MemoryAllocators::Destructor(this);
  if ( a2 & 1 )
    _delete_table(v3);
  return v3;
}

//----- (00431A40) --------------------------------------------------------
void *__thiscall MemoryAllocators::Free(void *this, char a2)
{
  void *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  sub_430855(this);
  if ( a2 & 1 )
    _delete_table(v3);
  return v3;
}

//----- (00431A70) --------------------------------------------------------
void __thiscall MemoryAllocator::lockGuardEnter(int this)
{
  EnterCriticalSection((LPCRITICAL_SECTION)(this + 32));
}

//----- (00431A90) --------------------------------------------------------
void __thiscall MemoryAllocator::lockGuardExit(int this)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(this + 32));
}

//----- (00431AB0) --------------------------------------------------------
int StaticInitFor_CAuthPacketPool::g_slot()
{
  CAuthPacketPool::g_slot_construction();
  return CAuthPacketPool::g_slot_registerDtor();
}

//----- (00431ABF) --------------------------------------------------------
int CAuthPacketPool::g_slot_construction()
{
  return `eh vector constructor iterator'(
           CAuthPacketPool::g_slot,
           0x24u,
           16,
           (int)CAuthSlot::CAuthSlot,
           (void (__thiscall *)(void *))CAuthSlot::Destructor);
}

//----- (00431ADC) --------------------------------------------------------
int CAuthPacketPool::g_slot_registerDtor()
{
  return atexit(CAuthPacketPool::g_slot_destruction);
}

//----- (00431AEE) --------------------------------------------------------
void __cdecl CAuthPacketPool::g_slot_destruction()
{
  if ( !(byte_480419 & 1) )
  {
    byte_480419 |= 1u;
    `eh vector destructor iterator'(
      CAuthPacketPool::g_slot,
      0x24u,
      16,
      (void (__thiscall *)(void *))CAuthSlot::Destructor);
  }
}
// 480419: using guessed type char byte_480419;

//----- (00431B23) --------------------------------------------------------
int StaticInitFor_CAuthPacketPool()
{
  StaticCallFor_CAuthPacketPool();
  return Register_StaticCallFor_CAuthPacketPoolDestructor();
}

//----- (00431B32) --------------------------------------------------------
void StaticCallFor_CAuthPacketPool()
{
  ;
}

//----- (00431B37) --------------------------------------------------------
int Register_StaticCallFor_CAuthPacketPoolDestructor()
{
  return atexit(CallFor_CAuthPacketPoolDestructor);
}

//----- (00431B49) --------------------------------------------------------
void __cdecl CallFor_CAuthPacketPoolDestructor()
{
  CAuthPacketPool::Destructor();
}

//----- (00431B58) --------------------------------------------------------
CAuthPacket *__cdecl CAuthPacket::Alloc()
{
  CAuthPacket *v1; // [sp+0h] [bp-20h]@4
  CAuthPacket *v2; // [sp+4h] [bp-1Ch]@3
  CAuthSlot *pSlot; // [sp+Ch] [bp-14h]@1
  WorldSrvPacket *v4; // [sp+10h] [bp-10h]@1

  pSlot = &CAuthPacketPool::g_slot[InterlockedIncrement(&CAuthPacketPool::g_nAlloc) & 0xF];
  SpinLock::Enter(&pSlot->m_lock);
  v4 = &pSlot->m_pPacket->base;
  if ( pSlot->m_pPacket )
  {
    pSlot->m_pPacket = (CAuthPacket *)v4->m_pSocket;
    SpinLock::Leave(&pSlot->m_lock);
  }
  else
  {
    SpinLock::Leave(&pSlot->m_lock);
    v2 = (CAuthPacket *)operator_new(0x14u);
    if ( v2 )
      v1 = CAuthPacket::CAuthPacket(v2);
    else
      v1 = 0;
    v4 = (WorldSrvPacket *)v1;
  }
  return (CAuthPacket *)v4;
}

//----- (00431C1A) --------------------------------------------------------
void __thiscall CAuthPacket::Free(CAuthPacket *this)
{
  CAuthPacket *v1; // ST04_4@1
  CAuthSlot *v2; // ST08_4@1

  v1 = this;
  v2 = &CAuthPacketPool::g_slot[InterlockedDecrement(&CAuthPacketPool::g_nFree) & 0xF];
  SpinLock::Enter(&v2->m_lock);
  v1->base.m_pSocket = (CIOSocket *)v2->m_pPacket;
  v2->m_pPacket = v1;
  SpinLock::Leave(&v2->m_lock);
}

//----- (00431C69) --------------------------------------------------------
void CAuthPacket::FreeAll()
{
  CAuthSlot *v0; // [sp+Ch] [bp-Ch]@3
  CAuthPacket *v1; // [sp+10h] [bp-8h]@4
  signed int i; // [sp+14h] [bp-4h]@1

  for ( i = 0; i < 16; ++i )
  {
    v0 = &CAuthPacketPool::g_slot[i];
    SpinLock::Enter(&CAuthPacketPool::g_slot[i].m_lock);
    while ( 1 )
    {
      v1 = v0->m_pPacket;
      if ( !v0->m_pPacket )
        break;
      v0->m_pPacket = (CAuthPacket *)v1->base.m_pSocket;
      if ( v1 )
        v1->base.base.vftbl_0_45F520->DestructorCall((MemoryObject *)v1, 1);
    }
    SpinLock::Leave(&v0->m_lock);
  }
}

//----- (00431CF7) --------------------------------------------------------
void __thiscall CAuthPacket::OnIOCallback(CAuthPacket *this, int bSuccess, int dwTransferred, int lpOverlapped)
{
  CAuthPacket *this_; // [sp+0h] [bp-8h]@1

  this_ = this;
  if ( ((int (__cdecl *)(_DWORD, _DWORD))this->base.m_pFunc)(
         this->base.m_pSocket,
         &this->base.m_pBuf->m_Buffer[dwTransferred + 1]) & 0xFF )
    CIOSocket::Close(this_->base.m_pSocket);
  MemoryObject::Release(&this_->base.m_pSocket->base);
  CIOBuffer::Release(this_->base.m_pBuf);
  InterlockedDecrement(&CAuthPacket::g_nPendingPacket);
  CAuthPacket::Free(this_);
}

//----- (00431D6A) --------------------------------------------------------
int sub_431D6A()
{
  SomeBitsInit();
  return sub_431D79();
}

//----- (00431D79) --------------------------------------------------------
int sub_431D79()
{
  return atexit(emptystub);
}

//----- (00431D90) --------------------------------------------------------
CAuthSlot *__thiscall CAuthSlot::CAuthSlot(CAuthSlot *this)
{
  CAuthSlot *v1; // ST08_4@1

  v1 = this;
  this->m_pPacket = 0;
  SpinLock::SpinLock(&this->m_lock, LockType_WaitLock, 0);
  return v1;
}

//----- (00431DC0) --------------------------------------------------------
// Microsoft VisualC 2-11/net runtime
void __thiscall CAuthSlot::Destructor(CAuthSlot *this)
{
  SpinLock::Destructor(&this->m_lock);
}

//----- (00431DE0) --------------------------------------------------------
void CAuthPacketPool::Destructor()
{
  CAuthPacket::FreeAll();
}

//----- (00431DF0) --------------------------------------------------------
CAuthPacket *__thiscall CAuthPacket::CAuthPacket(CAuthPacket *this)
{
  CAuthPacket *v1; // ST00_4@1

  v1 = this;
  MemoryObject::MemoryObject(&this->base.base);
  v1->base.base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&CAuthPacket_vtable_off_45F8E4;
  return v1;
}
// 45F8E4: using guessed type int (__stdcall *CAuthPacket_vtable_off_45F8E4)(int);

//----- (00431E10) --------------------------------------------------------
CAuthPacket *__thiscall CAuthPacket::CallDTor(CAuthPacket *this, char a2)
{
  CAuthPacket *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  CAuthPacket::Destructor(this);
  if ( a2 & 1 )
    operator_delete(v3);
  return v3;
}

//----- (00431E40) --------------------------------------------------------
// Microsoft VisualC 2-11/net runtime
MemoryObject *__thiscall CAuthPacket::Destructor(CAuthPacket *this)
{
  return MemoryObject::Destructor(&this->base.base);
}

//----- (00431E60) --------------------------------------------------------
Symbol __cdecl Config::readToken(void *a1, char *token, bool lookForWord)
{
  int v3; // edx@1
  Symbol result; // eax@2
  int v5; // edx@19
  int v6; // edx@26
  int v7; // edx@32
  int v8; // edx@49
  signed int index; // [sp+4h] [bp-Ch]@18
  char *token_; // [sp+8h] [bp-8h]@18
  char symbol; // [sp+Ch] [bp-4h]@3

  if ( (unsigned __int8)std::basic_ios::eof((char *)a1 + *(_DWORD *)(*(_DWORD *)a1 + 4)) )
    return Sym_EoF;
  do
    strstream::getc(v3, (int)a1, &symbol);
  while ( Reader::is_whiteSpace(symbol)
       && !(unsigned __int8)std::basic_ios::eof((char *)a1 + *(_DWORD *)(*(_DWORD *)a1 + 4)) );
  if ( (unsigned __int8)std::basic_ios::eof((char *)a1 + *(_DWORD *)(*(_DWORD *)a1 + 4)) )
    return Sym_EoF;
  switch ( symbol )
  {
    case '.':
      return Sym_Dot;
    case ',':
      return Sym_Comma;
    case ':':
      return Sym_Colon;
    case ';':
      return Sym_SemiColon;
    case '=':
      return Sym_Eqaul;
    case '/':
      return Sym_Slash;
    case '&':
      return Sym_Ampersand;
    case '(':
      return Sym_OpenBracer;
    case ')':
      return Sym_CloseBracer;
    case '\n':
      return Sym_NewLine;
    default:
      token_ = token;
      index = 0;
      if ( symbol != '-' )                      // negatives
        goto LABEL_22;
      strstream::getc('-', (int)a1, &symbol);
      if ( Reader::is_digit(symbol) )
      {
        *token = '-';
        token_ = token + 1;
        index = 1;
LABEL_22:
        if ( Reader::is_digit(symbol) )
        {
          do
          {
            *token_++ = symbol;
            strstream::getc(++index, (int)a1, &symbol);
          }
          while ( Reader::is_digit(symbol)
               && index < 'F'
               && !(unsigned __int8)std::basic_ios::eof((char *)a1 + *(_DWORD *)(*(_DWORD *)a1 + 4)) );
          if ( !(unsigned __int8)std::basic_ios::eof((char *)a1 + *(_DWORD *)(*(_DWORD *)a1 + 4)) )
            std::basic_istream::putback((int)a1, v6, symbol);
          *token_ = 0;
          if ( lookForWord )
            result = Sym_Word;
          else
            result = Sym_Digit;
        }
        else if ( symbol == '"' )
        {
          strstream::getc((int)a1, (int)a1, &symbol);
          while ( symbol != '"'
               && symbol != '\n'
               && index < 'F'
               && !(unsigned __int8)std::basic_ios::eof((char *)a1 + *(_DWORD *)(*(_DWORD *)a1 + 4)) )
          {
            *token_++ = symbol;
            ++index;
            strstream::getc((int)&symbol, (int)a1, &symbol);
          }
          if ( symbol == '\n' )
          {
            LOBYTE(v7) = symbol;
            std::basic_istream::putback((int)a1, v7, symbol);
          }
          *token_ = 0;
          result = Sym_Word;
        }
        else if ( Reader::is_alpha(symbol)
               || (signed int)(unsigned __int8)symbol >= 161 && (signed int)(unsigned __int8)symbol < 254 )
        {
          do
          {
            *token_++ = symbol;
            ++index;
            strstream::getc((int)&symbol, (int)a1, &symbol);
          }
          while ( (Reader::is_alpha(symbol)
                || (signed int)(unsigned __int8)symbol >= 161 && (signed int)(unsigned __int8)symbol < 254
                || symbol == '_')
               && !(unsigned __int8)std::basic_ios::eof((char *)a1 + *(_DWORD *)(*(_DWORD *)a1 + 4)) );
          if ( !(unsigned __int8)std::basic_ios::eof((char *)a1 + *(_DWORD *)(*(_DWORD *)a1 + 4)) )
          {
            std::basic_istream::putback((int)a1, v8, symbol);
            if ( (unsigned __int8)sub_432700((char *)a1 + *(_DWORD *)(*(_DWORD *)a1 + 4)) )
              LogWindow::Add(&g_LogWindow, 3, aPutback);
          }
          *token_ = 0;
          result = Sym_Word;
        }
        else
        {
          LogWindow::Add(&g_LogWindow, 3, aUnexpectedChar, (unsigned __int8)symbol);
          result = Sym_EoF;
        }
      }
      else
      {
        std::basic_istream::putback((int)a1, v5, symbol);
        result = 3;
      }
      return result;
  }
}

//----- (0043230C) --------------------------------------------------------
int sub_43230C()
{
  SomeBitsInit();
  return sub_43231B();
}

//----- (0043231B) --------------------------------------------------------
int sub_43231B()
{
  return atexit(emptystub);
}

//----- (00432330) --------------------------------------------------------
bool __cdecl Reader::is_digit(char a1)
{
  return a1 >= '0' && a1 <= '9';
}

//----- (00432360) --------------------------------------------------------
bool __cdecl Reader::is_whiteSpace(char a1)
{
  return a1 == ' ' || a1 == '\t' || a1 == '\r';
}

//----- (004323A0) --------------------------------------------------------
bool __cdecl Reader::is_alpha(char a1)
{
  return a1 >= 'a' && a1 <= 'z' || a1 >= 'A' && a1 <= 'Z';
}

//----- (004323E0) --------------------------------------------------------
int __fastcall std::basic_istream::putback(int a1, int a2, char a3)
{
  int v4; // [sp+0h] [bp-40h]@1
  int v5; // [sp+Ch] [bp-34h]@2
  int v6; // [sp+10h] [bp-30h]@2
  int v7; // [sp+14h] [bp-2Ch]@2
  void *v8; // [sp+18h] [bp-28h]@2
  int v9; // [sp+1Ch] [bp-24h]@1
  int v10; // [sp+20h] [bp-20h]@2
  int v11; // [sp+24h] [bp-1Ch]@2
  char v12; // [sp+28h] [bp-18h]@1
  int v13; // [sp+2Ch] [bp-14h]@1
  int *v14; // [sp+30h] [bp-10h]@1
  int v15; // [sp+3Ch] [bp-4h]@2

  v14 = &v4;
  v9 = a1;
  v13 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  Myis::sentry(&v12, a2, v9, 1);
  if ( sub_420340(&v12) )
  {
    v15 = 0;
    v8 = (void *)unknown_libname_110(*(_DWORD *)(*(_DWORD *)v9 + 4) + v9);
    v7 = sub_4324F0(v8, a3);
    v11 = v7;
    v6 = std::char_traits<char>::eof();
    v10 = v6;
    LOBYTE(v5) = std::char_traits<char>::eq_int_type(&v10, &v11);
    if ( (_BYTE)v5 )
      v13 |= 4u;
    v15 = -1;
  }
  I_setstate((void *)(*(_DWORD *)(*(_DWORD *)v9 + 4) + v9), v13, 0);
  return v9;
}
// 40B4D0: using guessed type int std::char_traits<char>::eof(void);
// 40B590: using guessed type _DWORD __cdecl std::char_traits<char>::eq_int_type(_DWORD, _DWORD);
// 4202F0: using guessed type int __thiscall unknown_libname_110(_DWORD);

//----- (004324F0) --------------------------------------------------------
int __thiscall sub_4324F0(void *this, char a2)
{
  unsigned int v2; // esi@2
  int v3; // eax@3
  int v4; // eax@4
  int v5; // eax@5
  int v7; // [sp+4h] [bp-8h]@4
  void *v8; // [sp+8h] [bp-4h]@1

  v8 = this;
  if ( std::basic_streambuf<wchar_t,std::char_traits<wchar_t>>::gptr(this)
    && (v2 = std::basic_streambuf<wchar_t,std::char_traits<wchar_t>>::eback(v8),
        v2 < std::basic_streambuf<wchar_t,std::char_traits<wchar_t>>::gptr(v8))
    && (v3 = std::basic_streambuf<wchar_t,std::char_traits<wchar_t>>::gptr(v8), sub_432580(&a2, (_BYTE *)(v3 - 1))) )
  {
    v4 = std::basic_streambuf<char,std::char_traits<char>>::_Gndec(v8);
    v7 = std::char_traits<char>::to_int_type(v4);
  }
  else
  {
    v5 = std::char_traits<char>::to_int_type(&a2);
    v7 = (*(int (__thiscall **)(void *, int))(*(_DWORD *)v8 + 8))(v8, v5);
  }
  return v7;
}
// 40B580: using guessed type _DWORD __cdecl std::char_traits<char>::to_int_type(_DWORD);
// 40B6E0: using guessed type int __thiscall std::basic_streambuf<wchar_t,std::char_traits<wchar_t>>::gptr(_DWORD);
// 420740: using guessed type int __thiscall std::basic_streambuf<wchar_t,std::char_traits<wchar_t>>::eback(_DWORD);
// 420770: using guessed type int __thiscall std::basic_streambuf<char,std::char_traits<char>>::_Gndec(_DWORD);

//----- (00432580) --------------------------------------------------------
bool __cdecl sub_432580(_BYTE *a1, _BYTE *a2)
{
  return *a1 == *a2;
}

//----- (004325A0) --------------------------------------------------------
int __usercall strstream::getc@<eax>(int a1@<edx>, int a2, _BYTE *a3)
{
  return basic_iostream::getc(a1, a2, a3);
}

//----- (004325C0) --------------------------------------------------------
int __usercall basic_iostream::getc@<eax>(int a1@<edx>, int a2, _BYTE *a3)
{
  int v4; // [sp+0h] [bp-40h]@1
  char v5; // [sp+Fh] [bp-31h]@4
  int v6; // [sp+10h] [bp-30h]@2
  int v7; // [sp+14h] [bp-2Ch]@2
  int v8; // [sp+18h] [bp-28h]@2
  int v9; // [sp+1Ch] [bp-24h]@2
  int v10; // [sp+20h] [bp-20h]@2
  char v11; // [sp+24h] [bp-1Ch]@1
  int v12; // [sp+28h] [bp-18h]@2
  int v13; // [sp+2Ch] [bp-14h]@1
  int *v14; // [sp+30h] [bp-10h]@1
  int v15; // [sp+3Ch] [bp-4h]@2

  v14 = &v4;
  v13 = 0;
  Myis::sentry(&v11, a1, a2, 0);
  if ( sub_420340(&v11) )
  {
    v15 = 0;
    v9 = unknown_libname_110(*(_DWORD *)(*(_DWORD *)a2 + 4) + a2);
    v8 = std::basic_streambuf<char,std::char_traits<char>>::sbumpc(v9);
    v12 = v8;
    v7 = std::char_traits<char>::eof();
    v10 = v7;
    LOBYTE(v6) = std::char_traits<char>::eq_int_type(&v10, &v12);
    if ( (_BYTE)v6 )
    {
      v13 |= 3u;
    }
    else
    {
      v5 = std::char_traits<char>::to_char_type(&v12);
      *a3 = v5;
    }
    v15 = -1;
  }
  I_setstate((void *)(*(_DWORD *)(*(_DWORD *)a2 + 4) + a2), v13, 0);
  return a2;
}
// 40B4D0: using guessed type int std::char_traits<char>::eof(void);
// 40B590: using guessed type _DWORD __cdecl std::char_traits<char>::eq_int_type(_DWORD, _DWORD);
// 40B6D0: using guessed type _DWORD __cdecl std::char_traits<char>::to_char_type(_DWORD);
// 4202F0: using guessed type int __thiscall unknown_libname_110(_DWORD);
// 4206E0: using guessed type int __thiscall std::basic_streambuf<char,std::char_traits<char>>::sbumpc(_DWORD);

//----- (004326E0) --------------------------------------------------------
int __thiscall std::basic_ios::eof(void *this)
{
  return unknown_libname_29((int)this) & 1;
}

//----- (00432700) --------------------------------------------------------
BOOL __thiscall sub_432700(void *this)
{
  return (unknown_libname_29((int)this) & 4) != 0;
}

//----- (00432720) --------------------------------------------------------
int StaticInitStatusLine()
{
  CallStatusLineCtor();
  return RegisterStatusLineDtor();
}

//----- (0043272F) --------------------------------------------------------
StatusLine *CallStatusLineCtor()
{
  return StatusLine::StatusLine(&g_StatusLine);
}

//----- (0043273E) --------------------------------------------------------
int RegisterStatusLineDtor()
{
  return atexit(CallStatusLineDtor);
}

//----- (00432750) --------------------------------------------------------
void __cdecl CallStatusLineDtor()
{
  StatusLine::Destructor(&g_StatusLine);
}

//----- (0043275F) --------------------------------------------------------
StatusLine *__thiscall StatusLine::StatusLine(StatusLine *this)
{
  StatusLine *v1; // ST04_4@1

  v1 = this;
  this->vftable = (int)&StatusLine_vtable_offset_45F8FC;
  this->font = 0;
  GetLocalTime(&this->systemTime);
  v1->users = 0;
  v1->sockets = 0;
  v1->field_16 = 0;
  v1->loggedUsers = 0;
  return v1;
}
// 45F8FC: using guessed type int (__stdcall *StatusLine_vtable_offset_45F8FC)(int);

//----- (004327B5) --------------------------------------------------------
StatusLine *__thiscall StatusLine::Destructor(StatusLine *this)
{
  StatusLine *result; // eax@1

  result = this;
  this->vftable = (int)&StatusLine_vtable_offset_45F8FC;
  return result;
}
// 45F8FC: using guessed type int (__stdcall *StatusLine_vtable_offset_45F8FC)(int);

//----- (004327C9) --------------------------------------------------------
StatusLine *__thiscall StatusLine::SetWindow(StatusLine *this, HWND a2)
{
  StatusLine *result; // eax@1

  result = this;
  this->statusLineWindow = a2;
  return result;
}

//----- (004327F0) --------------------------------------------------------
BOOL __thiscall StatusLine::updateTime(StatusLine *this)
{
  StatusLine *v1; // ST0C_4@1

  v1 = this;
  GetLocalTime(&this->systemTime);
  return InvalidateRect(v1->statusLineWindow, 0, 0);
}

//----- (00432819) --------------------------------------------------------
BOOL __thiscall StatusLine::Update(StatusLine *this)
{
  int v1; // eax@4
  StatusLine *v3; // [sp+0h] [bp-C8h]@1
  struct tagPAINTSTRUCT Paint; // [sp+4h] [bp-C4h]@1
  HDC hdc; // [sp+44h] [bp-84h]@1
  CHAR String[128]; // [sp+48h] [bp-80h]@4

  v3 = this;
  hdc = BeginPaint(this->statusLineWindow, &Paint);
  if ( v3->font )
  {
    SelectObject(hdc, v3->font);
  }
  else
  {
    v3->font = GetStockObject(16);
    SelectObject(hdc, v3->font);
    GetClientRect(v3->statusLineWindow, &v3->statusLineRect);
    v3->brush = (HBRUSH)GetStockObject(0);
    GetTextExtentPoint32A(hdc, asc_46CEC4, 1, (LPSIZE)&v3->textSize);
  }
  FillRect(hdc, &v3->statusLineRect, v3->brush);
  sprintf(String, aUser6dSocket4d, v3->users, v3->sockets, StatusLine::g_acceptCalls, StatusLine::g_nRunningThread);
  SetTextColor(hdc, 0);
  v1 = strlen(String);
  TextOutA(hdc, 0, 0, String, v1);
  return EndPaint(v3->statusLineWindow, &Paint);
}

//----- (0043297A) --------------------------------------------------------
BOOL __thiscall StatusLine::Move(StatusLine *this, int a2, int a3)
{
  this->statusLineRect.right = a2;
  this->statusLineRect.bottom = a3;
  return InvalidateRect(this->statusLineWindow, 0, 0);
}

//----- (004329AA) --------------------------------------------------------
int sub_4329AA()
{
  SomeBitsInit();
  return sub_4329B9();
}

//----- (004329B9) --------------------------------------------------------
int sub_4329B9()
{
  return atexit(emptystub);
}

//----- (004329D0) --------------------------------------------------------
StatusLine *__thiscall StatusLine::CallDestructor(StatusLine *this, char a2)
{
  StatusLine *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  StatusLine::Destructor(this);
  if ( a2 & 1 )
    _delete_table(v3);
  return v3;
}

//----- (00432A00) --------------------------------------------------------
int Static_InitMailServer()
{
  CallMailServerConstructor();
  return RegisterMailServerDestructor();
}

//----- (00432A0F) --------------------------------------------------------
MailServer *CallMailServerConstructor()
{
  return MailServer::MailServer(&g_mailServer);
}

//----- (00432A1E) --------------------------------------------------------
int RegisterMailServerDestructor()
{
  return atexit(CallMailServerDestructor);
}

//----- (00432A30) --------------------------------------------------------
void __cdecl CallMailServerDestructor()
{
  MailServer::Destructor(&g_mailServer);
}

//----- (00432A61) --------------------------------------------------------
SOCKET __thiscall MailServer::CloseSocket(MailServer *this)
{
  SOCKET oldSocket; // eax@1
  SOCKET s; // [sp+4h] [bp-8h]@1
  linger optval; // [sp+8h] [bp-4h]@2

  oldSocket = InterlockedExchange((volatile LONG *)this, -1);
  s = oldSocket;
  if ( oldSocket != -1 )
  {
    optval.l_linger = 0;
    optval.l_onoff = 1;
    setsockopt(oldSocket, SOL_SOCKET, SO_LINGER, (const char *)&optval, 4);
    oldSocket = closesocket(s);
  }
  return oldSocket;
}

//----- (00432AB3) --------------------------------------------------------
signed int __thiscall MailServer::Init(MailServer *this)
{
  signed int result; // eax@3
  char *v2; // eax@4
  MailServer *this_; // [sp+0h] [bp-8Ch]@1
  signed int serverNameLength; // [sp+4h] [bp-88h]@1
  char serverIp[128]; // [sp+8h] [bp-84h]@4
  struct hostent *host; // [sp+88h] [bp-4h]@1

  this_ = this;
  host = 0;
  serverNameLength = strlen(g_Config.Mailserver);
  if ( serverNameLength > 0 && serverNameLength <= 128 )
  {
    host = gethostbyname(g_Config.Mailserver);
    memset(serverIp, 0, 128u);
    v2 = inet_ntoa(**(struct in_addr **)host->h_addr_list);
    memcpy(serverIp, v2, 20u);
    this_->mailServerAddr.sin_family = SOCK_DGRAM;
    this_->mailServerAddr.sin_port = htons(25u);
    this_->mailServerAddr.sin_addr.S_un.S_addr = inet_addr(serverIp);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00432B89) --------------------------------------------------------
char *__thiscall MailServer::PrintErrorMessage(MailServer *this, DWORD dwMessageId, char *message)
{
  char *buffer; // [sp+4h] [bp-8h]@1
  DWORD size; // [sp+8h] [bp-4h]@1

  buffer = 0;
  size = FormatMessageA(0x3100u, 0, dwMessageId, 0, (LPSTR)&buffer, 0, 0);// FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_FROM_SYSTEM
  if ( size && (signed int)(size + 14) <= 1024 )
  {
    buffer[strlen(buffer) - 2] = 0;
    sprintf(message, aS0xX, buffer, dwMessageId);
  }
  else
  {
    *message = 0;
  }
  if ( buffer )
    LocalFree(buffer);
  return message;
}

//----- (00432C19) --------------------------------------------------------
int __thiscall MailServer::openSocket(MailServer *this)
{
  int result; // eax@2
  MailServer *this_; // [sp+0h] [bp-410h]@1
  char buf[1024]; // [sp+4h] [bp-40Ch]@7
  int optval; // [sp+404h] [bp-Ch]@1
  DWORD lastError; // [sp+408h] [bp-8h]@1
  int result_; // [sp+40Ch] [bp-4h]@1

  this_ = this;
  optval = 5000;
  lastError = 0;
  result_ = 0;
  this->socket = socket(2, 1, 0);
  if ( this_->socket == -1 )
  {
    lastError = GetLastError();
    result = 0;
  }
  else if ( setsockopt(this_->socket, SOL_SOCKET, SO_RCVTIMEO, (const char *)&optval, 4) == -1 )
  {
    lastError = GetLastError();
    result = 0;
  }
  else if ( setsockopt(this_->socket, SOL_SOCKET, SO_SNDTIMEO, (const char *)&optval, 4) == -1 )
  {
    lastError = GetLastError();
    result = 0;
  }
  else
  {
    memset(buf, 0, 0x400u);
    if ( connect(this_->socket, (const struct sockaddr *)&this_->mailServerAddr, 16) == -1 )
    {
      lastError = GetLastError();
    }
    else if ( recv(this_->socket, buf, 1024, 0) == -1 )
    {
      lastError = GetLastError();
    }
    else
    {
      result_ = 1;
    }
    if ( result_ )
    {
      if ( strncmp(buf, a220, 3u) )
      {
        MailServer::CloseSocket(this_);
        result_ = 0;
      }
    }
    else
    {
      MailServer::CloseSocket(this_);
    }
    result = result_;
  }
  return result;
}

//----- (00432D8F) --------------------------------------------------------
int __thiscall MailServer::SendMail(MailServer *this, char *mailTo, char *subj, char *body)
{
  MailServer *this_; // [sp+18h] [bp-24h]@1
  signed int subjLen; // [sp+1Ch] [bp-20h]@1
  signed int bodyLen; // [sp+1Ch] [bp-20h]@4
  signed int mailToLen; // [sp+1Ch] [bp-20h]@11
  int result_1; // [sp+20h] [bp-1Ch]@1

  this_ = this;
  result_1 = 0;
  subjLen = strlen(subj);
  if ( subjLen <= 0 || subjLen > 1024 )
    return 0;
  bodyLen = strlen(body);
  if ( bodyLen <= 0 || bodyLen > 1024 )
    return 0;
  if ( strchr(g_Config.Mailfrom, 64) )
  {
    if ( strchr(mailTo, 64) )
    {
      if ( strlen(g_Config.Mailfrom) > 4 && strlen(g_Config.Mailfrom) < 0x400 )
      {
        mailToLen = strlen(mailTo);
        if ( mailToLen > 4 && mailToLen < 1024 )
        {
          strcpy(this_->mails, mailTo);
          this_->mails[mailToLen] = 0;
          if ( !MailServer::openSocket(this_) )
            return 0;
          result_1 = MailServer::SendHello(this_);
          if ( result_1 )
          {
            result_1 = MailServer::SendMailFrom(this_);
            if ( result_1 )
            {
              result_1 = MailServer::SendRcptTo(this_);
              if ( result_1 )
              {
                result_1 = MailServer::SendMailBody(this_, subj, body);
                if ( result_1 )
                  result_1 = MailServer::SendQuit(this_);
              }
            }
          }
          if ( !result_1 )
            LogWindow::Add(&g_LogWindow, 3, aMailsendErrorS, body);
        }
      }
    }
  }
  return result_1;
}

//----- (00432FC9) --------------------------------------------------------
int __thiscall MailServer::SendHello(MailServer *this)
{
  int result; // eax@2
  size_t len; // ST14_4@3
  MailServer *this_; // [sp+0h] [bp-410h]@1
  char buf[1024]; // [sp+8h] [bp-408h]@1
  DWORD lastError; // [sp+408h] [bp-8h]@1
  int result_; // [sp+40Ch] [bp-4h]@1

  this_ = this;
  lastError = 0;
  result_ = 0;
  memset(buf, 0, 0x400u);
  if ( this_->socket == -1 )
  {
    result = 0;
  }
  else
  {
    strcpy(buf, aHeloMail_ncsof);
    len = strlen(buf);
    if ( send(this_->socket, buf, len, 0) == -1 )
    {
      lastError = GetLastError();
    }
    else
    {
      memset(buf, 0, 0x400u);
      if ( recv(this_->socket, buf, 1024, 0) == -1 )
        lastError = GetLastError();
      else
        result_ = 1;
    }
    if ( result_ )
    {
      if ( strncmp(buf, a250, 3u) )
      {
        MailServer::CloseSocket(this_);
        result_ = 0;
      }
    }
    else
    {
      MailServer::CloseSocket(this_);
    }
    result = result_;
  }
  return result;
}

//----- (00433100) --------------------------------------------------------
int __thiscall MailServer::SendMailFrom(MailServer *this)
{
  int result; // eax@2
  int len; // ST14_4@3
  MailServer *this_; // [sp+0h] [bp-410h]@1
  char buf[1024]; // [sp+8h] [bp-408h]@1
  DWORD lastError; // [sp+408h] [bp-8h]@1
  int result_; // [sp+40Ch] [bp-4h]@1

  this_ = this;
  lastError = 0;
  result_ = 0;
  memset(buf, 0, 0x400u);
  if ( this_->socket == -1 )
  {
    result = 0;
  }
  else
  {
    len = sprintf(buf, aMailFromS_0, g_Config.Mailfrom);
    if ( send(this_->socket, buf, len, 0) == -1 )
    {
      lastError = GetLastError();
    }
    else
    {
      memset(buf, 0, 0x400u);
      if ( recv(this_->socket, buf, 1024, 0) == -1 )
        lastError = GetLastError();
      else
        result_ = 1;
    }
    if ( result_ )
    {
      if ( strncmp(buf, a250_0, 3u) )
      {
        MailServer::CloseSocket(this_);
        result_ = 0;
      }
    }
    else
    {
      MailServer::CloseSocket(this_);
    }
    result = result_;
  }
  return result;
}

//----- (0043322F) --------------------------------------------------------
int __thiscall MailServer::SendRcptTo(MailServer *this)
{
  int result; // eax@2
  int len; // ST14_4@5
  MailServer *this_; // [sp+0h] [bp-814h]@1
  char buf[1024]; // [sp+8h] [bp-80Ch]@5
  DWORD lastError; // [sp+408h] [bp-40Ch]@1
  char mailsList[1024]; // [sp+40Ch] [bp-408h]@3
  char *i; // [sp+80Ch] [bp-8h]@3
  int result_; // [sp+810h] [bp-4h]@1

  this_ = this;
  lastError = 0;
  result_ = 0;
  if ( this->socket == -1 )
  {
    result = 0;
  }
  else
  {
    memset(mailsList, 0, 0x400u);
    strcpy(mailsList, this_->mails);
    for ( i = strtok(mailsList, asc_46CFBC); i; i = strtok(0, asc_46CFD4) )
    {
      memset(buf, 0, 0x400u);
      len = sprintf(buf, aRcptToS_0, i);
      if ( send(this_->socket, buf, len, 0) == -1 )
      {
        lastError = GetLastError();
      }
      else
      {
        memset(buf, 0, 0x400u);
        if ( recv(this_->socket, buf, 1024, 0) == -1 )
        {
          lastError = GetLastError();
        }
        else if ( !strncmp(buf, a250_1, 3u) )
        {
          result_ = 1;
        }
      }
    }
    if ( !result_ )
      MailServer::CloseSocket(this_);
    result = result_;
  }
  return result;
}

//----- (004333B7) --------------------------------------------------------
int __thiscall MailServer::SendMailBody(MailServer *this, char *subject, char *body)
{
  int result; // eax@2
  size_t len; // ST14_4@3
  int subjLen; // ST14_4@9
  int bodyLen; // ST14_4@11
  size_t v7; // ST14_4@13
  MailServer *this_; // [sp+0h] [bp-410h]@1
  char buf[1024]; // [sp+8h] [bp-408h]@1
  DWORD lastError; // [sp+408h] [bp-8h]@1
  int result_; // [sp+40Ch] [bp-4h]@1

  this_ = this;
  lastError = 0;
  result_ = 0;
  memset(buf, 0, 0x400u);
  if ( this_->socket == -1 )
  {
    result = 0;
  }
  else
  {
    strcpy(buf, aData_0);
    len = strlen(buf);
    if ( send(this_->socket, buf, len, 0) == -1 )
    {
      lastError = GetLastError();
    }
    else
    {
      memset(buf, 0, 0x400u);
      if ( recv(this_->socket, buf, 1024, 0) == -1 )
        lastError = GetLastError();
      else
        result_ = 1;
    }
    if ( result_ )
    {
      result_ = 0;
      memset(buf, 0, 0x400u);
      subjLen = sprintf(buf, aSubjectSToS, subject, this_->mails);
      if ( send(this_->socket, buf, subjLen, 0) == -1 )
      {
        lastError = GetLastError();
      }
      else
      {
        memset(buf, 0, 0x400u);
        bodyLen = sprintf(buf, aS_5, body);
        if ( send(this_->socket, buf, bodyLen, 0) == -1 )
        {
          lastError = GetLastError();
        }
        else
        {
          v7 = strlen(a__0);
          if ( send(this_->socket, byte_46D008, v7, 0) == -1 )// 354 End data with <CR><LF>.<CR><LF>
          {
            lastError = GetLastError();
          }
          else
          {
            memset(buf, 0, 0x400u);
            if ( recv(this_->socket, buf, 1024, 0) == -1 )
              lastError = GetLastError();
            else
              result_ = 1;
          }
        }
      }
    }
    if ( result_ )
    {
      if ( strncmp(buf, a250_3, 3u) )
      {
        MailServer::CloseSocket(this_);
        result_ = 0;
      }
    }
    else
    {
      MailServer::CloseSocket(this_);
    }
    result = result_;
  }
  return result;
}

//----- (00433661) --------------------------------------------------------
int __thiscall MailServer::SendQuit(MailServer *this)
{
  int result; // eax@2
  size_t len; // ST14_4@3
  MailServer *this_; // [sp+0h] [bp-410h]@1
  char buf[1024]; // [sp+8h] [bp-408h]@1
  DWORD lastError; // [sp+408h] [bp-8h]@1
  int result_; // [sp+40Ch] [bp-4h]@1

  this_ = this;
  lastError = 0;
  result_ = 0;
  memset(buf, 0, 0x400u);
  if ( this_->socket == -1 )
  {
    result = 0;
  }
  else
  {
    strcpy(buf, aQuit_0);
    len = strlen(buf);
    if ( send(this_->socket, buf, len, 0) == -1 )
      lastError = GetLastError();
    else
      result_ = 1;
    MailServer::CloseSocket(this_);
    result = result_;
  }
  return result;
}

//----- (0043371E) --------------------------------------------------------
int sub_43371E()
{
  SomeBitsInit();
  return sub_43372D();
}

//----- (0043372D) --------------------------------------------------------
int sub_43372D()
{
  return atexit(emptystub);
}

//----- (00433740) --------------------------------------------------------
int StaticInitForServerList()
{
  CallServerListConstructor();
  return RegisterServerListDestructor();
}

//----- (0043374F) --------------------------------------------------------
ServerList *CallServerListConstructor()
{
  return ServerList::ServerList(&g_ServerList);
}

//----- (0043375E) --------------------------------------------------------
int RegisterServerListDestructor()
{
  return atexit(CallServerListDestructor);
}

//----- (00433770) --------------------------------------------------------
void __cdecl CallServerListDestructor()
{
  ServerList::Destructor(&g_ServerList);
}

//----- (0043377F) --------------------------------------------------------
int StaticInitUserCountTable()
{
  CallUserCountTableCtor();
  return RegisterUserCountTableDtor();
}

//----- (0043378E) --------------------------------------------------------
UserCountTable *CallUserCountTableCtor()
{
  return UserCountTable::UserCountTable(&g_UserTable);
}

//----- (0043379D) --------------------------------------------------------
int RegisterUserCountTableDtor()
{
  return atexit(CallUserCountTableDtor);
}

//----- (004337AF) --------------------------------------------------------
void __cdecl CallUserCountTableDtor()
{
  UserCountTable::Destructor(&g_UserTable);
}

//----- (004337BE) --------------------------------------------------------
ServerList *__thiscall ServerList::ServerList(ServerList *this)
{
  ServerList *this_; // [sp+0h] [bp-18h]@1
  char a2; // [sp+4h] [bp-14h]@1
  int i; // [sp+8h] [bp-10h]@1
  int unused; // [sp+14h] [bp-4h]@1

  this_ = this;
  ReadWriteLock::ReadWriteLock(&this->m_rwLock);
  unused = 0;
  std::vector_ServerInfo::vector_ServerInfo(&this_->m_servers, &a2);
  this_->vftable = (int)&ServerList_vtable_off_45F90C;
  this_->m_serverCount = 0;
  this_->m_defaultOrCompressedSize = 0;
  this_->m_maxAgeLimit = 0;
  for ( i = 0; i < 10; ++i )
  {
    this_->m_frameLists[i] = 0;
    this_->m_frameSizes[i] = 0;
  }
  return this_;
}
// 45F90C: using guessed type int (__stdcall *ServerList_vtable_off_45F90C)(int);

//----- (0043387B) --------------------------------------------------------
void __thiscall ServerList::Destructor(ServerList *this)
{
  ServerList *this_; // [sp+0h] [bp-18h]@1
  signed int i; // [sp+8h] [bp-10h]@1

  this_ = this;
  this->vftable = (int)&ServerList_vtable_off_45F90C;
  for ( i = 1; i < 10; ++i )
  {
    if ( this_->m_frameLists[i] )
      _delete_table(this_->m_frameLists[i]);
  }
  std::vector_ServerInfo::Destructor2(&this_->m_servers);
  ReadWriteLock::Destructor(&this_->m_rwLock);
}
// 45F90C: using guessed type int (__stdcall *ServerList_vtable_off_45F90C)(int);

//----- (00433921) --------------------------------------------------------
void __thiscall ServerList::reload(ServerList *this)
{
  std::vector_ServerInfo::iterator *serverInfo; // eax@34
  ServerList *_this; // [sp+0h] [bp-46Ch]@1
  unsigned int i; // [sp+4h] [bp-468h]@32
  bool notFound_[4]; // [sp+8h] [bp-464h]@24
  int index; // [sp+Ch] [bp-460h]@24
  unsigned int currentServersSize; // [sp+10h] [bp-45Ch]@23
  LONG defaultOrCompressedSize; // [sp+14h] [bp-458h]@23
  bool notFound[4]; // [sp+18h] [bp-454h]@13
  int serverIdIndex_; // [sp+1Ch] [bp-450h]@13
  char *ageLimit; // [sp+20h] [bp-44Ch]@8
  char *outerIpStr; // [sp+24h] [bp-448h]@8
  char *serverId; // [sp+28h] [bp-444h]@8
  char *innerIpStr; // [sp+2Ch] [bp-440h]@8
  char *serverName; // [sp+30h] [bp-43Ch]@8
  char *serverKind; // [sp+34h] [bp-438h]@8
  char buffer[1024]; // [sp+38h] [bp-434h]@3
  int server_index; // [sp+438h] [bp-34h]@3
  char *str; // [sp+43Ch] [bp-30h]@2
  FILE *file; // [sp+440h] [bp-2Ch]@2
  SqlQuery sql; // [sp+444h] [bp-28h]@11
  int minAgeLimit; // [sp+458h] [bp-14h]@1
  char serverIdIndex; // [sp+45Ch] [bp-10h]@1
  int unused; // [sp+468h] [bp-4h]@11

  _this = this;
  minAgeLimit = this->m_maxAgeLimit;
  ReadWriteLock::writeLock(&this->m_rwLock);
  serverIdIndex = 0;
  _this->m_worldPort = g_Config.worldPort;
  if ( g_Config.ReadLocalServerList )
  {
    str = 0;
    file = fopen(aEtcServerlist, aRt);
    if ( file )
    {
      memset(buffer, 0, 1024u);
      str = fgets(buffer, 1024, file);
      server_index = 0;
      while ( str || !(file->_flag & 0x10) )
      {
        if ( strlen(buffer) <= 0xA )
        {
          LogWindow::Add(&g_LogWindow, 3, aCanTLoadServer);
          return;
        }
        serverId = strtok(buffer, asc_46D04C);
        _this->m_tmpServer.serverId = atoi(serverId);
        serverName = strtok(0, asc_46D050);
        strcpy(_this->m_tmpServer.serverName, serverName);
        innerIpStr = strtok(0, asc_46D054);
        _this->m_tmpServer.ipAddress = inet_addr(innerIpStr);
        strcpy(_this->m_tmpServer.innerIPStr, innerIpStr);
        outerIpStr = strtok(0, asc_46D058);
        strcpy(_this->m_tmpServer.outerIPStr, outerIpStr);
        ageLimit = strtok(0, asc_46D05C);
        _this->m_tmpServer.ageLimit = atoi(ageLimit);
        serverKind = strtok(0, asc_46D060);
        _this->m_tmpServer.kind = atoi(serverKind);
        _this->m_tmpServer.outerIP = inet_addr(_this->m_tmpServer.outerIPStr);
        _this->m_tmpServer.socket = -1;
        _this->m_tmpServer.pvp = 1;
        minAgeLimit = 12;
        _this->m_tmpServer.userNumber = 0;
        std::vector_ServerInfo::push_back(&_this->m_servers, &_this->m_tmpServer);// c    serverCount, then block:
        memcpy(&_this->m_compressedFrameBuffers[9 * server_index + 1], &_this->m_tmpServer, 1u);// c     serverId
        memcpy(&_this->m_compressedFrameBuffers[9 * server_index + 2], &_this->m_tmpServer.outerIP, 4u);// d serverIP
        memcpy(&_this->m_compressedFrameBuffers[9 * server_index + 6], &_this->m_worldPort, 4u);// d serverPort
        ++_this->m_serverCount;
        ++server_index;
        LogWindow::Add(
          &g_LogWindow,
          0,
          aServerDLoadedI,
          _this->m_tmpServer.serverId,
          _this->m_tmpServer.innerIPStr,
          _this->m_tmpServer.outerIPStr,
          _this->m_worldPort);
        memset(buffer, 0, 1024u);
        str = fgets(buffer, 1024, file);
      }
      memcpy(_this->m_compressedFrameBuffers, &_this->m_serverCount, 1u);
      _this->m_defaultOrCompressedSize = 9 * _this->m_serverCount + 1;
      fclose(file);
    }
    _this->m_serverNumber = std::vector_ServerInfo::size(&_this->m_servers);
    _this->m_frameLists[FrameType_DefaultOrCompressed] = _this->m_compressedFrameBuffers;
    _this->m_frameSizes[FrameType_DefaultOrCompressed] = _this->m_defaultOrCompressedSize;
    ServerList::reloadFrame_GameClient(_this);
    ReadWriteLock::releaseWriteLock(&_this->m_rwLock);
  }
  else
  {
    SqlQuery::SqlQuery(&sql, &g_dbManager);
    unused = 0;
    SqlQuery::bindByte(&sql, &_this->m_tmpServer);// id
    SqlQuery::bindStr(&sql, _this->m_tmpServer.serverName, 26);// name
    SqlQuery::bindStr(&sql, _this->m_tmpServer.outerIPStr, 16);// ip str
    SqlQuery::bindStr(&sql, _this->m_tmpServer.innerIPStr, 16);// inner_ip
    SqlQuery::bindByte(&sql, &_this->m_tmpServer.ageLimit);
    SqlQuery::bindBool(&sql, &_this->m_tmpServer.pvp);
    SqlQuery::bindInt(&sql, &_this->m_tmpServer.kind);
    SqlQuery::bindInt(&sql, &_this->m_tmpServer.serverPort);
    if ( (unsigned __int8)std::vector_ServerInfo::empty(&_this->m_servers) )
    {
      _this->m_serverCount = 0;
      _this->m_defaultOrCompressedSize = 0;
      if ( SqlQuery::exec(&sql, aSelectIdNameIp) )// Select id, name, ip, inner_ip, ageLimit, pk_flag, kind, port
      {
        SqlQuery::fetch(&sql, notFound);
        serverIdIndex_ = 0;
        while ( !notFound[0] )
        {
          if ( serverIdIndex + 1 < _this->m_tmpServer.serverId )
          {
            LogWindow::Add(&g_LogWindow, 3, aLoadingServerl);
            g_bTerminating = 1;
            break;
          }
          ++serverIdIndex;
          _this->m_tmpServer.ipAddress = inet_addr(_this->m_tmpServer.innerIPStr);
          _this->m_tmpServer.outerIP = inet_addr(_this->m_tmpServer.outerIPStr);
          _this->m_tmpServer.socket = -1;
          _this->m_tmpServer.userNumber = 0;
          if ( !minAgeLimit || minAgeLimit > _this->m_tmpServer.ageLimit )
            minAgeLimit = _this->m_tmpServer.ageLimit;
          std::vector_ServerInfo::push_back(&_this->m_servers, &_this->m_tmpServer);
          ++_this->m_serverCount;
          memcpy(&_this->m_compressedFrameBuffers[9 * serverIdIndex_ + 1], &_this->m_tmpServer, 1u);
          memcpy(&_this->m_compressedFrameBuffers[9 * serverIdIndex_ + 2], &_this->m_tmpServer.outerIP, 4u);
          memcpy(&_this->m_compressedFrameBuffers[9 * serverIdIndex_ + 6], &_this->m_tmpServer.serverPort, 4u);
          LogWindow::Add(
            &g_LogWindow,
            0,
            aServerDLoade_0,
            _this->m_tmpServer.serverId,
            _this->m_tmpServer.innerIPStr,
            _this->m_tmpServer.outerIPStr,
            _this->m_tmpServer.serverPort,
            _this->m_tmpServer.ageLimit,
            _this->m_tmpServer.pvp);
          SqlQuery::fetch(&sql, notFound);
          ++serverIdIndex_;
        }
        memcpy(_this->m_compressedFrameBuffers, &_this->m_serverCount, 1u);
        _this->m_defaultOrCompressedSize = 9 * _this->m_serverCount + 1;
        _this->m_serverNumber = std::vector_ServerInfo::size(&_this->m_servers);
        _this->m_frameLists[FrameType_DefaultOrCompressed] = _this->m_compressedFrameBuffers;
        _this->m_frameSizes[FrameType_DefaultOrCompressed] = _this->m_defaultOrCompressedSize;
      }
    }
    else
    {
      defaultOrCompressedSize = _this->m_defaultOrCompressedSize;
      currentServersSize = std::vector_ServerInfo::size(&_this->m_servers);
      if ( SqlQuery::exec(&sql, aSelectIdName_0) )
      {
        SqlQuery::fetch(&sql, notFound_);
        index = 0;
        while ( !notFound_[0] )
        {
          if ( serverIdIndex + 1 < _this->m_tmpServer.serverId )
          {
            LogWindow::Add(&g_LogWindow, 3, aLoadingServe_0);
            g_bTerminating = 1;
            break;
          }
          ++serverIdIndex;
          if ( _this->m_tmpServer.serverId > currentServersSize )
          {
            _this->m_tmpServer.ipAddress = inet_addr(_this->m_tmpServer.innerIPStr);
            _this->m_tmpServer.outerIP = inet_addr(_this->m_tmpServer.outerIPStr);
            _this->m_tmpServer.userNumber = 0;
            _this->m_tmpServer.socket = -1;
            std::vector_ServerInfo::push_back(&_this->m_servers, &_this->m_tmpServer);
            ++_this->m_serverCount;
            memcpy(
              &_this->m_compressedFrameBuffers[9 * index] + _this->m_defaultOrCompressedSize,
              &_this->m_tmpServer,
              1u);
            memcpy(
              &_this->m_compressedFrameBuffers[9 * index + 1] + _this->m_defaultOrCompressedSize,
              &_this->m_tmpServer.outerIP,
              4u);
            memcpy(
              &_this->m_compressedFrameBuffers[9 * index++ + 5] + _this->m_defaultOrCompressedSize,
              &_this->m_tmpServer.serverPort,
              4u);
            LogWindow::Add(
              &g_LogWindow,
              0,
              aServerDLoade_1,
              _this->m_tmpServer.serverId,
              _this->m_tmpServer.innerIPStr,
              _this->m_tmpServer.outerIPStr,
              _this->m_worldPort);
          }
          SqlQuery::fetch(&sql, notFound_);
        }
        if ( _this->m_tmpServer.serverId < currentServersSize )// remove missed servers. TODO: absent in other implementations!
        {
          for ( i = _this->m_tmpServer.serverId + 1; i <= currentServersSize; ++i )
          {
            serverInfo = std::vector_ServerInfo::at2(&_this->m_servers, i - 1);
            std::vector_ServerInfo::erase(&_this->m_servers, serverInfo);
          }
        }
        _this->m_serverNumber = std::vector_ServerInfo::size(&_this->m_servers);
        defaultOrCompressedSize = 9 * _this->m_serverCount + 1;
        InterlockedExchange((volatile LONG *)&_this->m_defaultOrCompressedSize, defaultOrCompressedSize);
        memcpy(_this->m_compressedFrameBuffers, &_this->m_serverCount, 1u);
      }
    }
    if ( (unsigned __int8)std::vector_ServerInfo::empty(&_this->m_servers) )
      LogWindow::Add(&g_LogWindow, 3, aServerLoadFail);
    _this->m_serverNumber = std::vector_ServerInfo::size(&_this->m_servers);
    _this->m_frameLists[FrameType_DefaultOrCompressed] = _this->m_compressedFrameBuffers;
    _this->m_frameSizes[FrameType_DefaultOrCompressed] = _this->m_defaultOrCompressedSize;
    ServerList::reloadFrame_GameClient(_this);
    ServerList::reloadFrame_Extended(_this);
    ServerList::reloadFrame_WithKind(_this);
    _this->m_maxAgeLimit = minAgeLimit;
    ReadWriteLock::releaseWriteLock(&_this->m_rwLock);
    ServerList::setStatuses(_this);
    unused = -1;
    SqlQuery::Destructor(&sql);
  }
}
// 4816F0: using guessed type char g_bTerminating;

//----- (00434524) --------------------------------------------------------
ServerInfo *__thiscall ServerList::getServerInfo(ServerList *this, ServerInfo *outServerInfo, int serverId)
{
  ServerInfo *result; // eax@3
  unsigned int unused_; // [sp+0h] [bp-68h]@0
  ServerList *this_; // [sp+8h] [bp-60h]@1
  ServerInfo serverInfo; // [sp+Ch] [bp-5Ch]@4
  ServerInfo *serverInfo_; // [sp+64h] [bp-4h]@3

  this_ = this;
  ReadWriteLock::readLock(&this->m_rwLock);
  if ( serverId > this_->m_serverNumber || serverId <= 0 )
  {
    serverInfo.serverId = 0;
    ReadWriteLock::releaseReadLock(&this_->m_rwLock);
    qmemcpy(outServerInfo, &serverInfo, sizeof(ServerInfo));
    result = outServerInfo;
  }
  else
  {
    serverInfo_ = std::vector_ServerInfo::at(&this_->m_servers, serverId - 1, unused_);
    ReadWriteLock::releaseReadLock(&this_->m_rwLock);
    qmemcpy(outServerInfo, serverInfo_, sizeof(ServerInfo));
    result = outServerInfo;
  }
  return result;
}

//----- (004345A7) --------------------------------------------------------
int __thiscall ServerList::updateServerAndGetServerID(ServerList *this, int ipAddress, SOCKET socket)
{
  ServerList *this_; // [sp+0h] [bp-Ch]@1
  std::vector_ServerInfo::iterator *it; // [sp+4h] [bp-8h]@1
  char serverId; // [sp+8h] [bp-4h]@1

  this_ = this;
  serverId = 0;
  ReadWriteLock::writeLock(&this->m_rwLock);
  for ( it = std::vector_ServerInfo::begin(&this_->m_servers); it != std::vector_ServerInfo::end(&this_->m_servers); ++it )
  {
    if ( !memcmp(&it->value.ipAddress, &ipAddress, 4u) )
    {
      if ( it->value.socket == INVALID_SOCKET )
      {
        it->value.socket = socket;
        serverId = it->value.serverId;
      }
      else if ( it->value.socket == socket )
      {
        it->value.socket = INVALID_SOCKET;
        serverId = it->value.serverId;
      }
      else
      {
        serverId = -1;
      }
      break;
    }
  }
  ReadWriteLock::releaseWriteLock(&this_->m_rwLock);
  return serverId;
}

//----- (00434659) --------------------------------------------------------
int __thiscall ServerList::setUserNumber(ServerList *this, int outerServerIP, int usersNumber, char serverId)
{
  ServerList *this_; // [sp+0h] [bp-4h]@1

  this_ = this;
  ReadWriteLock::readLock(&this->m_rwLock);
  if ( serverId > 0 )
  {
    memcpy(&g_ServerList.m_frameLists[FrameType_GameClient][16 * serverId - 3], &usersNumber, 4u);
    memcpy(&g_ServerList.m_frameLists[FrameType_WithKind][20 * serverId - 7], &usersNumber, 4u);
  }
  ReadWriteLock::releaseReadLock(&this_->m_rwLock);
  return serverId;
}                                               // c          serverNumber   0
                                                // c          zero           1
                                                // block
                                                // c          serverId       2 
                                                // d          serverIp       3-6
                                                // d          serverPort     7-10 
                                                // c          ageLimit       11
                                                // c          pvp            12
                                                // d          userNumber     13-16   <---- 16-3
                                                // c          serverStatus   17  
                                                // 
                                                // WithKind:
                                                // c          serverNumber   0
                                                // c          zero           1
                                                // block
                                                // c          serverId       2 
                                                // d          serverIp       3-6
                                                // d          serverPort     7-10 
                                                // c          ageLimit       11
                                                // c          pvp            12
                                                // d          userNumber     13-16   <---- 20-7
                                                // c          serverStatus   17
                                                // d          serverKind     18-21

//----- (004346C7) --------------------------------------------------------
void __thiscall ServerList::reloadFrame_GameClient(ServerList *this)
{
  char *iter_; // ST20_4@3
  unsigned int unused; // [sp+0h] [bp-80h]@0
  ServerList *this_; // [sp+8h] [bp-78h]@1
  char *iter; // [sp+14h] [bp-6Ch]@1
  signed int i; // [sp+1Ch] [bp-64h]@1
  char *buffer; // [sp+20h] [bp-60h]@1
  ServerInfo serverInfo; // [sp+24h] [bp-5Ch]@3
  char *old; // [sp+7Ch] [bp-4h]@4

  this_ = this;
  buffer = (char *)operator new(0x800u);
  memset(buffer, 0, 0x800u);
  *buffer = this_->m_serverNumber;              // 0          serverNumber
  buffer[1] = 0;                                // 1          lastWorld
  iter = buffer + 2;
  for ( i = 1; i <= this_->m_serverNumber; ++i )// block
  {
    qmemcpy(&serverInfo, std::vector_ServerInfo::at(&this_->m_servers, i - 1, unused), sizeof(serverInfo));
    *iter = serverInfo.serverId;                // c          serverId
    iter_ = iter + 1;
    memcpy(iter_, &serverInfo.outerIP, 4u);     // d          serverIp
    iter_ += 4;
    memcpy(iter_, &serverInfo.serverPort, 4u);  // d          serverPort
    iter_ += 4;
    *iter_++ = serverInfo.ageLimit;             // c          ageLimit
    *iter_ = serverInfo.pvp;                    // c          pvp
    iter = iter_ + 6;                           // d          userNumber
  }                                             // c          serverStatus
  old = 0;
  if ( this_->m_frameLists[FrameType_GameClient] )
    old = this_->m_frameLists[FrameType_GameClient];
  this_->m_frameSizes[FrameType_GameClient] = 16 * this_->m_serverNumber + 2;
  this_->m_frameLists[FrameType_GameClient] = buffer;
  if ( old )
    _delete_table(old);
}                                               // c          serverNumber   0
                                                // c          lastWorld      1
                                                // block
                                                // c          serverId       2 
                                                // d          serverIp       3-6
                                                // d          serverPort     7-10 
                                                // c          ageLimit       11
                                                // c          pvp            12
                                                // d          userNumber     13-16  
                                                // c          serverStatus   17  

//----- (00434848) --------------------------------------------------------
int __thiscall ServerList::reloadFrame_Extended(ServerList *this)
{
  int result; // eax@9
  unsigned int unused; // [sp+0h] [bp-94h]@0
  ServerList *this_; // [sp+8h] [bp-8Ch]@1
  char serverName[20]; // [sp+14h] [bp-80h]@5
  char *iter; // [sp+28h] [bp-6Ch]@1
  int size; // [sp+2Ch] [bp-68h]@1
  int i; // [sp+30h] [bp-64h]@1
  char *buffer; // [sp+34h] [bp-60h]@1
  ServerInfo serverInfo; // [sp+38h] [bp-5Ch]@3
  char *old; // [sp+90h] [bp-4h]@7

  this_ = this;
  buffer = (char *)operator new(0x1000u);
  memset(buffer, 0, 0x1000u);
  iter = buffer;
  *buffer = this_->m_serverNumber;
  *++iter = 0;
  ++iter;
  size = 56;
  for ( i = 1; i <= this_->m_serverNumber; ++i )
  {
    qmemcpy(&serverInfo, std::vector_ServerInfo::at(&this_->m_servers, i - 1, unused), sizeof(serverInfo));
    *iter++ = serverInfo.serverId;
    if ( strlen(serverInfo.serverName) >= 20 )
    {
      strncpy(serverName, serverInfo.serverName, 19u);
      serverName[19] = 0;
      swprintf((wchar_t *)iter, aS_7, serverName);
    }
    else
    {
      swprintf((wchar_t *)iter, aS_6, serverInfo.serverName);
    }
    iter += 40;
    memcpy(iter, &serverInfo.outerIP, 4u);
    iter += 4;
    memcpy(iter, &serverInfo.serverPort, 4u);
    iter += 4;
    *iter++ = serverInfo.ageLimit;
    *iter++ = serverInfo.pvp;
    iter += 5;
  }
  old = 0;
  if ( this_->m_frameLists[FrameType_Extended] )
    old = this_->m_frameLists[FrameType_Extended];
  result = (int)this_;
  this_->m_frameSizes[FrameType_Extended] = 56 * this_->m_serverNumber + 2;
  this_->m_frameLists[FrameType_Extended] = buffer;
  if ( old )
    _delete_table(old);
  return result;
}

//----- (00434A4F) --------------------------------------------------------
int __thiscall ServerList::reloadFrame_WithKind(ServerList *this)
{
  char *iter; // ST28_4@3
  int result; // eax@6
  unsigned int unused; // [sp+0h] [bp-9Ch]@0
  ServerList *this_; // [sp+Ch] [bp-90h]@1
  char *iter_; // [sp+18h] [bp-84h]@1
  signed int i; // [sp+20h] [bp-7Ch]@1
  char *buffer; // [sp+24h] [bp-78h]@1
  ServerInfo serverInfo; // [sp+28h] [bp-74h]@3
  char *old; // [sp+80h] [bp-1Ch]@4
  CPPEH_RECORD ms_exc; // [sp+84h] [bp-18h]@1

  this_ = this;
  ms_exc.registration.TryLevel = 0;
  buffer = (char *)operator new(0x800u);
  memset(buffer, 0, 0x800u);
  *buffer = this_->m_serverNumber;              // c          serverNumber   0
  buffer[1] = 0;                                // c          lastWorld      1
  iter_ = buffer + 2;
  for ( i = 1; i <= this_->m_serverNumber; ++i )// block
  {
    qmemcpy(&serverInfo, std::vector_ServerInfo::at(&this_->m_servers, i - 1, unused), sizeof(serverInfo));
    *iter_ = serverInfo.serverId;               // c          serverId       2
    iter = iter_ + 1;
    memcpy(iter, &serverInfo.outerIP, 4u);      // d          serverIp       3-6
    iter += 4;
    memcpy(iter, &serverInfo.serverPort, 4u);   // d          serverPort     7-10 
    iter += 4;
    *iter++ = serverInfo.ageLimit;              // c          ageLimit       11
    *iter = serverInfo.pvp;                     // c          pvp            12
    iter += 6;                                  // d          userNumber     13-16   <---- 20-7
    memcpy(iter, &serverInfo.kind, 4u);         // c          serverStatus   17
    iter_ = iter + 4;                           // d          serverKind     18-21
  }
  old = 0;
  if ( this_->m_frameLists[FrameType_WithKind] )
    old = this_->m_frameLists[FrameType_WithKind];
  this_->m_frameSizes[FrameType_WithKind] = 20 * this_->m_serverNumber + 2;
  result = (int)buffer;
  this_->m_frameLists[FrameType_WithKind] = buffer;
  if ( old )
    _delete_table(old);
  return result;
}                                               // c          serverNumber   0
                                                // c          lastWorld      1
                                                // block
                                                // c          serverId       2 
                                                // d          serverIp       3-6
                                                // d          serverPort     7-10 
                                                // c          ageLimit       11
                                                // c          pvp            12
                                                // d          userNumber     13-16   <---- 20-7
                                                // c          serverStatus   17
                                                // d          serverKind     18-21

//----- (00434CD9) --------------------------------------------------------
LogWindow *__thiscall ServerList::setServerStatus(ServerList *this, char serverId, char status)
{
  ServerList *this_; // [sp+0h] [bp-4h]@1

  this_ = this;
  ReadWriteLock::writeLock(&this->m_rwLock);
  if ( serverId > 0 && serverId <= g_ServerList.m_serverNumber )
  {
    g_ServerList.m_frameLists[FrameType_GameClient][16 * serverId + 1] = status;
    g_ServerList.m_frameLists[FrameType_WithKind][20 * serverId - 3] = status;
  }
  return ReadWriteLock::releaseWriteLock(&this_->m_rwLock);
}                                               // c          serverNumber   0
                                                // c          lastWorld      1
                                                // block
                                                // c          serverId       2 
                                                // d          serverIp       3-6
                                                // d          serverPort     7-10 
                                                // c          ageLimit       11
                                                // c          pvp            12
                                                // d          userNumber     13-16   
                                                // c          serverStatus   17      <---- 16+1
                                                // 
                                                // WithKind:
                                                // c          serverNumber   0
                                                // c          lastWorld      1
                                                // block
                                                // c          serverId       2 
                                                // d          serverIp       3-6
                                                // d          serverPort     7-10 
                                                // c          ageLimit       11
                                                // c          pvp            12
                                                // d          userNumber     13-16   
                                                // c          serverStatus   17      <---- 20-3
                                                // d          serverKind     18-21

//----- (00434D36) --------------------------------------------------------
void __thiscall ServerList::setStatuses(ServerList *this)
{
  ServerInfo *serverInfo; // eax@3
  ServerList *this_; // [sp+0h] [bp-60h]@1
  ServerInfo a2; // [sp+4h] [bp-5Ch]@3
  int i; // [sp+5Ch] [bp-4h]@1

  this_ = this;
  for ( i = 1; i <= g_ServerList.m_serverNumber; ++i )
  {
    serverInfo = ServerList::getServerInfo(this_, &a2, i);
    if ( WorldSrvServer::socketExists(&g_worldServServer, serverInfo->ipAddress) )
      ServerList::setServerStatus(this_, i, 1);
  }
}

//----- (00434D97) --------------------------------------------------------
char __thiscall ServerList::isServerOn(ServerList *this, char serverId)
{
  ServerList *this_; // [sp+0h] [bp-Ch]@1
  char available; // [sp+4h] [bp-8h]@0
  char available_; // [sp+8h] [bp-4h]@1

  this_ = this;
  available_ = 0;
  ReadWriteLock::readLock(&this->m_rwLock);
  if ( serverId > 0 && serverId <= g_ServerList.m_serverNumber )
    available = g_ServerList.m_frameLists[FrameType_GameClient][16 * serverId + 1];
  ReadWriteLock::releaseReadLock(&this_->m_rwLock);
  if ( available == 1 )
    available_ = 1;
  return available_;
}                                               // c          serverNumber   0
                                                // c          zero           1
                                                // block
                                                // c          serverId       2 
                                                // d          serverIp       3-6
                                                // d          serverPort     7-10 
                                                // c          ageLimit       11
                                                // c          pvp            12
                                                // d          userNumber     13-16  
                                                // c          serverStatus   17  

//----- (00434DF7) --------------------------------------------------------
void __stdcall UserCountTable::onTimeout(UserCountTable *table, BOOLEAN a2)
{
  UserCountTable::updateDb(table);
}

//----- (00434E0F) --------------------------------------------------------
UserCountTable *__thiscall UserCountTable::UserCountTable(UserCountTable *this)
{
  UserCountTable *this_; // [sp+0h] [bp-8h]@1
  signed int i; // [sp+4h] [bp-4h]@1

  this_ = this;
  InitializeCriticalSection(&this->m_criticalSection);
  this_->m_tickCount = GetTickCount();
  EnterCriticalSection(&this_->m_criticalSection);
  for ( i = 0; i < 100; ++i )
  {
    this_->m_users[i].usersLimit = 0;
    this_->m_users[i].users = 0;
    LOBYTE(this_->m_users[i].serverId) = i;
  }
  LeaveCriticalSection(&this_->m_criticalSection);
  CreateTimerQueueTimer(
    &this_->m_timerHandle,
    0,
    (WAITORTIMERCALLBACK)UserCountTable::onTimeout,
    this_,
    300000u,
    300000u,
    0);
  return this_;
}

//----- (00434ECF) --------------------------------------------------------
BOOL __thiscall UserCountTable::Destructor(UserCountTable *this)
{
  UserCountTable *this_; // ST0C_4@1

  this_ = this;
  DeleteCriticalSection(&this->m_criticalSection);
  return DeleteTimerQueueTimer(0, this_->m_timerHandle, 0);
}

//----- (00434EFD) --------------------------------------------------------
void __thiscall UserCountTable::setUsers(UserCountTable *this, unsigned __int8 serverId, __int16 users, __int16 socketLimit)
{
  UserCountTable *this_; // [sp+0h] [bp-4h]@1

  this_ = this;
  if ( (signed int)serverId <= 100 )
  {
    EnterCriticalSection(&this->m_criticalSection);
    this_->m_users[serverId].usersLimit = socketLimit;
    this_->m_users[serverId].users = users;
    LeaveCriticalSection(&this_->m_criticalSection);
  }
}

//----- (00434F73) --------------------------------------------------------
void __thiscall UserCountTable::refreshAuthUsers(UserCountTable *this)
{
  UserCountTable *this_; // ST04_4@1

  this_ = this;
  ++this->m_tickCount;
  EnterCriticalSection(&this->m_criticalSection);
  this_->m_users[0].usersLimit = g_Config.SocketLimit;
  this_->m_users[0].users = g_StatusLine.users;
  LeaveCriticalSection(&this_->m_criticalSection);
}

//----- (00434FCA) --------------------------------------------------------
void __thiscall UserCountTable::updateDb(UserCountTable *this)
{
  UserCountTable *this_; // [sp+0h] [bp-228h]@1
  SqlQuery sql; // [sp+4h] [bp-224h]@1
  int i; // [sp+18h] [bp-210h]@1
  char sqlQuery[520]; // [sp+1Ch] [bp-20Ch]@3
  int unused_; // [sp+224h] [bp-4h]@1

  this_ = this;
  SqlQuery::SqlQuery(&sql, &g_dbManager);
  unused_ = 0;
  UserCountTable::refreshAuthUsers(this_);
  for ( i = 0; i <= g_ServerList.m_serverNumber; ++i )
  {
    EnterCriticalSection(&this_->m_criticalSection);
    sprintf(
      sqlQuery,
      aInsertUser_cou,
      i,
      this_->m_users[i].users,
      this_->m_users[i].usersLimit,
      this_->m_users[0].users,
      g_StatusLine.sockets);
    LeaveCriticalSection(&this_->m_criticalSection);
    SqlQuery::exec(&sql, sqlQuery);
    SqlQuery::reset(&sql);
  }
  unused_ = -1;
  SqlQuery::Destructor(&sql);
}

//----- (004350FC) --------------------------------------------------------
signed int __cdecl ServersProvider::updateServerAndGetServerID(int IPaddress, SOCKET socket)
{
  int v3; // [sp+0h] [bp-4h]@2

  if ( g_Config.Newserverlist )
    v3 = ServerTable::updateServerAndGetServerID(&g_serverTable, IPaddress, socket);
  else
    v3 = ServerList::updateServerAndGetServerID(&g_ServerList, IPaddress, socket);
  return v3;
}

//----- (00435145) --------------------------------------------------------
void __cdecl ServersProvider::setServerStatus(char serverID, char status)
{
  if ( g_Config.Newserverlist )
    ServerTable::setServerStatus(&g_serverTable, serverID, status);
  else
    ServerList::setServerStatus(&g_ServerList, serverID, status);
}

//----- (0043517B) --------------------------------------------------------
char __cdecl ServersProvider::isServerOn(char serverId)
{
  char v2; // [sp+0h] [bp-4h]@2

  if ( g_Config.Newserverlist )
    v2 = ServerTable::isServerOn(&g_serverTable, serverId);
  else
    v2 = ServerList::isServerOn(&g_ServerList, serverId);
  return v2;
}

//----- (004351B9) --------------------------------------------------------
ServerInfo *__cdecl ServersProvider::getServerInfo(ServerInfo *out, char serverId)
{
  ServerInfo serverInfo_0; // [sp+8h] [bp-108h]@3
  ServerInfo serverInfo; // [sp+60h] [bp-B0h]@2
  ServerInfo serverInfo_; // [sp+B8h] [bp-58h]@2

  if ( g_Config.Newserverlist )
    qmemcpy(&serverInfo_, ServerTable::getServerInfo(&g_serverTable, &serverInfo, serverId), sizeof(serverInfo_));
  else
    qmemcpy(&serverInfo_, ServerList::getServerInfo(&g_ServerList, &serverInfo_0, serverId), sizeof(serverInfo_));
  qmemcpy(out, &serverInfo_, sizeof(ServerInfo));
  return out;
}

//----- (0043522B) --------------------------------------------------------
void __cdecl ServersProvider::setUserNumber(int outerServerIP, int usersNumber, int serverId)
{
  if ( g_Config.Newserverlist )
    ServerTable::setUserNumber(&g_serverTable, serverId, usersNumber);
  else
    ServerList::setUserNumber(&g_ServerList, outerServerIP, usersNumber, serverId);
}

//----- (00435265) --------------------------------------------------------
int sub_435265()
{
  SomeBitsInit();
  return sub_435274();
}

//----- (00435274) --------------------------------------------------------
int sub_435274()
{
  return atexit(emptystub);
}

//----- (00435290) --------------------------------------------------------
ServerList *__thiscall ServerList::CallDestructor(ServerList *this, char a2)
{
  ServerList *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  ServerList::Destructor(this);
  if ( a2 & 1 )
    _delete_table(v3);
  return v3;
}

//----- (00435300) --------------------------------------------------------
std::vector_ServerInfo *__thiscall std::vector_ServerInfo::Destructor(std::vector_ServerInfo *this)
{
  std::vector_ServerInfo *v1; // ST08_4@1
  std::vector_ServerInfo *result; // eax@1

  v1 = this;
  std::vector_ServerInfo::_Destroy((std::vector_ServerInfo::iterator *)this->_First, this->_Last);
  std::vector_ServerInfo::allocator_deallocate(v1->_First, (v1->_End - v1->_First) / 88);
  v1->_First = 0;
  v1->_Last = 0;
  result = v1;
  v1->_End = 0;
  return result;
}
// 435AD0: using guessed type _DWORD __stdcall std::vector_ServerInfo::allocator_deallocate(LPVOID lpMem, _DWORD);

//----- (004353B0) --------------------------------------------------------
int __thiscall std::vector_ServerInfo::size(std::vector_ServerInfo *this)
{
  int v2; // [sp+0h] [bp-8h]@2

  if ( this->_First )
    v2 = ((char *)this->_Last - this->_First) / 88;
  else
    v2 = 0;
  return v2;
}

//----- (004353F0) --------------------------------------------------------
BOOL __thiscall std::vector_ServerInfo::empty(void *this)
{
  return std::vector_ServerInfo::size((std::vector_ServerInfo *)this) == 0;
}

//----- (00435410) --------------------------------------------------------
ServerInfo *__thiscall std::vector_ServerInfo::at(std::vector_ServerInfo *retstr, size_t index, unsigned int a2)
{
  std::vector_ServerInfo *this_; // [sp+0h] [bp-4h]@1

  this_ = retstr;
  if ( std::vector_ServerInfo::size(retstr) <= index )
    std::vector_ServerInfo::_Xran();
  return &std::vector_ServerInfo::begin(this_)[index].value;
}

//----- (00435450) --------------------------------------------------------
std::vector_ServerInfo::iterator *__thiscall std::vector_ServerInfo::at2(std::vector_ServerInfo *this, int a2)
{
  return &std::vector_ServerInfo::begin(this)[a2];
}

//----- (00435470) --------------------------------------------------------
int __thiscall std::vector_ServerInfo::push_back(std::vector_ServerInfo *this, const ServerInfo *a2)
{
  std::vector_ServerInfo *v2; // ST08_4@1
  std::vector_ServerInfo::iterator *v3; // eax@1

  v2 = this;
  v3 = std::vector_ServerInfo::end(this);
  return (int)std::vector_ServerInfo::insert(v2, &v3->value.serverId, a2);
}

//----- (004354A0) --------------------------------------------------------
std::vector_ServerInfo::iterator *__thiscall std::vector_ServerInfo::erase(std::vector_ServerInfo *this, std::vector_ServerInfo::iterator *a2)
{
  std::vector_ServerInfo *v2; // ST0C_4@1
  std::vector_ServerInfo::iterator *v3; // eax@1

  v2 = this;
  v3 = std::vector_ServerInfo::end(this);
  sub_435E30(&a2[1], v3, a2);
  std::vector_ServerInfo::_Destroy(v2->_Last - 1, v2->_Last);
  --v2->_Last;
  return a2;
}

//----- (00435500) --------------------------------------------------------
std::vector_ServerInfo *__thiscall sub_435500(std::vector_ServerInfo *this, _BYTE *a2)
{
  this->allocator = *a2;
  this->_First = 0;
  this->_Last = 0;
  this->_End = 0;
  return this;
}

//----- (00435540) --------------------------------------------------------
std::vector_ServerInfo::iterator *__thiscall std::vector_ServerInfo::insert(std::vector_ServerInfo *this, char *_P, const void *_X)
{
  std::vector_ServerInfo *v3; // ST0C_4@1
  int _O; // ST10_4@1

  v3 = this;
  _O = (_P - (char *)std::vector_ServerInfo::begin(this)) / 88;
  std::vector_ServerInfo::insert_2(v3, _P, 1u, _X);
  return &std::vector_ServerInfo::begin(v3)[_O];
}

//----- (00435590) --------------------------------------------------------
char *__stdcall std::vector_ServerInfo::_Destroy(std::vector_ServerInfo::iterator *a1, std::vector_ServerInfo::iterator *a2)
{
  char *result; // eax@2

  while ( a1 != a2 )
  {
    sub_435D50((int)a1);
    result = &a1[1].value.serverId;
    ++a1;
  }
  return result;
}

//----- (004355C0) --------------------------------------------------------
void __noreturn std::vector_ServerInfo::_Xran()
{
  int v0; // [sp+4h] [bp-3Ch]@1
  char v1; // [sp+8h] [bp-38h]@1
  char v2; // [sp+18h] [bp-28h]@1
  int v3; // [sp+3Ch] [bp-4h]@1

  sub_435900(&v1, aInvalidVectorT, (int)&v0);
  v3 = 0;
  unknown_libname_196(&v2, &v1);
  _CxxThrowException(&v2, &unk_463570);
}
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);

//----- (00435620) --------------------------------------------------------
void *__thiscall sub_435620(void *this, int a2)
{
  void *v2; // ST04_4@1

  v2 = this;
  exception::exception((int)this, a2);
  sub_4358C0((char *)v2 + 12, (_BYTE *)(a2 + 12));
  *(_DWORD *)v2 = &std::logic_error::`vftable';
  return v2;
}
// 45FBD8: using guessed type int (__stdcall *std::logic_error::`vftable')(int);

//----- (004356B0) --------------------------------------------------------
void __thiscall __noreturn sub_4356B0(void *this)
{
  char v1; // [sp+4h] [bp-1Ch]@1

  sub_435620(&v1, (int)this);
  _CxxThrowException(&v1, &unk_4635E0);
}
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);

//----- (004356E0) --------------------------------------------------------
void __thiscall sub_4356E0(void *this)
{
  void *v1; // ST00_4@1

  v1 = this;
  *(_DWORD *)this = &std::logic_error::`vftable';
  sub_41FD50();
  sub_44DCB0((int)v1);
}
// 45FBD8: using guessed type int (__stdcall *std::logic_error::`vftable')(int);

//----- (00435740) --------------------------------------------------------
void *__thiscall sub_435740(void *this, char a2)
{
  void *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  sub_4356E0(this);
  if ( a2 & 1 )
    _delete_table(v3);
  return v3;
}

//----- (004357A0) --------------------------------------------------------
void *__thiscall sub_4357A0(void *this, _BYTE *a2)
{
  void *v2; // ST04_4@1
  CHAR *v4; // [sp+4h] [bp-10h]@1
  int v5; // [sp+10h] [bp-4h]@1

  v2 = this;
  v4 = byte_481640;
  exception::exception(this, (const char **)&v4);
  v5 = 0;
  sub_4358C0((char *)v2 + 12, a2);
  *(_DWORD *)v2 = &std::logic_error::`vftable';
  return v2;
}
// 45FBD8: using guessed type int (__stdcall *std::logic_error::`vftable')(int);

//----- (00435810) --------------------------------------------------------
void __thiscall sub_435810(void *this)
{
  *(_DWORD *)this = &std::out_of_range::`vftable';
  sub_4356E0(this);
}
// 45FBE8: using guessed type int (__stdcall *std::out_of_range::`vftable')(int);

//----- (00435830) --------------------------------------------------------
void __thiscall __noreturn sub_435830(void *this)
{
  char v1; // [sp+4h] [bp-1Ch]@1

  unknown_libname_197(&v1, (int)this);
  _CxxThrowException(&v1, &unk_463570);
}
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);

//----- (00435860) --------------------------------------------------------
void *__thiscall sub_435860(void *this, char a2)
{
  void *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  sub_435810(this);
  if ( a2 & 1 )
    _delete_table(v3);
  return v3;
}

//----- (004358C0) --------------------------------------------------------
void *__thiscall sub_4358C0(void *this, _BYTE *a2)
{
  void *v2; // ST0C_4@1

  v2 = this;
  *(_BYTE *)this = *a2;
  std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(0);
  std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(a2, 0, -1);
  return v2;
}
// 41FF10: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(_DWORD);
// 435960: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(_DWORD, _DWORD, _DWORD);

//----- (00435900) --------------------------------------------------------
void *__thiscall sub_435900(void *this, char *a2, int a3)
{
  void *v3; // ST04_4@1

  v3 = this;
  *(_BYTE *)this = *(_BYTE *)a3;
  std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(0);
  std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(a2);
  return v3;
}
// 41FF10: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(_DWORD);

//----- (00435930) --------------------------------------------------------
void *__thiscall sub_435930(int this)
{
  void *v2; // [sp+0h] [bp-8h]@2

  if ( *(_DWORD *)(this + 4) )
    v2 = *(void **)(this + 4);
  else
    v2 = sub_435AC0();
  return v2;
}

//----- (00435AC0) --------------------------------------------------------
void *sub_435AC0()
{
  return &unk_45F91C;
}

//----- (00435B10) --------------------------------------------------------
std::vector_ServerInfo *__thiscall std::vector_ServerInfo::insert_2(std::vector_ServerInfo *this, char *_P, unsigned int _M, const void *_X)
{
  int v4; // ST14_4@5
  ServerInfo *v5; // ST18_4@5
  ServerInfo *v6; // ST1C_4@5
  int v7; // ecx@5
  std::vector_ServerInfo *result; // eax@5
  unsigned int v9; // [sp+0h] [bp-14h]@3
  std::vector_ServerInfo *this_; // [sp+4h] [bp-10h]@1

  this_ = this;
  if ( (this->_End - this->_Last) / 88 >= _M )
  {
    result = (std::vector_ServerInfo *)(((char *)this->_Last - _P) / 88);
    if ( (unsigned int)result >= _M )
    {
      if ( _M )
      {
        std::vector_ServerInfo::_Ucopy(
          (int)&this->_Last[-_M].value.serverId,
          (int)&this->_Last->value.serverId,
          &this->_Last->value);
        std::vector_ServerInfo::copy_backward(_P, &this_->_Last[-_M].value.serverId, &this_->_Last->value.serverId);
        std::vector_ServerInfo::fill(_P, &_P[88 * _M], _X);
        result = this_;
        this_->_Last += _M;
      }
    }
    else
    {
      std::vector_ServerInfo::_Ucopy((int)_P, (int)&this->_Last->value.serverId, (ServerInfo *)&_P[88 * _M]);
      std::vector_ServerInfo::_Ufill(this_->_Last, _M - ((char *)this_->_Last - _P) / 88, (int)_X);
      std::vector_ServerInfo::fill(_P, this_->_Last, _X);
      result = this_;
      this_->_Last += _M;
    }
  }
  else
  {
    if ( _M >= std::vector_ServerInfo::size(this) )
      v9 = _M;
    else
      v9 = std::vector_ServerInfo::size(this_);
    v4 = v9 + std::vector_ServerInfo::size(this_);
    v5 = (ServerInfo *)std::vector_ServerInfo::allocator_allocate(v4, 0);
    v6 = std::vector_ServerInfo::_Ucopy((int)this_->_First, (int)_P, v5);
    std::vector_ServerInfo::_Ufill(v6, _M, (int)_X);
    std::vector_ServerInfo::_Ucopy((int)_P, (int)&this_->_Last->value.serverId, &v6[_M]);
    std::vector_ServerInfo::_Destroy((std::vector_ServerInfo::iterator *)this_->_First, this_->_Last);
    std::vector_ServerInfo::allocator_deallocate(this_->_First, (this_->_End - this_->_First) / 88);
    this_->_End = &v5[v4];
    v7 = (int)&v5[std::vector_ServerInfo::size(this_)].serverId;
    result = this_;
    this_->_Last = (std::vector_ServerInfo::iterator *)(88 * _M + v7);
    this_->_First = v5;
  }
  return result;
}
// 435AD0: using guessed type _DWORD __stdcall std::vector_ServerInfo::allocator_deallocate(LPVOID lpMem, _DWORD);

//----- (00435D50) --------------------------------------------------------
void __stdcall sub_435D50(int a1)
{
  sub_435EE0();
}

//----- (00435D70) --------------------------------------------------------
ServerInfo *__stdcall std::vector_ServerInfo::_Ucopy(int a1, int a2, ServerInfo *a3)
{
  while ( a1 != a2 )
  {
    sub_435E10(a3, a1);
    ++a3;
    a1 += 88;
  }
  return a3;
}

//----- (00435DB0) --------------------------------------------------------
int __stdcall std::vector_ServerInfo::_Ufill(void *a1, int a2, int a3)
{
  int result; // eax@2

  while ( a2 )
  {
    sub_435E10((ServerInfo *)a1, a3);
    result = a2-- - 1;
    a1 = (char *)a1 + 88;
  }
  return result;
}

//----- (00435DF0) --------------------------------------------------------
void *__stdcall std::vector_ServerInfo::allocator_allocate(int a1, int a2)
{
  return sub_435EF0(a1);
}

//----- (00435E10) --------------------------------------------------------
void *__stdcall sub_435E10(ServerInfo *a1, int a2)
{
  return sub_435F20(a1, a2);
}

//----- (00435E30) --------------------------------------------------------
void *__cdecl sub_435E30(const void *a1, const void *a2, void *a3)
{
  while ( a1 != a2 )
  {
    qmemcpy(a3, a1, 0x58u);
    a3 = (char *)a3 + 88;
    a1 = (char *)a1 + 88;
  }
  return a3;
}

//----- (00435E70) --------------------------------------------------------
char *__cdecl std::vector_ServerInfo::fill(void *a1, void *a2, const void *a3)
{
  char *result; // eax@2

  while ( a1 != a2 )
  {
    qmemcpy(a1, a3, 0x58u);
    result = (char *)a1 + 88;
    a1 = (char *)a1 + 88;
  }
  return result;
}

//----- (00435EA0) --------------------------------------------------------
char *__cdecl std::vector_ServerInfo::copy_backward(char *a1, char *a2, char *a3)
{
  while ( a1 != a2 )
  {
    a2 -= 88;
    a3 -= 88;
    qmemcpy(a3, a2, 0x58u);
  }
  return a3;
}

//----- (00435EE0) --------------------------------------------------------
void sub_435EE0()
{
  ;
}

//----- (00435EF0) --------------------------------------------------------
void *__cdecl sub_435EF0(int a1)
{
  if ( a1 < 0 )
    a1 = 0;
  return malloc(88 * a1);
}

//----- (00435F20) --------------------------------------------------------
void *__cdecl sub_435F20(ServerInfo *a1, int a2)
{
  void *result; // eax@1

  result = operator new(0x58u, a1);
  if ( result )
    qmemcpy(result, (const void *)a2, 0x58u);
  return result;
}

//----- (00435F70) --------------------------------------------------------
int StaticInit_ServerTable()
{
  CallStaticCtorForServerTable();
  return RegisterStaticDtorServerTable();
}

//----- (00435F7F) --------------------------------------------------------
ServerTable *CallStaticCtorForServerTable()
{
  return ServerTable::ServerTable(&g_serverTable);
}

//----- (00435F8E) --------------------------------------------------------
int RegisterStaticDtorServerTable()
{
  return atexit(CallStaticDtorForServerTable);
}

//----- (00435FA0) --------------------------------------------------------
void __cdecl CallStaticDtorForServerTable()
{
  ServerTable::Destructor(&g_serverTable);
}

//----- (00435FAF) --------------------------------------------------------
ServerFrameList *__thiscall ServerFrameList::ServerFrameList(ServerFrameList *this)
{
  ServerFrameList *this_; // ST00_4@1

  this_ = this;
  ReadWriteLock::ReadWriteLock(&this->m_rwLock);
  this_->vtable = &ServerFrameList_vtable_off_45F920;
  this_->m_serverKindIndex = 0;
  this_->m_frameType = 0;
  this_->m_usedBuffSize = 0;
  return this_;
}

//----- (00435FF8) --------------------------------------------------------
void __thiscall ServerFrameList::Destructor(ServerFrameList *this)
{
  this->vtable = &ServerFrameList_vtable_off_45F920;
  ReadWriteLock::Destructor(&this->m_rwLock);
}

//----- (00436017) --------------------------------------------------------
ServerFrameList *__thiscall ServerFrameList::init(ServerFrameList *this, FrameType frameType, int serverKindIndex)
{
  ServerFrameList *result; // eax@1
  ServerFrameList *this_; // [sp+0h] [bp-4h]@1

  this_ = this;
  memset(this->m_buff, 0, 0x800u);
  this_->m_serverKindIndex = serverKindIndex;
  result = this_;
  this_->m_frameType = frameType;
  if ( this_->m_frameType )
  {
    this_->m_usedBuffSize = 2;                  // initial offset
  }
  else
  {
    result = this_;
    this_->m_usedBuffSize = 1;                  // initial offset
  }
  this_->m_fameCount = 0;
  return result;
}

//----- (00436084) --------------------------------------------------------
char __thiscall ServerFrameList::addFrame(ServerFrameList *this, char serverId, char *outerIPStr, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23)
{
  char serverId_; // [sp-58h] [bp-6Ch]@4
  char outerIPStr_0[16]; // [sp-54h] [bp-68h]@4
  int outerIPStr_4; // [sp-50h] [bp-64h]@4
  int outerIPStr_8; // [sp-4Ch] [bp-60h]@4
  int outerIPStr_12; // [sp-48h] [bp-5Ch]@4
  int innerIPStr_0; // [sp-44h] [bp-58h]@4
  int innerIPStr_4; // [sp-40h] [bp-54h]@4
  int innerIPStr_8; // [sp-3Ch] [bp-50h]@4
  int innerIPStr_12; // [sp-38h] [bp-4Ch]@4
  int serverName_0; // [sp-34h] [bp-48h]@4
  int serverName_4; // [sp-30h] [bp-44h]@4
  int serverName_8; // [sp-2Ch] [bp-40h]@4
  int serverName_12; // [sp-28h] [bp-3Ch]@4
  int serverName_16; // [sp-24h] [bp-38h]@4
  int serverName_20; // [sp-20h] [bp-34h]@4
  char outerIP; // [sp-1Ch] [bp-30h]@4
  int ipAddress; // [sp-18h] [bp-2Ch]@4
  int age_pvp_; // [sp-14h] [bp-28h]@4
  int someZero; // [sp-10h] [bp-24h]@4
  int socket; // [sp-Ch] [bp-20h]@4
  int kind; // [sp-8h] [bp-1Ch]@4
  char serverPort; // [sp-4h] [bp-18h]@4
  FrameType frameType; // [sp+8h] [bp-Ch]@1
  ServerFrameList *this_; // [sp+Ch] [bp-8h]@1
  char unused; // [sp+10h] [bp-4h]@1

  this_ = this;
  unused = 0;
  frameType = this->m_frameType;
  switch ( frameType )
  {
    case FrameType_GameClient:
      qmemcpy(&serverId_, &serverId, 0x58u);
      unused = ServerFrameList::addGameClientFrame(
                 this_,
                 serverId_,
                 outerIPStr_0[0],
                 outerIPStr_4,
                 outerIPStr_8,
                 outerIPStr_12,
                 innerIPStr_0,
                 innerIPStr_4,
                 innerIPStr_8,
                 innerIPStr_12,
                 serverName_0,
                 serverName_4,
                 serverName_8,
                 serverName_12,
                 serverName_16,
                 serverName_20,
                 outerIP,
                 ipAddress,
                 age_pvp_,
                 someZero,
                 socket,
                 kind,
                 serverPort);
      break;
    case FrameType_Extended:
      qmemcpy(&serverId_, &serverId, 0x58u);
      unused = ServerFrameList::addExtendedFrame(
                 this_,
                 serverId_,
                 outerIPStr_0[0],
                 outerIPStr_4,
                 outerIPStr_8,
                 outerIPStr_12,
                 innerIPStr_0,
                 innerIPStr_4,
                 innerIPStr_8,
                 innerIPStr_12,
                 serverName_0,
                 serverName_4,
                 serverName_8,
                 serverName_12,
                 serverName_16,
                 serverName_20,
                 outerIP,
                 ipAddress,
                 age_pvp_,
                 someZero,
                 socket,
                 kind,
                 serverPort);
      break;
    case FrameType_WithKind:
      qmemcpy(&serverId_, &serverId, 0x58u);
      unused = ServerFrameList::addWithKindFrame(
                 this_,
                 serverId_,
                 outerIPStr_0[0],
                 outerIPStr_4,
                 outerIPStr_8,
                 outerIPStr_12,
                 innerIPStr_0,
                 innerIPStr_4,
                 innerIPStr_8,
                 innerIPStr_12,
                 serverName_0,
                 serverName_4,
                 serverName_8,
                 serverName_12,
                 serverName_16,
                 serverName_20,
                 outerIP,
                 ipAddress,
                 age_pvp_,
                 someZero,
                 socket,
                 kind,
                 serverPort);
      break;
    default:
      qmemcpy(&serverId_, &serverId, 0x58u);
      unused = ServerFrameList::addCompressedFrame(
                 this_,
                 serverId_,
                 outerIPStr_0[0],
                 outerIPStr_4,
                 outerIPStr_8,
                 outerIPStr_12,
                 innerIPStr_0,
                 innerIPStr_4,
                 innerIPStr_8,
                 innerIPStr_12,
                 serverName_0,
                 serverName_4,
                 serverName_8,
                 serverName_12,
                 serverName_16,
                 serverName_20,
                 outerIP,
                 ipAddress,
                 age_pvp_,
                 someZero,
                 socket,
                 kind,
                 serverPort);
      break;
  }
  return unused;
}

//----- (0043612C) --------------------------------------------------------
char __thiscall ServerFrameList::addCompressedFrame(ServerFrameList *this, char serverId_, char outerIPStr_0, int outerIPStr_4, int outerIPStr_8, int outerIPStr_12, int innerIPStr_0, int innerIPStr_4, int innerIPStr_8, int innerIPStr_12, int serverName_0, int serverName_4, int serverName_8, int serverName_12, int serverName_16, int serverName_20, char outerIP, int ipAddress, int age_pvp_, int userNumber, int socket, int kind, char serverPort)
{
  ServerFrameList *this_; // ST0C_4@1
  int index; // ST10_4@1

  this_ = this;
  ReadWriteLock::writeLock(&this->m_rwLock);
  ++this_->m_fameCount;
  index = this_->m_usedBuffSize;
  this_->m_buff[index++] = serverId_;
  memcpy(&this_->m_buff[index], &outerIP, 4u);
  index += 4;
  memcpy(&this_->m_buff[index], &serverPort, 4u);
  this_->m_usedBuffSize = index + 4;
  ReadWriteLock::releaseWriteLock(&this_->m_rwLock);
  return 1;
}

//----- (004361DF) --------------------------------------------------------
char __thiscall ServerFrameList::addGameClientFrame(ServerFrameList *this, char serverId_, char outerIPStr_0, int outerIPStr_4, int outerIPStr_8, int outerIPStr_12, int innerIPStr_0, int innerIPStr_4, int innerIPStr_8, int innerIPStr_12, int serverName_0, int serverName_4, int serverName_8, int serverName_12, int serverName_16, int serverName_20, char outerIP, int ipAddress, int age_pvp_, int userNumber, int socket, int kind, char serverPort)
{
  ServerFrameList *this_; // ST0C_4@1
  int index; // ST10_4@1

  this_ = this;
  ReadWriteLock::writeLock(&this->m_rwLock);
  ++this_->m_fameCount;
  index = this_->m_usedBuffSize;
  this_->m_buff[index++] = serverId_;           // 0            index = 0
  memcpy(&this_->m_buff[index], &outerIP, 4u);  // 1-4          index = 1
  index += 4;                                   //              index = 5
  memcpy(&this_->m_buff[index], &serverPort, 4u);// 5-8
  index += 4;                                   //              index = 9
  this_->m_buff[index++] = age_pvp_;            // 9            index = 9
  this_->m_buff[index] = BYTE1(age_pvp_);       // 10           index = 10
  index += 3;                                   //              index = 13
  memcpy(&this_->m_buff[index], &userNumber, 2u);// 13-15        index = 13
  this_->m_usedBuffSize = index + 3;            // end: 13 + 3 => 15 + 1 (begin of next frame)
  ReadWriteLock::releaseWriteLock(&this_->m_rwLock);
  return 1;
}                                               // 2 bytes - general offset before frames (count & frame type)
                                                // 
                                                // c serverId     0
                                                // d serverIp     1-4 
                                                // d serverPort   5-8
                                                // c age          9
                                                // c pvp          10
                                                // d userNumber   11-14
                                                // c serverStatus 15

//----- (004362E7) --------------------------------------------------------
char __thiscall ServerFrameList::addExtendedFrame(ServerFrameList *this, char serverId_, char outerIPStr_0, int outerIPStr_4, int outerIPStr_8, int outerIPStr_12, int innerIPStr_0, int innerIPStr_4, int innerIPStr_8, int innerIPStr_12, int serverName_0, int serverName_4, int serverName_8, int serverName_12, int serverName_16, int serverName_20, char outerIP, int ipAddress, int age_pvp_, int userNumber, int socket, int kind, char serverPort)
{
  int index; // ST10_4@1
  int index__; // ST10_4@4
  ServerFrameList *this_; // [sp+0h] [bp-20h]@1
  int index_; // [sp+4h] [bp-1Ch]@1
  char serverName[20]; // [sp+Ch] [bp-14h]@3

  this_ = this;
  ReadWriteLock::writeLock(&this->m_rwLock);
  ++this_->m_fameCount;
  index = this_->m_usedBuffSize;
  this_->m_buff[index] = serverId_;             // 0            index = 0
  index_ = index + 1;                           //              index = 1
  if ( strlen((const char *)&innerIPStr_12 + 1) >= 20 )
  {
    strncpy(serverName, (const char *)&innerIPStr_12 + 1, 19u);// serverName
    serverName[19] = 0;
    swprintf((wchar_t *)&this_->m_buff[index_], aS_9, serverName);
  }
  else
  {
    swprintf((wchar_t *)&this_->m_buff[index_], aS_8, (char *)&innerIPStr_12 + 1);// serverName
  }
  index__ = index_ + 40;                        //              index = 41
  memcpy(&this_->m_buff[index__], &outerIP, 4u);// 41-44        index = 41
  index__ += 4;                                 //              index = 45
  memcpy(&this_->m_buff[index__], &serverPort, 4u);// 45-48       index = 45
  index__ += 4;                                 //              index = 49
  this_->m_buff[index__++] = age_pvp_;          // 49           index = 49
  this_->m_buff[index__] = BYTE1(age_pvp_);     // 50           index = 50
  index__ += 3;                                 //              index = 53
  memcpy(&this_->m_buff[index__], &userNumber, 2u);// 53-54       index = 53
  this_->m_usedBuffSize = index__ + 3;          //              index = 55 + 1 => 56, beginning of next frame
  ReadWriteLock::releaseWriteLock(&this_->m_rwLock);
  return 1;
}                                               // 0      serverId
                                                // 1-40   serverName
                                                // 41-44  serverIP   
                                                // 45-48  serverPort
                                                // 49     ageLimit
                                                // 50     pvp
                                                // 51-54  userNumber
                                                // 55     serverStatus
                                                // 
                                                // 

//----- (00436452) --------------------------------------------------------
char __thiscall ServerFrameList::addWithKindFrame(ServerFrameList *this, char serverId_, char outerIPStr_0, int outerIPStr_4, int outerIPStr_8, int outerIPStr_12, int innerIPStr_0, int innerIPStr_4, int innerIPStr_8, int innerIPStr_12, int serverName_0, int serverName_4, int serverName_8, int serverName_12, int serverName_16, int serverName_20, char outerIP, int ipAddress, int age_pvp_, int userNumber, int socket, int kind, char serverPort)
{
  ServerFrameList *this_; // ST0C_4@1
  int index; // ST10_4@1

  this_ = this;
  ReadWriteLock::writeLock(&this->m_rwLock);
  ++this_->m_fameCount;
  index = this_->m_usedBuffSize;
  this_->m_buff[index++] = serverId_;
  memcpy(&this_->m_buff[index], &outerIP, 4u);
  index += 4;
  memcpy(&this_->m_buff[index], &serverPort, 4u);
  index += 4;
  this_->m_buff[index++] = age_pvp_;
  this_->m_buff[index] = BYTE1(age_pvp_);
  index += 3;
  memcpy(&this_->m_buff[index], &userNumber, 2u);
  index += 3;
  memcpy(&this_->m_buff[index], &kind, 4u);
  this_->m_usedBuffSize = index + 4;
  ReadWriteLock::releaseWriteLock(&this_->m_rwLock);
  return 1;
}

//----- (00436576) --------------------------------------------------------
void __thiscall ServerFrameList::adjustFrameSize(ServerFrameList *this)
{
  ServerFrameList *this_; // ST00_4@1

  this_ = this;
  ReadWriteLock::readLock(&this->m_rwLock);
  this_->m_buff[0] = this_->m_fameCount;
  ReadWriteLock::releaseReadLock(&this_->m_rwLock);
}

//----- (004365A3) --------------------------------------------------------
int __thiscall ServerFrameList::setServerStatus(ServerFrameList *this, int serverId, bool status)
{
  int serverCount; // eax@1
  int serverId_; // ecx@4
  FrameType frameType; // [sp+4h] [bp-8h]@4
  ServerFrameList *this_; // [sp+8h] [bp-4h]@1

  this_ = this;
  serverCount = (char)serverId;
  if ( (char)serverId > 0 )
  {
    serverCount = ServerTable::getServerCount(&g_serverTable);
    if ( (char)serverId <= serverCount )
    {
      serverId_ = (int)this_;
      frameType = this_->m_frameType;
      switch ( frameType )
      {
        case FrameType_GameClient:
          LOBYTE(serverId_) = serverId;
          serverCount = ServerFrameList::setStatus_GameClientFrame(this_, serverId_, status);
          break;
        case FrameType_Extended:
          LOBYTE(serverCount) = serverId;
          serverCount = ServerFrameList::setStatus_ExtendedFrame(this_, serverCount, status);
          break;
        case FrameType_WithKind:
          serverCount = ServerFrameList::setStatus_WithKindFrame(this_, this_->m_frameType, status);
          break;
      }
    }
  }
  return serverCount;
}

//----- (00436624) --------------------------------------------------------
int __thiscall ServerFrameList::setStatus_GameClientFrame(ServerFrameList *this, int serverId, bool status)
{
  int result; // eax@5
  ServerFrameList *this_; // [sp+0h] [bp-Ch]@1
  int i; // [sp+8h] [bp-4h]@1

  this_ = this;
  for ( i = 0; i < this_->m_fameCount; ++i )
  {
    if ( this_->m_buff[16 * i + 2] == (char)serverId )
    {
      ReadWriteLock::readLock(&this_->m_rwLock);
      this_->m_buff[16 * i + 17] = status;
      ReadWriteLock::releaseReadLock(&this_->m_rwLock);
    }
    result = i + 1;
  }
  return result;
}                                               // 2 bytes - general offset before frames (count & frame type)
                                                // 
                                                // c serverId     0
                                                // d serverIp     1-4 
                                                // d serverPort   5-8
                                                // c age          9
                                                // c pvp          10
                                                // d userNumber   11-14
                                                // c serverStatus 15

//----- (00436699) --------------------------------------------------------
int __thiscall ServerFrameList::setStatus_ExtendedFrame(ServerFrameList *this, int serverId, bool status)
{
  int result; // eax@5
  ServerFrameList *this_; // [sp+0h] [bp-Ch]@1
  int i; // [sp+8h] [bp-4h]@1

  this_ = this;
  for ( i = 0; i < this_->m_fameCount; ++i )
  {
    if ( this_->m_buff[56 * i + 2] == (char)serverId )
    {
      ReadWriteLock::readLock(&this_->m_rwLock);
      this_->m_buff[56 * i + 57] = status;      // initial offset = 2, 55 + 2 = 57
      ReadWriteLock::releaseReadLock(&this_->m_rwLock);
    }
    result = i + 1;
  }
  return result;
}                                               // 0      serverId
                                                // 1-40   serverName
                                                // 41-44  serverIP   
                                                // 45-48  serverPort
                                                // 49     ageLimit
                                                // 50     pvp
                                                // 51-54  userNumber
                                                // 55     serverStatus

//----- (0043670E) --------------------------------------------------------
int __thiscall ServerFrameList::setStatus_WithKindFrame(ServerFrameList *this, int serverId, bool status)
{
  int result; // eax@5
  ServerFrameList *this_; // [sp+0h] [bp-Ch]@1
  int i; // [sp+8h] [bp-4h]@1

  this_ = this;
  for ( i = 0; i < this_->m_fameCount; ++i )
  {
    if ( this_->m_buff[20 * i + 2] == (char)serverId )
    {
      ReadWriteLock::readLock(&this_->m_rwLock);
      this_->m_buff[20 * i + 17] = status;
      ReadWriteLock::releaseReadLock(&this_->m_rwLock);
    }
    result = i + 1;
  }
  return result;
}

//----- (00436783) --------------------------------------------------------
int __thiscall ServerFrameList::setUserNumber(ServerFrameList *this, int serverId, int userNumber)
{
  int result; // eax@1
  int v4; // ecx@4
  FrameType frameType; // [sp+4h] [bp-8h]@4
  ServerFrameList *this_; // [sp+8h] [bp-4h]@1

  this_ = this;
  result = (char)serverId;
  if ( (char)serverId > 0 )
  {
    result = ServerTable::getServerCount(&g_serverTable);
    if ( (char)serverId <= result )
    {
      v4 = (int)this_;
      frameType = this_->m_frameType;
      switch ( frameType )
      {
        case FrameType_GameClient:
          LOBYTE(v4) = serverId;
          result = ServerFrameList::setUserNumber_GameClientFrame(this_, v4, userNumber);
          break;
        case FrameType_Extended:
          LOBYTE(result) = serverId;
          result = ServerFrameList::setUserNumber_ExtendedFrame(this_, result, userNumber);
          break;
        case FrameType_WithKind:
          result = ServerFrameList::setUserNumber_WithKindFrame(this_, this_->m_frameType, userNumber);
          break;
      }
    }
  }
  return result;
}

//----- (00436804) --------------------------------------------------------
int __thiscall ServerFrameList::setUserNumber_GameClientFrame(ServerFrameList *this, int serverId, int userNumber)
{
  int result; // eax@5
  ServerFrameList *this_; // [sp+0h] [bp-Ch]@1
  int i; // [sp+8h] [bp-4h]@1

  this_ = this;
  for ( i = 0; i < this_->m_fameCount; ++i )
  {
    if ( this_->m_buff[16 * i + 2] == (char)serverId )
    {
      ReadWriteLock::readLock(&this_->m_rwLock);
      memcpy(&this_->m_buff[16 * i + 13], &userNumber, 4u);// initial offse = 2, 11 + 2 = 13
      ReadWriteLock::releaseReadLock(&this_->m_rwLock);
    }
    result = i + 1;
  }
  return result;
}                                               // 2 bytes - general offset before frames (count & frame type)
                                                // 
                                                // c serverId     0
                                                // d serverIp     1-4 
                                                // d serverPort   5-8
                                                // c age          9
                                                // c pvp          10
                                                // d userNumber   11-14
                                                // c serverStatus 15

//----- (00436885) --------------------------------------------------------
int __thiscall ServerFrameList::setUserNumber_ExtendedFrame(ServerFrameList *this, int serverId, int userNumber)
{
  int result; // eax@5
  ServerFrameList *this_; // [sp+0h] [bp-Ch]@1
  int i; // [sp+8h] [bp-4h]@1

  this_ = this;
  for ( i = 0; i < this_->m_fameCount; ++i )
  {
    if ( this_->m_buff[56 * i + 2] == (char)serverId )
    {
      ReadWriteLock::readLock(&this_->m_rwLock);
      memcpy(&this_->m_buff[56 * i + 53], &userNumber, 4u);// initial offse = 2, 51 + 2 = 53
      ReadWriteLock::releaseReadLock(&this_->m_rwLock);
    }
    result = i + 1;
  }
  return result;
}                                               // 0      serverId
                                                // 1-40   serverName
                                                // 41-44  serverIP   
                                                // 45-48  serverPort
                                                // 49     ageLimit
                                                // 50     pvp
                                                // 51-54  userNumber
                                                // 55     serverStatus

//----- (00436906) --------------------------------------------------------
int __thiscall ServerFrameList::setUserNumber_WithKindFrame(ServerFrameList *this, int serverId, int userNumber)
{
  int result; // eax@5
  ServerFrameList *this_; // [sp+0h] [bp-Ch]@1
  int i; // [sp+8h] [bp-4h]@1

  this_ = this;
  for ( i = 0; i < this_->m_fameCount; ++i )
  {
    if ( this_->m_buff[20 * i + 2] == (char)serverId )
    {
      ReadWriteLock::readLock(&this_->m_rwLock);
      memcpy(&this_->m_buff[20 * i + 13], &userNumber, 4u);//   initial offse = 2, 11 + 2 = 13
      ReadWriteLock::releaseReadLock(&this_->m_rwLock);
    }
    result = i + 1;
  }
  return result;
}

//----- (00436987) --------------------------------------------------------
int __thiscall ServerFrameList::getBuffer(ServerFrameList *this, char **buffer)
{
  int result; // eax@2

  if ( this == (ServerFrameList *)-40 )
  {
    result = 0;
  }
  else
  {
    *buffer = this->m_buff;                     // buffer?
    result = this->m_usedBuffSize;
  }
  return result;
}

//----- (004369B6) --------------------------------------------------------
char __thiscall ServerFrameList::copyFromBuffer(ServerFrameList *this, FrameType frameType, int serverKind, int usedBuffSize, char *buffer)
{
  ServerFrameList *this_; // [sp+0h] [bp-8h]@1
  char success; // [sp+4h] [bp-4h]@1

  this_ = this;
  success = 0;
  if ( frameType == this->m_frameType && serverKind == this->m_serverKindIndex && buffer )
  {
    ReadWriteLock::writeLock(&this->m_rwLock);
    memcpy(this_->m_buff, buffer, 0x800u);
    this_->m_fameCount = this_->m_buff[0];
    this_->m_usedBuffSize = usedBuffSize;
    ReadWriteLock::releaseWriteLock(&this_->m_rwLock);
    success = 1;
  }
  return success;
}

//----- (00436A39) --------------------------------------------------------
char __thiscall ServerFrameList::isServerOn(ServerFrameList *this, int serverId)
{
  ServerFrameList *this_; // [sp+0h] [bp-14h]@1
  char status; // [sp+8h] [bp-Ch]@0
  int i; // [sp+Ch] [bp-8h]@1
  char available; // [sp+10h] [bp-4h]@1

  this_ = this;
  available = 0;
  for ( i = 0; i < this->m_fameCount; ++i )
  {
    if ( this->m_buff[16 * i + 2] == (char)serverId )// initial offset = 2
    {
      ReadWriteLock::readLock(&this->m_rwLock);
      status = this_->m_buff[16 * i + 17];      // initial offse = 2, 15 + 2 = 17
      ReadWriteLock::releaseReadLock(&this_->m_rwLock);
      break;
    }
  }
  if ( status == 1 )
    available = 1;
  return available;
}                                               // 2 bytes - general offset before frames (count & frame type)
                                                // 
                                                // c serverId     0
                                                // d serverIp     1-4 
                                                // d serverPort   5-8
                                                // c age          9
                                                // c pvp          10
                                                // d userNumber   11-14
                                                // c serverStatus 15

//----- (00436AC4) --------------------------------------------------------
char __thiscall ServerFrameList::isServerOnExtended(ServerFrameList *this, char serverId)
{
  ServerFrameList *this_; // [sp+0h] [bp-14h]@1
  char status; // [sp+8h] [bp-Ch]@0
  int i; // [sp+Ch] [bp-8h]@1
  char available; // [sp+10h] [bp-4h]@1

  this_ = this;
  available = 0;
  for ( i = 0; i < this->m_fameCount; ++i )
  {
    if ( this->m_buff[56 * i + 2] == serverId )
    {
      ReadWriteLock::readLock(&this->m_rwLock);
      status = this_->m_buff[56 * i + 57];      // initial offset = 2, 55 + 2 = 57
      ReadWriteLock::releaseReadLock(&this_->m_rwLock);
      break;
    }
  }
  if ( status == 1 )
    available = 1;
  return available;
}                                               // 0      serverId
                                                // 1-40   serverName
                                                // 41-44  serverIP   
                                                // 45-48  serverPort
                                                // 49     ageLimit
                                                // 50     pvp
                                                // 51-54  userNumber
                                                // 55     serverStatus

//----- (00436B4F) --------------------------------------------------------
ServerTable *__thiscall ServerTable::ServerTable(ServerTable *this)
{
  ServerTable *this_; // ST04_4@1
  char a2; // [sp+4h] [bp-10h]@1
  int unused; // [sp+10h] [bp-4h]@1

  this_ = this;
  std::vector_ServerInfo::vector_ServerInfo(&this->m_servers, &a2);
  unused = 0;
  ReadWriteLock::ReadWriteLock(&this_->m_rwLock);
  this_->vftable = (int)&ServerDB_vtable_off_45F924;
  this_->m_serverKindsCount = 0;
  this_->m_serverCount = 0;
  return this_;
}
// 45F924: using guessed type int (__stdcall *ServerDB_vtable_off_45F924)(int);

//----- (00436BC3) --------------------------------------------------------
std::vector_ServerInfo *__thiscall ServerTable::Destructor(ServerTable *this)
{
  ServerTable *this_; // [sp+4h] [bp-24h]@1
  ServerFrameList *frameList; // [sp+10h] [bp-18h]@6
  int serverKindIndex; // [sp+14h] [bp-14h]@3
  signed int frameType; // [sp+18h] [bp-10h]@1

  this_ = this;
  this->vftable = (int)&ServerDB_vtable_off_45F924;
  for ( frameType = 0; frameType < 4; ++frameType )
  {
    for ( serverKindIndex = 0; serverKindIndex < this_->m_serverKindsCount; ++serverKindIndex )
    {
      if ( this_->m_serverFrames[frameType][serverKindIndex] )
      {
        frameList = this_->m_serverFrames[frameType][serverKindIndex];
        if ( frameList )
          frameList->vtable->DeletingDestructor(frameList, 1);
      }
    }
    if ( this_->m_serverFrames[frameType] )
      _delete_table(this_->m_serverFrames[frameType]);
  }
  ReadWriteLock::Destructor(&this_->m_rwLock);
  return std::vector_ServerInfo::Destructor2(&this_->m_servers);
}
// 45F924: using guessed type int (__stdcall *ServerDB_vtable_off_45F924)(int);

//----- (00436CD0) --------------------------------------------------------
void __thiscall ServerTable::loadServerKindList(ServerTable *this)
{
  char v1; // al@39
  ServerFrameList *serverFrameList; // [sp+0h] [bp-B4h]@16
  ServerTable *this_; // [sp+4h] [bp-B0h]@1
  ServerFrameList *serverFrameList_; // [sp+14h] [bp-A0h]@15
  bool notFound[4]; // [sp+24h] [bp-90h]@1
  int serverKindNumber; // [sp+28h] [bp-8Ch]@1
  SqlQuery sql; // [sp+2Ch] [bp-88h]@1
  int serverKind; // [sp+40h] [bp-74h]@1
  FrameType frameType; // [sp+44h] [bp-70h]@1
  char serverCount; // [sp+48h] [bp-6Ch]@1
  ServerInfo serverId; // [sp+4Ch] [bp-68h]@28
  int success; // [sp+A4h] [bp-10h]@1
  int unused; // [sp+B0h] [bp-4h]@1

  this_ = this;
  LOBYTE(success) = 1;
  notFound[0] = 0;
  serverKindNumber = 0;
  frameType = 0;
  serverKind = 0;
  serverCount = 0;
  SqlQuery::SqlQuery(&sql, &g_dbManager);
  unused = 0;
  ReadWriteLock::writeLock(&this_->m_rwLock);
  if ( (unsigned __int8)std::vector_ServerInfo::empty(&this_->m_servers) )
  {
    SqlQuery::bindInt(&sql, &serverKindNumber);
    if ( SqlQuery::exec(&sql, aSelectMaxKindF) )
    {
      if ( SqlQuery::fetch(&sql, notFound) )
      {
        if ( notFound[0] )
        {
          ReadWriteLock::releaseWriteLock(&this_->m_rwLock);
          SqlQuery::reset(&sql);
          LogWindow::Add(&g_LogWindow, 3, aLoadServerkind);
          unused = -1;
          SqlQuery::Destructor(&sql);
          return;
        }
        SqlQuery::reset(&sql);
        while ( serverKindNumber )
        {
          serverKindNumber >>= 1;
          ++this_->m_serverKindsCount;
        }
        ++this_->m_serverKindsCount;
        for ( frameType = FrameType_DefaultOrCompressed; frameType < FrameType_Compressed; ++frameType )
        {
          this_->m_serverFrames[frameType] = (ServerFrameList **)operator new(4 * this_->m_serverKindsCount);
          if ( !this_->m_serverFrames[frameType] )
          {
            LogWindow::Add(&g_LogWindow, 3, aLoadServerki_0);
            LOBYTE(success) = 0;
            break;
          }
          memset(this_->m_serverFrames[frameType], 0, 4 * this_->m_serverKindsCount);
          for ( serverKind = 0; serverKind < this_->m_serverKindsCount; ++serverKind )
          {
            serverFrameList_ = (ServerFrameList *)operator new(2100u);
            LOBYTE(unused) = 1;
            if ( serverFrameList_ )
              serverFrameList = ServerFrameList::ServerFrameList(serverFrameList_);
            else
              serverFrameList = 0;
            LOBYTE(unused) = 0;
            this_->m_serverFrames[frameType][serverKind] = serverFrameList;
            if ( !this_->m_serverFrames[frameType][serverKind] )
            {
              LogWindow::Add(&g_LogWindow, 3, aLoadServerki_1);
              unused = -1;
              SqlQuery::Destructor(&sql);
              return;
            }
            ServerFrameList::init(this_->m_serverFrames[frameType][serverKind], frameType, serverKind);
          }
        }
      }
      else
      {
        LOBYTE(success) = 0;
      }
    }
    else
    {
      LOBYTE(success) = 0;
    }
    if ( !(_BYTE)success )
    {
      ReadWriteLock::releaseWriteLock(&this_->m_rwLock);
      SqlQuery::reset(&sql);
      LogWindow::Add(&g_LogWindow, 3, aLoadServerki_2);
      unused = -1;
      SqlQuery::Destructor(&sql);
      return;
    }
    SqlQuery::bindByte(&sql, &serverId);
    SqlQuery::bindStr(&sql, serverId.serverName, 26);
    SqlQuery::bindStr(&sql, serverId.outerIPStr, 16);
    SqlQuery::bindStr(&sql, serverId.innerIPStr, 16);
    SqlQuery::bindByte(&sql, &serverId.ageLimit);
    SqlQuery::bindBool(&sql, &serverId.pvp);
    SqlQuery::bindInt(&sql, &serverId.kind);
    SqlQuery::bindInt(&sql, &serverId.serverPort);
    if ( SqlQuery::exec(&sql, aSelectIdName_1) )
    {
      SqlQuery::fetch(&sql, notFound);
      while ( !notFound[0] )
      {
        if ( serverCount + 1 < serverId.serverId )
        {
          LogWindow::Add(&g_LogWindow, 3, aLoadingServe_1);
          LOBYTE(success) = 0;
          break;
        }
        ++serverCount;
        serverId.ipAddress = inet_addr(serverId.innerIPStr);
        serverId.outerIP = inet_addr(serverId.outerIPStr);
        serverId.userNumber = 0;
        serverId.socket = -1;
        serverId.serverName[25] = '\0';
        std::vector_ServerInfo::push_back(&this_->m_servers, &serverId);
        ++this_->m_serverCount;
        SqlQuery::fetch(&sql, notFound);
      }
    }
    else
    {
      LogWindow::Add(&g_LogWindow, 3, aLoadingServe_2);
      LOBYTE(success) = 0;
    }
  }
  ReadWriteLock::releaseWriteLock(&this_->m_rwLock);
  if ( this_->m_serverCount )
  {
    if ( (_BYTE)success )
    {
      ServerTable::updateListFrames(this_);
      LOBYTE(success) = v1;
    }
  }
  else
  {
    LOBYTE(success) = 0;
  }
  unused = -1;
  SqlQuery::Destructor(&sql);
}

//----- (00437250) --------------------------------------------------------
int __thiscall ServerTable::getServerCount(ServerTable *this)
{
  return this->m_serverCount;
}

//----- (00437261) --------------------------------------------------------
ServerInfo *__thiscall ServerTable::getServerInfo(ServerTable *this, ServerInfo *serverInfo, int serverId)
{
  ServerInfo *result; // eax@3
  unsigned int unused; // [sp+0h] [bp-68h]@0
  ServerTable *this_; // [sp+8h] [bp-60h]@1
  char v6; // [sp+Ch] [bp-5Ch]@4
  ServerInfo *serverInfo_; // [sp+64h] [bp-4h]@3

  this_ = this;
  ReadWriteLock::readLock(&this->m_rwLock);
  if ( serverId <= 0 || serverId > this_->m_serverCount )
  {
    v6 = 0;
    ReadWriteLock::releaseReadLock(&this_->m_rwLock);
    qmemcpy(serverInfo, &v6, sizeof(ServerInfo));
    result = serverInfo;
  }
  else
  {
    serverInfo_ = std::vector_ServerInfo::at(&this_->m_servers, serverId - 1, unused);
    ReadWriteLock::releaseReadLock(&this_->m_rwLock);
    qmemcpy(serverInfo, serverInfo_, sizeof(ServerInfo));
    result = serverInfo;
  }
  return result;
}

//----- (004372E1) --------------------------------------------------------
signed int __thiscall ServerTable::updateServerAndGetServerID(ServerTable *this, int IPaddress, SOCKET socket)
{
  ServerTable *this_; // [sp+0h] [bp-Ch]@1
  std::vector_ServerInfo::iterator *it; // [sp+4h] [bp-8h]@1
  signed int serverId; // [sp+8h] [bp-4h]@1

  this_ = this;
  serverId = -1;
  ReadWriteLock::writeLock(&this->m_rwLock);
  for ( it = std::vector_ServerInfo::begin(&this_->m_servers); it != std::vector_ServerInfo::end(&this_->m_servers); ++it )
  {
    if ( it->value.ipAddress == IPaddress )
    {
      if ( it->value.socket == -1 )
      {
        serverId = it->value.serverId;
        it->value.socket = socket;
      }
      else if ( it->value.socket == socket )
      {
        it->value.socket = -1;
        serverId = it->value.serverId;
      }
      else
      {
        serverId = -1;
      }
      break;
    }
  }
  ReadWriteLock::releaseWriteLock(&this_->m_rwLock);
  return serverId;
}

//----- (0043738C) --------------------------------------------------------
void __thiscall ServerTable::setServerStatus(ServerTable *this, char serverId, char status)
{
  int v3; // eax@8
  ServerTable *this_; // [sp+0h] [bp-Ch]@1
  int serverKindIndex; // [sp+4h] [bp-8h]@6
  signed int frameType; // [sp+8h] [bp-4h]@4

  this_ = this;
  if ( serverId > 0 && serverId <= this->m_serverCount )
  {
    for ( frameType = 0; frameType < 4; ++frameType )
    {
      for ( serverKindIndex = 0; serverKindIndex < this_->m_serverKindsCount; ++serverKindIndex )
      {
        v3 = (int)this_->m_serverFrames[frameType];
        if ( *(_DWORD *)(v3 + 4 * serverKindIndex) )
        {
          LOBYTE(v3) = serverId;
          ServerFrameList::setServerStatus(this_->m_serverFrames[frameType][serverKindIndex], v3, status);
        }
      }
    }
  }
}

//----- (0043741A) --------------------------------------------------------
void __thiscall ServerTable::setUserNumber(ServerTable *this, char serverId, int userNumber)
{
  int v3; // eax@8
  ServerTable *this_; // [sp+0h] [bp-Ch]@1
  int serverKindIndex; // [sp+4h] [bp-8h]@6
  signed int frameType; // [sp+8h] [bp-4h]@4

  this_ = this;
  if ( serverId > 0 && serverId <= this->m_serverCount )
  {
    for ( frameType = 0; frameType < 4; ++frameType )
    {
      for ( serverKindIndex = 0; serverKindIndex < this_->m_serverKindsCount; ++serverKindIndex )
      {
        v3 = (int)this_->m_serverFrames[frameType];
        if ( *(_DWORD *)(v3 + 4 * serverKindIndex) )
        {
          LOBYTE(v3) = serverId;
          ServerFrameList::setUserNumber(this_->m_serverFrames[frameType][serverKindIndex], v3, userNumber);
        }
      }
    }
  }
}

//----- (004374A8) --------------------------------------------------------
void __thiscall ServerTable::reloadServerKindList(ServerTable *this)
{
  char unused_1; // al@50
  ServerFrameList *serverFrameList; // [sp+4h] [bp-F0h]@23
  ServerTable *this_; // [sp+8h] [bp-ECh]@1
  ServerFrameList *serverFrameList_; // [sp+20h] [bp-D4h]@22
  ServerFrameList **serverFrames[4]; // [sp+3Ch] [bp-B8h]@43
  bool notFound[4]; // [sp+4Ch] [bp-A8h]@1
  int serverMaxKindNumber; // [sp+50h] [bp-A4h]@1
  SqlQuery sql; // [sp+54h] [bp-A0h]@1
  int serverKindIndex; // [sp+68h] [bp-8Ch]@1
  FrameType frameType; // [sp+6Ch] [bp-88h]@1
  char currentServerId; // [sp+70h] [bp-84h]@1
  ServerInfo serverInfo; // [sp+74h] [bp-80h]@29
  char unused_; // [sp+CCh] [bp-28h]@1
  int serverCount; // [sp+D0h] [bp-24h]@1
  ServerFrameList **frameLists[4]; // [sp+D4h] [bp-20h]@13
  int serverKindsCount; // [sp+E4h] [bp-10h]@1
  int unused; // [sp+F0h] [bp-4h]@1

  this_ = this;
  notFound[0] = 0;
  unused_ = 0;
  serverMaxKindNumber = 0;
  frameType = 0;
  serverKindIndex = 0;
  serverKindsCount = 0;
  serverCount = 0;
  currentServerId = 0;
  SqlQuery::SqlQuery(&sql, &g_dbManager);
  unused = 0;
  if ( (unsigned __int8)std::vector_ServerInfo::empty(&this_->m_servers) )
  {
    LogWindow::Add(&g_LogWindow, 3, aReloadServerki);
    unused = -1;
    SqlQuery::Destructor(&sql);
  }
  else
  {
    SqlQuery::bindInt(&sql, &serverMaxKindNumber);
    if ( SqlQuery::exec(&sql, aSelectMaxKin_0) )
    {
      if ( SqlQuery::fetch(&sql, notFound) )
      {
        SqlQuery::reset(&sql);
        if ( notFound[0] )
        {
          LogWindow::Add(&g_LogWindow, 3, aReloadServer_1);
          unused = -1;
          SqlQuery::Destructor(&sql);
        }
        else
        {
          while ( serverMaxKindNumber )
          {
            serverMaxKindNumber >>= 1;
            ++serverKindsCount;
          }
          if ( ++serverKindsCount > this_->m_serverKindsCount )
          {
            for ( frameType = 0; (signed int)frameType < 4; ++frameType )
            {
              frameLists[frameType] = (ServerFrameList **)operator new(4 * serverKindsCount);
              if ( !frameLists[frameType] )
              {
                LogWindow::Add(&g_LogWindow, 3, aReloadServer_2);
                unused = -1;
                SqlQuery::Destructor(&sql);
                return;
              }
              for ( serverKindIndex = 0; serverKindIndex < this_->m_serverKindsCount; ++serverKindIndex )
              {
                if ( this_->m_serverFrames[frameType][serverKindIndex] )
                  frameLists[frameType][serverKindIndex] = this_->m_serverFrames[frameType][serverKindIndex];
              }
              for ( serverKindIndex = this_->m_serverKindsCount; serverKindIndex < serverKindsCount; ++serverKindIndex )
              {
                serverFrameList_ = (ServerFrameList *)operator new(0x834u);
                LOBYTE(unused) = 1;
                if ( serverFrameList_ )
                  serverFrameList = ServerFrameList::ServerFrameList(serverFrameList_);
                else
                  serverFrameList = 0;
                LOBYTE(unused) = 0;
                frameLists[frameType][serverKindIndex] = serverFrameList;
                if ( frameLists[frameType][serverKindIndex] )
                  ServerFrameList::init(frameLists[frameType][serverKindIndex], frameType, serverKindIndex);
              }
            }
          }                                     // Select id, name, ip, inner_ip, ageLimit, pk_flag,kind, port
          SqlQuery::bindByte(&sql, &serverInfo);
          SqlQuery::bindStr(&sql, serverInfo.serverName, 26);
          SqlQuery::bindStr(&sql, serverInfo.outerIPStr, 16);
          SqlQuery::bindStr(&sql, serverInfo.innerIPStr, 16);
          SqlQuery::bindByte(&sql, &serverInfo.ageLimit);
          SqlQuery::bindBool(&sql, &serverInfo.pvp);
          SqlQuery::bindInt(&sql, &serverInfo.kind);
          if ( SqlQuery::exec(&sql, aSelectIdName_2) )// TODO: port is missed
          {
            SqlQuery::fetch(&sql, notFound);
            while ( !notFound[0] )
            {
              if ( currentServerId + 1 < serverInfo.serverId )
              {
                LogWindow::Add(&g_LogWindow, 3, aReloadingServe);
                unused = -1;
                SqlQuery::Destructor(&sql);
                return;
              }
              if ( this_->m_serverCount < ++currentServerId )
              {
                serverInfo.ipAddress = inet_addr(serverInfo.innerIPStr);
                serverInfo.outerIP = inet_addr(serverInfo.outerIPStr);
                serverInfo.userNumber = 0;
                serverInfo.socket = -1;
                ++serverCount;
                ReadWriteLock::writeLock(&this_->m_rwLock);
                std::vector_ServerInfo::push_back(&this_->m_servers, &serverInfo);
                ReadWriteLock::releaseWriteLock(&this_->m_rwLock);
              }
              SqlQuery::fetch(&sql, notFound);
            }
            if ( this_->m_serverKindsCount < serverKindsCount )
            {
              for ( frameType = 0; (signed int)frameType < 4; ++frameType )
              {
                serverFrames[frameType] = this_->m_serverFrames[frameType];
                this_->m_serverFrames[frameType] = frameLists[frameType];
              }
              for ( frameType = 0; (signed int)frameType < 4; ++frameType )
              {
                if ( serverFrames[frameType] )
                  _delete_table(serverFrames[frameType]);
              }
              this_->m_serverKindsCount = serverKindsCount;
            }
            ServerTable::updateListFrames(this_);
            unused_ = unused_1;
            if ( serverCount > 0 )
              this_->m_serverCount += serverCount;
            unused = -1;
            SqlQuery::Destructor(&sql);
          }
          else
          {
            LogWindow::Add(&g_LogWindow, 3, aReloadServerli);
            unused = -1;
            SqlQuery::Destructor(&sql);
          }
        }
      }
      else
      {
        SqlQuery::reset(&sql);
        LogWindow::Add(&g_LogWindow, 3, aReloadServer_3);
        unused = -1;
        SqlQuery::Destructor(&sql);
      }
    }
    else
    {
      SqlQuery::reset(&sql);
      LogWindow::Add(&g_LogWindow, 3, aReloadServer_0);
      unused = -1;
      SqlQuery::Destructor(&sql);
    }
  }
}

//----- (00437BB6) --------------------------------------------------------
void __thiscall ServerTable::updateListFrames(ServerTable *this)
{
  std::vector_ServerInfo::iterator *end; // eax@4
  std::vector_ServerInfo::iterator *end_; // eax@16
  ServerInfo serverInfo; // [sp+0h] [bp-8CCh]@5
  char *v4; // [sp+4h] [bp-8C8h]@5
  int v5; // [sp+8h] [bp-8C4h]@5
  int v6; // [sp+Ch] [bp-8C0h]@5
  int v7; // [sp+10h] [bp-8BCh]@5
  int v8; // [sp+14h] [bp-8B8h]@5
  int v9; // [sp+18h] [bp-8B4h]@5
  int v10; // [sp+1Ch] [bp-8B0h]@5
  int v11; // [sp+20h] [bp-8ACh]@5
  int v12; // [sp+24h] [bp-8A8h]@5
  int v13; // [sp+28h] [bp-8A4h]@5
  int v14; // [sp+2Ch] [bp-8A0h]@5
  int v15; // [sp+30h] [bp-89Ch]@5
  int v16; // [sp+34h] [bp-898h]@5
  int v17; // [sp+38h] [bp-894h]@5
  int v18; // [sp+3Ch] [bp-890h]@5
  int v19; // [sp+40h] [bp-88Ch]@5
  int v20; // [sp+44h] [bp-888h]@5
  int v21; // [sp+48h] [bp-884h]@5
  int v22; // [sp+4Ch] [bp-880h]@5
  int v23; // [sp+50h] [bp-87Ch]@5
  char *v24; // [sp+54h] [bp-878h]@5
  ServerTable *this_; // [sp+60h] [bp-86Ch]@1
  char v26; // [sp+64h] [bp-868h]@29
  int unused_; // [sp+68h] [bp-864h]@1
  std::vector_ServerInfo::iterator *it; // [sp+6Ch] [bp-860h]@3
  int serverKindIndex; // [sp+70h] [bp-85Ch]@1
  FrameType frameType; // [sp+74h] [bp-858h]@1
  int success; // [sp+78h] [bp-854h]@1
  int frameAdded; // [sp+7Ch] [bp-850h]@1
  char *buffer; // [sp+80h] [bp-84Ch]@1
  ServerFrameList tempFrameList; // [sp+84h] [bp-848h]@1
  int serverKind_Flag; // [sp+8B8h] [bp-14h]@1
  int buffSize; // [sp+8BCh] [bp-10h]@1
  int unused_1; // [sp+8C8h] [bp-4h]@1

  this_ = this;
  LOBYTE(success) = 1;
  serverKind_Flag = 0;
  unused_ = 0;
  serverKindIndex = 0;
  buffSize = 0;
  LOBYTE(frameAdded) = 0;
  buffer = 0;
  ServerFrameList::ServerFrameList(&tempFrameList);
  unused_1 = 0;
  for ( frameType = FrameType_DefaultOrCompressed; frameType < FrameType_Compressed; ++frameType )
  {
    ServerFrameList::init(&tempFrameList, frameType, 0);
    for ( it = std::vector_ServerInfo::begin(&this_->m_servers); ; ++it )
    {
      end = std::vector_ServerInfo::end(&this_->m_servers);
      if ( it == end )
        break;
      qmemcpy(&serverInfo, it, sizeof(serverInfo));
      ServerFrameList::addFrame(
        &tempFrameList,
        serverInfo.serverId,
        v4,
        v5,
        v6,
        v7,
        v8,
        v9,
        v10,
        v11,
        v12,
        v13,
        v14,
        v15,
        v16,
        v17,
        v18,
        v19,
        v20,
        v21,
        v22,
        v23,
        (int)v24);
    }
    ServerFrameList::adjustFrameSize(&tempFrameList);
    buffer = 0;
    buffSize = ServerFrameList::getBuffer(&tempFrameList, &buffer);
    if ( buffSize > 0 && buffer )
    {
      if ( *this_->m_serverFrames[frameType] )
      {
        v24 = buffer;
        v23 = buffSize;
        v22 = 0;
        v21 = frameType;
        LOBYTE(success) = ServerFrameList::copyFromBuffer(
                            *this_->m_serverFrames[frameType],
                            frameType,
                            0,
                            buffSize,
                            buffer);            // serverKind = 0
      }
    }
  }
  for ( frameType = 0; (signed int)frameType < 4; ++frameType )
  {
    serverKind_Flag = 1;
    for ( serverKindIndex = 1; serverKindIndex < this_->m_serverKindsCount; ++serverKindIndex )
    {
      ServerFrameList::init(&tempFrameList, frameType, serverKindIndex);
      for ( it = std::vector_ServerInfo::begin(&this_->m_servers); ; ++it )
      {
        end_ = std::vector_ServerInfo::end(&this_->m_servers);
        if ( it == end_ )
          break;
        if ( serverKind_Flag & it->value.kind )
        {
          qmemcpy(&serverInfo, it, sizeof(serverInfo));
          ServerFrameList::addFrame(
            &tempFrameList,
            serverInfo.serverId,
            v4,
            v5,
            v6,
            v7,
            v8,
            v9,
            v10,
            v11,
            v12,
            v13,
            v14,
            v15,
            v16,
            v17,
            v18,
            v19,
            v20,
            v21,
            v22,
            v23,
            (int)v24);
          LOBYTE(frameAdded) = 1;
        }
      }
      if ( (_BYTE)frameAdded )
      {
        ServerFrameList::adjustFrameSize(&tempFrameList);
        buffer = 0;
        buffSize = ServerFrameList::getBuffer(&tempFrameList, &buffer);
        if ( buffSize > 0 && buffer && this_->m_serverFrames[frameType][serverKindIndex] )
        {
          v24 = buffer;
          v23 = buffSize;
          v22 = serverKindIndex;
          v21 = frameType;
          LOBYTE(success) = ServerFrameList::copyFromBuffer(
                              this_->m_serverFrames[frameType][serverKindIndex],
                              frameType,
                              serverKindIndex,
                              buffSize,
                              buffer);
        }
      }
      LOBYTE(frameAdded) = 0;
      serverKind_Flag *= 2;
    }
  }
  ServerTable::updateStatuses(this_);
  if ( !(_BYTE)success )
    LogWindow::Add(&g_LogWindow, 3, aReloadserverli);
  v26 = success;
  unused_1 = -1;
  ServerFrameList::Destructor(&tempFrameList);
}

//----- (00437F57) --------------------------------------------------------
int __thiscall ServerTable::getServerKindsNumber(ServerTable *this)
{
  return this->m_serverKindsCount;
}

//----- (00437F68) --------------------------------------------------------
int __thiscall ServerTable::getServerList(ServerTable *this, char frameFormat, int serverKindIndex, char **buffer)
{
  int size; // eax@3

  if ( frameFormat >= (signed int)FrameType_DefaultOrCompressed && frameFormat <= (signed int)FrameType_Compressed )
  {
    if ( serverKindIndex >= 0 && serverKindIndex < this->m_serverKindsCount )
      size = ServerFrameList::getBuffer(this->m_serverFrames[frameFormat][serverKindIndex], buffer);
    else
      size = 0;
  }
  else
  {
    size = 0;
  }
  return size;
}

//----- (00437FCA) --------------------------------------------------------
int __thiscall ServerTable::updateStatuses(ServerTable *this)
{
  int result; // eax@12
  ServerInfo *serverInfo; // eax@3
  ServerTable *v3; // edx@8
  ServerTable *this_; // [sp+0h] [bp-68h]@1
  ServerInfo serverInfo_; // [sp+4h] [bp-64h]@3
  int serverKind; // [sp+5Ch] [bp-Ch]@6
  FrameType frameType; // [sp+60h] [bp-8h]@4
  int servIndex; // [sp+64h] [bp-4h]@1

  this_ = this;
  for ( servIndex = 1; servIndex <= this_->m_serverCount; ++servIndex )
  {
    serverInfo = ServerTable::getServerInfo(this_, &serverInfo_, servIndex);
    if ( WorldSrvServer::socketExists(&g_worldServServer, serverInfo->ipAddress) )
    {
      for ( frameType = FrameType_DefaultOrCompressed; frameType < FrameType_Compressed; ++frameType )
      {
        for ( serverKind = 0; serverKind < this_->m_serverKindsCount; ++serverKind )
        {
          v3 = this_;
          if ( this_->m_serverFrames[frameType][serverKind] )
          {
            LOBYTE(v3) = servIndex;
            ServerFrameList::setServerStatus(this_->m_serverFrames[frameType][serverKind], (int)v3, 1);
          }
        }
      }
    }
    result = servIndex + 1;
  }
  return result;
}

//----- (0043808B) --------------------------------------------------------
char __thiscall ServerTable::isServerOn(ServerTable *this, int serverId)
{
  int v2; // eax@1
  char available; // [sp+4h] [bp-4h]@1

  available = 0;
  v2 = (char)serverId;
  if ( (char)serverId > 0 && (char)serverId <= this->m_serverCount )
  {
    LOBYTE(v2) = serverId;
    available = ServerFrameList::isServerOn(*this->m_serverFrames[FrameType_GameClient], v2);
  }
  return available;
}

//----- (004380C9) --------------------------------------------------------
int sub_4380C9()
{
  SomeBitsInit();
  return sub_4380D8();
}

//----- (004380D8) --------------------------------------------------------
int sub_4380D8()
{
  return atexit(emptystub);
}

//----- (004380F0) --------------------------------------------------------
void *__thiscall ServerFrameList::DeletingDestructor(void *this, char a2)
{
  void *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  ServerFrameList::Destructor((ServerFrameList *)this);
  if ( a2 & 1 )
    _delete_table(v3);
  return v3;
}

//----- (00438120) --------------------------------------------------------
ServerTable *__thiscall ServerTableCallDestructor(ServerTable *this, char a2)
{
  ServerTable *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  ServerTable::Destructor(this);
  if ( a2 & 1 )
    _delete_table(v3);
  return v3;
}

//----- (00438150) --------------------------------------------------------
int StaticInit_ForUserManager()
{
  CallUserManagerStaticCtor();
  return RegisterStaticDestructorForUserManager();
}

//----- (0043815F) --------------------------------------------------------
UserManager *CallUserManagerStaticCtor()
{
  return UserManager::UserManager(&g_userManager);
}

//----- (0043816E) --------------------------------------------------------
int RegisterStaticDestructorForUserManager()
{
  return atexit(CallStaticDestructorForUserManager);
}

//----- (00438180) --------------------------------------------------------
void __cdecl CallStaticDestructorForUserManager()
{
  UserManager::Destructor(&g_userManager);
}

//----- (0043818F) --------------------------------------------------------
char __cdecl CAuthSocket::packet00_RequestAuthLogin(CAuthSocket *this_, char *buffer)
{
  void *clearStack; // esp@1
  int blockMsgLength; // eax@15
  int age; // esi@17
  int *clientIP; // eax@26
  int errorCode; // eax@28
  int errorCode_; // eax@36
  int v9; // [sp+28h] [bp-1110h]@26
  UserInfo *v10; // [sp+2Ch] [bp-110Ch]@26
  int unused; // [sp+34h] [bp-1104h]@21
  int errorCode_1; // [sp+4Ch] [bp-10ECh]@27
  SqlQuery sql; // [sp+50h] [bp-10E8h]@22
  in_addr ipAddress_; // [sp+64h] [bp-10D4h]@22
  int blockPacketSize; // [sp+68h] [bp-10D0h]@15
  int blockMsgLength_; // [sp+6Ch] [bp-10CCh]@15
  char blockPkg[4096]; // [sp+70h] [bp-10C8h]@15
  char error; // [sp+1070h] [bp-C8h]@1
  char password[17]; // [sp+1074h] [bp-C4h]@4
  int notifyGameServer; // [sp+1088h] [bp-B0h]@7
  char account[16]; // [sp+108Ch] [bp-ACh]@4
  __int16 clientCookie; // [sp+109Ch] [bp-9Ch]@1
  int ipAddress; // [sp+10A0h] [bp-98h]@1
  UserInfoTable userDB; // [sp+10A4h] [bp-94h]@1
  char credentials[30]; // [sp+1104h] [bp-34h]@5
  int payStatFlag; // [sp+1124h] [bp-14h]@26
  UserInfo *userInfo; // [sp+1128h] [bp-10h]@26
  int unsed; // [sp+1134h] [bp-4h]@1

  clearStack = alloca(4396);
  UserInfoTable::UserInfoTable(&userDB);
  unsed = 0;
  error = 0;
  clientCookie = 0;
  CAuthSocket::getUserIp(this_, &ipAddress);
  if ( g_Config.Useforbiddenip && IPList::contains(&g_blockedIPs, ipAddress) )
  {
    CAuthSocket::assembleAndSend(this_, aCc_27, LS_LoginFail, REASON_RESTRICTED_IP);// LoginFail
    unsed = -1;
    UserInfoTable::Destructor(&userDB);
    return 0;
  }
  this_->m_lastPacketTime = GetTickCount();
  memset(account, 0, 15u);
  memset(password, 0, 17u);
  if ( LOBYTE(g_Config.b_DesApply) )
  {
    memcpy(credentials, buffer, 30u);
    buffer += 30;
    DesFrontEnd::decodeData(credentials, 30);
    strncpy(account, credentials, 14u);
    strncpy(password, &credentials[14], 0x10u);
  }
  else
  {
    memcpy(account, buffer, 14u);
    buffer += 14;
    memcpy(password, buffer, 16u);
    buffer += 16;
  }
  notifyGameServer = BufferReader::ReadInt(&buffer);
  clientCookie = BufferReader::ReadShort(&buffer);
  if ( g_Config.Newencrypt )
    error = UserInfoTable::findUser_newCrypt(&userDB, account, password);
  else
    error = UserInfoTable::findUser(&userDB, account, password);
  if ( error )
  {
    CAuthSocket::assembleAndSend(this_, aCc_25, LS_LoginFail, error);// LoginFail
    unsed = -1;
    UserInfoTable::Destructor(&userDB);
    return 0;
  }
  if ( userDB.blockFlag_standard )              // Account Kicked
  {
    CAuthSocket::assembleAndSend(
      this_,
      aCdd_3,                                   //  BUGGY!!
      LS_AccountKicked,
      userDB.blockFlag_standard,
      *(_DWORD *)&userDB.block_end_date.year,   // year + month
      *(_DWORD *)&userDB.block_end_date.day,    // day + hour
      *(_DWORD *)&userDB.block_end_date.minute, // minute + second
      userDB.block_end_date.fraction);
    unsed = -1;
    UserInfoTable::Destructor(&userDB);
    return 0;
  }
  if ( userDB.blockFlag_custom )
  {
    memset(blockPkg, 0, 0x1000u);
    blockMsgLength = UserInfoTable::addBlockReason(&userDB, &blockPkg[3]);
    blockMsgLength_ = blockMsgLength;
    blockPacketSize = g_Config.PacketSizeType + blockMsgLength;
    *(_WORD *)blockPkg = LOWORD(g_Config.PacketSizeType) + blockMsgLength;
    blockPkg[2] = LS_AccountBlocked;
    CAuthSocket::sendPacket(this_, blockPkg, blockMsgLength + 3);
    unsed = -1;
    UserInfoTable::Destructor(&userDB);
    return 0;
  }
  if ( !g_Config.CountryCode )
  {
    age = userDB.age;
    if ( age < ServerList::getAgeLimit(&g_ServerList) )// TODO: newServerList (Table) is not handled here
    {
      CAuthSocket::assembleAndSend(this_, aCc_26, LS_LoginFail, REASON_UNDER_18_YEARS_KR);
      unsed = -1;
      UserInfoTable::Destructor(&userDB);
      return 0;
    }
  }
  if ( userDB.loginFlag & 0x10                  // 0x10 - GM?
    && LOBYTE(g_Config.b_Restrictgmip)
    && *CAuthSocket::getUserIp(this_, &unused) != g_Config.gmIP )
  {
    CAuthSocket::getUserIp(this_, (int *)&ipAddress_);
    SqlQuery::SqlQuery(&sql, &g_dbManager);
    LOBYTE(unsed) = 1;
    SqlQuery::exec(
      &sql,
      aInsertGm_illeg,
      userDB.account,
      ipAddress_.S_un.S_un_b.s_b1,
      ipAddress_.S_un.S_un_b.s_b2,
      ipAddress_.S_un.S_un_b.s_b3,
      ipAddress_.S_un.S_un_b.s_b4);
    CAuthSocket::assembleAndSend(this_, aCc_10, LS_LoginFail, REASON_SYSTEM_ERROR);// not a gm IP 
    LOBYTE(unsed) = 0;
    SqlQuery::Destructor(&sql);
    unsed = -1;
    UserInfoTable::Destructor(&userDB);
    return 0;
  }
  if ( g_Config.Freeserver && userDB.payStat )
    userDB.payStat = 1002;
  v10 = (UserInfo *)operator new(0x50u);
  userInfo = v10;
  clientIP = CAuthSocket::getUserIp(this_, &v9);
  userInfo->connectedIP = *clientIP;
  userInfo->sessionKey = CAuthSocket::getSessionKey(this_);
  userInfo->payStat = userDB.payStat;
  userInfo->gameSocket = this_->base.m_hSocket;
  LOBYTE(userInfo->sexAndCentury) = userDB.someChar2;
  userInfo->timerHandler = 0;
  userInfo->loginState = LoginState_Connected;
  userInfo->birthdayEncoded = userDB.flag_113;
  userInfo->restOfSsn = userDB.restOfSsn;
  userInfo->loginFlag = userDB.loginFlag;
  userInfo->warnFlag = userDB.warnFlag;
  userInfo->age = userDB.age;
  userInfo->clientCookie = clientCookie;
  strncpy(userInfo->accountName, userDB.account, 15u);
  userInfo->accountName[14] = 0;
  userInfo->lastworld = userDB.lastworld;
  userInfo->loginTime = time(0);
  userInfo->loggedGameServerId = 0;
  userInfo->selectedGServerId = 0;
  userInfo->notifyGameServer = notifyGameServer;// 8 (dont) or 16 (report)
  this_->m_uid = userDB.uid;
  payStatFlag = userDB.payStat % 1000 / 100;
  if ( !g_Config.Useipserver )
    goto LABEL_45;
  errorCode_1 = 0;
  if ( g_Config.PcCafeFirst )
  {
    errorCode = IPSessionDB::registerWaitingAcc(&g_IPSessionDB, userInfo, userDB.uid);
    errorCode_1 = (char)errorCode;
    if ( (_BYTE)errorCode )
    {
      if ( (char)errorCode == 11 )
      {
        CAuthSocket::assembleAndSend(this_, aCc_11, LS_LoginFail, REASON_ACCOUNT_IN_USE);
        _delete_table(userInfo);
      }
      else
      {
        CAuthSocket::authenticateUser(this_, userInfo, userDB.uid);
        _delete_table(userInfo);
      }
    }
    unsed = -1;
    UserInfoTable::Destructor(&userDB);
    return 0;
  }
  if ( userDB.payStat && payStatFlag != 2 )
  {
LABEL_45:
    CAuthSocket::authenticateUser(this_, userInfo, userDB.uid);
    _delete_table(userInfo);
    unsed = -1;
    UserInfoTable::Destructor(&userDB);
    return 0;
  }
  errorCode_ = IPSessionDB::registerWaitingAcc(&g_IPSessionDB, userInfo, userDB.uid);
  errorCode_1 = (char)errorCode_;
  if ( (_BYTE)errorCode_ )
  {
    if ( (char)errorCode_ == 11 )
    {
      CAuthSocket::assembleAndSend(this_, aCc_12, LS_LoginFail, REASON_ACCESS_FAILED);//  acc in use
      _delete_table(userInfo);
    }
    else
    {
      CAuthSocket::authenticateUser(this_, userInfo, userDB.uid);
      _delete_table(userInfo);
    }
  }
  unsed = -1;
  UserInfoTable::Destructor(&userDB);
  return 0;
}

//----- (0043896C) --------------------------------------------------------
char __cdecl CAuthSocket::packet01_ServerListPacket(CAuthSocket *this, char *buffer)
{
  char result; // al@2
  char serverListPacket[1024]; // [sp+0h] [bp-420h]@5
  int unsed; // [sp+400h] [bp-20h]@5
  int sessionKey; // [sp+404h] [bp-1Ch]@1
  int uid; // [sp+408h] [bp-18h]@1
  char accountName[16]; // [sp+40Ch] [bp-14h]@1
  char lastWorld; // [sp+41Ch] [bp-4h]@1

  uid = BufferReader::ReadInt(&buffer);
  sessionKey = BufferReader::ReadInt(&buffer);
  this->m_uid = uid;
  lastWorld = UserManager::userAuthed(&g_userManager, uid, accountName);
  if ( lastWorld >= 0 )
  {
    this->m_lastPacketTime = GetTickCount();    // ServerList Format: cc [cddcchhcdc] 
                                                // c: server list size (number of servers) 
                                                // c: ? 
                                                // [ (repeat for each servers) 
                                                //     c: server id (ignored by client?) 
                                                //     d: server ip 
                                                //     d: server port 
                                                //     c: age limit (used by client?) 
                                                //     c: pvp or not (used by client?) 
                                                //     h: current number of players 
                                                //     h: max number of players 
                                                //     c: 0 if server is down 
                                                //     d: 2nd bit: clock 3rd bit: wont dsiplay server name 4th bit: test server (used by client?) 
                                                //     c: 0 if you dont want to display brackets in front of sever name ] 
                                                // Server will be considered as Good when the number of online players is less 
                                                // than half the maximum. as Normal between half and 4/5 and Full when there's more 
                                                // than 4/5 of the maximum number of players
                                                // 
    if ( g_ServerList.m_defaultOrCompressedSize >= 10 )
    {
      memcpy(&serverListPacket[3], g_ServerList.m_compressedFrameBuffers, g_ServerList.m_defaultOrCompressedSize);
      unsed = g_ServerList.m_defaultOrCompressedSize + g_Config.PacketSizeType;
      *(_WORD *)serverListPacket = LOWORD(g_ServerList.m_defaultOrCompressedSize) + LOWORD(g_Config.PacketSizeType);
      serverListPacket[2] = LS_ServerList;
      CAuthSocket::sendPacket(
        this,
        serverListPacket,
        g_ServerList.m_defaultOrCompressedSize + g_Config.PacketSizeType + 3 - g_Config.PacketSizeType);
      result = 0;
    }
    else
    {
      LogWindow::Add(&g_LogWindow, 3, aServerListErro);
      CAuthSocket::assembleAndSend(this, aCc_13, LS_ServerListFail, 6);
      result = 0;
    }
  }
  else
  {
    result = true;
  }
  return result;
}

//----- (00438A69) --------------------------------------------------------
char __cdecl CAuthSocket::packet02_RequestServerLogin(CAuthSocket *this, char *buffer)
{
  char result; // al@2
  char serverId_; // ST20_1@10
  int payStat_; // ST1C_4@10
  int *ipAddress; // eax@10
  int a2a; // [sp+14h] [bp-58h]@10
  char errorCode; // [sp+18h] [bp-54h]@10
  int sessionKey; // [sp+1Ch] [bp-50h]@1
  int payFlags; // [sp+20h] [bp-4Ch]@8
  int totalTime; // [sp+24h] [bp-48h]@13
  int payStat; // [sp+28h] [bp-44h]@1
  char timeError; // [sp+2Ch] [bp-40h]@13
  int warnFlag; // [sp+30h] [bp-3Ch]@1
  int receivedSessionKey; // [sp+34h] [bp-38h]@1
  int uid; // [sp+38h] [bp-34h]@1
  char accName[15]; // [sp+3Ch] [bp-30h]@1
  char selectedGServerId; // [sp+4Ch] [bp-20h]@1
  int loginFlag; // [sp+50h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+54h] [bp-18h]@1 exception handler. Bug

  loginFlag = 0;
  warnFlag = 0;
  ms_exc.registration.TryLevel = 0;
  memset(accName, 0, 15u);
  uid = BufferReader::ReadInt(&buffer);
  receivedSessionKey = BufferReader::ReadInt(&buffer);
  selectedGServerId = BufferReader::ReadByte(&buffer);
  payStat = 0;
  sessionKey = 0;
  this->m_lastPacketTime = GetTickCount();
  if ( UserManager::userReadyForGS(&g_userManager, uid, accName, &loginFlag, &warnFlag, &payStat, &sessionKey) )
  {
    if ( sessionKey == receivedSessionKey )
    {
      Utils::normalizeName(accName);
      if ( selectedGServerId <= g_ServerList.m_serverNumber && selectedGServerId >= 1 )
      {
        payFlags = payStat % 1000 / 100;
        if ( payStat < 1000 && g_Config.Useipserver )
        {
          serverId_ = selectedGServerId;
          payStat_ = payStat;
          ipAddress = CAuthSocket::getUserIp(this, &a2a);
          errorCode = IPSessionDB::sendServerLoginRequested(&g_IPSessionDB, uid, *ipAddress, payStat_, serverId_);
          if ( errorCode == 10 )
            CAuthSocket::assembleAndSend(this, aCc_17, LS_PlayFail, REASON_SYSTEM_ERROR);
          ms_exc.registration.TryLevel = -1;
          result = 0;
        }
        else
        {
          totalTime = 0;
          timeError = 0;
          if ( payFlags && payFlags == 2 )
            timeError = UserManager::getUserGameTime(uid, &totalTime);
          if ( timeError )
          {
            CAuthSocket::assembleAndSend(this, aCc_18, LS_PlayFail, timeError);
            ms_exc.registration.TryLevel = -1;
            result = 0;
          }
          else
          {
            MemoryObject::AddRef(&this->base.base);
            UserManager::forwardUserToGS(
              &g_userManager,
              uid,
              accName,
              totalTime,
              loginFlag,
              warnFlag,
              receivedSessionKey,
              this,
              selectedGServerId,
              payStat);
            MemoryObject::Release(&this->base.base);
            result = 0;
          }
        }
      }
      else
      {
        CAuthSocket::assembleAndSend(this, aCc_16, LS_PlayFail, REASON_IP_SESSION_REJECTED);
        ms_exc.registration.TryLevel = -1;
        result = 0;
      }
    }
    else
    {
      CAuthSocket::assembleAndSend(this, aCc_15, LS_PlayFail, REASON_INVALID_STATE);
      LogWindow::Add(&g_LogWindow, 3, aMd5keyDoesNotM);
      ms_exc.registration.TryLevel = -1;
      result = 0;
    }
  }
  else
  {
    CAuthSocket::assembleAndSend(this, aCc_14, LS_PlayFail, REASON_INVALID_STATE);
    ms_exc.registration.TryLevel = -1;
    result = 0;
  }
  return result;
}

//----- (00438D5A) --------------------------------------------------------
bool __cdecl CAuthSocket::packet03_CancelLogin(CAuthSocket *this, char *buffer)
{
  int uid; // ST0C_4@1
  int sessionKey; // ST08_4@1

  uid = BufferReader::ReadInt(&buffer);
  sessionKey = BufferReader::ReadInt(&buffer);
  return UserManager::loginCanceled(&g_userManager, uid, sessionKey) != false;
}

//----- (00438DA3) --------------------------------------------------------
char __cdecl CAuthSocket::packet05_RequestServerList_C4(CAuthSocket *this, char *buffer)
{
  int serverKindIndex; // [sp+14h] [bp-84Ch]@9
  char *servListBuffer; // [sp+18h] [bp-848h]@15
  int serverKind; // [sp+1Ch] [bp-844h]@7
  char frameFormat; // [sp+20h] [bp-840h]@1
  int v7; // [sp+24h] [bp-83Ch]@1
  int uid; // [sp+28h] [bp-838h]@1
  char accountName[16]; // [sp+2Ch] [bp-834h]@1
  char lastWorld; // [sp+3Ch] [bp-824h]@1
  char packetBuffer[2048]; // [sp+40h] [bp-820h]@6
  size_t unused; // [sp+840h] [bp-20h]@1
  size_t framesBufferSize; // [sp+844h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+848h] [bp-18h]@1

  unused = 0;
  framesBufferSize = 0;
  ms_exc.registration.TryLevel = 0;
  uid = BufferReader::ReadInt(&buffer);
  v7 = BufferReader::ReadInt(&buffer);
  BufferReader::ReadByte(&buffer);
  frameFormat = FrameType_GameClient;
  this->m_uid = uid;
  lastWorld = UserManager::userAuthed(&g_userManager, uid, accountName);
  if ( lastWorld < 0 )
  {
    ms_exc.registration.TryLevel = -1;
    return 1;
  }
  this->m_lastPacketTime = GetTickCount();
  if ( g_Config.Newserverlist )
  {
    serverKind = BufferReader::ReadInt(&buffer);
    if ( serverKind < 0 )
    {
      CAuthSocket::assembleAndSend(this, aCc_20, LS_ServerListFail, 20);
      ms_exc.registration.TryLevel = -1;
      return 0;
    }
    serverKindIndex = 0;
    while ( serverKind > 0 )
    {
      ++serverKindIndex;
      serverKind >>= 1;
    }
    if ( serverKindIndex < 0 || serverKindIndex >= ServerTable::getServerKindsNumber(&g_serverTable) )
    {
      CAuthSocket::assembleAndSend(this, aCc_21, LS_ServerListFail, 6);
      ms_exc.registration.TryLevel = -1;
      return 0;
    }
    servListBuffer = 0;
    framesBufferSize = ServerTable::getServerList(&g_serverTable, frameFormat, serverKindIndex, &servListBuffer);
    if ( (signed int)framesBufferSize <= 0 )
    {
      CAuthSocket::assembleAndSend(this, aCc_22, LS_ServerListFail, 20);
      ms_exc.registration.TryLevel = -1;
      return 0;
    }
    memcpy(&packetBuffer[3], servListBuffer, framesBufferSize);
  }
  else
  {
    if ( g_ServerList.m_frameSizes[frameFormat] < 10 )
    {
      LogWindow::Add(&g_LogWindow, 3, aServerListEr_0);
      CAuthSocket::assembleAndSend(this, aCc_19, LS_ServerListFail, 6);
      ms_exc.registration.TryLevel = -1;
      return 0;
    }
    framesBufferSize = g_ServerList.m_frameSizes[frameFormat];
    memcpy(&packetBuffer[3], g_ServerList.m_frameLists[frameFormat], framesBufferSize);
  }
  if ( frameFormat > 0 )
    packetBuffer[4] = lastWorld;
  unused = framesBufferSize + g_Config.PacketSizeType;
  *(_WORD *)packetBuffer = framesBufferSize + LOWORD(g_Config.PacketSizeType);
  packetBuffer[2] = LS_ServerList;
  CAuthSocket::sendPacket(this, packetBuffer, framesBufferSize + g_Config.PacketSizeType + 3 - g_Config.PacketSizeType);
  return 0;
}

//----- (00439142) --------------------------------------------------------
signed int WorldSrvServer::sendToWorldServer(int ipAddress, char *format, ...)
{
  signed int result; // eax@2
  WorldSrvSocket *worldSocket; // [sp+0h] [bp-14h]@1
  int packetSize; // [sp+8h] [bp-Ch]@3
  CIOBuffer *buff; // [sp+10h] [bp-4h]@3
  va_list va; // [sp+24h] [bp+10h]@1

  va_start(va, format);
  worldSocket = WorldSrvServer::getSocket(&g_worldServServer, ipAddress);
  if ( worldSocket )
  {
    buff = CIOBuffer::Alloc();
    packetSize = PacketUtils::VAssemble((char *)&buff->m_Buffer[2], 8190, format, va);
    if ( packetSize )
    {
      packetSize = g_Config.PacketSizeType + packetSize - 1;
      buff->m_Buffer[0] = packetSize;
      buff->m_Buffer[1] = BYTE1(packetSize);
    }
    else
    {
      LogWindow::Add(&g_LogWindow, 3, aDAssembleToo_4, worldSocket->m_base.m_hSocket, format);
    }
    buff->m_dwSize = packetSize + 3 - g_Config.PacketSizeType;
    CIOSocket::Write(&worldSocket->m_base, buff);
    MemoryObject::Release(&worldSocket->m_base.base);
    result = true;
  }
  else
  {
    result = false;
  }
  return result;
}

//----- (00439225) --------------------------------------------------------
char __cdecl CAuthSocket::packet04_unknownHandler(CAuthSocket *this)
{
  char pass[16]; // [sp+0h] [bp-20h]@1
  char accName[16]; // [sp+10h] [bp-10h]@1

  memset(accName, 0, 15u);
  memset(pass, 0, 16u);
  this->m_lastPacketTime = GetTickCount();
  return 0;
}

//----- (0043925D) --------------------------------------------------------
char __cdecl CAuthSocket::packet06_unknownHandler(CAuthSocket *this, char *buffer)
{
  char result; // al@2
  int uid_; // ST10_4@15
  ServerInfo *serverInfo; // eax@15
  ServerInfo outServerInfo; // [sp+8h] [bp-B0h]@15
  char *serversTable_; // [sp+60h] [bp-58h]@5
  SqlQuery sql; // [sp+68h] [bp-50h]@3
  bool notFound[4]; // [sp+7Ch] [bp-3Ch]@1
  int unused; // [sp+80h] [bp-38h]@1
  int serverId; // [sp+84h] [bp-34h]@12
  int uid; // [sp+88h] [bp-30h]@1
  char accountName[16]; // [sp+8Ch] [bp-2Ch]@1
  int unused_1; // [sp+9Ch] [bp-1Ch]@1
  char lastWorld; // [sp+A0h] [bp-18h]@1
  char *serversTable; // [sp+A4h] [bp-14h]@5
  int serversNumber; // [sp+A8h] [bp-10h]@5
  int unused_2; // [sp+B4h] [bp-4h]@3

  unused_1 = 0;
  lastWorld = 0;
  unused = 0;
  notFound[0] = 0;
  accountName[0] = 0;
  uid = BufferReader::ReadInt(&buffer);
  if ( UserManager::userAuthed(&g_userManager, uid, accountName) >= 0 )
  {
    SqlQuery::SqlQuery(&sql, &g_dbManager);
    unused_2 = 0;
    SqlQuery::bindByte(&sql, &lastWorld);
    if ( SqlQuery::exec(&sql, aSelectWorld_id, uid) )
    {
      serversNumber = ServerList::getServerCount(&g_ServerList);
      serversTable_ = (char *)operator new(serversNumber + 1);
      serversTable = serversTable_;
      memset(serversTable_, 0, serversNumber + 1);
      while ( SqlQuery::fetch(&sql, notFound) && !notFound[0] )
      {
        if ( lastWorld > 0 && lastWorld <= serversNumber )
          serversTable[lastWorld] = 1;
      }
      for ( serverId = 1; serverId <= serversNumber; ++serverId )
      {
        if ( serversTable[serverId] )
        {
          uid_ = uid;
          serverInfo = ServerList::getServerInfo(&g_ServerList, &outServerInfo, serverId);
          WorldSrvServer::sendToWorldServer(serverInfo->ipAddress, aCd_1, 6, uid_);
        }
      }
      _delete_table(serversTable);
      unused_2 = -1;
      SqlQuery::Destructor(&sql);
      result = 0;
    }
    else
    {
      unused_2 = -1;
      SqlQuery::Destructor(&sql);
      result = 0;
    }
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (00439436) --------------------------------------------------------
char __cdecl CAuthSocket::packet07_charsHandler(CAuthSocket *this, char *buffer)
{
  char result; // al@2
  int serverId_; // esi@6
  char *v4; // ST20_4@7
  int v5; // ST1C_4@7
  int v6; // ST18_4@7
  int serverId_1; // ST14_4@7
  int uid_; // ST10_4@7
  ServerInfo *serverInfo; // eax@7
  ServerInfo a2a; // [sp+8h] [bp-A8h]@7
  int v11; // [sp+68h] [bp-48h]@10
  int v12; // [sp+6Ch] [bp-44h]@8
  int success; // [sp+70h] [bp-40h]@7
  int unused; // [sp+74h] [bp-3Ch]@4
  int unused_2; // [sp+78h] [bp-38h]@2
  char v16; // [sp+7Ch] [bp-34h]@1
  int uid; // [sp+80h] [bp-30h]@1
  SqlQuery sql; // [sp+84h] [bp-2Ch]@1
  int userCharNumber; // [sp+98h] [bp-18h]@1
  char serverId; // [sp+9Ch] [bp-14h]@1
  int v21; // [sp+A0h] [bp-10h]@1
  int unused_3; // [sp+ACh] [bp-4h]@1

  v16 = 0;
  uid = BufferReader::ReadInt(&buffer);
  serverId = BufferReader::ReadByte(&buffer);
  v21 = BufferReader::ReadShort(&buffer);
  SqlQuery::SqlQuery(&sql, &g_dbManager);
  unused_3 = 0;
  userCharNumber = 0;
  userCharNumber = UserManager::getUserCharNumber(uid);
  if ( userCharNumber >= 0 )
  {
    if ( userCharNumber < 11 )
    {
      if ( serverId <= 0 || (serverId_ = serverId, serverId_ > ServerList::getServerCount(&g_ServerList)) )
      {
        v11 = 0;
        CAuthSocket::assembleAndSend(this, aCcdd_2, LS_CharSelection, 8, uid, 0);
      }
      else
      {
        v4 = buffer;
        v5 = v21;
        v6 = v21;
        serverId_1 = serverId;
        uid_ = uid;
        serverInfo = ServerList::getServerInfo(&g_ServerList, &a2a, serverId);
        success = WorldSrvServer::sendToWorldServer(serverInfo->ipAddress, aCdchb, 7, uid_, serverId_1, v6, v5, v4);
        if ( !success )
        {
          v12 = 0;
          CAuthSocket::assembleAndSend(this, aCcdd_1, LS_CharSelection, 8, uid, 0);
        }
      }
      unused_3 = -1;
      SqlQuery::Destructor(&sql);
      result = 0;
    }
    else
    {
      unused = 0;
      CAuthSocket::assembleAndSend(this, aCcdd_0, LS_CharSelection, 29, uid, 0);
      unused_3 = -1;
      SqlQuery::Destructor(&sql);
      result = 0;
    }
  }
  else
  {
    unused_2 = 0;
    CAuthSocket::assembleAndSend(this, aCcdd, LS_CharSelection, 1, uid, 0);
    unused_3 = -1;
    SqlQuery::Destructor(&sql);
    result = 0;
  }
  return result;
}

//----- (00439627) --------------------------------------------------------
char __cdecl CAuthSocket::packet08_unknownHandler(CAuthSocket *this, char *buffer)
{
  int v2; // ST14_4@3
  int v3; // ST10_4@3
  ServerInfo *serverInfo_; // eax@3
  ServerInfo serverInfo; // [sp+0h] [bp-6Ch]@3
  int success; // [sp+58h] [bp-14h]@3
  int uid; // [sp+5Ch] [bp-10h]@1
  int v9; // [sp+60h] [bp-Ch]@1
  int serverId; // [sp+64h] [bp-8h]@1
  __int16 zero; // [sp+68h] [bp-4h]@1

  uid = BufferReader::ReadInt(&buffer);
  serverId = BufferReader::ReadInt(&buffer);
  v9 = BufferReader::ReadInt(&buffer);
  zero = 0;
  if ( serverId <= 0 || serverId > ServerList::getServerCount(&g_ServerList) )
  {
    CAuthSocket::assembleAndSend(this, aCdch_0, LS_CharDeleted, 8, zero);
  }
  else
  {
    v2 = v9;
    v3 = uid;
    serverInfo_ = ServerList::getServerInfo(&g_ServerList, &serverInfo, serverId);
    success = WorldSrvServer::sendToWorldServer(serverInfo_->ipAddress, aCdcd, 8, v3, v2);
    if ( !success )
      CAuthSocket::assembleAndSend(this, aCdch, LS_CharDeleted, 8, zero);
  }
  return 0;
}

//----- (004396FC) --------------------------------------------------------
void __stdcall CAuthSocket::onTimeout(PVOID socket, BOOLEAN a2)
{
  CAuthSocket *userSocket; // [sp+0h] [bp-8h]@1

  userSocket = CAuthServer::getIOSocket(&g_authServer, (SOCKET)socket);
  if ( userSocket )
    userSocket->base.base.vftbl_0_45F520->OnTimerCallback((MemoryObject *)userSocket);
}

//----- (00439730) --------------------------------------------------------
CAuthSocket *__thiscall CAuthSocket::CAuthSocket(CAuthSocket *this, SOCKET socket)
{
  CAuthSocket *this_; // [sp+0h] [bp-18h]@1

  this_ = this;
  CIOSocket::CIOSocket(&this->base, socket);
  this_->base.base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&CAuthSocket_vtable_offset_0045F944;
  MemoryObject::AddRef(&this_->base.base);
  this_->m_socket = socket;
  this_->m_clientIP.S_un.S_addr = 0;
  this_->m_unused_156 = 0;
  this_->m_socketStatus = SocketStatus_Init;
  this_->m_packetHandler = (bool (__cdecl **)(CAuthPacket *, const char *))CAuthSocket_handlers_off_46D690;
  this_->m_clientLoginState = 0;
  this_->m_uid = 0;
  this_->m_socketTimeoutTimer = 0;
  this_->m_lastPacketTime = GetTickCount();
  InterlockedIncrement((volatile LONG *)&g_StatusLine.sockets);
  if ( !CreateTimerQueueTimer(
          (PHANDLE)&this_->m_socketTimeoutTimer,
          g_SocketTimer,
          CAuthSocket::onTimeout,
          (PVOID)this_->m_socket,
          g_Config.SocketTimeOut,
          g_Config.SocketTimeOut,
          0) )
    LogWindow::Add(&g_LogWindow, 3, aCreateSocketT);
  if ( g_Config.ProtocolVersion == 0x75FE )
  {
    this_->m_encrypt_handler = (bool (__cdecl *)(const char *, char *, int))Crypt::encrypt_75FE;
    this_->m_decrypt_handler = (bool (__cdecl *)(const char *, char *, int))Crypt::decrypt_75FE;
  }
  else if ( g_Config.ProtocolVersion == 0x785A )
  {
    this_->m_encrypt_handler = (bool (__cdecl *)(const char *, char *, int))Blowfish::EncryptPacket;
    this_->m_decrypt_handler = (bool (__cdecl *)(const char *, char *, int))Blowfish::DecryptPacket;
  }
  return this_;
}
// 45F944: using guessed type int (__stdcall *CAuthSocket_vtable_offset_0045F944)(int);

//----- (0043989F) --------------------------------------------------------
MemoryObject *__thiscall CAuthSocket::Destructor(CAuthSocket *this)
{
  this->base.base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&CAuthSocket_vtable_offset_0045F944;
  return CIOSocket::Destructor(&this->base);
}
// 45F944: using guessed type int (__stdcall *CAuthSocket_vtable_offset_0045F944)(int);

//----- (004398BB) --------------------------------------------------------
CAuthSocket *__cdecl CAuthSocket::Create(SOCKET socket)
{
  CAuthSocket *userSocket_; // [sp+0h] [bp-18h]@2
  CAuthSocket *userSocket; // [sp+4h] [bp-14h]@1

  userSocket = (CAuthSocket *)operator_new(0x10F0u);
  if ( userSocket )
    userSocket_ = CAuthSocket::CAuthSocket(userSocket, socket);
  else
    userSocket_ = 0;
  return userSocket_;
}

//----- (00439929) --------------------------------------------------------
char __thiscall CAuthSocket::OnClose(CAuthSocket *this)
{
  int ipAddress_; // eax@7
  CAuthSocket *this_; // [sp+0h] [bp-Ch]@1
  int ipAddress; // [sp+4h] [bp-8h]@7
  HANDLE timer; // [sp+8h] [bp-4h]@1

  this_ = this;
  timer = (HANDLE)InterlockedExchange((volatile LONG *)&this->m_socketTimeoutTimer, 0);
  if ( timer )
    DeleteTimerQueueTimer(g_SocketTimer, timer, 0);
  this_->m_socketTimeoutTimer = 0;
  this_->m_socketStatus = SocketStatus_Closed;
  InterlockedDecrement((volatile LONG *)&g_StatusLine.sockets);
  CAuthServer::removeSocket(&g_authServer, this_->m_socket);
  if ( this_->m_clientLoginState != LoginState_AcceptedByGS && this_->m_uid )
    UserManager::loginAborted(&g_userManager, this_->m_uid, this_->m_socket);
  else
    UserManager::bindUserWithGameServer(&g_userManager, this_->m_uid, -1u, this_->m_sessionKey, 0);
  ipAddress_ = (int)CAuthSocket::getUserIp(this_, &ipAddress);
  return IpRegistry::remove(&g_ipRegistry, *(_DWORD *)ipAddress_);
}

//----- (00439A04) --------------------------------------------------------
LONG __thiscall CAuthSocket::OnRead(CAuthSocket *this)
{
  LONG result; // eax@2
  CAuthPacket *packet; // ST18_4@17
  CAuthSocket *this_; // [sp+0h] [bp-18h]@1
  char *buffer; // [sp+8h] [bp-10h]@1
  signed __int32 buffSize; // [sp+Ch] [bp-Ch]@1
  signed __int32 dwNumberOfBytesTransferred; // [sp+10h] [bp-8h]@1

  this_ = this;
  dwNumberOfBytesTransferred = 0;
  buffSize = this->base.m_pReadBuf->m_dwSize;
  buffer = (char *)this->base.m_pReadBuf->m_Buffer;
  if ( this->m_socketStatus == SocketStatus_Closed )
  {
    result = CIOSocket::Close(&this->base);
  }
  else
  {
    while ( true )
    {
      while ( true )
      {
        if ( dwNumberOfBytesTransferred >= buffSize )
          return CIOSocket::Read(&this_->base, 0);
        if ( this_->m_socketStatus )
          break;
        if ( dwNumberOfBytesTransferred + 3 > buffSize )
          return CIOSocket::Read(&this_->base, buffSize - dwNumberOfBytesTransferred);
        this_->m_packetSize = (unsigned __int8)buffer[dwNumberOfBytesTransferred]
                            + ((unsigned __int8)buffer[dwNumberOfBytesTransferred + 1] << 8)
                            + 1
                            - g_Config.PacketSizeType;
        if ( this_->m_packetSize <= 0 || this_->m_packetSize > 0x2000 )
        {
          LogWindow::Add(&g_LogWindow, 3, aDBadPacketSi_2, this_->base.m_hSocket, this_->m_packetSize);
          goto LABEL_21;
        }
        dwNumberOfBytesTransferred += 2;
        this_->m_socketStatus = SocketStatus_BytesRead;
      }
      if ( this_->m_socketStatus != SocketStatus_BytesRead )
        goto LABEL_21;
      if ( this_->m_packetSize + dwNumberOfBytesTransferred > buffSize )
        return CIOSocket::Read(&this_->base, buffSize - dwNumberOfBytesTransferred);
      if ( !this_->m_decrypt_handler(buffer + 2, this_->m_xorKeyReceive, this_->m_packetSize) )
        goto LABEL_21;
      if ( (signed int)(unsigned __int8)buffer[dwNumberOfBytesTransferred] >= 9 )
        break;
      packet = CAuthPacket::Alloc();
      packet->base.m_pSocket = (CIOSocket *)this_;
      packet->base.m_pBuf = this_->base.m_pReadBuf;
      packet->base.m_pFunc = CAuthSocket_handlers_off_46D690[(unsigned __int8)buffer[dwNumberOfBytesTransferred]];
      MemoryObject::AddRef(&this_->base.base);
      CIOBuffer::AddRef(this_->base.m_pReadBuf);
      InterlockedIncrement(&CAuthPacket::g_nPendingPacket);
      CPacket::PostObject(&packet->base, dwNumberOfBytesTransferred, Threading::g_hCompletionPort);
      dwNumberOfBytesTransferred += this_->m_packetSize;
      this_->m_socketStatus = SocketStatus_Init;
      this_->m_lastPacketTime = GetTickCount();
    }
    LogWindow::Add(&g_LogWindow, 3, aUnknownProto_2, (unsigned __int8)buffer[dwNumberOfBytesTransferred]);
LABEL_21:
    result = CIOSocket::Close(&this_->base);
  }
  return result;
}

//----- (00439C87) --------------------------------------------------------
int __thiscall CAuthSocket::OnCreate(CAuthSocket *this)
{
  int someRand; // esi@1
  int xorSeed_1[2]; // rax@1
  int xorSeed_2[2]; // rax@1
  CAuthSocket *this_; // [sp+4h] [bp-4h]@1

  this_ = this;
  someRand = rand() << 16;
  this_->m_sessionKey = rand() | someRand;
  *(_QWORD *)xorSeed_1 = this_->m_sessionKey;
  *(_DWORD *)&this_->m_xorKeySend[0] = xorSeed_1[0];
  *(_DWORD *)&this_->m_xorKeySend[4] = xorSeed_1[1] | 0x87546CA1;
  *(_QWORD *)xorSeed_2 = this_->m_sessionKey;
  *(_DWORD *)&this_->m_xorKeyReceive[0] = xorSeed_2[0];
  *(_DWORD *)&this_->m_xorKeyReceive[4] = xorSeed_2[1] | 0x87546CA1;
  if ( LOBYTE(g_Config.b_encrypt) == true )
    CAuthSocket::sendInit(this_, aCdd_1, LS_Init, this_->m_sessionKey, g_Config.ProtocolVersion);
  else
    CAuthSocket::sendInit(this_, aCdd_2, LS_Init, this_->m_sessionKey, 0);
  return this_->base.base.vftbl_0_45F520->derived_func_9((CIOSocket *)this_);
}

//----- (00439D3C) --------------------------------------------------------
CAuthSocket *__thiscall CAuthSocket::setIPAddress(CAuthSocket *this, int ipAddress)
{
  CAuthSocket *result; // eax@1

  result = this;
  this->m_clientIP.S_un.S_addr = ipAddress;
  return result;
}

//----- (00439D55) --------------------------------------------------------
int CAuthSocket::assembleAndSend(CAuthSocket *this, char *format, ...)
{
  int result; // eax@1
  int size; // [sp+0h] [bp-14h]@4
  unsigned __int8 *buffer; // [sp+4h] [bp-10h]@2
  int size_1; // [sp+8h] [bp-Ch]@2
  int unused; // [sp+Ch] [bp-8h]@2
  CIOBuffer *buff; // [sp+10h] [bp-4h]@2
  va_list va; // [sp+24h] [bp+10h]@1

  va_start(va, format);
  result = (int)this;
  if ( this->m_socketStatus != SocketStatus_Closed )
  {
    buff = CIOBuffer::Alloc();
    buffer = buff->m_Buffer;
    size_1 = PacketUtils::VAssemble((char *)&buff->m_Buffer[2], 8190, format, va);
    unused = 0;
    if ( size_1 )
    {
      size_1 = size_1 + g_Config.PacketSizeType - 1;
      size = size_1 + 1 - g_Config.PacketSizeType;
      this->m_encrypt_handler((const char *)(buffer + 2), this->m_xorKeySend, (int)&size);
      size_1 = size + g_Config.PacketSizeType - 1;
      *buffer = size + LOBYTE(g_Config.PacketSizeType) - 1;
      buffer[1] = BYTE1(size_1);
      buff->m_dwSize = size + 2;
      CIOSocket::Write(&this->base, buff);
      result = GetTickCount();
      this->m_lastPacketTime = result;
    }
    else
    {
      result = (int)LogWindow::Add(&g_LogWindow, 3, aDAssembleToo_5, this->base.m_hSocket, format);
    }
  }
  return result;
}

//----- (00439E5B) --------------------------------------------------------
int CAuthSocket::sendInit(CAuthSocket *this, char *format, ...)
{
  int result; // eax@1
  int size; // [sp+4h] [bp-Ch]@2
  CIOBuffer *buff; // [sp+Ch] [bp-4h]@2
  va_list va; // [sp+20h] [bp+10h]@1

  va_start(va, format);
  result = (int)this;
  if ( this->m_socketStatus != SocketStatus_Closed )
  {
    buff = CIOBuffer::Alloc();
    size = PacketUtils::VAssemble((char *)&buff->m_Buffer[2], 8190, format, va);
    if ( size )
    {
      size = g_Config.PacketSizeType + size - 1;
      buff->m_Buffer[0] = size;
      buff->m_Buffer[1] = BYTE1(size);
    }
    else
    {
      LogWindow::Add(&g_LogWindow, 3, aDAssembleToo_6, this->base.m_hSocket, format);
    }
    buff->m_dwSize = size + 3 - g_Config.PacketSizeType;
    CIOSocket::Write(&this->base, buff);
    result = GetTickCount();
    this->m_lastPacketTime = result;
  }
  return result;
}

//----- (00439F30) --------------------------------------------------------
void __thiscall CAuthSocket::sendPacket(CAuthSocket *this, const char *packet, size_t fullSize)
{
  char *buffer; // ST10_4@2
  CAuthSocket *this_; // [sp+0h] [bp-14h]@1
  size_t payloadSize; // [sp+8h] [bp-Ch]@2
  size_t totalSize; // [sp+Ch] [bp-8h]@2
  CIOBuffer *buff; // [sp+10h] [bp-4h]@2

  this_ = this;
  if ( this->m_socketStatus != SocketStatus_Closed )
  {
    buff = CIOBuffer::Alloc();
    buffer = (char *)buff->m_Buffer;
    memcpy(buff->m_Buffer, packet, fullSize);
    payloadSize = fullSize - 2;
    this_->m_encrypt_handler((const char *)&buff->m_Buffer[2], this_->m_xorKeySend, (int)&payloadSize);
    totalSize = payloadSize + g_Config.PacketSizeType - 1;
    *buffer = payloadSize + LOBYTE(g_Config.PacketSizeType) - 1;
    buffer[1] = BYTE1(totalSize);
    buff->m_dwSize = payloadSize + 2;
    CIOSocket::Write(&this_->base, buff);
  }
}

//----- (00439FD8) --------------------------------------------------------
LONG __thiscall CAuthSocket::OnTimerCallback(CAuthSocket *this)
{
  LONG result; // eax@2
  CAuthSocket *this_; // [sp+0h] [bp-8h]@1

  this_ = this;
  if ( this->m_socketStatus == SocketStatus_Closed )
  {
    result = MemoryObject::Release(&this->base.base);
  }
  else
  {
    if ( GetTickCount() - this->m_lastPacketTime >= g_Config.SocketTimeOut - 500 )
      CIOSocket::Close(&this_->base);
    result = MemoryObject::Release(&this_->base.base);
  }
  return result;
}

//----- (0043A02B) --------------------------------------------------------
int sub_43A02B()
{
  SomeBitsInit();
  return sub_43A03A();
}

//----- (0043A03A) --------------------------------------------------------
int sub_43A03A()
{
  return atexit(emptystub);
}

//----- (0043A050) --------------------------------------------------------
CAuthSocket *__thiscall CAuthSocket::DeletingDestructor(CAuthSocket *this, char a2)
{
  CAuthSocket *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  CAuthSocket::Destructor(this);
  if ( a2 & 1 )
    operator_delete(v3);
  return v3;
}

//----- (0043A080) --------------------------------------------------------
int *__thiscall CAuthSocket::getUserIp(CAuthSocket *this, int *ipAddress)
{
  *ipAddress = this->m_clientIP.S_un.S_addr;
  return ipAddress;
}

//----- (0043A0A0) --------------------------------------------------------
int __thiscall ServerList::getAgeLimit(ServerList *this)
{
  return this->m_maxAgeLimit;
}

//----- (0043A0C0) --------------------------------------------------------
int __stdcall Threading::timersThread(int a1)
{
  TimerQueue::TimerDispatch(&g_timerQueue);
  LogWindow::Add(&g_LogWindow, 1, aTimerThreadTer);
  return 0;
}

//----- (0043A0E7) --------------------------------------------------------
unsigned int __stdcall Threading::IOThread(void *arglist)
{
  time_t now; // eax@1
  MemoryObject *pObject; // [sp+Ch] [bp-28h]@4
  AuthOverlapped *Overlapped; // [sp+10h] [bp-24h]@4
  DWORD dwTransferred; // [sp+14h] [bp-20h]@4
  int success; // [sp+18h] [bp-1Ch]@4
  CPPEH_RECORD ms_exc; // [sp+1Ch] [bp-18h]@1

  ms_exc.registration.TryLevel = 0;
  now = time(0);
  srand(now);
  while ( !g_bTerminating )
  {
    success = GetQueuedCompletionStatus(
                Threading::g_hCompletionPort,
                &dwTransferred,
                (PULONG_PTR)&pObject,
                (LPOVERLAPPED *)&Overlapped,
                INFINITE);
    InterlockedIncrement(&StatusLine::g_nRunningThread);
    pObject->vftbl_0_45F520->OnIOCallback(pObject, success, dwTransferred, Overlapped);
    InterlockedDecrement(&StatusLine::g_nRunningThread);
  }
  LogWindow::Add(&g_LogWindow, 1, aTerminateIothr);
  LogWindow::Add(&g_LogWindow, 1, aIothreadServer);
  ms_exc.registration.TryLevel = -1;
  return 0;
}
// 4816F0: using guessed type char g_bTerminating;

//----- (0043A201) --------------------------------------------------------
unsigned int __stdcall Threading::IOThreadExtra(void *a1)
{
  unsigned int now; // eax@1
  MemoryObject *pObject; // [sp+Ch] [bp-28h]@4
  AuthOverlapped *Overlapped; // [sp+10h] [bp-24h]@4
  DWORD dwTransferred; // [sp+14h] [bp-20h]@4
  int success; // [sp+18h] [bp-1Ch]@4
  CPPEH_RECORD ms_exc; // [sp+1Ch] [bp-18h]@1

  ms_exc.registration.TryLevel = 0;
  now = time(0);
  srand(now);
  while ( !g_bTerminating )
  {
    success = GetQueuedCompletionStatus(
                Threading::g_hCompletionPortExtra,
                &dwTransferred,
                (PULONG_PTR)&pObject,
                (LPOVERLAPPED *)&Overlapped,
                INFINITE);
    pObject->vftbl_0_45F520->OnIOCallback(pObject, success, dwTransferred, Overlapped);
  }
  LogWindow::Add(&g_LogWindow, 1, aTerminateIot_0);
  ms_exc.registration.TryLevel = -1;
  return 0;
}
// 4816F0: using guessed type char g_bTerminating;

//----- (0043A2F1) --------------------------------------------------------
int __stdcall Threading::startServersLoop(int a1)
{
  WorldSrvServer::Create(&g_worldServServer, g_Config.serverPort, WorldSrvSocket::Create, 0);
  CAuthServer::Create(&g_authServer, g_Config.serverExPort, CAuthSocket::Create);
  CIOServerInt::Create(&g_CIOServerInt, g_Config.serverIntPort, (MemoryObject *(__cdecl *)(int))CSocketInt::Create);// command line handler
  TimerQueue::execWaitLoop(&g_timerQueue);
  CIOServer::Close(&g_worldServServer.base);
  CAuthServer::stop(&g_authServer);
  CIOServer::Close(&g_CIOServerInt.base);
  if ( g_IPSocket )
  {
    ReadWriteLock::writeLock(&IPSocket::s_lock);
    if ( !IPSocket::isReconnecting )
      CIOSocket::Close(&g_IPSocket->base);
    MemoryObject::Release(&g_IPSocket->base.base);
    ReadWriteLock::releaseWriteLock(&IPSocket::s_lock);
  }
  if ( g_LogDSocket )
  {
    ReadWriteLock::writeLock(&CLogSocket::s_lock);
    if ( !CLogSocket::isReconnecting )
      CIOSocket::Close(&g_LogDSocket->base);
    MemoryObject::Release(&g_LogDSocket->base.base);
    ReadWriteLock::releaseWriteLock(&CLogSocket::s_lock);
  }
  delete_table((int)g_hThread);
  delete_table((int)g_nThreadId);
  delete_table((int)g_hThreadExtra);
  delete_table((int)g_nThreadIdExtra);
  Threading::s_threadsClosed = 1;
  return 0;
}
// 43A2F1: using guessed type int __stdcall Threading::startServersLoop(int);
// 47F811: using guessed type char IPSocket::isReconnecting;
// 47F8B8: using guessed type char Threading::s_threadsClosed;
// 480179: using guessed type char CLogSocket::isReconnecting;

//----- (0043A4A3) --------------------------------------------------------
signed int Threading::prepareThreads()
{
  DWORD timerThreadId; // [sp+Ch] [bp-20h]@1
  int i; // [sp+10h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+14h] [bp-18h]@1 try block: sub_417A31

  ms_exc.registration.TryLevel = 0;
  i = 0;
  _beginthreadex(NULL, 0, (int)Threading::timersThread, 0, 0, &timerThreadId);
  Threading::g_hCompletionPort = CreateIoCompletionPort((HANDLE)INVALID_HANDLE_VALUE, NULL, 0, 0);
  Threading::g_hCompletionPortExtra = CreateIoCompletionPort((HANDLE)INVALID_HANDLE_VALUE, NULL, 0, 0);
  g_hThread = (HANDLE *)managed_New(4 * g_Config.numServerThread);// 4 -> sizeof(HANDLE)
  g_nThreadId = managed_New(4 * g_Config.numServerThread);// // 4 -> sizeof(unsigned int)
  g_hThreadExtra = (HANDLE *)managed_New(4 * g_Config.numServerIntThread);
  g_nThreadIdExtra = managed_New(4 * g_Config.numServerIntThread);
  for ( i = 0; i < g_Config.numServerThread; ++i )
    g_hThread[i] = (HANDLE)_beginthreadex(NULL, 0, (int)Threading::IOThread, i, 0, (LPDWORD)&g_nThreadId[i]);
  for ( i = 0; i < g_Config.numServerIntThread; ++i )
    g_hThreadExtra[i] = (HANDLE)_beginthreadex(
                                  NULL,
                                  0,
                                  (int)Threading::IOThreadExtra,
                                  i,
                                  0,
                                  (LPDWORD)&g_nThreadIdExtra[i]);
  return 1;
}

//----- (0043A66B) --------------------------------------------------------
int sub_43A66B()
{
  SomeBitsInit();
  return sub_43A67A();
}

//----- (0043A67A) --------------------------------------------------------
int sub_43A67A()
{
  return atexit(emptystub);
}

//----- (0043A690) --------------------------------------------------------
int __cdecl PacketUtils::VAssemble(char *buff, int size, const char *format, va_list ap)
{
  wchar_t *p; // [sp+4h] [bp-20h]@4
  char *start; // [sp+8h] [bp-1Ch]@1
  size_t len; // [sp+Ch] [bp-18h]@5
  size_t lena; // [sp+Ch] [bp-18h]@11
  size_t lenb; // [sp+Ch] [bp-18h]@16
  int v10; // [sp+10h] [bp-14h]@20
  signed int v11; // [sp+10h] [bp-14h]@22
  char *end; // [sp+18h] [bp-Ch]@1
  int token; // [sp+1Ch] [bp-8h]@2
  char *v14; // [sp+20h] [bp-4h]@10
  char *buffa; // [sp+2Ch] [bp+8h]@8
  char *buffb; // [sp+2Ch] [bp+8h]@21
  char *buffc; // [sp+2Ch] [bp+8h]@23
  va_list apa; // [sp+38h] [bp+14h]@16

  start = buff;
  end = &buff[size];
  while ( 2 )
  {
    token = *format++;
    if ( !token )
      return buff - start;
    switch ( token )
    {
      case 'S':
        ap += 4;
        p = (wchar_t *)*((_DWORD *)ap - 1);
        if ( p )
        {
          len = 2 * wcslen(p) + 2;
          if ( &buff[len] > end )
            return 0;
          memcpy(buff, p, len);
          buff += len;
        }
        else
        {
          if ( buff + 2 > end )
            return 0;
          *buff = 0;
          buffa = buff + 1;
          *buffa = 0;
          buff = buffa + 1;
        }
        continue;
      case 's':
        ap += 4;
        v14 = (char *)*((_DWORD *)ap - 1);
        if ( v14 )
        {
          lena = strlen(v14);
          if ( &buff[lena + 1] > end )
            return 0;
          strcpy(buff, v14);
          buff += lena + 1;
          continue;
        }
        if ( buff + 1 <= end )
        {
          *buff++ = 0;
          continue;
        }
        return 0;
      case 'b':
        apa = ap + 4;
        lenb = *((_DWORD *)apa - 1);
        ap = apa + 4;
        if ( &buff[lenb] > end )
          return 0;
        memcpy(buff, *((const void **)ap - 1), lenb);
        buff += lenb;
        continue;
      case 'c':
        ap += 4;
        if ( buff + 1 > end )
          return 0;
        *buff++ = *((_DWORD *)ap - 1);
        continue;
      case 'h':
        ap += 4;
        v10 = *((_DWORD *)ap - 1);
        if ( buff + 2 > end )
          return 0;
        *buff = v10;
        buffb = buff + 1;
        *buffb = BYTE1(v10);
        buff = buffb + 1;
        continue;
      case 'd':
        ap += 4;
        v11 = *((_DWORD *)ap - 1);
        if ( buff + 4 > end )
          return 0;
        *buff = v11;
        buffc = buff + 1;
        *buffc++ = BYTE1(v11);
        *buffc++ = v11 >> 16;
        *buffc = BYTE3(v11);
        buff = buffc + 1;
        continue;
      default:
        continue;
    }
  }
}

//----- (0043A9A3) --------------------------------------------------------
int sub_43A9A3(unsigned __int8 *buff, int size, char *format, ...)
{
  va_list va; // [sp+1Ch] [bp+14h]@1

  va_start(va, format);
  return PacketUtils::VAssemble((char *)buff, size, format, va);
}

//----- (0043A9D8) --------------------------------------------------------
signed int __cdecl BufferReader::copyStrBuffer(char *out, const char *in, signed int size)
{
  signed int readSize; // [sp+0h] [bp-4h]@1

  readSize = 1;
  while ( *in )
  {
    *out = *in++;
    if ( ++readSize > size )
      break;
    ++out;
  }
  *out = 0;
  return readSize;
}

//----- (0043AA2B) --------------------------------------------------------
int __cdecl Hash::hash_unusual(char *password)
{
  int result; // eax@1
  int hash[4]; // [sp+0h] [bp-14h]@1
  int i; // [sp+10h] [bp-4h]@1

  hash[0] = 0x343FD * *(_DWORD *)password + 0x269735;
  hash[1] = 0x34127 * *((_DWORD *)password + 1) + 0x269741;
  hash[2] = 0x33FFB * *((_DWORD *)password + 2) + 0x269935;
  hash[3] = 0x33B1D * *((_DWORD *)password + 3) + 0x269ACD;
  result = SLOBYTE(hash[0]) ^ *password;
  *password = result;
  for ( i = 1; i < 16; ++i )
  {
    password[i] ^= *((_BYTE *)hash + (i & 0xF)) ^ password[i - 1];
    result = i + 1;
  }
  for ( i = 0; i < 16; ++i )
  {
    result = password[i];
    if ( !password[i] )
      password[i] = 0x66;
  }
  return result;
}

//----- (0043AB0C) --------------------------------------------------------
// Generates a 16-byte hash from a 16-byte string.
// This is how the password will be stored in the database.
int __cdecl Hash::hash(char *password)
{
  int result; // eax@1
  int hash[4]; // [sp+0h] [bp-14h]@1
  int i; // [sp+10h] [bp-4h]@1

  hash[0] = 0x3407F * *(_DWORD *)password + 0x269735;
  hash[1] = 0x340FF * *((_DWORD *)password + 1) + 0x269741;
  hash[2] = 0x340D3 * *((_DWORD *)password + 2) + 0x269935;
  hash[3] = 0x3433D * *((_DWORD *)password + 3) + 0x269ACD;
  result = SLOBYTE(hash[0]) ^ *password;
  *password = result;
  for ( i = 1; i < 16; ++i )
  {
    password[i] ^= *((_BYTE *)hash + (i & 0xF)) ^ password[i - 1];
    result = i + 1;
  }
  for ( i = 0; i < 16; ++i )
  {
    result = password[i];
    if ( !password[i] )
      password[i] = 0x66;
  }
  return result;
}

//----- (0043ABED) --------------------------------------------------------
void Hash::hash_empty_stub()
{
  ;
}

//----- (0043ABF2) --------------------------------------------------------
char __cdecl Crypt::decrypt_75FE(char *data, char *xorKey, signed int size)
{
  char result; // al@2
  char tmp; // ST10_1@5
  signed int i; // [sp+8h] [bp-Ch]@3
  char tempo; // [sp+Ch] [bp-8h]@3

  if ( LOBYTE(g_Config.b_encrypt) )
  {
    tempo = *data;
    *data ^= *xorKey;
    for ( i = 1; i < size; ++i )
    {
      tmp = data[i];
      data[i] ^= xorKey[i & 7] ^ tempo;
      tempo = tmp;
    }
    *(_QWORD *)xorKey += size;
    result = true;
  }
  else
  {
    result = true;
  }
  return result;
}

//----- (0043ACA0) --------------------------------------------------------
int __cdecl Crypt::encrypt_75FE(char *data, char *xorKey, int size)
{
  int result; // eax@1
  __int64 tmp; // kr08_8@5
  signed int i; // [sp+8h] [bp-4h]@2

  result = LOBYTE(g_Config.b_encrypt);
  if ( LOBYTE(g_Config.b_encrypt) )
  {
    *data ^= *xorKey;
    for ( i = 1; i < *(_DWORD *)size; ++i )
      data[i] ^= xorKey[i & 7] ^ data[i - 1];
    tmp = *(_DWORD *)size + *(_QWORD *)xorKey;
    result = HIDWORD(tmp);
    *(_QWORD *)xorKey = tmp;
  }
  return result;
}

//----- (0043AD3C) --------------------------------------------------------
int __cdecl Crypt::unused(int a1, int a2, int a3, int a4, char a5, int a6, int a7)
{
  int result; // eax@1
  int v8; // [sp+8h] [bp-28h]@2
  int v9; // [sp+Ch] [bp-24h]@2
  int v10; // [sp+10h] [bp-20h]@2
  int v11; // [sp+14h] [bp-1Ch]@2
  int v12; // [sp+18h] [bp-18h]@2
  int v13; // [sp+1Ch] [bp-14h]@2
  time_t v14; // [sp+2Ch] [bp-4h]@2

  result = LOBYTE(g_Config.UseLogD);
  if ( !LOBYTE(g_Config.UseLogD) )
  {
    v14 = time(0);
    qmemcpy(&v8, localtime(&v14), 0x24u);
    result = FileLog::write(
               &g_actLog,
               0,
               aDDDDDDSSDD_D_D,
               v13 + 1900,
               v12 + 1,
               v11,
               v10,
               v9,
               v8,
               a1,
               a2,
               a6,
               (unsigned __int8)a3,
               BYTE1(a3),
               BYTE2(a3),
               BYTE3(a3),
               a7,
               a4,
               a5);
  }
  return result;
}

//----- (0043ADF4) --------------------------------------------------------
int __cdecl Utils::normalizeName(char *accName)
{
  int tmp; // eax@1
  int length_; // [sp+Ch] [bp-20h]@1
  int i; // [sp+10h] [bp-1Ch]@2

  accName[14] = 0;
  tmp = strlen(accName);
  length_ = tmp;
  if ( tmp > 0 )
  {
    *accName = toupper(*accName);
    for ( i = 1; ; ++i )
    {
      tmp = i;
      if ( i >= length_ )
        break;
      if ( accName[i] == ' ' )
      {
        tmp = (int)&accName[i];
        accName[i] = 0;
        return tmp;
      }
      accName[i] = tolower(accName[i]);
    }
  }
  return tmp;
}

//----- (0043AF16) --------------------------------------------------------
HFONT sub_43AF16()
{
  HGDIOBJ v0; // eax@1

  v0 = GetStockObject(13);
  GetObjectA(v0, 60, &cHeight);
  return CreateFontA(
           cHeight,
           cWidth,
           cEscapement,
           cOrientation,
           cWeight,
           (unsigned __int8)byte_48171C,
           (unsigned __int8)byte_48171D,
           (unsigned __int8)byte_48171E,
           (unsigned __int8)byte_48171F,
           (unsigned __int8)byte_481720,
           (unsigned __int8)byte_481721,
           (unsigned __int8)byte_481722,
           (unsigned __int8)byte_481723,
           pszFaceName);
}
// 48171C: using guessed type char byte_48171C;
// 48171D: using guessed type char byte_48171D;
// 48171E: using guessed type char byte_48171E;
// 48171F: using guessed type char byte_48171F;
// 481720: using guessed type char byte_481720;
// 481721: using guessed type char byte_481721;
// 481722: using guessed type char byte_481722;
// 481723: using guessed type char byte_481723;

//----- (0043AFA2) --------------------------------------------------------
void __cdecl Utils::sendToLog(int type, const char *accName, int connectedIP, int payStat, int age, int a6, int zero, int variant, int uid)
{
  void *cleanStack; // esp@1
  int v10; // [sp-Ch] [bp-1058h]@1
  char buffer[1024]; // [sp+0h] [bp-104Ch]@16
  wchar_t bufferW[1024]; // [sp+800h] [bp-84Ch]@7
  WCHAR accNameW[15]; // [sp+1000h] [bp-4Ch]@4
  int v14; // [sp+1020h] [bp-2Ch]@4
  struct _SYSTEMTIME SystemTime; // [sp+1024h] [bp-28h]@2
  CPPEH_RECORD ms_exc; // [sp+1034h] [bp-18h]@1

  cleanStack = alloca(0x1034);
  ms_exc.old_esp = (DWORD)&v10;
  if ( g_Config.GameID & 8 )
  {
    ms_exc.registration.TryLevel = 0;
    GetLocalTime(&SystemTime);
    if ( strlen(accName) > 0xE )
      *((_BYTE *)accName + 14) = 0;
    v14 = Utils::toWideChar(accName, 15, accNameW);
    accNameW[14] = 0;
    if ( LOBYTE(g_Config.UseLogD) && !CLogSocket::isReconnecting && CLogSocket::created )
    {
      memset(bufferW, 0, 0x800u);
      switch ( type )
      {
        case 801:
          swprintf(
            bufferW,
            a02d02d04d02d02,
            SystemTime.wMonth,
            SystemTime.wDay,
            SystemTime.wYear,
            SystemTime.wHour,
            SystemTime.wMinute,
            SystemTime.wSecond,
            SystemTime.wMilliseconds,
            801,
            uid,
            (unsigned __int8)connectedIP,
            BYTE1(connectedIP),
            BYTE2(connectedIP),
            BYTE3(connectedIP),
            payStat,
            age,
            a6,
            variant,                            // users
            zero,
            accNameW);
          break;
        case 802:
          swprintf(
            bufferW,
            a02d02d04d02d_0,
            SystemTime.wMonth,
            SystemTime.wDay,
            SystemTime.wYear,
            SystemTime.wHour,
            SystemTime.wMinute,
            SystemTime.wSecond,
            SystemTime.wMilliseconds,
            802,
            uid,
            (unsigned __int8)connectedIP,
            BYTE1(connectedIP),
            BYTE2(connectedIP),
            BYTE3(connectedIP),
            payStat,
            age,
            a6,
            variant,                            // logged users
            zero,
            accNameW);
          break;
        case 804:
          swprintf(
            bufferW,
            a02d02d04d02d_1,
            SystemTime.wMonth,
            SystemTime.wDay,
            SystemTime.wYear,
            SystemTime.wHour,
            SystemTime.wMinute,
            SystemTime.wSecond,
            SystemTime.wMilliseconds,
            804,
            uid,
            (unsigned __int8)connectedIP,
            BYTE1(connectedIP),
            BYTE2(connectedIP),
            BYTE3(connectedIP),
            payStat,
            age,
            a6,
            variant,                            // total time
            zero,
            accNameW);
          break;
        case 831:
          swprintf(
            bufferW,
            a02d02d04d02d_2,
            SystemTime.wMonth,
            SystemTime.wDay,
            SystemTime.wYear,
            SystemTime.wHour,
            SystemTime.wMinute,
            SystemTime.wSecond,
            SystemTime.wMilliseconds,
            831,
            uid,
            (unsigned __int8)connectedIP,
            BYTE1(connectedIP),
            BYTE2(connectedIP),
            BYTE3(connectedIP),
            payStat,
            age,
            a6,
            accNameW);
          break;
      }
      ReadWriteLock::readLock(&CLogSocket::s_lock);
      CLogSocket::send(g_LogDSocket, aCdds, 0, 1, 6, bufferW);
      ReadWriteLock::releaseReadLock(&CLogSocket::s_lock);
    }
    else
    {
      memset(buffer, 0, 0x800u);
      switch ( type )
      {
        case 801:
          sprintf(
            buffer,
            a02d02d04d02d_3,
            SystemTime.wMonth,
            SystemTime.wDay,
            SystemTime.wYear,
            SystemTime.wHour,
            SystemTime.wMinute,
            SystemTime.wSecond,
            SystemTime.wMilliseconds,
            801,
            uid,
            (unsigned __int8)connectedIP,
            BYTE1(connectedIP),
            BYTE2(connectedIP),
            BYTE3(connectedIP),
            payStat,
            age,
            a6,
            variant,
            zero,
            accName);
          break;
        case 802:
          sprintf(
            buffer,
            a02d02d04d02d_4,
            SystemTime.wMonth,
            SystemTime.wDay,
            SystemTime.wYear,
            SystemTime.wHour,
            SystemTime.wMinute,
            SystemTime.wSecond,
            SystemTime.wMilliseconds,
            802,
            uid,
            (unsigned __int8)connectedIP,
            BYTE1(connectedIP),
            BYTE2(connectedIP),
            BYTE3(connectedIP),
            payStat,
            age,
            a6,
            variant,
            zero,
            accName);
          break;
        case 804:
          sprintf(
            buffer,
            a02d02d04d02d_5,
            SystemTime.wMonth,
            SystemTime.wDay,
            SystemTime.wYear,
            SystemTime.wHour,
            SystemTime.wMinute,
            SystemTime.wSecond,
            SystemTime.wMilliseconds,
            804,
            uid,
            (unsigned __int8)connectedIP,
            BYTE1(connectedIP),
            BYTE2(connectedIP),
            BYTE3(connectedIP),
            payStat,
            age,
            a6,
            variant,
            zero,
            accName);
          break;
        case 831:
          sprintf(
            buffer,
            a02d02d04d02d_6,
            SystemTime.wMonth,
            SystemTime.wDay,
            SystemTime.wYear,
            SystemTime.wHour,
            SystemTime.wMinute,
            SystemTime.wSecond,
            SystemTime.wMilliseconds,
            831,
            uid,
            (unsigned __int8)connectedIP,
            BYTE1(connectedIP),
            BYTE2(connectedIP),
            BYTE3(connectedIP),
            payStat,
            age,
            a6,
            accName);
          break;
      }
      buffer[1023] = 0;
      GeneralLog::write(&g_genLog, 0, aS_10, buffer);
    }
  }
}
// 480179: using guessed type char CLogSocket::isReconnecting;
// 48017A: using guessed type char CLogSocket::created;

//----- (0043B6A8) --------------------------------------------------------
int __cdecl Utils::toWideChar(const char *multiByteStr, int a2, wchar_t *wideCharStr)
{
  int size; // ST18_4@1

  size = MultiByteToWideChar(0, 0, multiByteStr, -1, 0, 0);
  MultiByteToWideChar(0, 0, multiByteStr, -1, wideCharStr, size);
  wideCharStr[size - 1] = 0;
  return size;
}

//----- (0043B6F6) --------------------------------------------------------
unsigned __int8 *__cdecl Blowfish::EncryptPacket(unsigned __int8 *data, char *xorKey, int *size)
{
  int i; // [sp+4h] [bp-Ch]@1
  int checkSum; // [sp+Ch] [bp-4h]@1

  *size = (*size + 7) & 0xFFFFFFF8;
  checkSum = 0;
  for ( i = 0; i < *size >> 2; ++i )
    checkSum ^= *(_DWORD *)&data[4 * i];
  *(_DWORD *)&data[4 * i] = checkSum;
  *size += 8;
  return Blowfish::Encrypt(data, *size);
}

//----- (0043B77E) --------------------------------------------------------
bool __cdecl Blowfish::DecryptPacket(unsigned __int8 *data, char *xorKey, int size)
{
  bool result; // al@5
  int i; // [sp+4h] [bp-Ch]@2
  int checkSum; // [sp+Ch] [bp-4h]@2

  if ( size & 7 )
  {
    result = 0;
  }
  else
  {
    Blowfish::Decrypt(data, size);
    checkSum = 0;
    for ( i = 0; i < (size - 8) >> 2; ++i )
      checkSum ^= *(_DWORD *)&data[4 * i];
    result = *(_DWORD *)&data[4 * i] == checkSum;
  }
  return result;
}

//----- (0043B7FE) --------------------------------------------------------
time_t __cdecl Utils::convertTime(TIMESTAMP_STRUCT *a1, struct tm *a2)
{
  a2->tm_sec = a1->second;
  a2->tm_min = a1->minute;
  a2->tm_hour = a1->hour;
  a2->tm_mday = a1->day;
  a2->tm_mon = a1->month - 1;
  a2->tm_year = a1->year - 1900;
  a2->tm_isdst = 0;
  return mktime(a2);
}

//----- (0043B878) --------------------------------------------------------
char __cdecl Utils::validateAccName(char *accName)
{
  char result; // al@2
  signed int i; // [sp+10h] [bp-1Ch]@5

  if ( accName )
  {
    if ( isalpha(*accName) )
    {
      for ( i = 1; i <= 14; ++i )
      {
        if ( !accName[i] )
          return 1;
        if ( !isalpha(accName[i]) && !isdigit(accName[i]) )
          return 0;
      }
      result = 0;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (0043B9BA) --------------------------------------------------------
char __cdecl Utils::isNumber(char *str, int size)
{
  char result; // al@3
  int i; // [sp+0h] [bp-4h]@4

  if ( str && size > 0 )
  {
    for ( i = 0; i < size; ++i )
    {
      if ( str[i] < '0' || str[i] > '9' )
        return 0;
    }
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (0043BA17) --------------------------------------------------------
char __cdecl Utils::checkDiskFreeSpace(LPCSTR lpDirectoryName, int a2, int a3)
{
  DWORD errorCode; // eax@9
  char errorMessage[1024]; // [sp+0h] [bp-40Ch]@3
  ULARGE_INTEGER TotalNumberOfFreeBytes; // [sp+400h] [bp-Ch]@1
  char v7; // [sp+408h] [bp-4h]@1

  v7 = 0;
  if ( GetDiskFreeSpaceExA(lpDirectoryName, 0, 0, &TotalNumberOfFreeBytes) )
  {
    if ( __PAIR__((unsigned int)a3, a2) <= TotalNumberOfFreeBytes.QuadPart )
    {
      v7 = 1;
    }
    else
    {
      sprintf(errorMessage, aInsufficientFr, lpDirectoryName);
      if ( g_Config.Mailto && g_Config.Mailfrom )
        MailServer::SendMail(&g_mailServer, g_Config.Mailto, subj, errorMessage);
      LogWindow::Add(&g_LogWindow, 2, errorMessage);
    }
  }
  else
  {
    errorCode = GetLastError();
    LogWindow::Add(&g_LogWindow, 3, aCheckdiskfrees, errorCode);
  }
  return v7;
}

//----- (0043BAD3) --------------------------------------------------------
int sub_43BAD3()
{
  SomeBitsInit();
  return sub_43BAE2();
}

//----- (0043BAE2) --------------------------------------------------------
int sub_43BAE2()
{
  return atexit(emptystub);
}

//----- (0043BB00) --------------------------------------------------------
int StaticInit_SocketWanted_semaphore()
{
  CallStaticCtorFor_SocketWanted_semaphore();
  return RegisterStaticDestructorFor_SocketWanted_semaphore();
}

//----- (0043BB0F) --------------------------------------------------------
ReadWriteLock *CallStaticCtorFor_SocketWanted_semaphore()
{
  return ReadWriteLock::ReadWriteLock(&CWantedSocket::s_lock);
}

//----- (0043BB1E) --------------------------------------------------------
int RegisterStaticDestructorFor_SocketWanted_semaphore()
{
  return atexit(CallStaticDestructorFor_SocketWanted_semaphore);
}

//----- (0043BB30) --------------------------------------------------------
void __cdecl CallStaticDestructorFor_SocketWanted_semaphore()
{
  ReadWriteLock::Destructor(&CWantedSocket::s_lock);
}

//----- (0043BB3F) --------------------------------------------------------
void __stdcall CWantedSocket::onTimeout(PVOID a1, BOOLEAN a2)
{
  SOCKET socket; // ST14_4@4
  int result; // ST10_4@4
  CWantedSocket *old; // ST0C_4@6
  CWantedSocket *wantedSocket; // [sp+Ch] [bp-14h]@4
  sockaddr_in name; // [sp+10h] [bp-10h]@4

  if ( g_WantedSockTimer )
    DeleteTimerQueueTimer(0, g_WantedSockTimer, 0);
  g_WantedSockTimer = 0;
  if ( CWantedSocket::isReconnecting == 1 )
  {
    socket = ::socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
    name.sin_family = AF_INET;
    name.sin_addr.S_un.S_addr = g_Config.WantedIP;
    name.sin_port = htons(g_Config.WantedPort);
    result = connect(socket, (const struct sockaddr *)&name, 16);
    wantedSocket = CWantedSocket::Create(socket);
    CWantedSocket::setIPAddress(wantedSocket, (in_addr)g_Config.WantedIP);
    if ( result == SOCKET_ERROR )
    {
      CIOSocket::Close(&wantedSocket->base);
      MemoryObject::Release(&wantedSocket->base.base);
    }
    else
    {
      ReadWriteLock::writeLock(&CWantedSocket::s_lock);
      old = g_SocketWanted;
      g_SocketWanted = wantedSocket;
      MemoryObject::Release(&old->base.base);
      CWantedSocket::isReconnecting = 0;
      LOBYTE(g_Config.UseWantedSystem) = 1;
      CIOSocket::Initialize(&g_SocketWanted->base, Threading::g_hCompletionPortExtra);
      ReadWriteLock::releaseWriteLock(&CWantedSocket::s_lock);
    }
  }
}
// 4819B9: using guessed type char CWantedSocket::isReconnecting;

//----- (0043BC44) --------------------------------------------------------
int CWantedPacketPool::g_slot_statis_init()
{
  CWantedPacketPool::g_slot_construction();
  return CWantedPacketPool::Call_g_slot_destruction();
}

//----- (0043BC53) --------------------------------------------------------
int CWantedPacketPool::g_slot_construction()
{
  return `eh vector constructor iterator'(
           CWantedPacketPool::g_slot,
           0x24u,
           16,
           (int)CWantedPacketSlot::CWantedPacketSlot,
           (void (__thiscall *)(void *))CSlotWanted::Destructor);
}

//----- (0043BC70) --------------------------------------------------------
int CWantedPacketPool::Call_g_slot_destruction()
{
  return atexit(CWantedPacketPool::g_slot_destruction);
}

//----- (0043BC82) --------------------------------------------------------
void __cdecl CWantedPacketPool::g_slot_destruction()
{
  if ( !(byte_4819B8 & 1) )
  {
    byte_4819B8 |= 1u;
    `eh vector destructor iterator'(
      CWantedPacketPool::g_slot,
      0x24u,
      16,
      (void (__thiscall *)(void *))CSlotWanted::Destructor);
  }
}
// 4819B8: using guessed type char byte_4819B8;

//----- (0043BCB7) --------------------------------------------------------
int StaticInitFor_CWantedPacketPool()
{
  StaticCallFor_CWantedPacketPoolCtor();
  return Register_StaticCallFor_CWantedPacketPoolDestructor();
}

//----- (0043BCC6) --------------------------------------------------------
void StaticCallFor_CWantedPacketPoolCtor()
{
  ;
}

//----- (0043BCCB) --------------------------------------------------------
int Register_StaticCallFor_CWantedPacketPoolDestructor()
{
  return atexit(StaticCallFor_CWantedPacketPoolDestructor);
}

//----- (0043BCDD) --------------------------------------------------------
void __cdecl StaticCallFor_CWantedPacketPoolDestructor()
{
  CWantedPacketPool::Destructor();
}

//----- (0043BCEC) --------------------------------------------------------
CWantedPacket *__cdecl CWantedPacket::Alloc()
{
  CWantedPacket *v1; // [sp+0h] [bp-20h]@4
  CWantedPacket *v2; // [sp+4h] [bp-1Ch]@3
  CWantedPacketSlot *slot; // [sp+Ch] [bp-14h]@1
  CWantedPacket *res; // [sp+10h] [bp-10h]@1

  slot = &CWantedPacketPool::g_slot[InterlockedIncrement(&CWantedPacketPool::g_nAlloc) & 0xF];
  SpinLock::Enter(&slot->m_lock);
  res = slot->m_pPacket;
  if ( slot->m_pPacket )
  {
    slot->m_pPacket = (CWantedPacket *)res->m_pSocket;
    SpinLock::Leave(&slot->m_lock);
  }
  else
  {
    SpinLock::Leave(&slot->m_lock);
    v2 = (CWantedPacket *)operator_new(0x14u);
    if ( v2 )
      v1 = CWantedPacket::CWantedPacket(v2);
    else
      v1 = 0;
    res = v1;
  }
  return res;
}

//----- (0043BDAE) --------------------------------------------------------
void CWantedPacket::FreeAll()
{
  CWantedPacketSlot *slot; // [sp+Ch] [bp-Ch]@3
  CWantedPacket *packet; // [sp+10h] [bp-8h]@4
  signed int i; // [sp+14h] [bp-4h]@1

  for ( i = 0; i < 16; ++i )
  {
    slot = &CWantedPacketPool::g_slot[i];
    SpinLock::Enter(&CWantedPacketPool::g_slot[i].m_lock);
    while ( true )
    {
      packet = slot->m_pPacket;
      if ( !slot->m_pPacket )
        break;
      slot->m_pPacket = (CWantedPacket *)packet->m_pSocket;
      if ( packet )
        packet->base.vftbl_0_45F520->DestructorCall((MemoryObject *)packet, 1);
    }
    SpinLock::Leave(&slot->m_lock);
  }
}

//----- (0043BE3C) --------------------------------------------------------
void __thiscall CWantedPacket::Free(CWantedPacket *this)
{
  CWantedPacket *this_; // ST04_4@1
  CWantedPacketSlot *slot; // ST08_4@1

  this_ = this;
  slot = &CWantedPacketPool::g_slot[InterlockedDecrement(&CWantedPacketPool::g_nFree) & 0xF];
  SpinLock::Enter(&slot->m_lock);
  this_->m_pSocket = (CWantedSocket *)slot->m_pPacket;
  slot->m_pPacket = this_;
  SpinLock::Leave(&slot->m_lock);
}

//----- (0043BE8B) --------------------------------------------------------
void __thiscall CWantedPacket::OnIOCallback(CWantedPacket *this, BOOL bSuccess, DWORD dwTransferred, LPOVERLAPPED lpOverlapped)
{
  CWantedPacket *this_; // [sp+Ch] [bp-20h]@1

  this_ = this;
  if ( ((int (__cdecl *)(_DWORD, _DWORD))this->m_pFunc)(this->m_pSocket, &this->m_pBuf->m_Buffer[dwTransferred + 1]) & 0xFF )
    CIOSocket::Close(&this_->m_pSocket->base);
  MemoryObject::Release(&this_->m_pSocket->base.base);
  CIOBuffer::Release(this_->m_pBuf);
  InterlockedDecrement(&CWantedPacket::g_nPendingPacket);
  CWantedPacket::Free(this_);
}

//----- (0043BF78) --------------------------------------------------------
char __cdecl CWantedSocket::h4_dummy_packet(CWantedSocket *this, char *buffer)
{
  LogWindow::Add(&g_LogWindow, 2, aCallDummypac_1);
  return 0;
}

//----- (0043BF93) --------------------------------------------------------
char __cdecl CWantedSocket::packet1_getVersion(CWantedSocket *this, char *buffer)
{
  int version; // ST10_4@1

  version = BufferReader::ReadInt(&buffer);
  LogWindow::Add(&g_LogWindow, 1, aGetVersionD, version);
  return 0;
}

//----- (0043BFC4) --------------------------------------------------------
char __cdecl CWantedSocket::h2(CWantedSocket *this, char *buffer)
{
  BufferReader::ReadInt(&buffer);
  return 0;
}

//----- (0043BFDD) --------------------------------------------------------
char __cdecl CWantedSocket::h3(CWantedSocket *this, char *buffer)
{
  BufferReader::ReadByte(&buffer);
  return 0;
}

//----- (0043C072) --------------------------------------------------------
CWantedSocket *__cdecl CWantedSocket::Create(SOCKET socket)
{
  CWantedSocket *v2; // [sp+0h] [bp-18h]@2
  CWantedSocket *v3; // [sp+4h] [bp-14h]@1

  v3 = (CWantedSocket *)operator_new(0x80u);
  if ( v3 )
    v2 = CWantedSocket::CWantedSocket(v3, socket);
  else
    v2 = 0;
  return v2;
}

//----- (0043C0E0) --------------------------------------------------------
CWantedSocket *__thiscall CWantedSocket::CWantedSocket(CWantedSocket *this, SOCKET socket)
{
  CWantedSocket *this_; // ST04_4@1

  this_ = this;
  CIOSocket::CIOSocket(&this->base, socket);
  this_->base.base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&CSocketWanted_vtable_off_45FA14;
  this_->m_ipAddress.S_un.S_addr = g_Config.WantedIP;
  this_->m_someBool = false;
  this_->m_status = SocketStatus_Init;
  this_->m_packetHandlers = (bool (__cdecl **)(CWantedPacket *, const unsigned __int8 *))CSocketWanted_handlers;
  MemoryObject::AddRef(&this_->base.base);
  CWantedSocket::isReconnecting = false;
  return this_;
}
// 45FA14: using guessed type int (__stdcall *CSocketWanted_vtable_off_45FA14)(int);
// 4819B9: using guessed type char CWantedSocket::isReconnecting;

//----- (0043C16A) --------------------------------------------------------
MemoryObject *__fastcall CWantedSocket::Destructor(CWantedSocket *this)
{
  CWantedSocket *this_; // ST0C_4@1

  this_ = this;
  this->base.base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&CSocketWanted_vtable_off_45FA14;
  LogWindow::Add(&g_LogWindow, 3, aWantedsocketDe);
  return CIOSocket::Destructor(&this_->base);
}
// 45FA14: using guessed type int (__stdcall *CSocketWanted_vtable_off_45FA14)(int);

//----- (0043C1C7) --------------------------------------------------------
BOOL __thiscall CWantedSocket::OnClose(CWantedSocket *this)
{
  CWantedSocket *this_; // ST1C_4@1
  CWantedSocket *this__; // ST18_4@1
  SOCKET v3; // ST14_4@1
  char *v4; // eax@1

  this_ = this;
  this->m_status = SocketStatus_Closed;
  CWantedSocket::isReconnecting = true;
  LOBYTE(g_Config.UseWantedSystem) = false;
  this__ = this;
  v3 = this->base.m_hSocket;
  v4 = CWantedSocket::addrToStr(this);
  LogWindow::Add(&g_LogWindow, 3, aCloseConnect_2, v4, v3, this__);
  MemoryObject::AddRef(&this_->base.base);
  return CreateTimerQueueTimer(
           &g_WantedSockTimer,
           0,
           CWantedSocket::onTimeout,
           this_,
           g_Config.WantedReconnectInterval,
           0,
           0);
}
// 4819B9: using guessed type char CWantedSocket::isReconnecting;

//----- (0043C23B) --------------------------------------------------------
void CWantedSocket::OnTimerCallback()
{
  ;
}

//----- (0043C246) --------------------------------------------------------
char *__thiscall CWantedSocket::addrToStr(CWantedSocket *this)
{
  return inet_ntoa(this->m_ipAddress);
}

//----- (0043C25E) --------------------------------------------------------
int __thiscall CWantedSocket::OnCreate(CWantedSocket *this)
{
  CWantedSocket *this_; // ST00_4@1

  this_ = this;
  MemoryObject::AddRef(&this->base.base);
  return this_->base.base.vftbl_0_45F520->derived_func_9((CIOSocket *)this_);// OnRead
}

//----- (0043C27C) --------------------------------------------------------
LONG __thiscall CWantedSocket::OnRead(CWantedSocket *this)
{
  LONG result; // eax@2
  CWantedPacket *packet; // ST18_4@16
  CWantedSocket *this_; // [sp+0h] [bp-14h]@1
  unsigned __int8 *buffer; // [sp+8h] [bp-Ch]@1
  signed __int32 buffSize; // [sp+Ch] [bp-8h]@1
  signed __int32 dwRead; // [sp+10h] [bp-4h]@1

  this_ = this;
  dwRead = 0;
  buffSize = this->base.m_pReadBuf->m_dwSize;
  buffer = this->base.m_pReadBuf->m_Buffer;
  if ( this->m_status == SocketStatus_Closed )
  {
    result = CIOSocket::Close(&this->base);
  }
  else
  {
    while ( true )
    {
      while ( true )
      {
        if ( dwRead >= buffSize )
          return CIOSocket::Read(&this_->base, 0);
        if ( this_->m_status )
          break;
        if ( dwRead + 3 > buffSize )
          return CIOSocket::Read(&this_->base, buffSize - dwRead);
        this_->m_packetSize = buffer[dwRead] + (buffer[dwRead + 1] << 8) + 1;
        if ( this_->m_packetSize <= 0 || this_->m_packetSize > 0x2000 )
        {
          LogWindow::Add(&g_LogWindow, 3, aDBadPacketSi_3, this_->base.m_hSocket, this_->m_packetSize);
          goto LABEL_20;
        }
        dwRead += 2;
        this_->m_status = SocketStatus_BytesRead;
      }
      if ( this_->m_status != SocketStatus_BytesRead )
        goto LABEL_20;
      if ( this_->m_packetSize + dwRead > buffSize )
        return CIOSocket::Read(&this_->base, buffSize - dwRead);
      if ( (signed int)buffer[dwRead] >= 3 )
        break;
      packet = CWantedPacket::Alloc();
      packet->m_pSocket = this_;
      packet->m_pBuf = this_->base.m_pReadBuf;
      packet->m_pFunc = (void (__cdecl *)(CWantedSocket *, char *))this_->m_packetHandlers[buffer[dwRead]];
      MemoryObject::AddRef(&this_->base.base);
      CIOBuffer::AddRef(this_->base.m_pReadBuf);
      InterlockedIncrement(&CWantedPacket::g_nPendingPacket);
      CPacket::PostObject((WorldSrvPacket *)packet, dwRead, Threading::g_hCompletionPort);// TODO: initialized with g_hCompletionPortExtra insie OnTimeout
      dwRead += this_->m_packetSize;            // and on WinMain : CIOSocket::Initialize(&g_SocketWanted->base, g_hCompletionPortExtra)
      this_->m_status = SocketStatus_Init;
    }
    LogWindow::Add(&g_LogWindow, 3, aUnknownProto_3, buffer[dwRead]);
LABEL_20:
    result = CIOSocket::Close(&this_->base);
  }
  return result;
}

//----- (0043C476) --------------------------------------------------------
char CWantedSocket::send(CWantedSocket *this, char *format, ...)
{
  char result; // al@5
  int packetSize; // [sp+4h] [bp-Ch]@6
  CIOBuffer *buff; // [sp+Ch] [bp-4h]@6
  va_list va; // [sp+20h] [bp+10h]@1

  va_start(va, format);
  MemoryObject::AddRef(&this->base.base);
  if ( this->m_status != SocketStatus_Closed
    && !CWantedSocket::isReconnecting
    && LOBYTE(g_Config.UseWantedSystem)
    && this->base.m_hSocket != INVALID_SOCKET )
  {
    buff = CIOBuffer::Alloc();
    packetSize = PacketUtils::VAssemble((char *)&buff->m_Buffer[2], 8190, format, va);
    if ( packetSize )
    {
      buff->m_Buffer[0] = --packetSize;
      buff->m_Buffer[1] = BYTE1(packetSize);
    }
    else
    {
      LogWindow::Add(&g_LogWindow, 3, aDAssembleToo_7, this->base.m_hSocket, format);
    }
    buff->m_dwSize = packetSize + 3;
    CIOSocket::Write(&this->base, buff);
    MemoryObject::Release(&this->base.base);
    result = true;
  }
  else
  {
    MemoryObject::Release(&this->base.base);
    result = false;
  }
  return result;
}
// 4819B9: using guessed type char CWantedSocket::isReconnecting;

//----- (0043C56D) --------------------------------------------------------
int sub_43C56D()
{
  SomeBitsInit();
  return sub_43C57C();
}

//----- (0043C57C) --------------------------------------------------------
int sub_43C57C()
{
  return atexit(emptystub);
}

//----- (0043C590) --------------------------------------------------------
CWantedPacketSlot *__thiscall CWantedPacketSlot::CWantedPacketSlot(CWantedPacketSlot *this)
{
  CWantedPacketSlot *v1; // ST08_4@1

  v1 = this;
  this->m_pPacket = 0;
  SpinLock::SpinLock(&this->m_lock, LockType_WaitLock, 0);
  return v1;
}

//----- (0043C5C0) --------------------------------------------------------
// Microsoft VisualC 2-11/net runtime
void __thiscall CSlotWanted::Destructor(CWantedPacketSlot *this)
{
  SpinLock::Destructor(&this->m_lock);
}

//----- (0043C5E0) --------------------------------------------------------
void CWantedPacketPool::Destructor()
{
  CWantedPacket::FreeAll();
}

//----- (0043C5F0) --------------------------------------------------------
CWantedPacket *__thiscall CWantedPacket::CWantedPacket(CWantedPacket *this)
{
  CWantedPacket *v1; // ST00_4@1

  v1 = this;
  MemoryObject::MemoryObject(&this->base);
  v1->base.vftbl_0_45F520 = (MemoryObject_VTABLE_45F520 *)&CWantedPacket_vtable_off_45F9DC;
  return v1;
}
// 45F9DC: using guessed type int (__stdcall *CWantedPacket_vtable_off_45F9DC)(int);

//----- (0043C610) --------------------------------------------------------
CWantedPacket *__thiscall CWantedPacket::DeletingDestructor(CWantedPacket *this, char a2)
{
  CWantedPacket *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  CWantedPacket::Destructor(this);
  if ( a2 & 1 )
    operator_delete(v3);
  return v3;
}

//----- (0043C640) --------------------------------------------------------
MemoryObject *__thiscall CWantedPacket::Destructor(CWantedPacket *this)
{
  return MemoryObject::Destructor(&this->base);
}

//----- (0043C660) --------------------------------------------------------
CWantedSocket *__thiscall CWantedSocket::DeletingDestructor(CWantedSocket *this, char a2)
{
  CWantedSocket *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  CWantedSocket::Destructor(this);
  if ( a2 & 1 )
    operator_delete(v3);
  return v3;
}

//----- (0043CA18) --------------------------------------------------------
void __cdecl _delete_table(LPVOID lpMem)
{
  _Free(lpMem);
}

//----- (0043D2E7) --------------------------------------------------------
_DWORD *__thiscall sub_43D2E7(_DWORD *this, int a2, int a3, char a4, int a5)
{
  _DWORD *v5; // esi@1
  int v6; // ecx@4

  v5 = this;
  if ( a5 )
  {
    *this = &unk_45FAF8;
    this[10] = 0;
    this[1] = &std::basic_ios<char,std::char_traits<char>>::`vftable';
  }
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4)) = &std::basic_ostream<char,std::char_traits<char>>::`vftable'{for `std::basic_ios<char,std::char_traits<char>>'};
  if ( a4 )
  {
    v6 = *(_DWORD *)(*this + 4);
    std::basic_ios<char,std::char_traits<char>>::init(a2, a3);
  }
  return v5;
}
// 40BC20: using guessed type _DWORD __stdcall std::basic_ios<char,std::char_traits<char>>::init(_DWORD, _DWORD);
// 45FACC: using guessed type int (__stdcall *std::basic_ios<char,std::char_traits<char>>::`vftable')(int);
// 45FADC: using guessed type int (__stdcall *std::basic_ostream<char,std::char_traits<char>>::`vftable'{for `std::basic_ios<char,std::char_traits<char>>'})(char);

//----- (0043D414) --------------------------------------------------------
char *__thiscall sub_43D414(char *this, char a2)
{
  char *v2; // esi@1

  v2 = this - 4;
  sub_43D45E(this - 4);
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}

//----- (0043D45E) --------------------------------------------------------
int __thiscall sub_43D45E(void *this)
{
  int v1; // eax@1
  std::ios_base *v2; // ecx@1

  v1 = *(_DWORD *)this;
  v2 = (std::ios_base *)((char *)this + 4);
  *(_DWORD *)((char *)v2 + *(_DWORD *)(v1 + 4) - 4) = &std::basic_ostream<char,std::char_traits<char>>::`vftable'{for `std::basic_ios<char,std::char_traits<char>>'};
  return sub_40B190(v2);
}
// 45FADC: using guessed type int (__stdcall *std::basic_ostream<char,std::char_traits<char>>::`vftable'{for `std::basic_ios<char,std::char_traits<char>>'})(char);

//----- (0043D49D) --------------------------------------------------------
int sub_43D49D()
{
  return atexit(emptystub);
}

//----- (0043D552) --------------------------------------------------------
_BYTE *__thiscall sub_43D552(_BYTE *this, _BYTE *a2)
{
  _BYTE *v2; // esi@1
  CHAR *v4; // [sp+10h] [bp-10h]@1
  int v5; // [sp+1Ch] [bp-4h]@1

  v2 = this;
  v4 = byte_481640;
  exception::exception(this, (const char **)&v4);
  v5 = 0;
  v2[12] = *a2;
  std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(0);
  std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(a2, 0, -1);
  *(_DWORD *)v2 = &std::runtime_error::`vftable';
  return v2;
}
// 41FF10: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(_DWORD);
// 435960: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(_DWORD, _DWORD, _DWORD);
// 45FB68: using guessed type int (__stdcall *std::runtime_error::`vftable')(char);

//----- (0043D5C3) --------------------------------------------------------
void __thiscall __noreturn sub_43D5C3(void *this)
{
  char v1; // [sp+0h] [bp-1Ch]@1

  sub_43D639(&v1, (int)this);
  _CxxThrowException(&v1, &unk_463AC8);
}
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);

//----- (0043D61D) --------------------------------------------------------
void *__thiscall sub_43D61D(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  unknown_libname_207(this);
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}

//----- (0043D639) --------------------------------------------------------
_BYTE *__thiscall sub_43D639(_BYTE *this, int a2)
{
  _BYTE *v2; // esi@1

  v2 = this;
  exception::exception((int)this, a2);
  v2[12] = *(_BYTE *)(a2 + 12);
  std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(0);
  std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(a2 + 12, 0, -1);
  *(_DWORD *)v2 = &std::runtime_error::`vftable';
  return v2;
}
// 41FF10: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(_DWORD);
// 435960: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(_DWORD, _DWORD, _DWORD);
// 45FB68: using guessed type int (__stdcall *std::runtime_error::`vftable')(char);

//----- (0043D6D3) --------------------------------------------------------
void __thiscall __noreturn sub_43D6D3(void *this)
{
  char v1; // [sp+0h] [bp-1Ch]@1

  sub_43D70C(&v1, (int)this);
  _CxxThrowException(&v1, &unk_463A58);
}
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);

//----- (0043D6F0) --------------------------------------------------------
void *__thiscall sub_43D6F0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  unknown_libname_208(this);
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}

//----- (0043D70C) --------------------------------------------------------
_DWORD *__thiscall sub_43D70C(_BYTE *this, int a2)
{
  _BYTE *v2; // esi@1

  v2 = this;
  sub_43D639(this, a2);
  *(_DWORD *)v2 = &std::ios_base::failure::`vftable';
  return v2;
}
// 45FB24: using guessed type int (__stdcall *std::ios_base::failure::`vftable')(char);

//----- (0043DA55) --------------------------------------------------------
int sub_43DA55()
{
  nullsub_3();
  return atexit(sub_43DA6C);
}
// 43DA5F: using guessed type int nullsub_3(void);

//----- (0043DA6C) --------------------------------------------------------
void __cdecl sub_43DA6C()
{
  std::locale::~locale((std::locale *)&dword_481A18);
}
// 481A18: using guessed type int dword_481A18;

//----- (0043DD3E) --------------------------------------------------------
void __thiscall sub_43DD3E(void *this)
{
  struct std::locale::facet *v1; // eax@2
  void *v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+Ch] [bp-4h]@1

  v2 = this;
  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  if ( dword_481A20 )
  {
    v1 = std::locale::facet::_Decref(dword_481A20);
    if ( v1 )
      (**(void (__thiscall ***)(struct std::locale::facet *, signed int))v1)(v1, 1);
  }
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
}

//----- (0043DF4D) --------------------------------------------------------
int sub_43DF4D()
{
  return atexit(emptystub);
}

//----- (0043DF65) --------------------------------------------------------
void __noreturn sub_43DF65()
{
  size_t v0; // eax@1
  int (__stdcall **v1)(char); // [sp+4h] [bp-3Ch]@1
  char v2; // [sp+20h] [bp-20h]@1
  char v3; // [sp+33h] [bp-Dh]@1
  int v4; // [sp+3Ch] [bp-4h]@1

  v2 = v3;
  std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(0);
  v0 = strlen("string too long");
  std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign("string too long", v0);
  v4 = 0;
  sub_4357A0(&v1, &v2);
  v1 = &std::length_error::`vftable';
  _CxxThrowException(&v1, &unk_463D10);
}
// 41FF10: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(_DWORD);
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 45FBB8: using guessed type int (__stdcall *std::length_error::`vftable')(char);

//----- (0043DFFC) --------------------------------------------------------
void __thiscall __noreturn sub_43DFFC(void *this)
{
  char v1; // [sp+0h] [bp-1Ch]@1

  sub_43E035(&v1, (int)this);
  _CxxThrowException(&v1, &unk_463D10);
}
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);

//----- (0043E019) --------------------------------------------------------
void *__thiscall sub_43E019(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  unknown_libname_210(this);
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}

//----- (0043E035) --------------------------------------------------------
_DWORD *__thiscall sub_43E035(_DWORD *this, int a2)
{
  _DWORD *v2; // esi@1

  v2 = this;
  sub_435620(this, a2);
  *v2 = &std::length_error::`vftable';
  return v2;
}
// 45FBB8: using guessed type int (__stdcall *std::length_error::`vftable')(char);

//----- (0043E04D) --------------------------------------------------------
void __noreturn sub_43E04D()
{
  size_t v0; // eax@1
  int (__stdcall **v1)(int); // [sp+4h] [bp-3Ch]@1
  char v2; // [sp+20h] [bp-20h]@1
  char v3; // [sp+33h] [bp-Dh]@1
  int v4; // [sp+3Ch] [bp-4h]@1

  v2 = v3;
  std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(0);
  v0 = strlen("invalid string position");
  std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign("invalid string position", v0);
  v4 = 0;
  sub_4357A0(&v1, &v2);
  v1 = &std::out_of_range::`vftable';
  _CxxThrowException(&v1, &unk_463570);
}
// 41FF10: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(_DWORD);
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 45FBE8: using guessed type int (__stdcall *std::out_of_range::`vftable')(int);

//----- (0043E0A7) --------------------------------------------------------
int sub_43E0A7()
{
  if ( !(byte_481F40 & 1) )
    byte_481F40 |= 1u;
  sub_43E0D1();
  if ( !(byte_481F41 & 1) )
    byte_481F41 |= 1u;
  return atexit(nullsub_1);
}
// 481F40: using guessed type char byte_481F40;
// 481F41: using guessed type char byte_481F41;

//----- (0043E0D1) --------------------------------------------------------
int sub_43E0D1()
{
  return atexit(emptystub);
}

//----- (0043E18C) --------------------------------------------------------
int sub_43E18C()
{
  return atexit(emptystub);
}

//----- (0043EC89) --------------------------------------------------------
int __stdcall sub_43EC89(int a1, int a2, int a3, int a4, int a5, int a6, _DWORD *a7, bool *a8)
{
  int v8; // edi@1
  int v9; // eax@1
  std::locale *v10; // eax@2
  const struct std::locale::facet *v11; // edi@2
  int v12; // eax@2
  int v13; // eax@2
  void *v14; // eax@2
  int v15; // eax@4
  std::locale *v16; // eax@5
  int v17; // edi@5
  int v18; // eax@5
  unsigned __int32 v19; // eax@5
  unsigned int v20; // edi@5
  bool v21; // zf@9
  _DWORD *v22; // eax@9
  int result; // eax@14
  char v24; // [sp+Ch] [bp-48h]@5
  char v25; // [sp+1Ch] [bp-38h]@2
  char v26; // [sp+2Ch] [bp-28h]@2
  int v27; // [sp+30h] [bp-24h]@2
  char *v28; // [sp+3Ch] [bp-18h]@5
  char v29; // [sp+40h] [bp-14h]@5
  int v30; // [sp+44h] [bp-10h]@1
  int v31; // [sp+50h] [bp-4h]@2

  v30 = -1;
  v8 = a6;
  v9 = *(_DWORD *)(a6 + 12);
  if ( BYTE1(v9) & 0x40 )
  {
    v10 = (std::locale *)std::ios_base::getloc(&a6);
    v11 = sub_44099B(v10, 0, 1);
    std::locale::~locale((std::locale *)&a6);
    v26 = BYTE3(a6);
    std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(0);
    std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(1u, 0);
    v31 = 1;
    v12 = unknown_libname_221((void *)v11, (int)&v25);
    LOBYTE(v31) = 2;
    std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(v12, 0, 0xFFFFFFFF);
    LOBYTE(v31) = 1;
    std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(1);
    std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(1u, 0);
    v13 = unknown_libname_222(&v25);
    LOBYTE(v31) = 3;
    std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(v13, 0, 0xFFFFFFFF);
    LOBYTE(v31) = 1;
    std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(1);
    v14 = (void *)v27;
    if ( !v27 )
      v14 = &unk_45F91C;
    v15 = std::_Getloctxt((int)&a2, (int)&a4, 2u, (int)v14);
    v31 = -1;
    v30 = v15;
    std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(1);
  }
  else
  {
    *_errno() = 0;
    v16 = (std::locale *)std::ios_base::getloc(&v29);
    v17 = *(_DWORD *)(v8 + 12);
    v31 = 4;
    v18 = std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::_Getifld(&v24, &a2, &a4, v17, v16);
    v19 = strtoul(&v24, &v28, v18);
    v31 = -1;
    v20 = v19;
    std::locale::~locale((std::locale *)&v29);
    if ( v28 != &v24 && !*_errno() && v20 <= 1 )
      v30 = v20;
  }
  v21 = (unsigned __int8)sub_440C62((int)&a2, (int)&a4) == 0;
  v22 = a7;
  if ( !v21 )
    *a7 |= 1u;
  if ( v30 >= 0 )
    *a8 = v30 != 0;
  else
    *v22 |= 2u;
  result = a1;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  return result;
}
// 41FF10: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(_DWORD);
// 4212F0: using guessed type int __stdcall std::ios_base::getloc(_DWORD);
// 43F96D: using guessed type _DWORD __cdecl std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::_Getifld(_DWORD, _DWORD, _DWORD, _DWORD, std::locale *);
// 440605: using guessed type _DWORD __stdcall unknown_libname_222(_DWORD);

//----- (0043EE33) --------------------------------------------------------
int __stdcall sub_43EE33(int a1, int a2, int a3, char a4, int a5, int a6, _DWORD *a7, _WORD *a8)
{
  int v8; // esi@1
  std::locale *v9; // eax@1
  int v10; // esi@1
  int v11; // eax@1
  int v12; // esi@1
  char *v13; // edi@1
  unsigned __int32 v14; // esi@3
  char v15; // al@3
  _DWORD *v16; // ebx@3
  int result; // eax@12
  char v18; // [sp+Ch] [bp-30h]@1
  char v19; // [sp+Dh] [bp-2Fh]@1
  char *v20; // [sp+2Ch] [bp-10h]@3
  int v21; // [sp+38h] [bp-4h]@1

  *_errno() = 0;
  v8 = a6;
  v9 = (std::locale *)std::ios_base::getloc(&a6);
  v10 = *(_DWORD *)(v8 + 12);
  v21 = 0;
  v11 = std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::_Getifld(&v18, &a2, &a4, v10, v9);
  v21 = -1;
  v12 = v11;
  std::locale::~locale((std::locale *)&a6);
  v13 = &v19;
  if ( v18 != 45 )
    v13 = &v18;
  v14 = strtoul(v13, &v20, v12);
  v15 = sub_440C62((int)&a2, (int)&a4);
  v16 = a7;
  if ( v15 )
    *a7 |= 1u;
  if ( v20 == v13 || *_errno() || v14 > 0xFFFF )
  {
    *v16 |= 2u;
  }
  else
  {
    if ( v18 == 45 )
      v14 = -v14;
    *a8 = v14;
  }
  result = a1;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  return result;
}
// 4212F0: using guessed type int __stdcall std::ios_base::getloc(_DWORD);
// 43F96D: using guessed type _DWORD __cdecl std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::_Getifld(_DWORD, _DWORD, _DWORD, _DWORD, std::locale *);

//----- (0043EEFF) --------------------------------------------------------
int __stdcall sub_43EEFF(int a1, int a2, int a3, char a4, int a5, int a6, _DWORD *a7, unsigned __int32 *a8)
{
  int v8; // esi@1
  std::locale *v9; // eax@1
  int v10; // esi@1
  int v11; // eax@1
  int v12; // esi@1
  char *v13; // edi@1
  unsigned int v14; // esi@3
  char v15; // al@3
  _DWORD *v16; // ebx@3
  int result; // eax@12
  char v18; // [sp+Ch] [bp-30h]@1
  char v19; // [sp+Dh] [bp-2Fh]@1
  char *v20; // [sp+2Ch] [bp-10h]@3
  int v21; // [sp+38h] [bp-4h]@1

  *_errno() = 0;
  v8 = a6;
  v9 = (std::locale *)std::ios_base::getloc(&a6);
  v10 = *(_DWORD *)(v8 + 12);
  v21 = 0;
  v11 = std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::_Getifld(&v18, &a2, &a4, v10, v9);
  v21 = -1;
  v12 = v11;
  std::locale::~locale((std::locale *)&a6);
  v13 = &v19;
  if ( v18 != 45 )
    v13 = &v18;
  v14 = strtoul(v13, &v20, v12);
  v15 = sub_440C62((int)&a2, (int)&a4);
  v16 = a7;
  if ( v15 )
    *a7 |= 1u;
  if ( v20 == v13 || *_errno() || v14 > 0xFFFFFFFF )
  {
    *v16 |= 2u;
  }
  else
  {
    if ( v18 == 45 )
      v14 = -v14;
    *a8 = v14;
  }
  result = a1;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  return result;
}
// 4212F0: using guessed type int __stdcall std::ios_base::getloc(_DWORD);
// 43F96D: using guessed type _DWORD __cdecl std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::_Getifld(_DWORD, _DWORD, _DWORD, _DWORD, std::locale *);

//----- (0043F123) --------------------------------------------------------
int __stdcall sub_43F123(int a1, int a2, int a3, char a4, int a5, int a6, _DWORD *a7, float *a8)
{
  std::locale *v8; // eax@1
  __int32 v9; // eax@1
  char v10; // al@1
  _DWORD *v11; // esi@1
  int result; // eax@7
  char v13; // [sp+4h] [bp-60h]@1
  float v14; // [sp+50h] [bp-14h]@1
  char *v15; // [sp+54h] [bp-10h]@1
  int v16; // [sp+60h] [bp-4h]@1

  *_errno() = 0;
  v8 = (std::locale *)std::ios_base::getloc(&a6);
  v16 = 0;
  v9 = std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::_Getffld(&v13, &a2, &a4, v8);
  v14 = sub_44A74B(&v13, &v15, v9);
  v16 = -1;
  std::locale::~locale((std::locale *)&a6);
  v10 = sub_440C62((int)&a2, (int)&a4);
  v11 = a7;
  if ( v10 )
    *a7 |= 1u;
  if ( v15 == &v13 || *_errno() )
    *v11 |= 2u;
  else
    *a8 = v14;
  result = a1;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  return result;
}
// 4212F0: using guessed type int __stdcall std::ios_base::getloc(_DWORD);
// 43FD02: using guessed type _DWORD __cdecl std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::_Getffld(_DWORD, _DWORD, _DWORD, std::locale *);

//----- (0043F5BF) --------------------------------------------------------
int __stdcall sub_43F5BF(int a1, int a2, int a3, int a4, int a5, int a6)
{
  const char *v6; // eax@1
  int v7; // eax@1
  int v8; // ecx@1
  int result; // eax@1
  char v10; // [sp+4h] [bp-50h]@1
  char v11; // [sp+44h] [bp-10h]@1
  char v12; // [sp+4Ch] [bp-8h]@1

  v6 = (const char *)unknown_libname_220(&v12, 100, *(_DWORD *)(a4 + 12));
  v7 = sprintf(&v10, v6, a6);
  v8 = std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::_Iput(&v11, a2, a3, a4, a5, &v10, v7);
  result = a1;
  *(_DWORD *)a1 = *(_DWORD *)v8;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(v8 + 4);
  return result;
}
// 4402FF: using guessed type _DWORD __cdecl unknown_libname_220(_DWORD, char, _DWORD);
// 440359: using guessed type int __cdecl std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::_Iput(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0043F617) --------------------------------------------------------
int __stdcall sub_43F617(int a1, int a2, int a3, int a4, int a5, int a6)
{
  const char *v6; // eax@1
  int v7; // eax@1
  int v8; // ecx@1
  int result; // eax@1
  char v10; // [sp+4h] [bp-50h]@1
  char v11; // [sp+44h] [bp-10h]@1
  char v12; // [sp+4Ch] [bp-8h]@1

  v6 = (const char *)unknown_libname_220(&v12, 117, *(_DWORD *)(a4 + 12));
  v7 = sprintf(&v10, v6, a6);
  v8 = std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::_Iput(&v11, a2, a3, a4, a5, &v10, v7);
  result = a1;
  *(_DWORD *)a1 = *(_DWORD *)v8;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(v8 + 4);
  return result;
}
// 4402FF: using guessed type _DWORD __cdecl unknown_libname_220(_DWORD, char, _DWORD);
// 440359: using guessed type int __cdecl std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::_Iput(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0043F66F) --------------------------------------------------------
int __stdcall sub_43F66F(int a1, int a2, int a3, int a4, int a5, double a6)
{
  signed int v6; // esi@1
  signed int v7; // ebx@4
  double v8; // ST2C_8@6
  const char *v9; // eax@6
  int v10; // eax@6
  int v11; // ecx@6
  int result; // eax@6
  char v13; // [sp+14h] [bp-54h]@6
  int v14; // [sp+60h] [bp-8h]@6

  v6 = *(_DWORD *)(a4 + 16);
  if ( v6 <= 0 && !(*(_BYTE *)(a4 + 13) & 0x20) )
    v6 = 6;
  v7 = 36;
  if ( v6 <= 36 )
    v7 = v6;
  v8 = a6;
  v9 = (const char *)unknown_libname_219(&a6, 0, *(_DWORD *)(a4 + 12));
  v10 = sprintf(&v13, v9, v7, v8);
  v11 = std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::_Fput(
          (int)&v14,
          a2,
          a3,
          a4,
          a5,
          &v13,
          v6 - v7,
          v10);
  result = a1;
  *(_DWORD *)a1 = *(_DWORD *)v11;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(v11 + 4);
  return result;
}
// 43FFEE: using guessed type _DWORD __cdecl unknown_libname_219(_DWORD, char, _DWORD);

//----- (0043F6ED) --------------------------------------------------------
int __stdcall sub_43F6ED(int a1, int a2, int a3, int a4, int a5, double a6)
{
  signed int v6; // esi@1
  signed int v7; // ebx@4
  double v8; // ST2C_8@6
  const char *v9; // eax@6
  int v10; // eax@6
  int v11; // ecx@6
  int result; // eax@6
  char v13; // [sp+14h] [bp-54h]@6
  int v14; // [sp+60h] [bp-8h]@6

  v6 = *(_DWORD *)(a4 + 16);
  if ( v6 <= 0 && !(*(_BYTE *)(a4 + 13) & 0x20) )
    v6 = 6;
  v7 = 36;
  if ( v6 <= 36 )
    v7 = v6;
  v8 = a6;
  v9 = (const char *)unknown_libname_219(&a6, 76, *(_DWORD *)(a4 + 12));
  v10 = sprintf(&v13, v9, v7, v8);
  v11 = std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::_Fput(
          (int)&v14,
          a2,
          a3,
          a4,
          a5,
          &v13,
          v6 - v7,
          v10);
  result = a1;
  *(_DWORD *)a1 = *(_DWORD *)v11;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(v11 + 4);
  return result;
}
// 43FFEE: using guessed type _DWORD __cdecl unknown_libname_219(_DWORD, char, _DWORD);

//----- (0043F835) --------------------------------------------------------
char __thiscall sub_43F835(int this)
{
  return *(_BYTE *)(this + 12);
}

//----- (0043F839) --------------------------------------------------------
char __thiscall sub_43F839(int this)
{
  return *(_BYTE *)(this + 13);
}

//----- (0043F8DF) --------------------------------------------------------
void *__thiscall sub_43F8DF(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_43F8FB(this);
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}

//----- (0043F8FB) --------------------------------------------------------
void __thiscall sub_43F8FB(void *this)
{
  *(_DWORD *)this = &std::locale::facet::`vftable';
}
// 45FBB0: using guessed type int (__stdcall *std::locale::facet::`vftable')(int);

//----- (0043F902) --------------------------------------------------------
void *__thiscall sub_43F902(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_43F91E(this);
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}

//----- (0043F91E) --------------------------------------------------------
void __thiscall sub_43F91E(void *this)
{
  *(_DWORD *)this = &std::locale::facet::`vftable';
}
// 45FBB0: using guessed type int (__stdcall *std::locale::facet::`vftable')(int);

//----- (0043F925) --------------------------------------------------------
void *__thiscall sub_43F925(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_43F941((int)this);
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}

//----- (0043F941) --------------------------------------------------------
void __thiscall sub_43F941(int this)
{
  int v1; // esi@1
  void *v2; // ST08_4@1

  v1 = this;
  v2 = *(void **)(this + 8);
  *(_DWORD *)this = &std::numpunct<char>::`vftable';
  _delete_table(v2);
  _delete_table(*(LPVOID *)(v1 + 16));
  _delete_table(*(LPVOID *)(v1 + 20));
  *(_DWORD *)v1 = &std::locale::facet::`vftable';
}
// 45FBB0: using guessed type int (__stdcall *std::locale::facet::`vftable')(int);
// 45FCAC: using guessed type int (__stdcall *std::numpunct<char>::`vftable')(char);

//----- (004407E3) --------------------------------------------------------
const struct std::locale::facet *__cdecl sub_4407E3(std::locale *a1, int a2, int a3)
{
  unsigned int v3; // eax@1
  const struct std::locale::facet *v4; // esi@1
  std::locale::facet *v5; // eax@4
  std::locale::facet *v6; // eax@5
  std::locale::facet *v7; // esi@5
  char v9; // [sp+4h] [bp-5Ch]@6
  int (__stdcall **v10)(int); // [sp+44h] [bp-1Ch]@11
  char v11; // [sp+50h] [bp-10h]@1
  int v12; // [sp+5Ch] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v11);
  v12 = 0;
  v3 = std::locale::id::operator unsigned int(&unk_481A30);
  v4 = std::locale::_Getfacet(a1, v3, 1);
  if ( !v4 )
  {
    if ( !(_BYTE)a3 || !std::locale::_Iscloc(a1) )
    {
      a3 = (int)aMissingLocaleF;
      exception::exception(&v10, (const char **)&a3);
      v10 = &std::bad_cast::`vftable';
      _CxxThrowException(&v10, &unk_462ED8);
    }
    v5 = (std::locale::facet *)dword_481A40;
    if ( !dword_481A40 )
    {
      v6 = (std::locale::facet *)operator new(8u);
      v7 = v6;
      a3 = (int)v6;
      if ( v6 )
      {
        *((_DWORD *)v6 + 1) = 0;
        LOBYTE(v12) = 2;
        *(_DWORD *)v6 = &std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::`vftable';
        std::_Locinfo::_Locinfo((std::_Locinfo *)&v9, aC_0);
        std::_Locinfo::~_Locinfo((std::_Locinfo *)&v9);
      }
      else
      {
        v7 = 0;
      }
      LOBYTE(v12) = 0;
      v5 = sub_440CFA(v7);
      dword_481A40 = (int)v5;
    }
    v4 = v5;
  }
  v12 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v4;
}
// 423460: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 45FCE8: using guessed type int (__stdcall *std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::`vftable')(char);
// 45FD64: using guessed type int (__stdcall *std::bad_cast::`vftable')(int);
// 481A40: using guessed type int dword_481A40;

//----- (004408BF) --------------------------------------------------------
const struct std::locale::facet *__cdecl sub_4408BF(std::locale *a1, int a2, int a3)
{
  unsigned int v3; // eax@1
  const struct std::locale::facet *v4; // esi@1
  std::locale::facet *v5; // eax@4
  std::locale::facet *v6; // eax@5
  std::locale::facet *v7; // esi@5
  char v9; // [sp+4h] [bp-5Ch]@6
  int (__stdcall **v10)(int); // [sp+44h] [bp-1Ch]@11
  char v11; // [sp+50h] [bp-10h]@1
  int v12; // [sp+5Ch] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v11);
  v12 = 0;
  v3 = std::locale::id::operator unsigned int(&unk_481A3C);
  v4 = std::locale::_Getfacet(a1, v3, 1);
  if ( !v4 )
  {
    if ( !(_BYTE)a3 || !std::locale::_Iscloc(a1) )
    {
      a3 = (int)aMissingLocaleF;
      exception::exception(&v10, (const char **)&a3);
      v10 = &std::bad_cast::`vftable';
      _CxxThrowException(&v10, &unk_462ED8);
    }
    v5 = (std::locale::facet *)dword_481A44;
    if ( !dword_481A44 )
    {
      v6 = (std::locale::facet *)operator new(8u);
      v7 = v6;
      a3 = (int)v6;
      if ( v6 )
      {
        *((_DWORD *)v6 + 1) = 0;
        LOBYTE(v12) = 2;
        *(_DWORD *)v6 = &std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::`vftable';
        std::_Locinfo::_Locinfo((std::_Locinfo *)&v9, aC_0);
        std::_Locinfo::~_Locinfo((std::_Locinfo *)&v9);
      }
      else
      {
        v7 = 0;
      }
      LOBYTE(v12) = 0;
      v5 = sub_440D48(v7);
      dword_481A44 = (int)v5;
    }
    v4 = v5;
  }
  v12 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v4;
}
// 423460: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 45FCC8: using guessed type int (__stdcall *std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::`vftable')(char);
// 45FD64: using guessed type int (__stdcall *std::bad_cast::`vftable')(int);
// 481A44: using guessed type int dword_481A44;

//----- (0044099B) --------------------------------------------------------
const struct std::locale::facet *__cdecl sub_44099B(std::locale *a1, int a2, int a3)
{
  unsigned int v3; // eax@1
  const struct std::locale::facet *v4; // esi@1
  void *v5; // ecx@5
  std::locale::facet *v6; // eax@6
  int (__stdcall **v8)(int); // [sp+4h] [bp-1Ch]@10
  char v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+1Ch] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v9);
  v10 = 0;
  v3 = std::locale::id::operator unsigned int(&unk_481A38);
  v4 = std::locale::_Getfacet(a1, v3, 1);
  if ( !v4 )
  {
    if ( !(_BYTE)a3 || !std::locale::_Iscloc(a1) )
    {
      a3 = (int)aMissingLocaleF;
      exception::exception(&v8, (const char **)&a3);
      v8 = &std::bad_cast::`vftable';
      _CxxThrowException(&v8, &unk_462ED8);
    }
    v4 = (const struct std::locale::facet *)dword_481A48;
    if ( !dword_481A48 )
    {
      v5 = operator new(0x18u);
      a3 = (int)v5;
      LOBYTE(v10) = 1;
      if ( v5 )
        v6 = (std::locale::facet *)sub_440CA1((int)v5, (int)v4);
      else
        v6 = 0;
      LOBYTE(v10) = 0;
      dword_481A48 = (int)sub_440D96(v6);
      v4 = (const struct std::locale::facet *)dword_481A48;
    }
  }
  v10 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v9);
  return v4;
}
// 423460: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 45FD64: using guessed type int (__stdcall *std::bad_cast::`vftable')(int);
// 481A48: using guessed type int dword_481A48;

//----- (00440C62) --------------------------------------------------------
signed int __thiscall sub_440C62(int this, int a2)
{
  _DWORD *v2; // esi@1

  v2 = (_DWORD *)this;
  if ( !*(_BYTE *)(this + 4) )
    unknown_libname_223(this);
  if ( !*(_BYTE *)(a2 + 4) )
    unknown_libname_223(a2);
  if ( !*v2 )
  {
    if ( *(_DWORD *)a2 )
      return 0;
    return 1;
  }
  if ( *(_DWORD *)a2 )
    return 1;
  return 0;
}
// 4406CD: using guessed type int __thiscall unknown_libname_223(_DWORD);

//----- (00440CA1) --------------------------------------------------------
int __thiscall sub_440CA1(int this, int a2)
{
  int v2; // esi@1
  int v3; // eax@1
  char v5; // [sp+4h] [bp-50h]@1
  int v6; // [sp+44h] [bp-10h]@1
  int v7; // [sp+50h] [bp-4h]@1

  v2 = this;
  v6 = this;
  *(_DWORD *)(this + 4) = a2;
  v7 = 0;
  *(_DWORD *)this = &std::numpunct<char>::`vftable';
  v3 = std::_Locinfo::_Locinfo((std::_Locinfo *)&v5, aC_0);
  LOBYTE(v7) = 1;
  std::numpunct<char>::_Init(v3);
  LOBYTE(v7) = 0;
  std::_Locinfo::~_Locinfo((std::_Locinfo *)&v5);
  return v2;
}
// 44061C: using guessed type _DWORD __stdcall std::numpunct<char>::_Init(_DWORD);
// 45FCAC: using guessed type int (__stdcall *std::numpunct<char>::`vftable')(char);

//----- (00440CFA) --------------------------------------------------------
std::locale::facet *__cdecl sub_440CFA(std::locale::facet *a1)
{
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+10h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  dword_481A4C = a1;
  std::locale::facet::_Incref(a1);
  atexit((void (__cdecl *)())sub_440DE4);
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
  return a1;
}

//----- (00440D48) --------------------------------------------------------
std::locale::facet *__cdecl sub_440D48(std::locale::facet *a1)
{
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+10h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  dword_481A50 = a1;
  std::locale::facet::_Incref(a1);
  atexit((void (__cdecl *)())sub_440E31);
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
  return a1;
}

//----- (00440D96) --------------------------------------------------------
std::locale::facet *__cdecl sub_440D96(std::locale::facet *a1)
{
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+10h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  dword_481A54 = a1;
  std::locale::facet::_Incref(a1);
  atexit((void (__cdecl *)())sub_440E7E);
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
  return a1;
}

//----- (00440DE4) --------------------------------------------------------
void __thiscall sub_440DE4(void *this)
{
  struct std::locale::facet *v1; // eax@1
  void *v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+Ch] [bp-4h]@1

  v2 = this;
  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  v1 = std::locale::facet::_Decref(dword_481A4C);
  if ( v1 )
    (**(void (__thiscall ***)(struct std::locale::facet *, signed int))v1)(v1, 1);
  dword_481A4C = 0;
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
}

//----- (00440E31) --------------------------------------------------------
void __thiscall sub_440E31(void *this)
{
  struct std::locale::facet *v1; // eax@1
  void *v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+Ch] [bp-4h]@1

  v2 = this;
  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  v1 = std::locale::facet::_Decref(dword_481A50);
  if ( v1 )
    (**(void (__thiscall ***)(struct std::locale::facet *, signed int))v1)(v1, 1);
  dword_481A50 = 0;
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
}

//----- (00440E7E) --------------------------------------------------------
void __thiscall sub_440E7E(void *this)
{
  struct std::locale::facet *v1; // eax@1
  void *v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+Ch] [bp-4h]@1

  v2 = this;
  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  v1 = std::locale::facet::_Decref(dword_481A54);
  if ( v1 )
    (**(void (__thiscall ***)(struct std::locale::facet *, signed int))v1)(v1, 1);
  dword_481A54 = 0;
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
}

//----- (00440EF5) --------------------------------------------------------
int sub_440EF5()
{
  return atexit(emptystub);
}

//----- (0044134E) --------------------------------------------------------
LCID sub_44134E()
{
  signed int v0; // eax@1
  LCID v1; // ebx@3

  InterlockedIncrement(&dword_4832D8);
  v0 = 0;
  if ( dword_4832D4 )
  {
    InterlockedDecrement(&dword_4832D8);
    _lock(19);
    v0 = 1;
  }
  v1 = dword_481C60;
  if ( v0 )
    _unlock(19);
  else
    InterlockedDecrement(&dword_4832D8);
  return v1;
}
// 44F483: using guessed type _DWORD __cdecl _lock(_DWORD);
// 44F4E4: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 4832D4: using guessed type int dword_4832D4;

//----- (004415A2) --------------------------------------------------------
_DWORD *__thiscall sub_4415A2(_DWORD *this, char a2)
{
  _DWORD *v2; // esi@1

  v2 = this;
  exception::exception(this, (const char **)&a2);
  *v2 = &std::bad_alloc::`vftable';
  return v2;
}
// 45FD88: using guessed type int (__stdcall *std::bad_alloc::`vftable')(char);

//----- (004415BB) --------------------------------------------------------
void __thiscall sub_4415BB(int this)
{
  *(_DWORD *)this = &std::bad_alloc::`vftable';
  sub_44DCB0(this);
}
// 45FD88: using guessed type int (__stdcall *std::bad_alloc::`vftable')(char);

//----- (004415C6) --------------------------------------------------------
void __thiscall __noreturn sub_4415C6(void *this)
{
  char v1; // [sp+0h] [bp-Ch]@1

  sub_4415FF(&v1, (int)this);
  _CxxThrowException(&v1, &unk_464490);
}
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);

//----- (004415E3) --------------------------------------------------------
void *__thiscall sub_4415E3(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_4415BB((int)this);
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}

//----- (004415FF) --------------------------------------------------------
_DWORD *__thiscall sub_4415FF(_DWORD *this, int a2)
{
  _DWORD *v2; // esi@1

  v2 = this;
  exception::exception((int)this, a2);
  *v2 = &std::bad_alloc::`vftable';
  return v2;
}
// 45FD88: using guessed type int (__stdcall *std::bad_alloc::`vftable')(char);

//----- (00441617) --------------------------------------------------------
void __cdecl sub_441617()
{
  sub_4415BB((int)&unk_481A60);
}

//----- (00441D20) --------------------------------------------------------
char sub_441D20()
{
  return 0;
}

//----- (00441D23) --------------------------------------------------------
signed int sub_441D23()
{
  return 2;
}

//----- (00441D27) --------------------------------------------------------
int sub_441D27()
{
  return 0;
}

//----- (00441D2A) --------------------------------------------------------
void *__thiscall sub_441D2A(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_441D46(this);
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}

//----- (00441D46) --------------------------------------------------------
void __thiscall sub_441D46(void *this)
{
  *(_DWORD *)this = &std::locale::facet::`vftable';
}
// 45FBB0: using guessed type int (__stdcall *std::locale::facet::`vftable')(int);

//----- (00441E4A) --------------------------------------------------------
_WORD *__thiscall sub_441E4A(void *this, _WORD *a2, _WORD *a3)
{
  _WORD *v3; // esi@1
  const _Ctypevec *v4; // edi@2

  v3 = a2;
  if ( a2 != a3 )
  {
    v4 = (const _Ctypevec *)((char *)this + 8);
    do
    {
      *v3 = _Tolower(*v3, v4);
      ++v3;
    }
    while ( v3 != a3 );
  }
  return v3;
}

//----- (00441EA8) --------------------------------------------------------
_WORD *__thiscall sub_441EA8(void *this, _WORD *a2, _WORD *a3)
{
  _WORD *v3; // esi@1
  const _Ctypevec *v4; // edi@2

  v3 = a2;
  if ( a2 != a3 )
  {
    v4 = (const _Ctypevec *)((char *)this + 8);
    do
    {
      *v3 = _Toupper(*v3, v4);
      ++v3;
    }
    while ( v3 != a3 );
  }
  return v3;
}

//----- (00441F11) --------------------------------------------------------
int __stdcall sub_441F11(wint_t a1, int a2)
{
  return wctob(a1);
}

//----- (00442026) --------------------------------------------------------
int __stdcall sub_442026(int a1, int a2, int a3, int a4, int a5, int a6, _DWORD *a7, bool *a8)
{
  int v8; // edi@1
  int v9; // eax@1
  std::locale *v10; // eax@2
  int v11; // eax@2
  int v12; // eax@2
  void *v13; // eax@2
  int v14; // eax@4
  std::locale *v15; // eax@5
  int v16; // edi@5
  int v17; // eax@5
  unsigned __int32 v18; // eax@5
  unsigned int v19; // edi@5
  bool v20; // zf@9
  _DWORD *v21; // eax@9
  int result; // eax@14
  char v23; // [sp+Ch] [bp-48h]@5
  char v24; // [sp+1Ch] [bp-38h]@2
  char v25; // [sp+2Ch] [bp-28h]@2
  int v26; // [sp+30h] [bp-24h]@2
  char *v27; // [sp+3Ch] [bp-18h]@5
  char v28; // [sp+40h] [bp-14h]@5
  int v29; // [sp+44h] [bp-10h]@1
  int v30; // [sp+50h] [bp-4h]@2

  v29 = -1;
  v8 = a6;
  v9 = *(_DWORD *)(a6 + 12);
  if ( BYTE1(v9) & 0x40 )
  {
    v10 = (std::locale *)std::ios_base::getloc(&a6);
    sub_446317(v10, 0, 1);
    std::locale::~locale((std::locale *)&a6);
    v25 = BYTE3(a6);
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::_Tidy(0);
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::assign(1, 0);
    v30 = 1;
    v11 = unknown_libname_241(&v24);
    LOBYTE(v30) = 2;
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::append(
      v11,
      0,
      -1);
    LOBYTE(v30) = 1;
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::_Tidy(1);
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::append(1, 0);
    v12 = unknown_libname_242(&v24);
    LOBYTE(v30) = 3;
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::append(
      v12,
      0,
      -1);
    LOBYTE(v30) = 1;
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::_Tidy(1);
    v13 = (void *)v26;
    if ( !v26 )
      v13 = &unk_45FF28;
    v14 = std::_Getloctxt((int)&a2, (int)&a4, 2u, (int)v13);
    v30 = -1;
    v29 = v14;
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::_Tidy(1);
  }
  else
  {
    *_errno() = 0;
    v15 = (std::locale *)std::ios_base::getloc(&v28);
    v16 = *(_DWORD *)(v8 + 12);
    v30 = 4;
    v17 = std::num_get<unsigned short,std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::_Getifld(
            &v23,
            &a2,
            &a4,
            v16,
            v15);
    v18 = strtoul(&v23, &v27, v17);
    v30 = -1;
    v19 = v18;
    std::locale::~locale((std::locale *)&v28);
    if ( v27 != &v23 && !*_errno() && v19 <= 1 )
      v29 = v19;
  }
  v20 = (unsigned __int8)std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>::equal(&a4) == 0;
  v21 = a7;
  if ( !v20 )
    *a7 |= 1u;
  if ( v29 >= 0 )
    *a8 = v29 != 0;
  else
    *v21 |= 2u;
  result = a1;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  return result;
}
// 4212F0: using guessed type int __stdcall std::ios_base::getloc(_DWORD);
// 443962: using guessed type _DWORD __cdecl std::num_get<unsigned short,std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::_Getifld(_DWORD, _DWORD, _DWORD, _DWORD, std::locale *);
// 4446C7: using guessed type _DWORD __stdcall unknown_libname_241(_DWORD);
// 4446DE: using guessed type _DWORD __stdcall unknown_libname_242(_DWORD);
// 4455FE: using guessed type _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::append(_DWORD, _DWORD);
// 445ACF: using guessed type _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::assign(_DWORD, _DWORD);
// 445D22: using guessed type _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::_Tidy(char);
// 445EA6: using guessed type _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::append(_DWORD, _DWORD, _DWORD);
// 446E30: using guessed type _DWORD __stdcall std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>::equal(_DWORD);

//----- (004421D0) --------------------------------------------------------
int __stdcall sub_4421D0(int a1, int a2, int a3, char a4, int a5, int a6, _DWORD *a7, _WORD *a8)
{
  int v8; // esi@1
  std::locale *v9; // eax@1
  int v10; // esi@1
  int v11; // eax@1
  int v12; // esi@1
  char *v13; // edi@1
  unsigned __int32 v14; // esi@3
  char v15; // al@3
  _DWORD *v16; // ebx@3
  int result; // eax@12
  char v18; // [sp+Ch] [bp-30h]@1
  char v19; // [sp+Dh] [bp-2Fh]@1
  char *v20; // [sp+2Ch] [bp-10h]@3
  int v21; // [sp+38h] [bp-4h]@1

  *_errno() = 0;
  v8 = a6;
  v9 = (std::locale *)std::ios_base::getloc(&a6);
  v10 = *(_DWORD *)(v8 + 12);
  v21 = 0;
  v11 = std::num_get<unsigned short,std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::_Getifld(
          &v18,
          &a2,
          &a4,
          v10,
          v9);
  v21 = -1;
  v12 = v11;
  std::locale::~locale((std::locale *)&a6);
  v13 = &v19;
  if ( v18 != 45 )
    v13 = &v18;
  v14 = strtoul(v13, &v20, v12);
  v15 = std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>::equal(&a4);
  v16 = a7;
  if ( v15 )
    *a7 |= 1u;
  if ( v20 == v13 || *_errno() || v14 > 0xFFFF )
  {
    *v16 |= 2u;
  }
  else
  {
    if ( v18 == 45 )
      v14 = -v14;
    *a8 = v14;
  }
  result = a1;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  return result;
}
// 4212F0: using guessed type int __stdcall std::ios_base::getloc(_DWORD);
// 443962: using guessed type _DWORD __cdecl std::num_get<unsigned short,std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::_Getifld(_DWORD, _DWORD, _DWORD, _DWORD, std::locale *);
// 446E30: using guessed type _DWORD __stdcall std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>::equal(_DWORD);

//----- (0044229C) --------------------------------------------------------
int __stdcall sub_44229C(int a1, int a2, int a3, char a4, int a5, int a6, _DWORD *a7, unsigned __int32 *a8)
{
  int v8; // esi@1
  std::locale *v9; // eax@1
  int v10; // esi@1
  int v11; // eax@1
  int v12; // esi@1
  char *v13; // edi@1
  unsigned int v14; // esi@3
  char v15; // al@3
  _DWORD *v16; // ebx@3
  int result; // eax@12
  char v18; // [sp+Ch] [bp-30h]@1
  char v19; // [sp+Dh] [bp-2Fh]@1
  char *v20; // [sp+2Ch] [bp-10h]@3
  int v21; // [sp+38h] [bp-4h]@1

  *_errno() = 0;
  v8 = a6;
  v9 = (std::locale *)std::ios_base::getloc(&a6);
  v10 = *(_DWORD *)(v8 + 12);
  v21 = 0;
  v11 = std::num_get<unsigned short,std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::_Getifld(
          &v18,
          &a2,
          &a4,
          v10,
          v9);
  v21 = -1;
  v12 = v11;
  std::locale::~locale((std::locale *)&a6);
  v13 = &v19;
  if ( v18 != 45 )
    v13 = &v18;
  v14 = strtoul(v13, &v20, v12);
  v15 = std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>::equal(&a4);
  v16 = a7;
  if ( v15 )
    *a7 |= 1u;
  if ( v20 == v13 || *_errno() || v14 > 0xFFFFFFFF )
  {
    *v16 |= 2u;
  }
  else
  {
    if ( v18 == 45 )
      v14 = -v14;
    *a8 = v14;
  }
  result = a1;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  return result;
}
// 4212F0: using guessed type int __stdcall std::ios_base::getloc(_DWORD);
// 443962: using guessed type _DWORD __cdecl std::num_get<unsigned short,std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::_Getifld(_DWORD, _DWORD, _DWORD, _DWORD, std::locale *);
// 446E30: using guessed type _DWORD __stdcall std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>::equal(_DWORD);

//----- (004424C0) --------------------------------------------------------
int __stdcall sub_4424C0(int a1, int a2, int a3, int a4, int a5, int a6, _DWORD *a7, float *a8)
{
  struct std::locale *v8; // eax@1
  __int32 v9; // eax@1
  char v10; // al@1
  _DWORD *v11; // esi@1
  int result; // eax@7
  char v13[4]; // [sp+4h] [bp-60h]@1
  float v14; // [sp+50h] [bp-14h]@1
  char *v15; // [sp+54h] [bp-10h]@1
  int v16; // [sp+60h] [bp-4h]@1

  *_errno() = 0;
  v8 = (struct std::locale *)std::ios_base::getloc(&a6);
  v16 = 0;
  v9 = std::num_get<unsigned short,std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::_Getffld(
         (int)v13,
         (int)&a2,
         (int)&a4,
         v8);
  v14 = sub_44A74B(v13, &v15, v9);
  v16 = -1;
  std::locale::~locale((std::locale *)&a6);
  v10 = std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>::equal(&a4);
  v11 = a7;
  if ( v10 )
    *a7 |= 1u;
  if ( v15 == v13 || *_errno() )
    *v11 |= 2u;
  else
    *a8 = v14;
  result = a1;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  return result;
}
// 4212F0: using guessed type int __stdcall std::ios_base::getloc(_DWORD);
// 446E30: using guessed type _DWORD __stdcall std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>::equal(_DWORD);

//----- (0044296F) --------------------------------------------------------
int __stdcall sub_44296F(int a1, int a2, int a3, int a4, int a5, int a6)
{
  const char *v6; // eax@1
  int v7; // eax@1
  int v8; // ecx@1
  int result; // eax@1
  char v10; // [sp+4h] [bp-50h]@1
  char v11; // [sp+44h] [bp-10h]@1
  char v12; // [sp+4Ch] [bp-8h]@1

  v6 = (const char *)unknown_libname_240(&v12, 100, *(_DWORD *)(a4 + 12));
  v7 = sprintf(&v10, v6, a6);
  v8 = std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::_Iput(
         &v11,
         a2,
         a3,
         a4,
         a5,
         &v10,
         v7);
  result = a1;
  *(_DWORD *)a1 = *(_DWORD *)v8;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(v8 + 4);
  return result;
}
// 4443BF: using guessed type _DWORD __cdecl unknown_libname_240(_DWORD, char, _DWORD);
// 444419: using guessed type int __cdecl std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::_Iput(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004429C7) --------------------------------------------------------
int __stdcall sub_4429C7(int a1, int a2, int a3, int a4, int a5, int a6)
{
  const char *v6; // eax@1
  int v7; // eax@1
  int v8; // ecx@1
  int result; // eax@1
  char v10; // [sp+4h] [bp-50h]@1
  char v11; // [sp+44h] [bp-10h]@1
  char v12; // [sp+4Ch] [bp-8h]@1

  v6 = (const char *)unknown_libname_240(&v12, 117, *(_DWORD *)(a4 + 12));
  v7 = sprintf(&v10, v6, a6);
  v8 = std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::_Iput(
         &v11,
         a2,
         a3,
         a4,
         a5,
         &v10,
         v7);
  result = a1;
  *(_DWORD *)a1 = *(_DWORD *)v8;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(v8 + 4);
  return result;
}
// 4443BF: using guessed type _DWORD __cdecl unknown_libname_240(_DWORD, char, _DWORD);
// 444419: using guessed type int __cdecl std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::_Iput(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00442A1F) --------------------------------------------------------
int __stdcall sub_442A1F(int a1, int a2, int a3, int a4, int a5, double a6)
{
  signed int v6; // esi@1
  signed int v7; // ebx@4
  double v8; // ST2C_8@6
  const char *v9; // eax@6
  int v10; // eax@6
  int v11; // ecx@6
  int result; // eax@6
  char v13; // [sp+14h] [bp-54h]@6
  int v14; // [sp+60h] [bp-8h]@6

  v6 = *(_DWORD *)(a4 + 16);
  if ( v6 <= 0 && !(*(_BYTE *)(a4 + 13) & 0x20) )
    v6 = 6;
  v7 = 36;
  if ( v6 <= 36 )
    v7 = v6;
  v8 = a6;
  v9 = (const char *)unknown_libname_239(&a6, 0, *(_DWORD *)(a4 + 12));
  v10 = sprintf(&v13, v9, v7, v8);
  v11 = std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::_Fput(
          (int)&v14,
          a2,
          a3,
          a4,
          a5,
          &v13,
          v6 - v7,
          v10);
  result = a1;
  *(_DWORD *)a1 = *(_DWORD *)v11;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(v11 + 4);
  return result;
}
// 44407C: using guessed type _DWORD __cdecl unknown_libname_239(_DWORD, char, _DWORD);

//----- (00442A9D) --------------------------------------------------------
int __stdcall sub_442A9D(int a1, int a2, int a3, int a4, int a5, double a6)
{
  signed int v6; // esi@1
  signed int v7; // ebx@4
  double v8; // ST2C_8@6
  const char *v9; // eax@6
  int v10; // eax@6
  int v11; // ecx@6
  int result; // eax@6
  char v13; // [sp+14h] [bp-54h]@6
  int v14; // [sp+60h] [bp-8h]@6

  v6 = *(_DWORD *)(a4 + 16);
  if ( v6 <= 0 && !(*(_BYTE *)(a4 + 13) & 0x20) )
    v6 = 6;
  v7 = 36;
  if ( v6 <= 36 )
    v7 = v6;
  v8 = a6;
  v9 = (const char *)unknown_libname_239(&a6, 76, *(_DWORD *)(a4 + 12));
  v10 = sprintf(&v13, v9, v7, v8);
  v11 = std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::_Fput(
          (int)&v14,
          a2,
          a3,
          a4,
          a5,
          &v13,
          v6 - v7,
          v10);
  result = a1;
  *(_DWORD *)a1 = *(_DWORD *)v11;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(v11 + 4);
  return result;
}
// 44407C: using guessed type _DWORD __cdecl unknown_libname_239(_DWORD, char, _DWORD);

//----- (00442DD5) --------------------------------------------------------
int __stdcall sub_442DD5(int a1, int a2)
{
  return 0;
}

//----- (00442F83) --------------------------------------------------------
int __stdcall sub_442F83(int a1, int a2, int a3, char a4, int a5, char a6, int a7, _DWORD *a8, int a9)
{
  bool v9; // zf@1
  _DWORD *v10; // eax@1
  char v12; // [sp+4h] [bp-1Ch]@1
  int v13; // [sp+Ch] [bp-14h]@3
  int v14; // [sp+1Ch] [bp-4h]@1

  std::money_get<unsigned short,std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::_Getmfld(
    &v12,
    &a2,
    &a4,
    a6,
    a7);
  v14 = 0;
  v9 = (unsigned __int8)std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>::equal(&a4) == 0;
  v10 = a8;
  if ( !v9 )
    *a8 |= 1u;
  if ( v13 )
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::assign(
      &v12,
      0,
      -1);
  else
    *v10 |= 2u;
  v14 = -1;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::_Tidy(1);
  return a1;
}
// 44477A: using guessed type _DWORD __stdcall std::money_get<unsigned short,std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::_Getmfld(_DWORD, _DWORD, _DWORD, char, _DWORD);
// 4459AF: using guessed type _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::assign(_DWORD, _DWORD, _DWORD);
// 445D22: using guessed type _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::_Tidy(char);
// 446E30: using guessed type _DWORD __stdcall std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>::equal(_DWORD);

//----- (0044335F) --------------------------------------------------------
int __thiscall sub_44335F(int this)
{
  return *(_DWORD *)(this + 28);
}

//----- (0044337B) --------------------------------------------------------
signed int sub_44337B()
{
  return 2;
}

//----- (00443656) --------------------------------------------------------
void *__thiscall sub_443656(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_443672((int)this);
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}

//----- (00443672) --------------------------------------------------------
void __thiscall sub_443672(int this)
{
  _DWORD *v1; // esi@1
  bool v2; // zf@1

  v1 = (_DWORD *)this;
  v2 = *(_DWORD *)(this + 20) == 0;
  *(_DWORD *)this = &std::ctype<unsigned short>::`vftable';
  if ( !v2 )
    _Free(*(LPVOID *)(this + 16));
  *v1 = &std::locale::facet::`vftable';
}
// 45FBB0: using guessed type int (__stdcall *std::locale::facet::`vftable')(int);
// 45FEEC: using guessed type int (__stdcall *std::ctype<unsigned short>::`vftable')(char);

//----- (00443692) --------------------------------------------------------
void *__thiscall sub_443692(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_4436AE((int)this);
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}

//----- (004436AE) --------------------------------------------------------
void __thiscall sub_4436AE(int this)
{
  _DWORD *v1; // esi@1
  void *v2; // ST00_4@1

  v1 = (_DWORD *)this;
  v2 = *(void **)(this + 8);
  *(_DWORD *)this = &std::time_put<unsigned short,std::ostreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::`vftable';
  _Free(v2);
  *v1 = &std::locale::facet::`vftable';
}
// 45FBB0: using guessed type int (__stdcall *std::locale::facet::`vftable')(int);
// 45FDB8: using guessed type int (__stdcall *std::time_put<unsigned short,std::ostreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::`vftable')(char);

//----- (004436C8) --------------------------------------------------------
void *__thiscall sub_4436C8(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_4436E4(this);
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}

//----- (004436E4) --------------------------------------------------------
void __thiscall sub_4436E4(void *this)
{
  *(_DWORD *)this = &std::locale::facet::`vftable';
}
// 45FBB0: using guessed type int (__stdcall *std::locale::facet::`vftable')(int);

//----- (004436EB) --------------------------------------------------------
void *__thiscall sub_4436EB(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_443707(this);
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}

//----- (00443707) --------------------------------------------------------
void __thiscall sub_443707(void *this)
{
  *(_DWORD *)this = &std::locale::facet::`vftable';
}
// 45FBB0: using guessed type int (__stdcall *std::locale::facet::`vftable')(int);

//----- (0044370E) --------------------------------------------------------
void *__thiscall sub_44370E(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_44372A((int)this);
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}

//----- (0044372A) --------------------------------------------------------
void __thiscall sub_44372A(int this)
{
  int v1; // esi@1
  void *v2; // ST08_4@1

  v1 = this;
  v2 = *(void **)(this + 8);
  *(_DWORD *)this = &std::numpunct<unsigned short>::`vftable';
  _delete_table(v2);
  _delete_table(*(LPVOID *)(v1 + 16));
  _delete_table(*(LPVOID *)(v1 + 20));
  *(_DWORD *)v1 = &std::locale::facet::`vftable';
}
// 45FBB0: using guessed type int (__stdcall *std::locale::facet::`vftable')(int);
// 45FE84: using guessed type int (__stdcall *std::numpunct<unsigned short>::`vftable')(char);

//----- (00443756) --------------------------------------------------------
void *__thiscall sub_443756(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_443772(this);
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}

//----- (00443772) --------------------------------------------------------
void __thiscall sub_443772(void *this)
{
  *(_DWORD *)this = &std::locale::facet::`vftable';
}
// 45FBB0: using guessed type int (__stdcall *std::locale::facet::`vftable')(int);

//----- (00443779) --------------------------------------------------------
void *__thiscall sub_443779(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_443795((int)this);
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}

//----- (00443795) --------------------------------------------------------
void __thiscall sub_443795(int this)
{
  int v1; // esi@1
  void *v2; // ST04_4@1

  v1 = this;
  v2 = *(void **)(this + 8);
  *(_DWORD *)this = &std::messages<unsigned short>::`vftable';
  _delete_table(v2);
  _delete_table(*(LPVOID *)(v1 + 12));
  *(_DWORD *)v1 = &std::locale::facet::`vftable';
}
// 45FBB0: using guessed type int (__stdcall *std::locale::facet::`vftable')(int);
// 45FE5C: using guessed type int (__stdcall *std::messages<unsigned short>::`vftable')(char);

//----- (004437B8) --------------------------------------------------------
void *__thiscall sub_4437B8(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_4437D4(this);
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}

//----- (004437D4) --------------------------------------------------------
void __thiscall sub_4437D4(void *this)
{
  *(_DWORD *)this = &std::locale::facet::`vftable';
}
// 45FBB0: using guessed type int (__stdcall *std::locale::facet::`vftable')(int);

//----- (004437DB) --------------------------------------------------------
void *__thiscall sub_4437DB(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_4437F7(this);
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}

//----- (004437F7) --------------------------------------------------------
void __thiscall sub_4437F7(void *this)
{
  *(_DWORD *)this = &std::locale::facet::`vftable';
}
// 45FBB0: using guessed type int (__stdcall *std::locale::facet::`vftable')(int);

//----- (004437FE) --------------------------------------------------------
void *__thiscall sub_4437FE(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_443875();
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}
// 443875: using guessed type int sub_443875(void);

//----- (0044381A) --------------------------------------------------------
void *__thiscall sub_44381A(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_4438CA();
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}
// 4438CA: using guessed type int sub_4438CA(void);

//----- (00443836) --------------------------------------------------------
void *__thiscall sub_443836(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_443852((int)this);
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}

//----- (00443852) --------------------------------------------------------
void __thiscall sub_443852(int this)
{
  int v1; // esi@1
  void *v2; // ST04_4@1

  v1 = this;
  v2 = *(void **)(this + 8);
  *(_DWORD *)this = &std::time_get<unsigned short,std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::`vftable';
  _delete_table(v2);
  _delete_table(*(LPVOID *)(v1 + 12));
  *(_DWORD *)v1 = &std::locale::facet::`vftable';
}
// 45FBB0: using guessed type int (__stdcall *std::locale::facet::`vftable')(int);
// 45FDC4: using guessed type int (__stdcall *std::time_get<unsigned short,std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::`vftable')(char);

//----- (0044387A) --------------------------------------------------------
void __thiscall sub_44387A(int this)
{
  int v1; // esi@1
  void *v2; // ST0C_4@1

  v1 = this;
  v2 = *(void **)(this + 8);
  *(_DWORD *)this = &std::_Mpunct<unsigned short>::`vftable';
  _delete_table(v2);
  _delete_table(*(LPVOID *)(v1 + 16));
  _delete_table(*(LPVOID *)(v1 + 20));
  _delete_table(*(LPVOID *)(v1 + 24));
  *(_DWORD *)v1 = &std::locale::facet::`vftable';
}
// 45FBB0: using guessed type int (__stdcall *std::locale::facet::`vftable')(int);
// 45FF54: using guessed type int (__stdcall *std::_Mpunct<unsigned short>::`vftable')(char);

//----- (004438AE) --------------------------------------------------------
void *__thiscall sub_4438AE(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_44387A((int)this);
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}

//----- (00445667) --------------------------------------------------------
int __thiscall sub_445667(int this, unsigned int a2)
{
  int v2; // edx@1
  int result; // eax@2

  v2 = *(_DWORD *)(this + 8);
  if ( a2 > v2 )
    result = std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::append(
               a2 - v2,
               0);
  else
    result = std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::erase(
               a2,
               -1);
  return result;
}
// 4455FE: using guessed type _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::append(_DWORD, _DWORD);
// 445C01: using guessed type _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::erase(_DWORD, _DWORD);

//----- (0044568D) --------------------------------------------------------
int __thiscall sub_44568D(int this, int a2, int a3, char a4)
{
  int v4; // esi@1

  v4 = this;
  *(_DWORD *)(this + 4) = a3;
  *(_BYTE *)(this + 40) = a4;
  *(_DWORD *)this = &std::_Mpunct<unsigned short>::`vftable';
  std::_Mpunct<unsigned short>::_Init(a2);
  return v4;
}
// 445DBB: using guessed type _DWORD __stdcall std::_Mpunct<unsigned short>::_Init(_DWORD);
// 45FF54: using guessed type int (__stdcall *std::_Mpunct<unsigned short>::`vftable')(char);

//----- (0044609B) --------------------------------------------------------
const struct std::locale::facet *__cdecl sub_44609B(std::locale *a1, int a2, int a3)
{
  unsigned int v3; // eax@1
  const struct std::locale::facet *v4; // esi@1
  void *v5; // ecx@5
  std::locale::facet *v6; // eax@6
  int (__stdcall **v8)(int); // [sp+4h] [bp-1Ch]@10
  char v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+1Ch] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v9);
  v10 = 0;
  v3 = std::locale::id::operator unsigned int(&unk_481A88);
  v4 = std::locale::_Getfacet(a1, v3, 1);
  if ( !v4 )
  {
    if ( !(_BYTE)a3 || !std::locale::_Iscloc(a1) )
    {
      a3 = (int)aMissingLocaleF;
      exception::exception(&v8, (const char **)&a3);
      v8 = &std::bad_cast::`vftable';
      _CxxThrowException(&v8, &unk_462ED8);
    }
    v4 = (const struct std::locale::facet *)dword_481AA0;
    if ( !dword_481AA0 )
    {
      v5 = operator new(0x18u);
      a3 = (int)v5;
      LOBYTE(v10) = 1;
      if ( v5 )
        v6 = (std::locale::facet *)std::ctype<unsigned short>::ctype<unsigned short>((int)v5, (int)v4);
      else
        v6 = 0;
      LOBYTE(v10) = 0;
      dword_481AA0 = (int)sub_446FE7(v6);
      v4 = (const struct std::locale::facet *)dword_481AA0;
    }
  }
  v10 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v9);
  return v4;
}
// 423460: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 45FD64: using guessed type int (__stdcall *std::bad_cast::`vftable')(int);
// 481AA0: using guessed type int dword_481AA0;

//----- (0044615F) --------------------------------------------------------
const struct std::locale::facet *__cdecl sub_44615F(std::locale *a1, int a2, int a3)
{
  unsigned int v3; // eax@1
  const struct std::locale::facet *v4; // esi@1
  std::locale::facet *v5; // eax@4
  std::locale::facet *v6; // eax@5
  std::locale::facet *v7; // esi@5
  char v9; // [sp+4h] [bp-5Ch]@6
  int (__stdcall **v10)(int); // [sp+44h] [bp-1Ch]@11
  char v11; // [sp+50h] [bp-10h]@1
  int v12; // [sp+5Ch] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v11);
  v12 = 0;
  v3 = std::locale::id::operator unsigned int(&unk_481A8C);
  v4 = std::locale::_Getfacet(a1, v3, 1);
  if ( !v4 )
  {
    if ( !(_BYTE)a3 || !std::locale::_Iscloc(a1) )
    {
      a3 = (int)aMissingLocaleF;
      exception::exception(&v10, (const char **)&a3);
      v10 = &std::bad_cast::`vftable';
      _CxxThrowException(&v10, &unk_462ED8);
    }
    v5 = (std::locale::facet *)dword_481AA4;
    if ( !dword_481AA4 )
    {
      v6 = (std::locale::facet *)operator new(8u);
      v7 = v6;
      a3 = (int)v6;
      if ( v6 )
      {
        *((_DWORD *)v6 + 1) = 0;
        LOBYTE(v12) = 2;
        *(_DWORD *)v6 = &std::num_get<unsigned short,std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::`vftable';
        std::_Locinfo::_Locinfo((std::_Locinfo *)&v9, aC_0);
        std::_Locinfo::~_Locinfo((std::_Locinfo *)&v9);
      }
      else
      {
        v7 = 0;
      }
      LOBYTE(v12) = 0;
      v5 = sub_447035(v7);
      dword_481AA4 = (int)v5;
    }
    v4 = v5;
  }
  v12 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v4;
}
// 423460: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 45FD64: using guessed type int (__stdcall *std::bad_cast::`vftable')(int);
// 45FEC0: using guessed type int (__stdcall *std::num_get<unsigned short,std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::`vftable')(char);
// 481AA4: using guessed type int dword_481AA4;

//----- (0044623B) --------------------------------------------------------
const struct std::locale::facet *__cdecl sub_44623B(std::locale *a1, int a2, int a3)
{
  unsigned int v3; // eax@1
  const struct std::locale::facet *v4; // esi@1
  std::locale::facet *v5; // eax@4
  std::locale::facet *v6; // eax@5
  std::locale::facet *v7; // esi@5
  char v9; // [sp+4h] [bp-5Ch]@6
  int (__stdcall **v10)(int); // [sp+44h] [bp-1Ch]@11
  char v11; // [sp+50h] [bp-10h]@1
  int v12; // [sp+5Ch] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v11);
  v12 = 0;
  v3 = std::locale::id::operator unsigned int(&unk_481A7C);
  v4 = std::locale::_Getfacet(a1, v3, 1);
  if ( !v4 )
  {
    if ( !(_BYTE)a3 || !std::locale::_Iscloc(a1) )
    {
      a3 = (int)aMissingLocaleF;
      exception::exception(&v10, (const char **)&a3);
      v10 = &std::bad_cast::`vftable';
      _CxxThrowException(&v10, &unk_462ED8);
    }
    v5 = (std::locale::facet *)dword_481AA8;
    if ( !dword_481AA8 )
    {
      v6 = (std::locale::facet *)operator new(8u);
      v7 = v6;
      a3 = (int)v6;
      if ( v6 )
      {
        *((_DWORD *)v6 + 1) = 0;
        LOBYTE(v12) = 2;
        *(_DWORD *)v6 = &std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::`vftable';
        std::_Locinfo::_Locinfo((std::_Locinfo *)&v9, aC_0);
        std::_Locinfo::~_Locinfo((std::_Locinfo *)&v9);
      }
      else
      {
        v7 = 0;
      }
      LOBYTE(v12) = 0;
      v5 = sub_447083(v7);
      dword_481AA8 = (int)v5;
    }
    v4 = v5;
  }
  v12 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v4;
}
// 423460: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 45FD64: using guessed type int (__stdcall *std::bad_cast::`vftable')(int);
// 45FEA0: using guessed type int (__stdcall *std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::`vftable')(char);
// 481AA8: using guessed type int dword_481AA8;

//----- (00446317) --------------------------------------------------------
const struct std::locale::facet *__cdecl sub_446317(std::locale *a1, int a2, int a3)
{
  unsigned int v3; // eax@1
  const struct std::locale::facet *v4; // esi@1
  void *v5; // ecx@5
  std::locale::facet *v6; // eax@6
  int (__stdcall **v8)(int); // [sp+4h] [bp-1Ch]@10
  char v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+1Ch] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v9);
  v10 = 0;
  v3 = std::locale::id::operator unsigned int(&unk_481A6C);
  v4 = std::locale::_Getfacet(a1, v3, 1);
  if ( !v4 )
  {
    if ( !(_BYTE)a3 || !std::locale::_Iscloc(a1) )
    {
      a3 = (int)aMissingLocaleF;
      exception::exception(&v8, (const char **)&a3);
      v8 = &std::bad_cast::`vftable';
      _CxxThrowException(&v8, &unk_462ED8);
    }
    v4 = (const struct std::locale::facet *)dword_481AAC;
    if ( !dword_481AAC )
    {
      v5 = operator new(0x18u);
      a3 = (int)v5;
      LOBYTE(v10) = 1;
      if ( v5 )
        v6 = (std::locale::facet *)sub_446E6F((int)v5, (int)v4);
      else
        v6 = 0;
      LOBYTE(v10) = 0;
      dword_481AAC = (int)sub_4470D1(v6);
      v4 = (const struct std::locale::facet *)dword_481AAC;
    }
  }
  v10 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v9);
  return v4;
}
// 423460: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 45FD64: using guessed type int (__stdcall *std::bad_cast::`vftable')(int);
// 481AAC: using guessed type int dword_481AAC;

//----- (004463DB) --------------------------------------------------------
const struct std::locale::facet *__cdecl sub_4463DB(std::locale *a1, int a2, int a3)
{
  unsigned int v3; // eax@1
  const struct std::locale::facet *v4; // esi@1
  void *v5; // ecx@5
  std::locale::facet *v6; // eax@6
  int (__stdcall **v8)(int); // [sp+4h] [bp-1Ch]@10
  char v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+1Ch] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v9);
  v10 = 0;
  v3 = std::locale::id::operator unsigned int(&unk_481A80);
  v4 = std::locale::_Getfacet(a1, v3, 1);
  if ( !v4 )
  {
    if ( !(_BYTE)a3 || !std::locale::_Iscloc(a1) )
    {
      a3 = (int)aMissingLocaleF;
      exception::exception(&v8, (const char **)&a3);
      v8 = &std::bad_cast::`vftable';
      _CxxThrowException(&v8, &unk_462ED8);
    }
    v4 = (const struct std::locale::facet *)dword_481AB0;
    if ( !dword_481AB0 )
    {
      v5 = operator new(0x10u);
      a3 = (int)v5;
      LOBYTE(v10) = 1;
      if ( v5 )
        v6 = (std::locale::facet *)sub_446EC8((int)v5, (int)v4);
      else
        v6 = 0;
      LOBYTE(v10) = 0;
      dword_481AB0 = (int)sub_44711F(v6);
      v4 = (const struct std::locale::facet *)dword_481AB0;
    }
  }
  v10 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v9);
  return v4;
}
// 423460: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 45FD64: using guessed type int (__stdcall *std::bad_cast::`vftable')(int);
// 481AB0: using guessed type int dword_481AB0;

//----- (0044649F) --------------------------------------------------------
const struct std::locale::facet *__cdecl sub_44649F(std::locale *a1, int a2, int a3)
{
  unsigned int v3; // eax@1
  const struct std::locale::facet *v4; // esi@1
  void *v5; // ecx@5
  std::locale::facet *v6; // eax@6
  int (__stdcall **v8)(int); // [sp+4h] [bp-1Ch]@10
  char v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+1Ch] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v9);
  v10 = 0;
  v3 = std::locale::id::operator unsigned int(&unk_481A74);
  v4 = std::locale::_Getfacet(a1, v3, 1);
  if ( !v4 )
  {
    if ( !(_BYTE)a3 || !std::locale::_Iscloc(a1) )
    {
      a3 = (int)aMissingLocaleF;
      exception::exception(&v8, (const char **)&a3);
      v8 = &std::bad_cast::`vftable';
      _CxxThrowException(&v8, &unk_462ED8);
    }
    v4 = (const struct std::locale::facet *)dword_481AB4;
    if ( !dword_481AB4 )
    {
      v5 = operator new(0x10u);
      a3 = (int)v5;
      LOBYTE(v10) = 1;
      if ( v5 )
        v6 = (std::locale::facet *)sub_446F1C((int)v5, (int)v4);
      else
        v6 = 0;
      LOBYTE(v10) = 0;
      dword_481AB4 = (int)sub_44716D(v6);
      v4 = (const struct std::locale::facet *)dword_481AB4;
    }
  }
  v10 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v9);
  return v4;
}
// 423460: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 45FD64: using guessed type int (__stdcall *std::bad_cast::`vftable')(int);
// 481AB4: using guessed type int dword_481AB4;

//----- (00446563) --------------------------------------------------------
const struct std::locale::facet *__cdecl sub_446563(std::locale *a1, int a2, int a3)
{
  unsigned int v3; // eax@1
  const struct std::locale::facet *v4; // esi@1
  std::locale::facet *v5; // eax@4
  std::locale::facet *v6; // eax@5
  std::locale::facet *v7; // esi@5
  char v9; // [sp+4h] [bp-5Ch]@6
  int (__stdcall **v10)(int); // [sp+44h] [bp-1Ch]@11
  char v11; // [sp+50h] [bp-10h]@1
  int v12; // [sp+5Ch] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v11);
  v12 = 0;
  v3 = std::locale::id::operator unsigned int(&unk_481A70);
  v4 = std::locale::_Getfacet(a1, v3, 1);
  if ( !v4 )
  {
    if ( !(_BYTE)a3 || !std::locale::_Iscloc(a1) )
    {
      a3 = (int)aMissingLocaleF;
      exception::exception(&v10, (const char **)&a3);
      v10 = &std::bad_cast::`vftable';
      _CxxThrowException(&v10, &unk_462ED8);
    }
    v5 = (std::locale::facet *)dword_481AB8;
    if ( !dword_481AB8 )
    {
      v6 = (std::locale::facet *)operator new(8u);
      v7 = v6;
      a3 = (int)v6;
      if ( v6 )
      {
        *((_DWORD *)v6 + 1) = 0;
        LOBYTE(v12) = 2;
        *(_DWORD *)v6 = &std::money_get<unsigned short,std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::`vftable';
        std::_Locinfo::_Locinfo((std::_Locinfo *)&v9, aC_0);
        std::_Locinfo::~_Locinfo((std::_Locinfo *)&v9);
      }
      else
      {
        v7 = 0;
      }
      LOBYTE(v12) = 0;
      v5 = sub_4471BB(v7);
      dword_481AB8 = (int)v5;
    }
    v4 = v5;
  }
  v12 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v4;
}
// 423460: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 45FD64: using guessed type int (__stdcall *std::bad_cast::`vftable')(int);
// 45FE4C: using guessed type int (__stdcall *std::money_get<unsigned short,std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::`vftable')(char);
// 481AB8: using guessed type int dword_481AB8;

//----- (0044663F) --------------------------------------------------------
const struct std::locale::facet *__cdecl sub_44663F(std::locale *a1, int a2, int a3)
{
  unsigned int v3; // eax@1
  const struct std::locale::facet *v4; // esi@1
  std::locale::facet *v5; // eax@4
  std::locale::facet *v6; // eax@5
  std::locale::facet *v7; // esi@5
  char v9; // [sp+4h] [bp-5Ch]@6
  int (__stdcall **v10)(int); // [sp+44h] [bp-1Ch]@11
  char v11; // [sp+50h] [bp-10h]@1
  int v12; // [sp+5Ch] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v11);
  v12 = 0;
  v3 = std::locale::id::operator unsigned int(&unk_481A9C);
  v4 = std::locale::_Getfacet(a1, v3, 1);
  if ( !v4 )
  {
    if ( !(_BYTE)a3 || !std::locale::_Iscloc(a1) )
    {
      a3 = (int)aMissingLocaleF;
      exception::exception(&v10, (const char **)&a3);
      v10 = &std::bad_cast::`vftable';
      _CxxThrowException(&v10, &unk_462ED8);
    }
    v5 = (std::locale::facet *)dword_481ABC;
    if ( !dword_481ABC )
    {
      v6 = (std::locale::facet *)operator new(8u);
      v7 = v6;
      a3 = (int)v6;
      if ( v6 )
      {
        *((_DWORD *)v6 + 1) = 0;
        LOBYTE(v12) = 2;
        *(_DWORD *)v6 = &std::money_put<unsigned short,std::ostreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::`vftable';
        std::_Locinfo::_Locinfo((std::_Locinfo *)&v9, aC_0);
        std::_Locinfo::~_Locinfo((std::_Locinfo *)&v9);
      }
      else
      {
        v7 = 0;
      }
      LOBYTE(v12) = 0;
      v5 = sub_447209(v7);
      dword_481ABC = (int)v5;
    }
    v4 = v5;
  }
  v12 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v4;
}
// 423460: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 45FD64: using guessed type int (__stdcall *std::bad_cast::`vftable')(int);
// 45FE3C: using guessed type int (__stdcall *std::money_put<unsigned short,std::ostreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::`vftable')(char);
// 481ABC: using guessed type int dword_481ABC;

//----- (0044671B) --------------------------------------------------------
const struct std::locale::facet *__cdecl sub_44671B(std::locale *a1, int a2, int a3)
{
  unsigned int v3; // eax@1
  const struct std::locale::facet *v4; // esi@1
  std::locale::facet *v5; // eax@5
  std::locale::facet *v6; // esi@5
  int (__stdcall **v8)(int); // [sp+8h] [bp-1Ch]@10
  char v9; // [sp+14h] [bp-10h]@1
  int v10; // [sp+20h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v9);
  v10 = 0;
  v3 = std::locale::id::operator unsigned int(&unk_481A98);
  v4 = std::locale::_Getfacet(a1, v3, 1);
  if ( !v4 )
  {
    if ( !(_BYTE)a3 || !std::locale::_Iscloc(a1) )
    {
      a3 = (int)aMissingLocaleF;
      exception::exception(&v8, (const char **)&a3);
      v8 = &std::bad_cast::`vftable';
      _CxxThrowException(&v8, &unk_462ED8);
    }
    v4 = (const struct std::locale::facet *)dword_481AC0;
    if ( !dword_481AC0 )
    {
      v5 = (std::locale::facet *)operator new(0x2Cu);
      v6 = v5;
      a3 = (int)v5;
      LOBYTE(v10) = 1;
      if ( v5 )
      {
        sub_4473DD((int)v5, 0, 0);
        *(_DWORD *)v6 = &std::moneypunct<unsigned short,0>::`vftable';
      }
      else
      {
        v6 = 0;
      }
      LOBYTE(v10) = 0;
      dword_481AC0 = (int)sub_447257(v6);
      v4 = (const struct std::locale::facet *)dword_481AC0;
    }
  }
  v10 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v9);
  return v4;
}
// 423460: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 45FD64: using guessed type int (__stdcall *std::bad_cast::`vftable')(int);
// 45FE10: using guessed type int (__stdcall *std::moneypunct<unsigned short,0>::`vftable')(char);
// 481AC0: using guessed type int dword_481AC0;

//----- (004467EA) --------------------------------------------------------
const struct std::locale::facet *__cdecl sub_4467EA(std::locale *a1, int a2, int a3)
{
  unsigned int v3; // eax@1
  const struct std::locale::facet *v4; // esi@1
  std::locale::facet *v5; // eax@5
  std::locale::facet *v6; // esi@5
  int (__stdcall **v8)(int); // [sp+4h] [bp-1Ch]@10
  char v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+1Ch] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v9);
  v10 = 0;
  v3 = std::locale::id::operator unsigned int(&unk_481A78);
  v4 = std::locale::_Getfacet(a1, v3, 1);
  if ( !v4 )
  {
    if ( !(_BYTE)a3 || !std::locale::_Iscloc(a1) )
    {
      a3 = (int)aMissingLocaleF;
      exception::exception(&v8, (const char **)&a3);
      v8 = &std::bad_cast::`vftable';
      _CxxThrowException(&v8, &unk_462ED8);
    }
    v4 = (const struct std::locale::facet *)dword_481AC4;
    if ( !dword_481AC4 )
    {
      v5 = (std::locale::facet *)operator new(0x2Cu);
      v6 = v5;
      a3 = (int)v5;
      LOBYTE(v10) = 1;
      if ( v5 )
      {
        sub_4473DD((int)v5, 0, 1);
        *(_DWORD *)v6 = &std::moneypunct<unsigned short,1>::`vftable';
      }
      else
      {
        v6 = 0;
      }
      LOBYTE(v10) = 0;
      dword_481AC4 = (int)sub_4472A5(v6);
      v4 = (const struct std::locale::facet *)dword_481AC4;
    }
  }
  v10 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v9);
  return v4;
}
// 423460: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 45FD64: using guessed type int (__stdcall *std::bad_cast::`vftable')(int);
// 45FDE4: using guessed type int (__stdcall *std::moneypunct<unsigned short,1>::`vftable')(char);
// 481AC4: using guessed type int dword_481AC4;

//----- (004468B9) --------------------------------------------------------
const struct std::locale::facet *__cdecl sub_4468B9(std::locale *a1, int a2, int a3)
{
  unsigned int v3; // eax@1
  const struct std::locale::facet *v4; // esi@1
  void *v5; // ecx@5
  std::locale::facet *v6; // eax@6
  int (__stdcall **v8)(int); // [sp+4h] [bp-1Ch]@10
  char v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+1Ch] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v9);
  v10 = 0;
  v3 = std::locale::id::operator unsigned int(&unk_481A84);
  v4 = std::locale::_Getfacet(a1, v3, 1);
  if ( !v4 )
  {
    if ( !(_BYTE)a3 || !std::locale::_Iscloc(a1) )
    {
      a3 = (int)aMissingLocaleF;
      exception::exception(&v8, (const char **)&a3);
      v8 = &std::bad_cast::`vftable';
      _CxxThrowException(&v8, &unk_462ED8);
    }
    v4 = (const struct std::locale::facet *)dword_481AC8;
    if ( !dword_481AC8 )
    {
      v5 = operator new(0x10u);
      a3 = (int)v5;
      LOBYTE(v10) = 1;
      if ( v5 )
        v6 = (std::locale::facet *)sub_446F8E((int)v5, (int)v4);
      else
        v6 = 0;
      LOBYTE(v10) = 0;
      dword_481AC8 = (int)sub_4472F3(v6);
      v4 = (const struct std::locale::facet *)dword_481AC8;
    }
  }
  v10 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v9);
  return v4;
}
// 423460: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 45FD64: using guessed type int (__stdcall *std::bad_cast::`vftable')(int);
// 481AC8: using guessed type int dword_481AC8;

//----- (0044697D) --------------------------------------------------------
const struct std::locale::facet *__cdecl sub_44697D(std::locale *a1, int a2, int a3)
{
  unsigned int v3; // eax@1
  const struct std::locale::facet *v4; // esi@1
  void *v5; // ecx@5
  std::locale::facet *v6; // eax@6
  int (__stdcall **v8)(int); // [sp+4h] [bp-1Ch]@10
  char v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+1Ch] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v9);
  v10 = 0;
  v3 = std::locale::id::operator unsigned int(&unk_481A94);
  v4 = std::locale::_Getfacet(a1, v3, 1);
  if ( !v4 )
  {
    if ( !(_BYTE)a3 || !std::locale::_Iscloc(a1) )
    {
      a3 = (int)aMissingLocaleF;
      exception::exception(&v8, (const char **)&a3);
      v8 = &std::bad_cast::`vftable';
      _CxxThrowException(&v8, &unk_462ED8);
    }
    v4 = (const struct std::locale::facet *)dword_481ACC;
    if ( !dword_481ACC )
    {
      v5 = operator new(0xCu);
      a3 = (int)v5;
      LOBYTE(v10) = 1;
      if ( v5 )
        v6 = (std::locale::facet *)sub_446DC3((int)v5, (LPVOID)v4);
      else
        v6 = 0;
      LOBYTE(v10) = 0;
      dword_481ACC = (int)sub_447341(v6);
      v4 = (const struct std::locale::facet *)dword_481ACC;
    }
  }
  v10 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v9);
  return v4;
}
// 423460: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 45FD64: using guessed type int (__stdcall *std::bad_cast::`vftable')(int);
// 481ACC: using guessed type int dword_481ACC;

//----- (00446A41) --------------------------------------------------------
const struct std::locale::facet *__cdecl sub_446A41(std::locale *a1, int a2, int a3)
{
  unsigned int v3; // eax@1
  const struct std::locale::facet *v4; // esi@1
  void *v5; // ecx@5
  std::locale::facet *v6; // eax@6
  int (__stdcall **v8)(int); // [sp+4h] [bp-1Ch]@10
  char v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+1Ch] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v9);
  v10 = 0;
  v3 = std::locale::id::operator unsigned int(&unk_481A90);
  v4 = std::locale::_Getfacet(a1, v3, 1);
  if ( !v4 )
  {
    if ( !(_BYTE)a3 || !std::locale::_Iscloc(a1) )
    {
      a3 = (int)aMissingLocaleF;
      exception::exception(&v8, (const char **)&a3);
      v8 = &std::bad_cast::`vftable';
      _CxxThrowException(&v8, &unk_462ED8);
    }
    v4 = (const struct std::locale::facet *)dword_481AD0;
    if ( !dword_481AD0 )
    {
      v5 = operator new(0x10u);
      a3 = (int)v5;
      LOBYTE(v10) = 1;
      if ( v5 )
        v6 = (std::locale::facet *)sub_446B05((int)v5, (int)v4);
      else
        v6 = 0;
      LOBYTE(v10) = 0;
      dword_481AD0 = (int)sub_44738F(v6);
      v4 = (const struct std::locale::facet *)dword_481AD0;
    }
  }
  v10 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v9);
  return v4;
}
// 423460: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 45FD64: using guessed type int (__stdcall *std::bad_cast::`vftable')(int);
// 481AD0: using guessed type int dword_481AD0;

//----- (00446B05) --------------------------------------------------------
int __thiscall sub_446B05(int this, int a2)
{
  int v2; // esi@1
  int v3; // edx@1
  char v5; // [sp+4h] [bp-50h]@1
  int v6; // [sp+44h] [bp-10h]@1
  int v7; // [sp+50h] [bp-4h]@1

  v2 = this;
  v6 = this;
  *(_DWORD *)(this + 4) = a2;
  v7 = 0;
  *(_DWORD *)this = &std::codecvt<unsigned short,char,int>::`vftable';
  std::_Locinfo::_Locinfo((std::_Locinfo *)&v5, aC_0);
  *(_DWORD *)(v2 + 8) = sub_44134E();
  *(_DWORD *)(v2 + 12) = v3;
  std::_Locinfo::~_Locinfo((std::_Locinfo *)&v5);
  return v2;
}
// 45FD98: using guessed type int (__stdcall *std::codecvt<unsigned short,char,int>::`vftable')(char);

//----- (00446DC3) --------------------------------------------------------
int __thiscall sub_446DC3(int this, LPVOID lpMem)
{
  int v2; // esi@1
  int v3; // eax@1
  _DWORD *v4; // eax@1
  char v6; // [sp+4h] [bp-50h]@1
  int v7; // [sp+44h] [bp-10h]@1
  int v8; // [sp+50h] [bp-4h]@1

  v2 = this;
  v7 = this;
  *(_DWORD *)(this + 4) = lpMem;
  v8 = 0;
  *(_DWORD *)(this + 8) = 0;
  LOBYTE(v8) = 1;
  *(_DWORD *)this = &std::time_put<unsigned short,std::ostreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::`vftable';
  v3 = std::_Locinfo::_Locinfo((std::_Locinfo *)&v6, aC_0);
  v4 = (_DWORD *)std::_Locinfo::_Gettnames(v3, &lpMem);
  *(_DWORD *)(v2 + 8) = *v4;
  *v4 = 0;
  _Free(lpMem);
  std::_Locinfo::~_Locinfo((std::_Locinfo *)&v6);
  return v2;
}
// 4438F7: using guessed type int __thiscall std::_Locinfo::_Gettnames(_DWORD, _DWORD);
// 45FDB8: using guessed type int (__stdcall *std::time_put<unsigned short,std::ostreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::`vftable')(char);

//----- (00446E6F) --------------------------------------------------------
int __thiscall sub_446E6F(int this, int a2)
{
  int v2; // esi@1
  int v3; // eax@1
  char v5; // [sp+4h] [bp-50h]@1
  int v6; // [sp+44h] [bp-10h]@1
  int v7; // [sp+50h] [bp-4h]@1

  v2 = this;
  v6 = this;
  *(_DWORD *)(this + 4) = a2;
  v7 = 0;
  *(_DWORD *)this = &std::numpunct<unsigned short>::`vftable';
  v3 = std::_Locinfo::_Locinfo((std::_Locinfo *)&v5, aC_0);
  LOBYTE(v7) = 1;
  std::numpunct<unsigned short>::_Init(v3);
  LOBYTE(v7) = 0;
  std::_Locinfo::~_Locinfo((std::_Locinfo *)&v5);
  return v2;
}
// 4446F5: using guessed type _DWORD __stdcall std::numpunct<unsigned short>::_Init(_DWORD);
// 45FE84: using guessed type int (__stdcall *std::numpunct<unsigned short>::`vftable')(char);

//----- (00446EC8) --------------------------------------------------------
int __thiscall sub_446EC8(int this, int a2)
{
  int v2; // esi@1
  int v3; // edx@1
  char v5; // [sp+4h] [bp-50h]@1
  int v6; // [sp+44h] [bp-10h]@1
  int v7; // [sp+50h] [bp-4h]@1

  v2 = this;
  v6 = this;
  *(_DWORD *)(this + 4) = a2;
  v7 = 0;
  *(_DWORD *)this = &std::collate<unsigned short>::`vftable';
  std::_Locinfo::_Locinfo((std::_Locinfo *)&v5, aC_0);
  *(_DWORD *)(v2 + 8) = sub_44A86E();
  *(_DWORD *)(v2 + 12) = v3;
  std::_Locinfo::~_Locinfo((std::_Locinfo *)&v5);
  return v2;
}
// 45FE70: using guessed type int (__stdcall *std::collate<unsigned short>::`vftable')(char);

//----- (00446F1C) --------------------------------------------------------
int __thiscall sub_446F1C(int this, int a2)
{
  int v2; // esi@1
  unsigned __int16 *v3; // eax@1
  char v5; // [sp+4h] [bp-50h]@1
  int v6; // [sp+44h] [bp-10h]@1
  int v7; // [sp+50h] [bp-4h]@1

  v2 = this;
  v6 = this;
  *(_DWORD *)(this + 4) = a2;
  v7 = 0;
  *(_DWORD *)this = &std::messages<unsigned short>::`vftable';
  std::_Locinfo::_Locinfo((std::_Locinfo *)&v5, aC_0);
  LOBYTE(v7) = 1;
  *(_DWORD *)(v2 + 8) = std::_Maklocstr("no", 0);
  v3 = std::_Maklocstr("yes", 0);
  LOBYTE(v7) = 0;
  *(_DWORD *)(v2 + 12) = v3;
  std::_Locinfo::~_Locinfo((std::_Locinfo *)&v5);
  return v2;
}
// 45FE5C: using guessed type int (__stdcall *std::messages<unsigned short>::`vftable')(char);

//----- (00446F8E) --------------------------------------------------------
int __thiscall sub_446F8E(int this, int a2)
{
  int v2; // esi@1
  std::_Locinfo *v3; // eax@1
  char v5; // [sp+4h] [bp-50h]@1
  int v6; // [sp+44h] [bp-10h]@1
  int v7; // [sp+50h] [bp-4h]@1

  v2 = this;
  v6 = this;
  *(_DWORD *)(this + 4) = a2;
  v7 = 0;
  *(_DWORD *)this = &std::time_get<unsigned short,std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::`vftable';
  v3 = (std::_Locinfo *)std::_Locinfo::_Locinfo((std::_Locinfo *)&v5, aC_0);
  LOBYTE(v7) = 1;
  std::time_get<unsigned short,std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::_Init(v3);
  LOBYTE(v7) = 0;
  std::_Locinfo::~_Locinfo((std::_Locinfo *)&v5);
  return v2;
}
// 4456D4: using guessed type _DWORD __stdcall std::time_get<unsigned short,std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::_Init(std::_Locinfo *);
// 45FDC4: using guessed type int (__stdcall *std::time_get<unsigned short,std::istreambuf_iterator<unsigned short,std::char_traits<unsigned short>>>::`vftable')(char);

//----- (00446FE7) --------------------------------------------------------
std::locale::facet *__cdecl sub_446FE7(std::locale::facet *a1)
{
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+10h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  dword_481AD4 = a1;
  std::locale::facet::_Incref(a1);
  atexit((void (__cdecl *)())sub_44743C);
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
  return a1;
}

//----- (00447035) --------------------------------------------------------
std::locale::facet *__cdecl sub_447035(std::locale::facet *a1)
{
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+10h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  dword_481AD8 = a1;
  std::locale::facet::_Incref(a1);
  atexit((void (__cdecl *)())sub_447489);
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
  return a1;
}

//----- (00447083) --------------------------------------------------------
std::locale::facet *__cdecl sub_447083(std::locale::facet *a1)
{
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+10h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  dword_481ADC = a1;
  std::locale::facet::_Incref(a1);
  atexit((void (__cdecl *)())sub_4474D6);
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
  return a1;
}

//----- (004470D1) --------------------------------------------------------
std::locale::facet *__cdecl sub_4470D1(std::locale::facet *a1)
{
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+10h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  dword_481AE0 = a1;
  std::locale::facet::_Incref(a1);
  atexit((void (__cdecl *)())sub_447523);
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
  return a1;
}

//----- (0044711F) --------------------------------------------------------
std::locale::facet *__cdecl sub_44711F(std::locale::facet *a1)
{
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+10h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  dword_481AE4 = a1;
  std::locale::facet::_Incref(a1);
  atexit((void (__cdecl *)())sub_447570);
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
  return a1;
}

//----- (0044716D) --------------------------------------------------------
std::locale::facet *__cdecl sub_44716D(std::locale::facet *a1)
{
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+10h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  dword_481AE8 = a1;
  std::locale::facet::_Incref(a1);
  atexit((void (__cdecl *)())sub_4475BD);
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
  return a1;
}

//----- (004471BB) --------------------------------------------------------
std::locale::facet *__cdecl sub_4471BB(std::locale::facet *a1)
{
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+10h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  dword_481AEC = a1;
  std::locale::facet::_Incref(a1);
  atexit((void (__cdecl *)())sub_44760A);
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
  return a1;
}

//----- (00447209) --------------------------------------------------------
std::locale::facet *__cdecl sub_447209(std::locale::facet *a1)
{
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+10h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  dword_481AF0 = a1;
  std::locale::facet::_Incref(a1);
  atexit((void (__cdecl *)())sub_447657);
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
  return a1;
}

//----- (00447257) --------------------------------------------------------
std::locale::facet *__cdecl sub_447257(std::locale::facet *a1)
{
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+10h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  dword_481AF4 = a1;
  std::locale::facet::_Incref(a1);
  atexit((void (__cdecl *)())sub_4476A4);
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
  return a1;
}

//----- (004472A5) --------------------------------------------------------
std::locale::facet *__cdecl sub_4472A5(std::locale::facet *a1)
{
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+10h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  dword_481AF8 = a1;
  std::locale::facet::_Incref(a1);
  atexit((void (__cdecl *)())sub_4476F1);
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
  return a1;
}

//----- (004472F3) --------------------------------------------------------
std::locale::facet *__cdecl sub_4472F3(std::locale::facet *a1)
{
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+10h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  dword_481AFC = a1;
  std::locale::facet::_Incref(a1);
  atexit((void (__cdecl *)())sub_44773E);
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
  return a1;
}

//----- (00447341) --------------------------------------------------------
std::locale::facet *__cdecl sub_447341(std::locale::facet *a1)
{
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+10h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  dword_481B00 = a1;
  std::locale::facet::_Incref(a1);
  atexit((void (__cdecl *)())sub_44778B);
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
  return a1;
}

//----- (0044738F) --------------------------------------------------------
std::locale::facet *__cdecl sub_44738F(std::locale::facet *a1)
{
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+10h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  dword_481B04 = a1;
  std::locale::facet::_Incref(a1);
  atexit((void (__cdecl *)())sub_4477D8);
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
  return a1;
}

//----- (004473DD) --------------------------------------------------------
int __thiscall sub_4473DD(int this, int a2, char a3)
{
  int v3; // esi@1
  int v4; // eax@1
  char v6; // [sp+4h] [bp-50h]@1
  int v7; // [sp+44h] [bp-10h]@1
  int v8; // [sp+50h] [bp-4h]@1

  v3 = this;
  v7 = this;
  *(_DWORD *)(this + 4) = a2;
  v8 = 0;
  *(_BYTE *)(this + 40) = a3;
  *(_DWORD *)this = &std::_Mpunct<unsigned short>::`vftable';
  v4 = std::_Locinfo::_Locinfo((std::_Locinfo *)&v6, aC_0);
  LOBYTE(v8) = 1;
  std::_Mpunct<unsigned short>::_Init(v4);
  LOBYTE(v8) = 0;
  std::_Locinfo::~_Locinfo((std::_Locinfo *)&v6);
  return v3;
}
// 445DBB: using guessed type _DWORD __stdcall std::_Mpunct<unsigned short>::_Init(_DWORD);
// 45FF54: using guessed type int (__stdcall *std::_Mpunct<unsigned short>::`vftable')(char);

//----- (0044743C) --------------------------------------------------------
void __thiscall sub_44743C(void *this)
{
  struct std::locale::facet *v1; // eax@1
  void *v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+Ch] [bp-4h]@1

  v2 = this;
  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  v1 = std::locale::facet::_Decref(dword_481AD4);
  if ( v1 )
    (**(void (__thiscall ***)(struct std::locale::facet *, signed int))v1)(v1, 1);
  dword_481AD4 = 0;
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
}

//----- (00447489) --------------------------------------------------------
void __thiscall sub_447489(void *this)
{
  struct std::locale::facet *v1; // eax@1
  void *v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+Ch] [bp-4h]@1

  v2 = this;
  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  v1 = std::locale::facet::_Decref(dword_481AD8);
  if ( v1 )
    (**(void (__thiscall ***)(struct std::locale::facet *, signed int))v1)(v1, 1);
  dword_481AD8 = 0;
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
}

//----- (004474D6) --------------------------------------------------------
void __thiscall sub_4474D6(void *this)
{
  struct std::locale::facet *v1; // eax@1
  void *v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+Ch] [bp-4h]@1

  v2 = this;
  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  v1 = std::locale::facet::_Decref(dword_481ADC);
  if ( v1 )
    (**(void (__thiscall ***)(struct std::locale::facet *, signed int))v1)(v1, 1);
  dword_481ADC = 0;
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
}

//----- (00447523) --------------------------------------------------------
void __thiscall sub_447523(void *this)
{
  struct std::locale::facet *v1; // eax@1
  void *v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+Ch] [bp-4h]@1

  v2 = this;
  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  v1 = std::locale::facet::_Decref(dword_481AE0);
  if ( v1 )
    (**(void (__thiscall ***)(struct std::locale::facet *, signed int))v1)(v1, 1);
  dword_481AE0 = 0;
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
}

//----- (00447570) --------------------------------------------------------
void __thiscall sub_447570(void *this)
{
  struct std::locale::facet *v1; // eax@1
  void *v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+Ch] [bp-4h]@1

  v2 = this;
  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  v1 = std::locale::facet::_Decref(dword_481AE4);
  if ( v1 )
    (**(void (__thiscall ***)(struct std::locale::facet *, signed int))v1)(v1, 1);
  dword_481AE4 = 0;
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
}

//----- (004475BD) --------------------------------------------------------
void __thiscall sub_4475BD(void *this)
{
  struct std::locale::facet *v1; // eax@1
  void *v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+Ch] [bp-4h]@1

  v2 = this;
  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  v1 = std::locale::facet::_Decref(dword_481AE8);
  if ( v1 )
    (**(void (__thiscall ***)(struct std::locale::facet *, signed int))v1)(v1, 1);
  dword_481AE8 = 0;
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
}

//----- (0044760A) --------------------------------------------------------
void __thiscall sub_44760A(void *this)
{
  struct std::locale::facet *v1; // eax@1
  void *v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+Ch] [bp-4h]@1

  v2 = this;
  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  v1 = std::locale::facet::_Decref(dword_481AEC);
  if ( v1 )
    (**(void (__thiscall ***)(struct std::locale::facet *, signed int))v1)(v1, 1);
  dword_481AEC = 0;
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
}

//----- (00447657) --------------------------------------------------------
void __thiscall sub_447657(void *this)
{
  struct std::locale::facet *v1; // eax@1
  void *v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+Ch] [bp-4h]@1

  v2 = this;
  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  v1 = std::locale::facet::_Decref(dword_481AF0);
  if ( v1 )
    (**(void (__thiscall ***)(struct std::locale::facet *, signed int))v1)(v1, 1);
  dword_481AF0 = 0;
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
}

//----- (004476A4) --------------------------------------------------------
void __thiscall sub_4476A4(void *this)
{
  struct std::locale::facet *v1; // eax@1
  void *v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+Ch] [bp-4h]@1

  v2 = this;
  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  v1 = std::locale::facet::_Decref(dword_481AF4);
  if ( v1 )
    (**(void (__thiscall ***)(struct std::locale::facet *, signed int))v1)(v1, 1);
  dword_481AF4 = 0;
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
}

//----- (004476F1) --------------------------------------------------------
void __thiscall sub_4476F1(void *this)
{
  struct std::locale::facet *v1; // eax@1
  void *v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+Ch] [bp-4h]@1

  v2 = this;
  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  v1 = std::locale::facet::_Decref(dword_481AF8);
  if ( v1 )
    (**(void (__thiscall ***)(struct std::locale::facet *, signed int))v1)(v1, 1);
  dword_481AF8 = 0;
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
}

//----- (0044773E) --------------------------------------------------------
void __thiscall sub_44773E(void *this)
{
  struct std::locale::facet *v1; // eax@1
  void *v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+Ch] [bp-4h]@1

  v2 = this;
  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  v1 = std::locale::facet::_Decref(dword_481AFC);
  if ( v1 )
    (**(void (__thiscall ***)(struct std::locale::facet *, signed int))v1)(v1, 1);
  dword_481AFC = 0;
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
}

//----- (0044778B) --------------------------------------------------------
void __thiscall sub_44778B(void *this)
{
  struct std::locale::facet *v1; // eax@1
  void *v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+Ch] [bp-4h]@1

  v2 = this;
  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  v1 = std::locale::facet::_Decref(dword_481B00);
  if ( v1 )
    (**(void (__thiscall ***)(struct std::locale::facet *, signed int))v1)(v1, 1);
  dword_481B00 = 0;
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
}

//----- (004477D8) --------------------------------------------------------
void __thiscall sub_4477D8(void *this)
{
  struct std::locale::facet *v1; // eax@1
  void *v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+Ch] [bp-4h]@1

  v2 = this;
  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  v1 = std::locale::facet::_Decref(dword_481B04);
  if ( v1 )
    (**(void (__thiscall ***)(struct std::locale::facet *, signed int))v1)(v1, 1);
  dword_481B04 = 0;
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
}

//----- (00447CCC) --------------------------------------------------------
int __stdcall sub_447CCC(int a1, int a2)
{
  return 0;
}

//----- (00447CD1) --------------------------------------------------------
_BYTE *__thiscall sub_447CD1(int this, _BYTE *a2, int a3, int a4, int a5, _BYTE *a6)
{
  const char *v6; // edi@2
  _BYTE *v7; // esi@2
  char v8; // al@2
  size_t v9; // eax@5

  if ( a5 )
  {
    if ( a5 != 1 )
    {
      v7 = a2;
      *a2 = *a6;
      std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(0);
      std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(a6, 0, -1);
      return v7;
    }
    v6 = *(const char **)(this + 12);
    v7 = a2;
    v8 = BYTE3(a2);
  }
  else
  {
    v6 = *(const char **)(this + 8);
    v7 = a2;
    v8 = BYTE3(a2);
  }
  *v7 = v8;
  std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(0);
  v9 = strlen(v6);
  std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign((void *)v6, v9);
  return v7;
}
// 41FF10: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(_DWORD);
// 435960: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(_DWORD, _DWORD, _DWORD);

//----- (00447E73) --------------------------------------------------------
int __stdcall sub_447E73(int a1, int a2, int a3, char a4, int a5, char a6, int a7, _DWORD *a8, int a9)
{
  bool v9; // zf@1
  _DWORD *v10; // eax@1
  char v12; // [sp+4h] [bp-1Ch]@1
  int v13; // [sp+Ch] [bp-14h]@3
  int v14; // [sp+1Ch] [bp-4h]@1

  std::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::_Getmfld(&v12, &a2, &a4, a6, a7);
  v14 = 0;
  v9 = (unsigned __int8)sub_440C62((int)&a2, (int)&a4) == 0;
  v10 = a8;
  if ( !v9 )
    *a8 |= 1u;
  if ( v13 )
    std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(&v12, 0, -1);
  else
    *v10 |= 2u;
  v14 = -1;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(1);
  return a1;
}
// 41FF10: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(_DWORD);
// 435960: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(_DWORD, _DWORD, _DWORD);
// 4487BD: using guessed type _DWORD __stdcall std::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::_Getmfld(_DWORD, _DWORD, _DWORD, char, _DWORD);

//----- (0044813F) --------------------------------------------------------
char __thiscall sub_44813F(int this)
{
  return *(_BYTE *)(this + 12);
}

//----- (00448143) --------------------------------------------------------
char __thiscall sub_448143(int this)
{
  return *(_BYTE *)(this + 13);
}

//----- (004481E9) --------------------------------------------------------
_BYTE *__thiscall sub_4481E9(int this, _BYTE *a2)
{
  const char *v2; // edi@1
  size_t v3; // eax@1

  v2 = *(const char **)(this + 24);
  *a2 = BYTE3(a2);
  std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(0);
  v3 = strlen(v2);
  std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign((void *)v2, v3);
  return a2;
}
// 41FF10: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(_DWORD);

//----- (0044821F) --------------------------------------------------------
int __thiscall sub_44821F(int this)
{
  return *(_DWORD *)(this + 28);
}

//----- (0044823B) --------------------------------------------------------
signed int sub_44823B()
{
  return 2;
}

//----- (004485C0) --------------------------------------------------------
void *__thiscall sub_4485C0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_4485DC(this);
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}

//----- (004485DC) --------------------------------------------------------
void __thiscall sub_4485DC(void *this)
{
  *(_DWORD *)this = &std::locale::facet::`vftable';
}
// 45FBB0: using guessed type int (__stdcall *std::locale::facet::`vftable')(int);

//----- (004485E3) --------------------------------------------------------
void *__thiscall sub_4485E3(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_4485FF((int)this);
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}

//----- (004485FF) --------------------------------------------------------
void __thiscall sub_4485FF(int this)
{
  int v1; // esi@1
  void *v2; // ST04_4@1

  v1 = this;
  v2 = *(void **)(this + 8);
  *(_DWORD *)this = &std::messages<char>::`vftable';
  _delete_table(v2);
  _delete_table(*(LPVOID *)(v1 + 12));
  *(_DWORD *)v1 = &std::locale::facet::`vftable';
}
// 45FBB0: using guessed type int (__stdcall *std::locale::facet::`vftable')(int);
// 46016C: using guessed type int (__stdcall *std::messages<char>::`vftable')(char);

//----- (00448622) --------------------------------------------------------
void *__thiscall sub_448622(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_44863E(this);
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}

//----- (0044863E) --------------------------------------------------------
void __thiscall sub_44863E(void *this)
{
  *(_DWORD *)this = &std::locale::facet::`vftable';
}
// 45FBB0: using guessed type int (__stdcall *std::locale::facet::`vftable')(int);

//----- (00448645) --------------------------------------------------------
void *__thiscall sub_448645(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_448661(this);
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}

//----- (00448661) --------------------------------------------------------
void __thiscall sub_448661(void *this)
{
  *(_DWORD *)this = &std::locale::facet::`vftable';
}
// 45FBB0: using guessed type int (__stdcall *std::locale::facet::`vftable')(int);

//----- (00448668) --------------------------------------------------------
void *__thiscall sub_448668(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_448715();
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}
// 448715: using guessed type int sub_448715(void);

//----- (00448684) --------------------------------------------------------
void *__thiscall sub_448684(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_44876A();
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}
// 44876A: using guessed type int sub_44876A(void);

//----- (004486A0) --------------------------------------------------------
void *__thiscall sub_4486A0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_4486BC((int)this);
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}

//----- (004486BC) --------------------------------------------------------
void __thiscall sub_4486BC(int this)
{
  int v1; // esi@1
  void *v2; // ST04_4@1

  v1 = this;
  v2 = *(void **)(this + 8);
  *(_DWORD *)this = &std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::`vftable';
  _delete_table(v2);
  _delete_table(*(LPVOID *)(v1 + 12));
  *(_DWORD *)v1 = &std::locale::facet::`vftable';
}
// 45FBB0: using guessed type int (__stdcall *std::locale::facet::`vftable')(int);
// 4600D4: using guessed type int (__stdcall *std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::`vftable')(char);

//----- (004486DF) --------------------------------------------------------
void *__thiscall sub_4486DF(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_4486FB((int)this);
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}

//----- (004486FB) --------------------------------------------------------
void __thiscall sub_4486FB(int this)
{
  _DWORD *v1; // esi@1
  void *v2; // ST00_4@1

  v1 = (_DWORD *)this;
  v2 = *(void **)(this + 8);
  *(_DWORD *)this = &std::time_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::`vftable';
  _Free(v2);
  *v1 = &std::locale::facet::`vftable';
}
// 45FBB0: using guessed type int (__stdcall *std::locale::facet::`vftable')(int);
// 4600C8: using guessed type int (__stdcall *std::time_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::`vftable')(char);

//----- (0044871A) --------------------------------------------------------
void __thiscall sub_44871A(int this)
{
  int v1; // esi@1
  void *v2; // ST0C_4@1

  v1 = this;
  v2 = *(void **)(this + 8);
  *(_DWORD *)this = &std::_Mpunct<char>::`vftable';
  _delete_table(v2);
  _delete_table(*(LPVOID *)(v1 + 16));
  _delete_table(*(LPVOID *)(v1 + 20));
  _delete_table(*(LPVOID *)(v1 + 24));
  *(_DWORD *)v1 = &std::locale::facet::`vftable';
}
// 45FBB0: using guessed type int (__stdcall *std::locale::facet::`vftable')(int);
// 460194: using guessed type int (__stdcall *std::_Mpunct<char>::`vftable')(char);

//----- (0044874E) --------------------------------------------------------
void *__thiscall sub_44874E(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_44871A((int)this);
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}

//----- (0044876F) --------------------------------------------------------
int __thiscall sub_44876F(int this, unsigned int a2)
{
  int v2; // edx@1
  int result; // eax@2

  v2 = *(_DWORD *)(this + 8);
  if ( a2 > v2 )
    result = std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(a2 - v2, 0);
  else
    result = std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(a2, -1);
  return result;
}
// 41FE10: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(_DWORD, _DWORD);

//----- (004495DD) --------------------------------------------------------
int __thiscall sub_4495DD(int this, int a2, int a3, char a4)
{
  int v4; // esi@1

  v4 = this;
  *(_DWORD *)(this + 4) = a3;
  *(_BYTE *)(this + 40) = a4;
  *(_DWORD *)this = &std::_Mpunct<char>::`vftable';
  std::_Mpunct<char>::_Init(a2);
  return v4;
}
// 44988A: using guessed type _DWORD __stdcall std::_Mpunct<char>::_Init(_DWORD);
// 460194: using guessed type int (__stdcall *std::_Mpunct<char>::`vftable')(char);

//----- (004499C5) --------------------------------------------------------
const struct std::locale::facet *__cdecl sub_4499C5(std::locale *a1, int a2, int a3)
{
  unsigned int v3; // eax@1
  const struct std::locale::facet *v4; // esi@1
  void *v5; // ecx@5
  std::locale::facet *v6; // eax@6
  int (__stdcall **v8)(int); // [sp+4h] [bp-1Ch]@10
  char v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+1Ch] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v9);
  v10 = 0;
  v3 = std::locale::id::operator unsigned int(&unk_481B24);
  v4 = std::locale::_Getfacet(a1, v3, 1);
  if ( !v4 )
  {
    if ( !(_BYTE)a3 || !std::locale::_Iscloc(a1) )
    {
      a3 = (int)aMissingLocaleF;
      exception::exception(&v8, (const char **)&a3);
      v8 = &std::bad_cast::`vftable';
      _CxxThrowException(&v8, &unk_462ED8);
    }
    v4 = (const struct std::locale::facet *)dword_481B28;
    if ( !dword_481B28 )
    {
      v5 = operator new(0x10u);
      a3 = (int)v5;
      LOBYTE(v10) = 1;
      if ( v5 )
        v6 = (std::locale::facet *)sub_44A02B((int)v5, (int)v4);
      else
        v6 = 0;
      LOBYTE(v10) = 0;
      dword_481B28 = (int)sub_44A1B7(v6);
      v4 = (const struct std::locale::facet *)dword_481B28;
    }
  }
  v10 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v9);
  return v4;
}
// 423460: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 45FD64: using guessed type int (__stdcall *std::bad_cast::`vftable')(int);
// 481B28: using guessed type int dword_481B28;

//----- (00449A89) --------------------------------------------------------
const struct std::locale::facet *__cdecl sub_449A89(std::locale *a1, int a2, int a3)
{
  unsigned int v3; // eax@1
  const struct std::locale::facet *v4; // esi@1
  void *v5; // ecx@5
  std::locale::facet *v6; // eax@6
  int (__stdcall **v8)(int); // [sp+4h] [bp-1Ch]@10
  char v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+1Ch] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v9);
  v10 = 0;
  v3 = std::locale::id::operator unsigned int(&unk_481B18);
  v4 = std::locale::_Getfacet(a1, v3, 1);
  if ( !v4 )
  {
    if ( !(_BYTE)a3 || !std::locale::_Iscloc(a1) )
    {
      a3 = (int)aMissingLocaleF;
      exception::exception(&v8, (const char **)&a3);
      v8 = &std::bad_cast::`vftable';
      _CxxThrowException(&v8, &unk_462ED8);
    }
    v4 = (const struct std::locale::facet *)dword_481B2C;
    if ( !dword_481B2C )
    {
      v5 = operator new(0x10u);
      a3 = (int)v5;
      LOBYTE(v10) = 1;
      if ( v5 )
        v6 = (std::locale::facet *)sub_44A07F((int)v5, (int)v4);
      else
        v6 = 0;
      LOBYTE(v10) = 0;
      dword_481B2C = (int)sub_44A205(v6);
      v4 = (const struct std::locale::facet *)dword_481B2C;
    }
  }
  v10 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v9);
  return v4;
}
// 423460: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 45FD64: using guessed type int (__stdcall *std::bad_cast::`vftable')(int);
// 481B2C: using guessed type int dword_481B2C;

//----- (00449B4D) --------------------------------------------------------
const struct std::locale::facet *__cdecl sub_449B4D(std::locale *a1, int a2, int a3)
{
  unsigned int v3; // eax@1
  const struct std::locale::facet *v4; // esi@1
  std::locale::facet *v5; // eax@4
  std::locale::facet *v6; // eax@5
  std::locale::facet *v7; // esi@5
  char v9; // [sp+4h] [bp-5Ch]@6
  int (__stdcall **v10)(int); // [sp+44h] [bp-1Ch]@11
  char v11; // [sp+50h] [bp-10h]@1
  int v12; // [sp+5Ch] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v11);
  v12 = 0;
  v3 = std::locale::id::operator unsigned int(&unk_481B20);
  v4 = std::locale::_Getfacet(a1, v3, 1);
  if ( !v4 )
  {
    if ( !(_BYTE)a3 || !std::locale::_Iscloc(a1) )
    {
      a3 = (int)aMissingLocaleF;
      exception::exception(&v10, (const char **)&a3);
      v10 = &std::bad_cast::`vftable';
      _CxxThrowException(&v10, &unk_462ED8);
    }
    v5 = (std::locale::facet *)dword_481B30;
    if ( !dword_481B30 )
    {
      v6 = (std::locale::facet *)operator new(8u);
      v7 = v6;
      a3 = (int)v6;
      if ( v6 )
      {
        *((_DWORD *)v6 + 1) = 0;
        LOBYTE(v12) = 2;
        *(_DWORD *)v6 = &std::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::`vftable';
        std::_Locinfo::_Locinfo((std::_Locinfo *)&v9, aC_0);
        std::_Locinfo::~_Locinfo((std::_Locinfo *)&v9);
      }
      else
      {
        v7 = 0;
      }
      LOBYTE(v12) = 0;
      v5 = sub_44A253(v7);
      dword_481B30 = (int)v5;
    }
    v4 = v5;
  }
  v12 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v4;
}
// 423460: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 45FD64: using guessed type int (__stdcall *std::bad_cast::`vftable')(int);
// 46015C: using guessed type int (__stdcall *std::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::`vftable')(char);
// 481B30: using guessed type int dword_481B30;

//----- (00449C29) --------------------------------------------------------
const struct std::locale::facet *__cdecl sub_449C29(std::locale *a1, int a2, int a3)
{
  unsigned int v3; // eax@1
  const struct std::locale::facet *v4; // esi@1
  std::locale::facet *v5; // eax@4
  std::locale::facet *v6; // eax@5
  std::locale::facet *v7; // esi@5
  char v9; // [sp+4h] [bp-5Ch]@6
  int (__stdcall **v10)(int); // [sp+44h] [bp-1Ch]@11
  char v11; // [sp+50h] [bp-10h]@1
  int v12; // [sp+5Ch] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v11);
  v12 = 0;
  v3 = std::locale::id::operator unsigned int(&unk_481B08);
  v4 = std::locale::_Getfacet(a1, v3, 1);
  if ( !v4 )
  {
    if ( !(_BYTE)a3 || !std::locale::_Iscloc(a1) )
    {
      a3 = (int)aMissingLocaleF;
      exception::exception(&v10, (const char **)&a3);
      v10 = &std::bad_cast::`vftable';
      _CxxThrowException(&v10, &unk_462ED8);
    }
    v5 = (std::locale::facet *)dword_481B34;
    if ( !dword_481B34 )
    {
      v6 = (std::locale::facet *)operator new(8u);
      v7 = v6;
      a3 = (int)v6;
      if ( v6 )
      {
        *((_DWORD *)v6 + 1) = 0;
        LOBYTE(v12) = 2;
        *(_DWORD *)v6 = &std::money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::`vftable';
        std::_Locinfo::_Locinfo((std::_Locinfo *)&v9, aC_0);
        std::_Locinfo::~_Locinfo((std::_Locinfo *)&v9);
      }
      else
      {
        v7 = 0;
      }
      LOBYTE(v12) = 0;
      v5 = sub_44A2A1(v7);
      dword_481B34 = (int)v5;
    }
    v4 = v5;
  }
  v12 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v4;
}
// 423460: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 45FD64: using guessed type int (__stdcall *std::bad_cast::`vftable')(int);
// 46014C: using guessed type int (__stdcall *std::money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::`vftable')(char);
// 481B34: using guessed type int dword_481B34;

//----- (00449D05) --------------------------------------------------------
const struct std::locale::facet *__cdecl sub_449D05(std::locale *a1, int a2, int a3)
{
  unsigned int v3; // eax@1
  const struct std::locale::facet *v4; // esi@1
  std::locale::facet *v5; // eax@5
  std::locale::facet *v6; // esi@5
  int (__stdcall **v8)(int); // [sp+8h] [bp-1Ch]@10
  char v9; // [sp+14h] [bp-10h]@1
  int v10; // [sp+20h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v9);
  v10 = 0;
  v3 = std::locale::id::operator unsigned int(&unk_481B1C);
  v4 = std::locale::_Getfacet(a1, v3, 1);
  if ( !v4 )
  {
    if ( !(_BYTE)a3 || !std::locale::_Iscloc(a1) )
    {
      a3 = (int)aMissingLocaleF;
      exception::exception(&v8, (const char **)&a3);
      v8 = &std::bad_cast::`vftable';
      _CxxThrowException(&v8, &unk_462ED8);
    }
    v4 = (const struct std::locale::facet *)dword_481B38;
    if ( !dword_481B38 )
    {
      v5 = (std::locale::facet *)operator new(0x2Cu);
      v6 = v5;
      a3 = (int)v5;
      LOBYTE(v10) = 1;
      if ( v5 )
      {
        sub_44A427((int)v5, 0, 0);
        *(_DWORD *)v6 = &std::moneypunct<char,0>::`vftable';
      }
      else
      {
        v6 = 0;
      }
      LOBYTE(v10) = 0;
      dword_481B38 = (int)sub_44A2EF(v6);
      v4 = (const struct std::locale::facet *)dword_481B38;
    }
  }
  v10 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v9);
  return v4;
}
// 423460: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 45FD64: using guessed type int (__stdcall *std::bad_cast::`vftable')(int);
// 460120: using guessed type int (__stdcall *std::moneypunct<char,0>::`vftable')(char);
// 481B38: using guessed type int dword_481B38;

//----- (00449DD4) --------------------------------------------------------
const struct std::locale::facet *__cdecl sub_449DD4(std::locale *a1, int a2, int a3)
{
  unsigned int v3; // eax@1
  const struct std::locale::facet *v4; // esi@1
  std::locale::facet *v5; // eax@5
  std::locale::facet *v6; // esi@5
  int (__stdcall **v8)(int); // [sp+4h] [bp-1Ch]@10
  char v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+1Ch] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v9);
  v10 = 0;
  v3 = std::locale::id::operator unsigned int(&unk_481B0C);
  v4 = std::locale::_Getfacet(a1, v3, 1);
  if ( !v4 )
  {
    if ( !(_BYTE)a3 || !std::locale::_Iscloc(a1) )
    {
      a3 = (int)aMissingLocaleF;
      exception::exception(&v8, (const char **)&a3);
      v8 = &std::bad_cast::`vftable';
      _CxxThrowException(&v8, &unk_462ED8);
    }
    v4 = (const struct std::locale::facet *)dword_481B3C;
    if ( !dword_481B3C )
    {
      v5 = (std::locale::facet *)operator new(0x2Cu);
      v6 = v5;
      a3 = (int)v5;
      LOBYTE(v10) = 1;
      if ( v5 )
      {
        sub_44A427((int)v5, 0, 1);
        *(_DWORD *)v6 = &std::moneypunct<char,1>::`vftable';
      }
      else
      {
        v6 = 0;
      }
      LOBYTE(v10) = 0;
      dword_481B3C = (int)sub_44A33D(v6);
      v4 = (const struct std::locale::facet *)dword_481B3C;
    }
  }
  v10 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v9);
  return v4;
}
// 423460: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 45FD64: using guessed type int (__stdcall *std::bad_cast::`vftable')(int);
// 4600F4: using guessed type int (__stdcall *std::moneypunct<char,1>::`vftable')(char);
// 481B3C: using guessed type int dword_481B3C;

//----- (00449EA3) --------------------------------------------------------
const struct std::locale::facet *__cdecl sub_449EA3(std::locale *a1, int a2, int a3)
{
  unsigned int v3; // eax@1
  const struct std::locale::facet *v4; // esi@1
  void *v5; // ecx@5
  std::locale::facet *v6; // eax@6
  int (__stdcall **v8)(int); // [sp+4h] [bp-1Ch]@10
  char v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+1Ch] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v9);
  v10 = 0;
  v3 = std::locale::id::operator unsigned int(&unk_481B10);
  v4 = std::locale::_Getfacet(a1, v3, 1);
  if ( !v4 )
  {
    if ( !(_BYTE)a3 || !std::locale::_Iscloc(a1) )
    {
      a3 = (int)aMissingLocaleF;
      exception::exception(&v8, (const char **)&a3);
      v8 = &std::bad_cast::`vftable';
      _CxxThrowException(&v8, &unk_462ED8);
    }
    v4 = (const struct std::locale::facet *)dword_481B40;
    if ( !dword_481B40 )
    {
      v5 = operator new(0x10u);
      a3 = (int)v5;
      LOBYTE(v10) = 1;
      if ( v5 )
        v6 = (std::locale::facet *)sub_44A0F1((int)v5, (int)v4);
      else
        v6 = 0;
      LOBYTE(v10) = 0;
      dword_481B40 = (int)sub_44A38B(v6);
      v4 = (const struct std::locale::facet *)dword_481B40;
    }
  }
  v10 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v9);
  return v4;
}
// 423460: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 45FD64: using guessed type int (__stdcall *std::bad_cast::`vftable')(int);
// 481B40: using guessed type int dword_481B40;

//----- (00449F67) --------------------------------------------------------
const struct std::locale::facet *__cdecl sub_449F67(std::locale *a1, int a2, int a3)
{
  unsigned int v3; // eax@1
  const struct std::locale::facet *v4; // esi@1
  void *v5; // ecx@5
  std::locale::facet *v6; // eax@6
  int (__stdcall **v8)(int); // [sp+4h] [bp-1Ch]@10
  char v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+1Ch] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v9);
  v10 = 0;
  v3 = std::locale::id::operator unsigned int(&unk_481B14);
  v4 = std::locale::_Getfacet(a1, v3, 1);
  if ( !v4 )
  {
    if ( !(_BYTE)a3 || !std::locale::_Iscloc(a1) )
    {
      a3 = (int)aMissingLocaleF;
      exception::exception(&v8, (const char **)&a3);
      v8 = &std::bad_cast::`vftable';
      _CxxThrowException(&v8, &unk_462ED8);
    }
    v4 = (const struct std::locale::facet *)dword_481B44;
    if ( !dword_481B44 )
    {
      v5 = operator new(0xCu);
      a3 = (int)v5;
      LOBYTE(v10) = 1;
      if ( v5 )
        v6 = (std::locale::facet *)sub_44A14A((int)v5, (LPVOID)v4);
      else
        v6 = 0;
      LOBYTE(v10) = 0;
      dword_481B44 = (int)sub_44A3D9(v6);
      v4 = (const struct std::locale::facet *)dword_481B44;
    }
  }
  v10 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v9);
  return v4;
}
// 423460: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 44DD82: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 45FD64: using guessed type int (__stdcall *std::bad_cast::`vftable')(int);
// 481B44: using guessed type int dword_481B44;

//----- (0044A02B) --------------------------------------------------------
int __thiscall sub_44A02B(int this, int a2)
{
  int v2; // esi@1
  int v3; // edx@1
  char v5; // [sp+4h] [bp-50h]@1
  int v6; // [sp+44h] [bp-10h]@1
  int v7; // [sp+50h] [bp-4h]@1

  v2 = this;
  v6 = this;
  *(_DWORD *)(this + 4) = a2;
  v7 = 0;
  *(_DWORD *)this = &std::collate<char>::`vftable';
  std::_Locinfo::_Locinfo((std::_Locinfo *)&v5, aC_0);
  *(_DWORD *)(v2 + 8) = sub_44A86E();
  *(_DWORD *)(v2 + 12) = v3;
  std::_Locinfo::~_Locinfo((std::_Locinfo *)&v5);
  return v2;
}
// 460180: using guessed type int (__stdcall *std::collate<char>::`vftable')(char);

//----- (0044A07F) --------------------------------------------------------
int __thiscall sub_44A07F(int this, int a2)
{
  int v2; // esi@1
  char *v3; // eax@1
  char v5; // [sp+4h] [bp-50h]@1
  int v6; // [sp+44h] [bp-10h]@1
  int v7; // [sp+50h] [bp-4h]@1

  v2 = this;
  v6 = this;
  *(_DWORD *)(this + 4) = a2;
  v7 = 0;
  *(_DWORD *)this = &std::messages<char>::`vftable';
  std::_Locinfo::_Locinfo((std::_Locinfo *)&v5, aC_0);
  LOBYTE(v7) = 1;
  *(_DWORD *)(v2 + 8) = std::_Maklocstr("no", 0);
  v3 = std::_Maklocstr("yes", 0);
  LOBYTE(v7) = 0;
  *(_DWORD *)(v2 + 12) = v3;
  std::_Locinfo::~_Locinfo((std::_Locinfo *)&v5);
  return v2;
}
// 46016C: using guessed type int (__stdcall *std::messages<char>::`vftable')(char);

//----- (0044A0F1) --------------------------------------------------------
int __thiscall sub_44A0F1(int this, int a2)
{
  int v2; // esi@1
  std::_Locinfo *v3; // eax@1
  char v5; // [sp+4h] [bp-50h]@1
  int v6; // [sp+44h] [bp-10h]@1
  int v7; // [sp+50h] [bp-4h]@1

  v2 = this;
  v6 = this;
  *(_DWORD *)(this + 4) = a2;
  v7 = 0;
  *(_DWORD *)this = &std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::`vftable';
  v3 = (std::_Locinfo *)std::_Locinfo::_Locinfo((std::_Locinfo *)&v5, aC_0);
  LOBYTE(v7) = 1;
  std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::_Init(v3);
  LOBYTE(v7) = 0;
  std::_Locinfo::~_Locinfo((std::_Locinfo *)&v5);
  return v2;
}
// 4600D4: using guessed type int (__stdcall *std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::`vftable')(char);

//----- (0044A14A) --------------------------------------------------------
int __thiscall sub_44A14A(int this, LPVOID lpMem)
{
  int v2; // esi@1
  int v3; // eax@1
  _DWORD *v4; // eax@1
  char v6; // [sp+4h] [bp-50h]@1
  int v7; // [sp+44h] [bp-10h]@1
  int v8; // [sp+50h] [bp-4h]@1

  v2 = this;
  v7 = this;
  *(_DWORD *)(this + 4) = lpMem;
  v8 = 0;
  *(_DWORD *)(this + 8) = 0;
  LOBYTE(v8) = 1;
  *(_DWORD *)this = &std::time_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::`vftable';
  v3 = std::_Locinfo::_Locinfo((std::_Locinfo *)&v6, aC_0);
  v4 = (_DWORD *)std::_Locinfo::_Gettnames(v3, &lpMem);
  *(_DWORD *)(v2 + 8) = *v4;
  *v4 = 0;
  _Free(lpMem);
  std::_Locinfo::~_Locinfo((std::_Locinfo *)&v6);
  return v2;
}
// 4438F7: using guessed type int __thiscall std::_Locinfo::_Gettnames(_DWORD, _DWORD);
// 4600C8: using guessed type int (__stdcall *std::time_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::`vftable')(char);

//----- (0044A1B7) --------------------------------------------------------
std::locale::facet *__cdecl sub_44A1B7(std::locale::facet *a1)
{
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+10h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  dword_481B48 = a1;
  std::locale::facet::_Incref(a1);
  atexit((void (__cdecl *)())sub_44A486);
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
  return a1;
}

//----- (0044A205) --------------------------------------------------------
std::locale::facet *__cdecl sub_44A205(std::locale::facet *a1)
{
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+10h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  dword_481B4C = a1;
  std::locale::facet::_Incref(a1);
  atexit((void (__cdecl *)())sub_44A4D3);
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
  return a1;
}

//----- (0044A253) --------------------------------------------------------
std::locale::facet *__cdecl sub_44A253(std::locale::facet *a1)
{
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+10h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  dword_481B50 = a1;
  std::locale::facet::_Incref(a1);
  atexit((void (__cdecl *)())sub_44A520);
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
  return a1;
}

//----- (0044A2A1) --------------------------------------------------------
std::locale::facet *__cdecl sub_44A2A1(std::locale::facet *a1)
{
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+10h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  dword_481B54 = a1;
  std::locale::facet::_Incref(a1);
  atexit((void (__cdecl *)())sub_44A56D);
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
  return a1;
}

//----- (0044A2EF) --------------------------------------------------------
std::locale::facet *__cdecl sub_44A2EF(std::locale::facet *a1)
{
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+10h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  dword_481B58 = a1;
  std::locale::facet::_Incref(a1);
  atexit((void (__cdecl *)())sub_44A5BA);
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
  return a1;
}

//----- (0044A33D) --------------------------------------------------------
std::locale::facet *__cdecl sub_44A33D(std::locale::facet *a1)
{
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+10h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  dword_481B5C = a1;
  std::locale::facet::_Incref(a1);
  atexit((void (__cdecl *)())sub_44A607);
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
  return a1;
}

//----- (0044A38B) --------------------------------------------------------
std::locale::facet *__cdecl sub_44A38B(std::locale::facet *a1)
{
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+10h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  dword_481B60 = a1;
  std::locale::facet::_Incref(a1);
  atexit((void (__cdecl *)())sub_44A654);
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
  return a1;
}

//----- (0044A3D9) --------------------------------------------------------
std::locale::facet *__cdecl sub_44A3D9(std::locale::facet *a1)
{
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+10h] [bp-4h]@1

  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  dword_481B64 = a1;
  std::locale::facet::_Incref(a1);
  atexit((void (__cdecl *)())sub_44A6A1);
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
  return a1;
}

//----- (0044A427) --------------------------------------------------------
int __thiscall sub_44A427(int this, int a2, char a3)
{
  int v3; // esi@1
  int v4; // eax@1
  char v6; // [sp+4h] [bp-50h]@1
  int v7; // [sp+44h] [bp-10h]@1
  int v8; // [sp+50h] [bp-4h]@1

  v3 = this;
  v7 = this;
  *(_DWORD *)(this + 4) = a2;
  v8 = 0;
  *(_BYTE *)(this + 40) = a3;
  *(_DWORD *)this = &std::_Mpunct<char>::`vftable';
  v4 = std::_Locinfo::_Locinfo((std::_Locinfo *)&v6, aC_0);
  LOBYTE(v8) = 1;
  std::_Mpunct<char>::_Init(v4);
  LOBYTE(v8) = 0;
  std::_Locinfo::~_Locinfo((std::_Locinfo *)&v6);
  return v3;
}
// 44988A: using guessed type _DWORD __stdcall std::_Mpunct<char>::_Init(_DWORD);
// 460194: using guessed type int (__stdcall *std::_Mpunct<char>::`vftable')(char);

//----- (0044A486) --------------------------------------------------------
void __thiscall sub_44A486(void *this)
{
  struct std::locale::facet *v1; // eax@1
  void *v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+Ch] [bp-4h]@1

  v2 = this;
  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  v1 = std::locale::facet::_Decref(dword_481B48);
  if ( v1 )
    (**(void (__thiscall ***)(struct std::locale::facet *, signed int))v1)(v1, 1);
  dword_481B48 = 0;
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
}

//----- (0044A4D3) --------------------------------------------------------
void __thiscall sub_44A4D3(void *this)
{
  struct std::locale::facet *v1; // eax@1
  void *v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+Ch] [bp-4h]@1

  v2 = this;
  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  v1 = std::locale::facet::_Decref(dword_481B4C);
  if ( v1 )
    (**(void (__thiscall ***)(struct std::locale::facet *, signed int))v1)(v1, 1);
  dword_481B4C = 0;
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
}

//----- (0044A520) --------------------------------------------------------
void __thiscall sub_44A520(void *this)
{
  struct std::locale::facet *v1; // eax@1
  void *v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+Ch] [bp-4h]@1

  v2 = this;
  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  v1 = std::locale::facet::_Decref(dword_481B50);
  if ( v1 )
    (**(void (__thiscall ***)(struct std::locale::facet *, signed int))v1)(v1, 1);
  dword_481B50 = 0;
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
}

//----- (0044A56D) --------------------------------------------------------
void __thiscall sub_44A56D(void *this)
{
  struct std::locale::facet *v1; // eax@1
  void *v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+Ch] [bp-4h]@1

  v2 = this;
  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  v1 = std::locale::facet::_Decref(dword_481B54);
  if ( v1 )
    (**(void (__thiscall ***)(struct std::locale::facet *, signed int))v1)(v1, 1);
  dword_481B54 = 0;
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
}

//----- (0044A5BA) --------------------------------------------------------
void __thiscall sub_44A5BA(void *this)
{
  struct std::locale::facet *v1; // eax@1
  void *v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+Ch] [bp-4h]@1

  v2 = this;
  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  v1 = std::locale::facet::_Decref(dword_481B58);
  if ( v1 )
    (**(void (__thiscall ***)(struct std::locale::facet *, signed int))v1)(v1, 1);
  dword_481B58 = 0;
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
}

//----- (0044A607) --------------------------------------------------------
void __thiscall sub_44A607(void *this)
{
  struct std::locale::facet *v1; // eax@1
  void *v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+Ch] [bp-4h]@1

  v2 = this;
  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  v1 = std::locale::facet::_Decref(dword_481B5C);
  if ( v1 )
    (**(void (__thiscall ***)(struct std::locale::facet *, signed int))v1)(v1, 1);
  dword_481B5C = 0;
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
}

//----- (0044A654) --------------------------------------------------------
void __thiscall sub_44A654(void *this)
{
  struct std::locale::facet *v1; // eax@1
  void *v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+Ch] [bp-4h]@1

  v2 = this;
  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  v1 = std::locale::facet::_Decref(dword_481B60);
  if ( v1 )
    (**(void (__thiscall ***)(struct std::locale::facet *, signed int))v1)(v1, 1);
  dword_481B60 = 0;
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
}

//----- (0044A6A1) --------------------------------------------------------
void __thiscall sub_44A6A1(void *this)
{
  struct std::locale::facet *v1; // eax@1
  void *v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+Ch] [bp-4h]@1

  v2 = this;
  std::_Lockit::_Lockit((std::_Lockit *)&v2);
  v3 = 0;
  v1 = std::locale::facet::_Decref(dword_481B64);
  if ( v1 )
    (**(void (__thiscall ***)(struct std::locale::facet *, signed int))v1)(v1, 1);
  dword_481B64 = 0;
  v3 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v2);
}

//----- (0044A74B) --------------------------------------------------------
double __cdecl sub_44A74B(char *a1, char **a2, __int32 a3)
{
  return _Stod(a1, a2, a3);
}

//----- (0044A86E) --------------------------------------------------------
LCID sub_44A86E()
{
  signed int v0; // eax@1
  LCID v1; // ebx@3

  InterlockedIncrement(&dword_4832D8);
  v0 = 0;
  if ( dword_4832D4 )
  {
    InterlockedDecrement(&dword_4832D8);
    _lock(19);
    v0 = 1;
  }
  v1 = dword_481C5C;
  if ( v0 )
    _unlock(19);
  else
    InterlockedDecrement(&dword_4832D8);
  return v1;
}
// 44F483: using guessed type _DWORD __cdecl _lock(_DWORD);
// 44F4E4: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 4832D4: using guessed type int dword_4832D4;

//----- (0044BDA0) --------------------------------------------------------
void __cdecl _Free(LPVOID lpMem)
{
  char *v1; // eax@3
  bool v2; // zf@5
  _BYTE *v3; // eax@7
  int v4; // [sp+Ch] [bp-28h]@7
  _BYTE *v5; // [sp+10h] [bp-24h]@7
  int v6; // [sp+14h] [bp-20h]@7
  char *v7; // [sp+18h] [bp-1Ch]@3
  CPPEH_RECORD ms_exc; // [sp+1Ch] [bp-18h]@3

  if ( lpMem )
  {
    if ( dword_4832C8 == 3 )
    {
      _lock(9);
      ms_exc.registration.TryLevel = 0;
      v1 = __sbh_find_block((int)lpMem);
      v7 = v1;
      if ( v1 )
        sub_452FA5((unsigned int)v1, (int)lpMem);
      ms_exc.registration.TryLevel = -1;
      _unlock(9);
      v2 = v7 == 0;
    }
    else
    {
      if ( dword_4832C8 != 2 )
      {
        HeapFree(hHeap, 0, lpMem);
        return;
      }
      _lock(9);
      ms_exc.registration.TryLevel = 1;
      v3 = (_BYTE *)sub_4540F7((unsigned int)lpMem, (void ***)&v4, (unsigned int *)&v6);
      v5 = v3;
      if ( v3 )
        sub_45414E(v4, v6, v3);
      ms_exc.registration.TryLevel = -1;
      _unlock(9);
      v2 = v5 == 0;
    }
    if ( v2 )
      HeapFree(hHeap, 0, lpMem);
  }
}
// 44F483: using guessed type _DWORD __cdecl _lock(_DWORD);
// 44F4E4: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 4832C8: using guessed type int dword_4832C8;

//----- (0044BEC7) --------------------------------------------------------
LPVOID __cdecl sub_44BEC7(unsigned int a1)
{
  void *v1; // ST18_4@3
  LPVOID result; // eax@3
  unsigned int v3; // esi@7
  char *v4; // ST18_4@10
  unsigned int v5; // eax@12
  SIZE_T v6; // eax@14

  if ( dword_4832C8 == 3 )
  {
    if ( a1 <= dword_4832C0 )
    {
      _lock(9);
      v1 = (void *)__sbh_alloc_block(a1);
      _unlock(9);
      result = v1;
      if ( v1 )
        return result;
    }
    goto LABEL_12;
  }
  if ( dword_4832C8 != 2 )
  {
LABEL_12:
    v5 = a1;
    if ( !a1 )
      v5 = 1;
    v6 = v5 + 15;
    LOBYTE(v6) = v6 & 0xF0;
    return HeapAlloc(hHeap, 0, v6);
  }
  if ( a1 )
    v3 = (a1 + 15) & 0xFFFFFFF0;
  else
    v3 = 16;
  if ( v3 > dword_47149C || (_lock(9), v4 = sub_454193(v3 >> 4), _unlock(9), (result = v4) == 0) )
    result = HeapAlloc(hHeap, 0, v3);
  return result;
}
// 44F483: using guessed type _DWORD __cdecl _lock(_DWORD);
// 44F4E4: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 4532CE: using guessed type _DWORD __cdecl __sbh_alloc_block(_DWORD);
// 47149C: using guessed type int dword_47149C;
// 4832C0: using guessed type int dword_4832C0;
// 4832C8: using guessed type int dword_4832C8;

//----- (0044D37C) --------------------------------------------------------
void __noreturn pure_call()
{
  _amsg_exit(0x19u);
}

//----- (0044D601) --------------------------------------------------------
size_t __cdecl sub_44D601(void *a1, size_t a2, size_t a3, FILE *a4)
{
  size_t v4; // esi@1

  _lock_file(a4);
  v4 = fwrite(a1, a2, a3, a4);
  _unlock_file(a4);
  return v4;
}
// 455ED8: using guessed type _DWORD __cdecl _lock_file(_DWORD);
// 455F2A: using guessed type _DWORD __cdecl _unlock_file(_DWORD);

//----- (0044D9D1) --------------------------------------------------------
int sub_44D9D1()
{
  return flsall(1);
}
// 44D9DA: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (0044DBEE) --------------------------------------------------------
void *__thiscall sub_44DBEE(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_44DCB0((int)this);
  if ( a2 & 1 )
    _delete_table(v2);
  return v2;
}

//----- (0044DCB0) --------------------------------------------------------
void __thiscall sub_44DCB0(int this)
{
  bool v1; // zf@1

  v1 = *(_DWORD *)(this + 8) == 0;
  *(_DWORD *)this = &exception::`vftable';
  if ( !v1 )
    _delete_table(*(LPVOID *)(this + 4));
}
// 460258: using guessed type int (__stdcall *exception::`vftable')(char);

//----- (0044EE45) --------------------------------------------------------
int sub_44EE45()
{
  return 0;
}

//----- (0044EF8C) --------------------------------------------------------
void *__cdecl sub_44EF8C(LPVOID lpMem, SIZE_T dwBytes)
{
  const void *v2; // ebx@1
  void *result; // eax@2
  unsigned int v4; // esi@3
  char *v5; // eax@7
  size_t v6; // eax@12
  size_t v7; // eax@19
  _BYTE *v8; // eax@36
  _BYTE *v9; // edi@36
  size_t v10; // eax@41
  size_t v11; // eax@47
  int v12; // [sp+Ch] [bp-38h]@36
  size_t v13; // [sp+10h] [bp-34h]@41
  _BYTE *v14; // [sp+14h] [bp-30h]@36
  int v15; // [sp+18h] [bp-2Ch]@36
  char *v16; // [sp+1Ch] [bp-28h]@7
  void *v17; // [sp+20h] [bp-24h]@6
  size_t v18; // [sp+24h] [bp-20h]@12
  CPPEH_RECORD ms_exc; // [sp+2Ch] [bp-18h]@7

  v2 = lpMem;
  if ( lpMem )
  {
    v4 = dwBytes;
    if ( dwBytes )
    {
      if ( dword_4832C8 == 3 )
      {
        while ( 1 )
        {
          v17 = 0;
          if ( v4 <= 0xFFFFFFE0 )
          {
            _lock(9);
            ms_exc.registration.TryLevel = 0;
            v5 = __sbh_find_block((int)lpMem);
            v16 = v5;
            if ( v5 )
            {
              if ( v4 <= dword_4832C0 )
              {
                if ( __sbh_resize_block(v5, lpMem, v4) )
                {
                  v17 = lpMem;
                }
                else
                {
                  v17 = (void *)__sbh_alloc_block(v4);
                  if ( v17 )
                  {
                    v6 = *((_DWORD *)lpMem - 1) - 1;
                    v18 = v6;
                    if ( v6 >= v4 )
                      v6 = v4;
                    memcpy(v17, lpMem, v6);
                    v16 = __sbh_find_block((int)lpMem);
                    sub_452FA5((unsigned int)v16, (int)lpMem);
                  }
                }
              }
              if ( !v17 )
              {
                if ( !v4 )
                  v4 = 1;
                v4 = (v4 + 15) & 0xFFFFFFF0;
                v17 = HeapAlloc(hHeap, 0, v4);
                if ( v17 )
                {
                  v7 = *((_DWORD *)lpMem - 1) - 1;
                  v18 = v7;
                  if ( v7 >= v4 )
                    v7 = v4;
                  memcpy(v17, lpMem, v7);
                  sub_452FA5((unsigned int)v16, (int)lpMem);
                }
              }
            }
            ms_exc.registration.TryLevel = -1;
            _unlock(9);
            if ( !v16 )
            {
              if ( !v4 )
                v4 = 1;
              v4 = (v4 + 15) & 0xFFFFFFF0;
              v17 = HeapReAlloc(hHeap, 0, lpMem, v4);
            }
          }
          result = v17;
          if ( v17 || !dword_481D68 )
            break;
          if ( !_callnewh(v4) )
            goto LABEL_63;
        }
      }
      else if ( dword_4832C8 == 2 )
      {
        if ( dwBytes <= 0xFFFFFFE0 )
        {
          if ( dwBytes <= 0 )
            v4 = 16;
          else
            v4 = (dwBytes + 15) & 0xFFFFFFF0;
        }
        while ( 1 )
        {
          v17 = 0;
          if ( v4 <= 0xFFFFFFE0 )
          {
            _lock(9);
            ms_exc.registration.TryLevel = 1;
            v8 = (_BYTE *)sub_4540F7((unsigned int)v2, (void ***)&v12, (unsigned int *)&v15);
            v9 = v8;
            v14 = v8;
            if ( v8 )
            {
              if ( v4 < dword_47149C )
              {
                if ( sub_4544BF(v12, v15, v8, v4 >> 4) )
                {
                  v17 = lpMem;
                }
                else
                {
                  v17 = sub_454193(v4 >> 4);
                  if ( v17 )
                  {
                    v10 = 16 * *v9;
                    v13 = v10;
                    if ( v10 >= v4 )
                      v10 = v4;
                    memcpy(v17, lpMem, v10);
                    sub_45414E(v12, v15, v9);
                  }
                }
                v2 = lpMem;
              }
              if ( !v17 )
              {
                v17 = HeapAlloc(hHeap, 0, v4);
                if ( v17 )
                {
                  v11 = 16 * *v9;
                  v13 = v11;
                  if ( v11 >= v4 )
                    v11 = v4;
                  memcpy(v17, v2, v11);
                  sub_45414E(v12, v15, v9);
                }
              }
            }
            else
            {
              v17 = HeapReAlloc(hHeap, 0, (LPVOID)v2, v4);
            }
            ms_exc.registration.TryLevel = -1;
            _unlock(9);
          }
          result = v17;
          if ( v17 || !dword_481D68 )
            break;
          if ( !_callnewh(v4) )
            goto LABEL_63;
        }
      }
      else
      {
        while ( 1 )
        {
          result = 0;
          if ( v4 <= 0xFFFFFFE0 )
          {
            if ( !v4 )
              v4 = 1;
            v4 = (v4 + 15) & 0xFFFFFFF0;
            result = HeapReAlloc(hHeap, 0, lpMem, v4);
          }
          if ( result || !dword_481D68 )
            break;
          if ( !_callnewh(v4) )
            goto LABEL_63;
        }
      }
    }
    else
    {
      _Free(lpMem);
LABEL_63:
      result = 0;
    }
  }
  else
  {
    result = malloc(dwBytes);
  }
  return result;
}
// 44F483: using guessed type _DWORD __cdecl _lock(_DWORD);
// 44F4E4: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 4532CE: using guessed type _DWORD __cdecl __sbh_alloc_block(_DWORD);
// 453783: using guessed type _DWORD __cdecl __sbh_resize_block(_DWORD, _DWORD, _DWORD);
// 4546F0: using guessed type _DWORD __cdecl _callnewh(_DWORD);
// 47149C: using guessed type int dword_47149C;
// 481D68: using guessed type int dword_481D68;
// 4832C0: using guessed type int dword_4832C0;
// 4832C8: using guessed type int dword_4832C8;

//----- (0044F3A0) --------------------------------------------------------
void **sub_44F3A0()
{
  return off_46F018;
}
// 46F018: using guessed type void **off_46F018;

//----- (0044FB46) --------------------------------------------------------
unsigned int __cdecl sub_44FB46(unsigned __int8 *a1, unsigned int a2, unsigned __int8 *a3, int a4, void *a5)
{
  void *v5; // eax@4
  unsigned __int8 *v6; // esi@7
  unsigned __int8 v7; // al@8
  char *v8; // esi@14
  unsigned int result; // eax@22
  signed int v10; // [sp+Ch] [bp-8h]@2
  unsigned int v11; // [sp+10h] [bp-4h]@1

  v11 = a2;
  InterlockedIncrement(&dword_4832D8);
  if ( dword_4832D4 )
  {
    InterlockedDecrement(&dword_4832D8);
    _lock(19);
    v10 = 1;
  }
  else
  {
    v10 = 0;
  }
  v5 = a5;
  if ( !a5 )
    v5 = off_46F2F8;
  a5 = v5;
  if ( v11 > 0 )
  {
    v6 = a3;
    do
    {
      v7 = *v6;
      if ( !*v6 )
        break;
      if ( v7 == 37 )
      {
        dword_4832CC = 0;
        v8 = (char *)(v6 + 1);
        if ( *v8 == 35 )
        {
          dword_4832CC = 1;
          ++v8;
        }
        _expandtime(*v8, a4, &a1, &v11, a5);
        v6 = (unsigned __int8 *)(v8 + 1);
      }
      else
      {
        if ( *((_BYTE *)off_46F0E0 + 2 * v7 + 1) & 0x80 && v11 > 1 )
        {
          *a1++ = v7;
          ++v6;
          --v11;
        }
        *a1++ = *v6++;
        --v11;
      }
    }
    while ( v11 );
  }
  if ( v10 )
    _unlock(19);
  else
    InterlockedDecrement(&dword_4832D8);
  if ( v11 )
  {
    *a1 = 0;
    result = a2 - v11;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 44F483: using guessed type _DWORD __cdecl _lock(_DWORD);
// 44F4E4: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 44FC40: using guessed type _DWORD __cdecl _expandtime(char, _DWORD, _DWORD, _DWORD, _DWORD);
// 4832CC: using guessed type int dword_4832CC;
// 4832D4: using guessed type int dword_4832D4;

//----- (00452AF8) --------------------------------------------------------
int __cdecl sub_452AF8(LPCVOID lpMem)
{
  int v1; // esi@3
  bool v2; // zf@5
  _BYTE *v3; // eax@7
  char v5; // [sp+Ch] [bp-2Ch]@7
  _BYTE *v6; // [sp+10h] [bp-28h]@7
  char v7; // [sp+14h] [bp-24h]@7
  int v8; // [sp+18h] [bp-20h]@3
  char *v9; // [sp+1Ch] [bp-1Ch]@2
  CPPEH_RECORD ms_exc; // [sp+20h] [bp-18h]@2

  if ( dword_4832C8 == 3 )
  {
    _lock(9);
    ms_exc.registration.TryLevel = 0;
    v9 = __sbh_find_block((int)lpMem);
    if ( v9 )
    {
      v1 = *((_DWORD *)lpMem - 1) - 9;
      v8 = *((_DWORD *)lpMem - 1) - 9;
    }
    else
    {
      v1 = v8;
    }
    ms_exc.registration.TryLevel = -1;
    _unlock(9);
    v2 = v9 == 0;
  }
  else
  {
    if ( dword_4832C8 != 2 )
      return HeapSize(hHeap, 0, lpMem);
    _lock(9);
    ms_exc.registration.TryLevel = 1;
    v3 = (_BYTE *)sub_4540F7((unsigned int)lpMem, (void ***)&v5, (unsigned int *)&v7);
    v6 = v3;
    if ( v3 )
    {
      v1 = 16 * *v3;
      v8 = 16 * *v3;
    }
    else
    {
      v1 = v8;
    }
    ms_exc.registration.TryLevel = -1;
    _unlock(9);
    v2 = v6 == 0;
  }
  if ( v2 )
    return HeapSize(hHeap, 0, lpMem);
  return v1;
}
// 44F483: using guessed type _DWORD __cdecl _lock(_DWORD);
// 44F4E4: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 4832C8: using guessed type int dword_4832C8;

//----- (00452BE6) --------------------------------------------------------
char __cdecl sub_452BE6(int a1)
{
  HMODULE v1; // eax@1
  int v2; // ecx@2

  *(_DWORD *)a1 = 0;
  v1 = GetModuleHandleA(0);
  if ( *(_WORD *)v1 == 23117 )
  {
    v2 = *((_DWORD *)v1 + 15);
    if ( v2 )
    {
      v1 = (HMODULE)((char *)v1 + v2);
      *(_BYTE *)a1 = *((_BYTE *)v1 + 26);
      LOBYTE(v1) = *((_BYTE *)v1 + 27);
      *(_BYTE *)(a1 + 1) = (_BYTE)v1;
    }
  }
  return (unsigned int)v1;
}

//----- (00452C13) --------------------------------------------------------
__int32 sub_452C13()
{
  __int32 result; // eax@4
  CHAR *v1; // ecx@6
  CHAR v2; // al@7
  CHAR *v3; // eax@12
  CHAR *v4; // ecx@13
  CHAR v5; // al@14
  char *v6; // eax@20
  const char *v7; // eax@21
  char *v8; // ecx@21
  CHAR Buffer; // [sp+4h] [bp-122Ch]@5
  CHAR Filename; // [sp+1094h] [bp-19Ch]@13
  struct _OSVERSIONINFOA VersionInformation; // [sp+1198h] [bp-98h]@1
  unsigned __int8 v12; // [sp+122Ch] [bp-4h]@29

  VersionInformation.dwOSVersionInfoSize = 148;
  if ( GetVersionExA(&VersionInformation)
    && VersionInformation.dwPlatformId == 2
    && VersionInformation.dwMajorVersion >= 5 )
  {
    result = 1;
  }
  else
  {
    if ( !GetEnvironmentVariableA("__MSVCRT_HEAP_SELECT", &Buffer, 0x1090u) )
      goto LABEL_32;
    v1 = &Buffer;
    if ( Buffer )
    {
      do
      {
        v2 = *v1;
        if ( *v1 >= 97 && v2 <= 122 )
          *v1 = v2 - 32;
        ++v1;
      }
      while ( *v1 );
    }
    if ( !strncmp("__GLOBAL_HEAP_SELECTED", &Buffer, 0x16u) )
    {
      v3 = &Buffer;
    }
    else
    {
      GetModuleFileNameA(0, &Filename, 0x104u);
      v4 = &Filename;
      if ( Filename )
      {
        do
        {
          v5 = *v4;
          if ( *v4 >= 97 && v5 <= 122 )
            *v4 = v5 - 32;
          ++v4;
        }
        while ( *v4 );
      }
      v3 = strstr(&Buffer, &Filename);
    }
    if ( !v3 )
      goto LABEL_32;
    v6 = strchr(v3, 44);
    if ( !v6 )
      goto LABEL_32;
    v7 = v6 + 1;
    v8 = (char *)v7;
    if ( *v7 )
    {
      do
      {
        if ( *v8 == 59 )
          *v8 = 0;
        else
          ++v8;
      }
      while ( *v8 );
    }
    result = strtol(v7, 0, 10);
    if ( result != 2 && result != 3 && result != 1 )
    {
LABEL_32:
      sub_452BE6((int)&v12);
      result = 3 - (v12 < 6u);
    }
  }
  return result;
}

//----- (00452D5B) --------------------------------------------------------
signed int __cdecl sub_452D5B(int a1)
{
  __int32 v1; // eax@2
  void **v2; // eax@3

  hHeap = HeapCreate(a1 == 0, 0x1000u, 0);
  if ( !hHeap )
    return 0;
  v1 = sub_452C13();
  dword_4832C8 = v1;
  if ( v1 == 3 )
  {
    v2 = (void **)__sbh_heap_init(1016);
  }
  else
  {
    if ( v1 != 2 )
      return 1;
    v2 = sub_453E9B();
  }
  if ( !v2 )
  {
    HeapDestroy(hHeap);
    return 0;
  }
  return 1;
}
// 452F32: using guessed type _DWORD __cdecl __sbh_heap_init(_DWORD);
// 4832C8: using guessed type int dword_4832C8;

//----- (00452FA5) --------------------------------------------------------
char *__cdecl sub_452FA5(unsigned int a1, int a2)
{
  char *result; // eax@1
  int v3; // esi@1
  unsigned int v4; // edi@1
  signed int v5; // ecx@1
  int v6; // ebx@2
  unsigned int v7; // edx@3
  char *v8; // ecx@7
  unsigned int v9; // ebx@7
  bool v10; // zf@7
  char *v11; // ecx@9
  unsigned int v12; // ebx@9
  int v13; // ecx@11
  unsigned int v14; // edx@14
  unsigned int v15; // ebx@17
  unsigned int v16; // esi@24
  unsigned int v17; // esi@26
  int v18; // ecx@33
  void *v19; // eax@43
  char *v20; // [sp+Ch] [bp-10h]@1
  signed int v21; // [sp+10h] [bp-Ch]@2
  signed int v22; // [sp+14h] [bp-8h]@2
  int v23; // [sp+18h] [bp-4h]@1
  int v24; // [sp+28h] [bp+Ch]@2
  int v25; // [sp+28h] [bp+Ch]@17
  char v26; // [sp+2Bh] [bp+Fh]@34

  result = *(char **)(a1 + 16);
  v3 = a2 - 4;
  v4 = (unsigned int)(a2 - *(_DWORD *)(a1 + 12)) >> 15;
  v20 = &result[516 * v4 + 324];
  v5 = *(_DWORD *)(a2 - 4) - 1;
  v23 = *(_DWORD *)(a2 - 4) - 1;
  if ( !(v5 & 1) )
  {
    v6 = v5 + v3;
    v21 = *(_DWORD *)(v5 + v3);
    v22 = *(_DWORD *)(a2 - 8);
    v24 = v5 + v3;
    if ( !(v21 & 1) )
    {
      v7 = (v21 >> 4) - 1;
      if ( v7 > 0x3F )
        v7 = 63;
      if ( *(_DWORD *)(v6 + 4) == *(_DWORD *)(v6 + 8) )
      {
        if ( v7 >= 0x20 )
        {
          v11 = &result[v7 + 4];
          v12 = ~(0x80000000 >> (v7 - 32));
          *(_DWORD *)&result[4 * v4 + 196] &= v12;
          v10 = (*v11)-- == 1;
          if ( v10 )
            *(_DWORD *)(a1 + 4) &= v12;
        }
        else
        {
          v8 = &result[v7 + 4];
          v9 = ~(0x80000000 >> v7);
          *(_DWORD *)&result[4 * v4 + 68] &= v9;
          v10 = (*v8)-- == 1;
          if ( v10 )
            *(_DWORD *)a1 &= v9;
        }
        v13 = v23;
        v6 = v24;
      }
      else
      {
        v13 = v23;
      }
      v5 = v21 + v13;
      *(_DWORD *)(*(_DWORD *)(v6 + 8) + 4) = *(_DWORD *)(v6 + 4);
      v23 = v5;
      *(_DWORD *)(*(_DWORD *)(v24 + 4) + 8) = *(_DWORD *)(v24 + 8);
    }
    v14 = (v5 >> 4) - 1;
    if ( v14 > 0x3F )
      v14 = 63;
    if ( v22 & 1 )
    {
      v15 = a1;
    }
    else
    {
      v25 = v3 - v22;
      v15 = (v22 >> 4) - 1;
      if ( v15 > 0x3F )
        v15 = 63;
      v23 = v22 + v5;
      v14 = ((v22 + v5) >> 4) - 1;
      if ( v14 > 0x3F )
        v14 = 63;
      if ( v15 != v14 )
      {
        if ( *(_DWORD *)(v25 + 4) == *(_DWORD *)(v25 + 8) )
        {
          if ( v15 >= 0x20 )
          {
            v17 = ~(0x80000000 >> (v15 - 32));
            *(_DWORD *)&result[4 * v4 + 196] &= v17;
            v10 = result[v15 + 4]-- == 1;
            if ( v10 )
              *(_DWORD *)(a1 + 4) &= v17;
          }
          else
          {
            v16 = ~(0x80000000 >> v15);
            *(_DWORD *)&result[4 * v4 + 68] &= v16;
            v10 = result[v15 + 4]-- == 1;
            if ( v10 )
              *(_DWORD *)a1 &= v16;
          }
        }
        *(_DWORD *)(*(_DWORD *)(v25 + 8) + 4) = *(_DWORD *)(v25 + 4);
        *(_DWORD *)(*(_DWORD *)(v25 + 4) + 8) = *(_DWORD *)(v25 + 8);
      }
      v3 = v25;
    }
    if ( v22 & 1 || v15 != v14 )
    {
      v18 = (int)&v20[8 * v14];
      *(_DWORD *)(v3 + 4) = *(_DWORD *)&v20[8 * v14 + 4];
      *(_DWORD *)(v3 + 8) = v18;
      *(_DWORD *)(v18 + 4) = v3;
      *(_DWORD *)(*(_DWORD *)(v3 + 4) + 8) = v3;
      if ( *(_DWORD *)(v3 + 4) == *(_DWORD *)(v3 + 8) )
      {
        v26 = result[v14 + 4];
        result[v14 + 4] = v26 + 1;
        if ( v14 >= 0x20 )
        {
          if ( !v26 )
            *(_DWORD *)(a1 + 4) |= 0x80000000 >> (v14 - 32);
          *(_DWORD *)&result[4 * v4 + 196] |= 0x80000000 >> (v14 - 32);
        }
        else
        {
          if ( !v26 )
            *(_DWORD *)a1 |= 0x80000000 >> v14;
          *(_DWORD *)&result[4 * v4 + 68] |= 0x80000000 >> v14;
        }
      }
    }
    *(_DWORD *)v3 = v23;
    *(_DWORD *)(v23 + v3 - 4) = v23;
    result += 516 * v4 + 324;
    v10 = *(_DWORD *)v20 == 1;
    --*(_DWORD *)result;
    if ( v10 )
    {
      if ( dword_4832B4 )
      {
        VirtualFree((LPVOID)(*((_DWORD *)dword_4832B4 + 3) + (dword_4832A8 << 15)), 0x8000u, 0x4000u);
        *((_DWORD *)dword_4832B4 + 2) |= 0x80000000 >> dword_4832A8;
        *(_DWORD *)(*((_DWORD *)dword_4832B4 + 4) + 4 * dword_4832A8 + 196) = 0;
        --*(_BYTE *)(*((_DWORD *)dword_4832B4 + 4) + 67);
        v19 = dword_4832B4;
        if ( !*(_BYTE *)(*((_DWORD *)dword_4832B4 + 4) + 67) )
        {
          *((_DWORD *)dword_4832B4 + 1) &= 0xFFFFFFFE;
          v19 = dword_4832B4;
        }
        if ( *((_DWORD *)v19 + 2) == -1 )
        {
          VirtualFree(*((LPVOID *)v19 + 3), 0, 0x8000u);
          HeapFree(hHeap, 0, *((LPVOID *)dword_4832B4 + 4));
          memmove(dword_4832B4, (char *)dword_4832B4 + 20, (size_t)lp + 20 * dword_4832B8 - (_DWORD)dword_4832B4 - 20);
          --dword_4832B8;
          if ( a1 > (unsigned int)dword_4832B4 )
            a1 -= 20;
          dword_4832AC = (int)lp;
        }
      }
      result = (char *)a1;
      dword_4832A8 = v4;
      dword_4832B4 = (void *)a1;
    }
  }
  return result;
}
// 4832A8: using guessed type int dword_4832A8;
// 4832AC: using guessed type int dword_4832AC;
// 4832B8: using guessed type int dword_4832B8;

//----- (00453E9B) --------------------------------------------------------
void **sub_453E9B()
{
  void **v0; // esi@2
  void *v1; // eax@4
  unsigned int v2; // edi@4
  int v3; // eax@12
  signed int v4; // ebp@12
  int v5; // edx@13

  if ( dword_46F488 == -1 )
  {
    v0 = &off_46F478;
  }
  else
  {
    v0 = (void **)HeapAlloc(hHeap, 0, 0x2020u);
    if ( !v0 )
      return 0;
  }
  v1 = VirtualAlloc(0, 0x400000u, 0x2000u, 4u);
  v2 = (unsigned int)v1;
  if ( !v1 )
  {
LABEL_19:
    if ( v0 != &off_46F478 )
      HeapFree(hHeap, 0, v0);
    return 0;
  }
  if ( !VirtualAlloc(v1, 0x10000u, 0x1000u, 4u) )
  {
    VirtualFree((LPVOID)v2, 0, 0x8000u);
    goto LABEL_19;
  }
  if ( v0 == &off_46F478 )
  {
    if ( !off_46F478 )
      off_46F478 = &off_46F478;
    if ( !lpMem )
      lpMem = &off_46F478;
  }
  else
  {
    *v0 = &off_46F478;
    v0[1] = lpMem;
    lpMem = v0;
    *(_DWORD *)v0[1] = v0;
  }
  v0[5] = (void *)(v2 + 0x400000);
  v3 = (int)(v0 + 6);
  v0[3] = v0 + 38;
  v0[4] = (void *)v2;
  v0[2] = v0 + 6;
  v4 = 0;
  do
  {
    v5 = v4++ >= 16;
    *(_DWORD *)v3 = ((v5 - 1) & 0xF1) - 1;
    *(_DWORD *)(v3 + 4) = 241;
    v3 += 8;
  }
  while ( v4 < 1024 );
  memset((void *)v2, 0, 0x10000u);
  while ( v2 < (unsigned int)v0[4] + 0x10000 )
  {
    *(_BYTE *)(v2 + 248) = -1;
    *(_DWORD *)v2 = v2 + 8;
    *(_DWORD *)(v2 + 4) = 240;
    v2 += 4096;
  }
  return v0;
}
// 46F478: using guessed type void *off_46F478;
// 46F488: using guessed type int dword_46F488;

//----- (00453FDF) --------------------------------------------------------
int __cdecl sub_453FDF(LPVOID lpMem)
{
  int result; // eax@1

  result = VirtualFree(*((LPVOID *)lpMem + 4), 0, 0x8000u);
  if ( off_471498 == lpMem )
  {
    result = *((_DWORD *)lpMem + 1);
    off_471498 = (void **)*((_DWORD *)lpMem + 1);
  }
  if ( lpMem == &off_46F478 )
  {
    dword_46F488 = -1;
  }
  else
  {
    **((_DWORD **)lpMem + 1) = *(_DWORD *)lpMem;
    *(_DWORD *)(*(_DWORD *)lpMem + 4) = *((_DWORD *)lpMem + 1);
    result = HeapFree(hHeap, 0, lpMem);
  }
  return result;
}
// 46F478: using guessed type void *off_46F478;
// 46F488: using guessed type int dword_46F488;
// 471498: using guessed type void **off_471498;

//----- (00454035) --------------------------------------------------------
void __cdecl sub_454035(int a1)
{
  LPVOID v1; // esi@1
  _DWORD *v2; // edi@3
  signed int v3; // ebx@3
  unsigned int v4; // eax@6
  LPVOID v5; // ecx@11
  _DWORD *v6; // eax@13
  signed int v7; // edx@13
  int v8; // [sp+Ch] [bp-4h]@3

  v1 = lpMem;
  do
  {
    if ( *((_DWORD *)v1 + 4) != -1 )
    {
      v8 = 0;
      v2 = (char *)v1 + 8208;
      v3 = 4190208;
      do
      {
        if ( *v2 == 240 && VirtualFree((LPVOID)(*((_DWORD *)v1 + 4) + v3), 0x1000u, 0x4000u) )
        {
          *v2 = -1;
          --dword_481D64;
          v4 = *((_DWORD *)v1 + 3);
          if ( !v4 || v4 > (unsigned int)v2 )
            *((_DWORD *)v1 + 3) = v2;
          ++v8;
          if ( !--a1 )
            break;
        }
        v3 -= 4096;
        v2 -= 2;
      }
      while ( v3 >= 0 );
      v5 = v1;
      v1 = (LPVOID)*((_DWORD *)v1 + 1);
      if ( v8 && *((_DWORD *)v5 + 6) == -1 )
      {
        v6 = (char *)v5 + 32;
        v7 = 1;
        do
        {
          if ( *v6 != -1 )
            break;
          ++v7;
          v6 += 2;
        }
        while ( v7 < 1024 );
        if ( v7 == 1024 )
          sub_453FDF(v5);
      }
    }
  }
  while ( v1 != lpMem && a1 > 0 );
}
// 481D64: using guessed type int dword_481D64;

//----- (004540F7) --------------------------------------------------------
unsigned int __cdecl sub_4540F7(unsigned int a1, void ***a2, unsigned int *a3)
{
  void **v3; // ecx@1

  v3 = &off_46F478;
  while ( a1 <= (unsigned int)v3[4] || a1 >= (unsigned int)v3[5] )
  {
    v3 = (void **)*v3;
    if ( v3 == &off_46F478 )
      return 0;
  }
  if ( !(a1 & 0xF) && (a1 & 0xFFF) >= 0x100 )
  {
    *a2 = v3;
    *a3 = a1 & 0xFFFFF000;
    return ((signed int)(a1 - (a1 & 0xFFFFF000) - 256) >> 4) + (a1 & 0xFFFFF000) + 8;
  }
  return 0;
}
// 46F478: using guessed type void *off_46F478;

//----- (0045414E) --------------------------------------------------------
void __cdecl sub_45414E(int a1, int a2, _BYTE *a3)
{
  int v3; // eax@1
  bool v4; // zf@1

  v3 = a1 + 8 * ((a2 - *(_DWORD *)(a1 + 16)) >> 12) + 24;
  *(_DWORD *)v3 += *a3;
  *a3 = 0;
  v4 = *(_DWORD *)v3 == 240;
  *(_DWORD *)(v3 + 4) = 241;
  if ( v4 && ++dword_481D64 == 32 )
    sub_454035(16);
}
// 481D64: using guessed type int dword_481D64;

//----- (00454193) --------------------------------------------------------
char *__cdecl sub_454193(unsigned int a1)
{
  void **v1; // esi@1
  char *v2; // edx@2
  unsigned int v3; // edi@3
  int v4; // eax@3
  unsigned int v5; // ebx@4
  char *result; // eax@6
  void **v7; // edi@22
  _DWORD *v8; // ebx@27
  _DWORD *v9; // eax@27
  int i; // esi@27
  _DWORD *v11; // ecx@31
  int v12; // eax@32
  unsigned int v13; // eax@34
  bool v14; // cf@35
  void **v15; // eax@40
  _BYTE *v16; // ecx@41
  unsigned int v17; // [sp+Ch] [bp-8h]@11
  int v18; // [sp+10h] [bp-4h]@3
  int v19; // [sp+10h] [bp-4h]@11
  signed int v20; // [sp+10h] [bp-4h]@27

  v1 = off_471498;
  do
  {
    v2 = (char *)v1[4];
    if ( v2 == (char *)-1 )
    {
      v5 = a1;
    }
    else
    {
      v3 = (unsigned int)v1[2];
      v4 = (int)&v2[4096 * (((_BYTE *)v1[2] - (_BYTE *)v1 - 24) >> 3)];
      v18 = (int)&v2[4096 * (((_BYTE *)v1[2] - (_BYTE *)v1 - 24) >> 3)];
      if ( v3 < (unsigned int)(v1 + 2054) )
      {
        while ( 1 )
        {
          v5 = a1;
          if ( *(_DWORD *)v3 >= (signed int)a1 && *(_DWORD *)(v3 + 4) > a1 )
          {
            result = (char *)sub_45439B(v4, *(_DWORD *)v3, a1);
            if ( result )
            {
LABEL_21:
              off_471498 = v1;
              *(_DWORD *)v3 -= v5;
              v1[2] = (void *)v3;
              return result;
            }
            v4 = v18;
            *(_DWORD *)(v3 + 4) = a1;
          }
          v3 += 8;
          v4 += 4096;
          v18 = v4;
          if ( v3 >= (unsigned int)(v1 + 2054) )
            goto LABEL_11;
        }
      }
      v5 = a1;
LABEL_11:
      v3 = (unsigned int)(v1 + 6);
      v17 = (unsigned int)v1[2];
      v19 = (int)v1[4];
      if ( (unsigned int)(v1 + 6) < v17 )
      {
        do
        {
          if ( *(_DWORD *)v3 >= (signed int)v5 && *(_DWORD *)(v3 + 4) > v5 )
          {
            result = (char *)sub_45439B(v19, *(_DWORD *)v3, v5);
            if ( result )
              goto LABEL_21;
            *(_DWORD *)(v3 + 4) = v5;
          }
          v19 += 4096;
          v3 += 8;
        }
        while ( v3 < v17 );
      }
    }
    v1 = (void **)*v1;
  }
  while ( v1 != off_471498 );
  v7 = &off_46F478;
  while ( v7[4] == (void *)-1 || !v7[3] )
  {
    v7 = (void **)*v7;
    if ( v7 == &off_46F478 )
    {
      v15 = sub_453E9B();
      if ( v15 )
      {
        v16 = v15[4];
        v16[8] = v5;
        off_471498 = v15;
        *(_DWORD *)v16 = &v16[v5 + 8];
        *((_DWORD *)v16 + 1) = 240 - v5;
        v15[6] = (char *)v15[6] - (unsigned __int8)v5;
        return v16 + 256;
      }
      return 0;
    }
  }
  v8 = v7[3];
  v20 = 0;
  v9 = v8;
  for ( i = (int)v7[4] + 4096 * (((char *)v8 - (char *)v7 - 24) >> 3); *v9 == -1; ++v20 )
  {
    if ( v20 >= 16 )
      break;
    v9 += 2;
  }
  if ( VirtualAlloc((LPVOID)i, v20 << 12, 0x1000u, 4u) != (LPVOID)i )
    return 0;
  v11 = v8;
  if ( v20 > 0 )
  {
    v12 = i + 4;
    do
    {
      *(_BYTE *)(v12 + 244) = -1;
      *(_DWORD *)(v12 - 4) = v12 + 4;
      *(_DWORD *)v12 = 240;
      *v11 = 240;
      v11[1] = 241;
      v12 += 4096;
      v11 += 2;
      --v20;
    }
    while ( v20 );
  }
  off_471498 = v7;
  v13 = (unsigned int)(v7 + 2054);
  while ( 1 )
  {
    v14 = (unsigned int)v11 < v13;
    if ( (unsigned int)v11 >= v13 )
      break;
    if ( *v11 == -1 )
    {
      v14 = (unsigned int)v11 < v13;
      break;
    }
    v11 += 2;
  }
  v7[3] = (void *)(v14 ? (unsigned int)v11 : 0);
  *(_BYTE *)(i + 8) = a1;
  v7[2] = v8;
  *v8 -= a1;
  *(_DWORD *)(i + 4) -= a1;
  result = (char *)(i + 256);
  *(_DWORD *)i = i + a1 + 8;
  return result;
}
// 46F478: using guessed type void *off_46F478;
// 471498: using guessed type void **off_471498;

//----- (0045439B) --------------------------------------------------------
int __cdecl sub_45439B(int a1, unsigned int a2, unsigned int a3)
{
  int v3; // ecx@1
  unsigned int v4; // esi@1
  _BYTE *v5; // edi@1
  unsigned int v6; // ebx@1
  _BYTE *v7; // eax@1
  int v8; // eax@5
  _BYTE *v9; // esi@6
  _BYTE *v10; // ebx@10
  unsigned int v11; // esi@10
  _BYTE *v12; // esi@20
  _BYTE *v13; // ebx@24
  unsigned int v14; // eax@24
  _BYTE *v16; // [sp+Ch] [bp-4h]@1
  unsigned int v17; // [sp+18h] [bp+8h]@1

  v3 = a1;
  v4 = *(_DWORD *)(a1 + 4);
  v5 = *(_BYTE **)a1;
  v6 = a1 + 248;
  v16 = *(_BYTE **)a1;
  v7 = *(_BYTE **)a1;
  v17 = a1 + 248;
  if ( v4 >= a3 )
  {
    *v5 = a3;
    if ( (unsigned int)&v5[a3] >= v6 )
    {
      *(_DWORD *)(v3 + 4) = 0;
      *(_DWORD *)v3 = v3 + 8;
    }
    else
    {
      *(_DWORD *)v3 += a3;
      *(_DWORD *)(v3 + 4) -= a3;
    }
    v8 = (int)(v5 + 8);
    return 16 * v8 - 15 * v3;
  }
  v9 = &v5[v4];
  if ( *v9 )
    v7 = v9;
  if ( (unsigned int)&v7[a3] >= v6 )
  {
LABEL_20:
    v12 = (_BYTE *)(v3 + 8);
    while ( v12 < v5 && (unsigned int)&v12[a3] < v17 )
    {
      if ( *v12 )
      {
        v12 += *v12;
      }
      else
      {
        v13 = v12 + 1;
        v14 = 1;
        while ( !*v13 )
        {
          ++v13;
          ++v14;
        }
        if ( v14 >= a3 )
        {
          if ( (unsigned int)&v12[a3] >= v17 )
          {
            *(_DWORD *)(v3 + 4) = 0;
            *(_DWORD *)v3 = v3 + 8;
          }
          else
          {
            *(_DWORD *)v3 = &v12[a3];
            *(_DWORD *)(v3 + 4) = v14 - a3;
          }
          *v12 = a3;
          v8 = (int)(v12 + 8);
          return 16 * v8 - 15 * v3;
        }
        a2 -= v14;
        if ( a2 < a3 )
          return 0;
        v12 = v13;
      }
    }
    return 0;
  }
  while ( *v7 )
  {
    v7 += *v7;
LABEL_19:
    if ( (unsigned int)&v7[a3] >= v17 )
      goto LABEL_20;
  }
  v10 = v7 + 1;
  v11 = 1;
  while ( !*v10 )
  {
    ++v10;
    ++v11;
  }
  if ( v11 < a3 )
  {
    if ( v7 == v16 )
    {
      *(_DWORD *)(v3 + 4) = v11;
    }
    else
    {
      a2 -= v11;
      if ( a2 < a3 )
        return 0;
    }
    v5 = v16;
    v7 = v10;
    goto LABEL_19;
  }
  if ( (unsigned int)&v7[a3] >= v17 )
  {
    *(_DWORD *)(v3 + 4) = 0;
    *(_DWORD *)v3 = v3 + 8;
  }
  else
  {
    *(_DWORD *)v3 = &v7[a3];
    *(_DWORD *)(v3 + 4) = v11 - a3;
  }
  *v7 = a3;
  v8 = (int)(v7 + 8);
  return 16 * v8 - 15 * v3;
}

//----- (004544BF) --------------------------------------------------------
signed int __cdecl sub_4544BF(int a1, int a2, _BYTE *a3, unsigned int a4)
{
  int v4; // ecx@1
  int v5; // edi@1
  _BYTE *v6; // esi@4
  _BYTE *i; // eax@5
  bool v8; // zf@6
  int v9; // eax@14
  int v11; // [sp+Ch] [bp-4h]@1

  v4 = *a3;
  v11 = 0;
  v5 = a1 + 8 * ((a2 - *(_DWORD *)(a1 + 16)) >> 12) + 24;
  if ( v4 > a4 )
  {
    *a3 = a4;
    *(_DWORD *)v5 += v4 - a4;
    *(_DWORD *)(v5 + 4) = 241;
    return 1;
  }
  if ( v4 < a4 )
  {
    v6 = &a3[a4];
    if ( a2 + 248 >= (unsigned int)&a3[a4] )
    {
      for ( i = &a3[v4]; ; ++i )
      {
        v8 = i == v6;
        if ( i >= v6 )
          break;
        if ( *i )
        {
          v8 = i == v6;
          break;
        }
      }
      if ( v8 )
      {
        *a3 = a4;
        if ( (unsigned int)a3 <= *(_DWORD *)a2 && (unsigned int)v6 > *(_DWORD *)a2 )
        {
          if ( (unsigned int)v6 >= a2 + 248 )
          {
            *(_DWORD *)(a2 + 4) = 0;
            *(_DWORD *)a2 = a2 + 8;
          }
          else
          {
            v9 = 0;
            *(_DWORD *)a2 = v6;
            if ( !*v6 )
            {
              do
                ++v9;
              while ( !v6[v9] );
            }
            *(_DWORD *)(a2 + 4) = v9;
          }
        }
        *(_DWORD *)v5 += v4 - a4;
        return 1;
      }
    }
  }
  return v11;
}

//----- (0045678B) --------------------------------------------------------
int (__stdcall *sub_45678B())()
{
  int (__stdcall *result)(); // eax@1

  result = (int (__stdcall *)())SetUnhandledExceptionFilter(__CxxUnhandledExceptionFilter);
  lpfn = result;
  return result;
}

//----- (0045679C) --------------------------------------------------------
LPTOP_LEVEL_EXCEPTION_FILTER sub_45679C()
{
  return SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)lpfn);
}

//----- (004567A9) --------------------------------------------------------
void *__cdecl sub_4567A9(int a1, int a2)
{
  unsigned int v2; // esi@1
  void *result; // eax@19
  size_t v4; // [sp-4h] [bp-38h]@9
  void *v5; // [sp+14h] [bp-20h]@5
  unsigned int v6; // [sp+18h] [bp-1Ch]@1

  v2 = a2 * a1;
  v6 = a2 * a1;
  if ( (unsigned int)(a2 * a1) <= 0xFFFFFFE0 )
  {
    if ( !v2 )
      v2 = 1;
    v2 = (v2 + 15) & 0xFFFFFFF0;
  }
  while ( 1 )
  {
    v5 = 0;
    if ( v2 <= 0xFFFFFFE0 )
    {
      if ( dword_4832C8 == 3 )
      {
        if ( v6 > dword_4832C0 )
          goto LABEL_15;
        _lock(9);
        v5 = (void *)__sbh_alloc_block(v6);
        _unlock(9);
        if ( v5 )
        {
          v4 = a2 * a1;
LABEL_14:
          memset(v5, 0, v4);
          goto LABEL_15;
        }
      }
      else
      {
        if ( dword_4832C8 != 2 || v2 > dword_47149C )
        {
LABEL_15:
          if ( v5 )
            return v5;
          goto LABEL_16;
        }
        _lock(9);
        v5 = sub_454193(v2 >> 4);
        _unlock(9);
        if ( v5 )
        {
          v4 = v2;
          goto LABEL_14;
        }
      }
LABEL_16:
      v5 = HeapAlloc(hHeap, 8u, v2);
    }
    if ( v5 || !dword_481D68 )
      return v5;
    result = (void *)_callnewh(v2);
    if ( !result )
      return result;
  }
}
// 44F483: using guessed type _DWORD __cdecl _lock(_DWORD);
// 44F4E4: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 4532CE: using guessed type _DWORD __cdecl __sbh_alloc_block(_DWORD);
// 4546F0: using guessed type _DWORD __cdecl _callnewh(_DWORD);
// 47149C: using guessed type int dword_47149C;
// 481D68: using guessed type int dword_481D68;
// 4832C0: using guessed type int dword_4832C0;
// 4832C8: using guessed type int dword_4832C8;

//----- (00457FCC) --------------------------------------------------------
int sub_457FCC()
{
  return 0;
}

//----- (00459225) --------------------------------------------------------
__int16 __cdecl sub_459225(wchar_t a1, FILE *a2)
{
  __int16 v2; // si@1

  _lock_file(a2);
  v2 = _putwc_lk(a1, a2);
  _unlock_file(a2);
  return v2;
}
// 455ED8: using guessed type _DWORD __cdecl _lock_file(_DWORD);
// 455F2A: using guessed type _DWORD __cdecl _unlock_file(_DWORD);

//----- (00459DB3) --------------------------------------------------------
signed int __cdecl sub_459DB3(unsigned __int8 a1, int a2, unsigned __int8 a3)
{
  signed int result; // eax@3

  if ( a3 & (unsigned __int8)byte_482061[a1]
    || (!a2 ? (result = 0) : (result = (unsigned __int16)(a2 & _ctype[a1 + 1])), result) )
  {
    result = 1;
  }
  return result;
}

//----- (0045A964) --------------------------------------------------------
int __cdecl sub_45A964(int a1, int a2)
{
  return _ld12cvt(a1, a2, &unk_472170);
}
// 45A7F8: using guessed type _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD);

//----- (0045A97A) --------------------------------------------------------
int __cdecl sub_45A97A(int a1, int a2)
{
  return _ld12cvt(a1, a2, &unk_472188);
}
// 45A7F8: using guessed type _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD);

//----- (0045AA0A) --------------------------------------------------------
int __cdecl sub_45AA0A(int a1, int a2)
{
  char v3; // [sp+0h] [bp-Ch]@1

  __strgtold12(&v3, &a2, a2, 0, 0, 0, 0);
  return sub_45A964((int)&v3, a1);
}
// 45AC24: using guessed type _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0045AA65) --------------------------------------------------------
int __cdecl sub_45AA65(int a1, int a2)
{
  char v3; // [sp+0h] [bp-Ch]@1

  __strgtold12(&v3, &a2, a2, 0, 0, 0, 0);
  return sub_45A97A((int)&v3, a1);
}
// 45AC24: using guessed type _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0045C440) --------------------------------------------------------
void __usercall sub_45C440(int a1@<ebp>)
{
  SqlQuery::Destructor((SqlQuery *)(a1 - 572));
}

//----- (0045C456) --------------------------------------------------------
void __usercall sub_45C456(int a1@<ebp>)
{
  SqlQuery::Destructor((SqlQuery *)(a1 - 336));
}

//----- (0045C46C) --------------------------------------------------------
void __usercall sub_45C46C(int a1@<ebp>)
{
  SqlQuery::Destructor((SqlQuery *)(a1 - 56));
}

//----- (0045C47F) --------------------------------------------------------
void __usercall sub_45C47F(int a1@<ebp>)
{
  SqlQuery::Destructor((SqlQuery *)(a1 - 300));
}

//----- (0045C495) --------------------------------------------------------
void __usercall sub_45C495(int a1@<ebp>)
{
  SqlQuery::Destructor((SqlQuery *)(a1 - 360));
}

//----- (0045C4B0) --------------------------------------------------------
void __usercall sub_45C4B0(int a1@<ebp>)
{
  std::map::destructor_2((std::map *)(*(_DWORD *)(a1 - 24) + 4));
}

//----- (0045C4C6) --------------------------------------------------------
void __usercall sub_45C4C6(int a1@<ebp>)
{
  std::map::destructor_2((std::map *)(*(_DWORD *)(a1 - 16) + 4));
}

//----- (0045C4DC) --------------------------------------------------------
void __usercall sub_45C4DC(int a1@<ebp>)
{
  SqlQuery::Destructor((SqlQuery *)(a1 - 448));
}

//----- (0045C4E8) --------------------------------------------------------
void __usercall sub_45C4E8(int a1@<ebp>)
{
  SqlQuery::Destructor((SqlQuery *)(a1 - 736));
}

//----- (0045C4F4) --------------------------------------------------------
void __usercall sub_45C4F4(int a1@<ebp>)
{
  SqlQuery::Destructor((SqlQuery *)(a1 - 1032));
}

//----- (0045C50A) --------------------------------------------------------
void __usercall sub_45C50A(int a1@<ebp>)
{
  SqlQuery::Destructor((SqlQuery *)(a1 - 308));
}

//----- (0045C520) --------------------------------------------------------
void __usercall sub_45C520(int a1@<ebp>)
{
  SqlQuery::Destructor((SqlQuery *)(a1 - 40));
}

//----- (0045C533) --------------------------------------------------------
void __usercall sub_45C533(int a1@<ebp>)
{
  SqlQuery::Destructor((SqlQuery *)(a1 - 36));
}

//----- (0045C546) --------------------------------------------------------
void __usercall sub_45C546(int a1@<ebp>)
{
  SqlQuery::Destructor((SqlQuery *)(a1 - 36));
}

//----- (0045C559) --------------------------------------------------------
void __usercall sub_45C559(int a1@<ebp>)
{
  SqlQuery::Destructor((SqlQuery *)(a1 - 36));
}

//----- (0045C570) --------------------------------------------------------
int __usercall sub_45C570@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 28));
}

//----- (0045C590) --------------------------------------------------------
int __usercall sub_45C590@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 20));
}

//----- (0045C5B0) --------------------------------------------------------
int __usercall sub_45C5B0@<eax>(int a1@<ebp>)
{
  return FileStream_dtor(a1 - 244);
}

//----- (0045C5BC) --------------------------------------------------------
int __usercall sub_45C5BC@<eax>(int a1@<ebp>)
{
  return std::string::destructor((void *)(a1 - 372));
}

//----- (0045C5C8) --------------------------------------------------------
int __usercall sub_45C5C8@<eax>(int a1@<ebp>)
{
  return std::string::destructor((void *)(a1 - 392));
}

//----- (0045C5D4) --------------------------------------------------------
int __usercall sub_45C5D4@<eax>(int a1@<ebp>)
{
  return std::pair_str_str::destructor((std::pair_str_str *)(a1 - 356));
}

//----- (0045C5F0) --------------------------------------------------------
int __usercall sub_45C5F0@<eax>(int a1@<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 16) & 1;
  if ( result )
    result = sub_40B190((std::ios_base *)(*(_DWORD *)(a1 - 20) + 88));
  return result;
}

//----- (0045C60A) --------------------------------------------------------
char *__usercall sub_45C60A@<eax>(int a1@<ebp>)
{
  return sub_40B2E0((char *)(*(_DWORD *)(a1 - 20) + 8));
}

//----- (0045C620) --------------------------------------------------------
int __usercall sub_45C620@<eax>(int a1@<ebp>)
{
  return sub_40B490(*(_DWORD *)(a1 - 16));
}

//----- (0045C640) --------------------------------------------------------
int __usercall sub_45C640@<eax>(int a1@<ebp>)
{
  return std::string::destructor(*(void **)(a1 - 16));
}

//----- (0045C6B0) --------------------------------------------------------
int __usercall sub_45C6B0@<eax>(int a1@<ebp>)
{
  return std::string::destructor(*(void **)(a1 - 16));
}

//----- (0045C6D0) --------------------------------------------------------
int __usercall sub_45C6D0@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 28));
}

//----- (0045C6F0) --------------------------------------------------------
int __usercall sub_45C6F0@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 20));
}

//----- (0045C720) --------------------------------------------------------
void __usercall sub_45C720(int a1@<ebp>)
{
  int v1; // ST04_4@1
  int v2; // ST00_4@1

  v1 = *(_DWORD *)(a1 + 8);
  v2 = *(_DWORD *)(a1 - 20);
  sub_40E4B0();
}

//----- (0045C740) --------------------------------------------------------
int __usercall sub_45C740@<eax>(int a1@<ebp>)
{
  return std::string::destructor(*(void **)(a1 - 16));
}

//----- (0045C760) --------------------------------------------------------
void __usercall sub_45C760(int a1@<ebp>)
{
  SqlQuery::Destructor((SqlQuery *)(a1 - 32));
}

//----- (0045C769) --------------------------------------------------------
int __cdecl SEH_40E6E3(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 44B10C: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0045C773) --------------------------------------------------------
UserInfoTable *__usercall sub_45C773@<eax>(int a1@<ebp>)
{
  return UserInfoTable::Destructor((UserInfoTable *)(a1 - 468));
}

//----- (0045C77F) --------------------------------------------------------
int __cdecl SEH_40EB66(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 44B10C: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0045C789) --------------------------------------------------------
UserInfoTable *__usercall sub_45C789@<eax>(int a1@<ebp>)
{
  return UserInfoTable::Destructor((UserInfoTable *)(a1 - 404));
}

//----- (0045C795) --------------------------------------------------------
int __cdecl SEH_40EDD3(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 44B10C: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0045C79F) --------------------------------------------------------
UserInfoTable *__usercall sub_45C79F@<eax>(int a1@<ebp>)
{
  return UserInfoTable::Destructor((UserInfoTable *)(a1 - 112));
}

//----- (0045C7A8) --------------------------------------------------------
int __cdecl CSocketInt_SEH(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 44B10C: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0045C7D0) --------------------------------------------------------
void __usercall sub_45C7D0(int a1@<ebp>)
{
  SqlQuery::Destructor((SqlQuery *)(a1 - 32));
}

//----- (0045C7D9) --------------------------------------------------------
int __cdecl SEH_40FBBE(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 44B10C: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0045C7E3) --------------------------------------------------------
void __usercall sub_45C7E3(int a1@<ebp>)
{
  SqlQuery::Destructor((SqlQuery *)(a1 - 32));
}

//----- (0045C7EC) --------------------------------------------------------
int __cdecl SEH_40FC7A(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 44B10C: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0045C7F6) --------------------------------------------------------
void __usercall sub_45C7F6(int a1@<ebp>)
{
  SqlQuery::Destructor((SqlQuery *)(a1 - 144));
}

//----- (0045C802) --------------------------------------------------------
int __cdecl SEH_40FD0D(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 44B10C: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0045C80C) --------------------------------------------------------
void __usercall sub_45C80C(int a1@<ebp>)
{
  SqlQuery::Destructor((SqlQuery *)(a1 - 128));
}

//----- (0045C815) --------------------------------------------------------
int __cdecl SEH_41070C(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 44B10C: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0045C81F) --------------------------------------------------------
MemoryObject *__usercall sub_45C81F@<eax>(int a1@<ebp>)
{
  return CIOSocket::Destructor(*(CIOSocket **)(a1 - 16));
}

//----- (0045C832) --------------------------------------------------------
MemoryObject *__usercall sub_45C832@<eax>(int a1@<ebp>)
{
  return CIOSocket::Destructor(*(CIOSocket **)(a1 - 16));
}

//----- (0045C85A) --------------------------------------------------------
void __usercall sub_45C85A(int a1@<ebp>)
{
  SqlQuery::Destructor((SqlQuery *)(a1 - 72));
}

//----- (0045C863) --------------------------------------------------------
int __cdecl SEH_410D11(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 44B10C: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0045C86D) --------------------------------------------------------
void __usercall sub_45C86D(int a1@<ebp>)
{
  SqlQuery::Destructor((SqlQuery *)(a1 - 32));
}

//----- (0045C880) --------------------------------------------------------
int __usercall sub_45C880@<eax>(int a1@<ebp>)
{
  return std::string::destructor((void *)(a1 - 60));
}

//----- (0045C889) --------------------------------------------------------
int __usercall sub_45C889@<eax>(int a1@<ebp>)
{
  return unknown_libname_53(a1 - 44);
}

//----- (0045C8A0) --------------------------------------------------------
void __usercall sub_45C8A0(int a1@<ebp>)
{
  std::map_uid_acc::destructor(*(std::map_uid_acc **)(a1 - 24));
}

//----- (0045C8C0) --------------------------------------------------------
void __usercall sub_45C8C0(int a1@<ebp>)
{
  std::map_uid_acc::destructor(*(std::map_uid_acc **)(a1 - 16));
}

//----- (0045C8E0) --------------------------------------------------------
int __usercall sub_45C8E0@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 28));
}

//----- (0045C900) --------------------------------------------------------
int __usercall sub_45C900@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 20));
}

//----- (0045C920) --------------------------------------------------------
void __usercall sub_45C920(int a1@<ebp>)
{
  int v1; // ST04_4@1
  int v2; // ST00_4@1

  v1 = *(_DWORD *)(a1 + 8);
  v2 = *(_DWORD *)(a1 - 20);
  sub_40E4B0();
}

//----- (0045C940) --------------------------------------------------------
MemoryObject *__usercall sub_45C940@<eax>(int a1@<ebp>)
{
  return MemoryObject::Destructor(*(MemoryObject **)(a1 - 16));
}

//----- (0045C953) --------------------------------------------------------
MemoryObject *__usercall sub_45C953@<eax>(int a1@<ebp>)
{
  return MemoryObject::Destructor(*(MemoryObject **)(a1 - 20));
}

//----- (0045C95C) --------------------------------------------------------
void __usercall sub_45C95C(int a1@<ebp>)
{
  SpinLock::Destructor((SpinLock *)(*(_DWORD *)(a1 - 20) + 8));
}

//----- (0045C980) --------------------------------------------------------
void sub_45C980()
{
  ExceptionHandler::leaveCritSection();
}

//----- (0045C993) --------------------------------------------------------
void sub_45C993()
{
  ExceptionHandler::leaveCritSection();
}

//----- (0045C9A9) --------------------------------------------------------
void sub_45C9A9()
{
  ExceptionHandler::leaveCritSection();
}

//----- (0045C9BC) --------------------------------------------------------
void sub_45C9BC()
{
  ExceptionHandler::leaveCritSection();
}

//----- (0045C9D0) --------------------------------------------------------
void __usercall sub_45C9D0(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 - 28));
}

//----- (0045C9F0) --------------------------------------------------------
MemoryObject *__usercall sub_45C9F0@<eax>(int a1@<ebp>)
{
  return MemoryObject::Destructor(*(MemoryObject **)(a1 - 16));
}

//----- (0045CA03) --------------------------------------------------------
MemoryObject *__usercall sub_45CA03@<eax>(int a1@<ebp>)
{
  return CIOServer::Destructor(*(CIOServer **)(a1 - 24));
}

//----- (0045CA16) --------------------------------------------------------
MemoryObject *__usercall sub_45CA16@<eax>(int a1@<ebp>)
{
  return CIOServer::Destructor(*(CIOServer **)(a1 - 16));
}

//----- (0045CA29) --------------------------------------------------------
MemoryObject *__usercall sub_45CA29@<eax>(int a1@<ebp>)
{
  return MemoryObject::Destructor(*(MemoryObject **)(a1 - 24));
}

//----- (0045CA32) --------------------------------------------------------
void __usercall sub_45CA32(int a1@<ebp>)
{
  unknown_libname_75((void *)(*(_DWORD *)(a1 - 24) + 8));
}

//----- (0045CA51) --------------------------------------------------------
void __usercall sub_45CA51(int a1@<ebp>)
{
  unknown_libname_75((void *)(*(_DWORD *)(a1 - 16) + 8));
}

//----- (0045CA70) --------------------------------------------------------
int __usercall sub_45CA70@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 28));
}

//----- (0045CA90) --------------------------------------------------------
int __usercall sub_45CA90@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 28));
}

//----- (0045CAB0) --------------------------------------------------------
int __usercall sub_45CAB0@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 20));
}

//----- (0045CAD0) --------------------------------------------------------
int __usercall sub_45CAD0@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 20));
}

//----- (0045CAF0) --------------------------------------------------------
MemoryObject *__usercall sub_45CAF0@<eax>(int a1@<ebp>)
{
  return MemoryObject::Destructor(*(MemoryObject **)(a1 - 16));
}

//----- (0045CB03) --------------------------------------------------------
MemoryObject *__usercall sub_45CB03@<eax>(int a1@<ebp>)
{
  return MemoryObject::Destructor(*(MemoryObject **)(a1 - 20));
}

//----- (0045CB16) --------------------------------------------------------
void __usercall sub_45CB16(int a1@<ebp>)
{
  operator_delete(*(LPVOID *)(a1 - 28));
}

//----- (0045CB30) --------------------------------------------------------
std::vector_IPRange *__usercall sub_45CB30@<eax>(int a1@<ebp>)
{
  return std::vector_IPRange::Destructor(*(std::vector_IPRange **)(a1 - 20));
}

//----- (0045CB43) --------------------------------------------------------
int __usercall sub_45CB43@<eax>(int a1@<ebp>)
{
  return std::istrstream::`vbase destructor(a1 - 160);
}

//----- (0045CB60) --------------------------------------------------------
std::vector_IPRange *__usercall sub_45CB60@<eax>(int a1@<ebp>)
{
  return std::vector_IPRange::Destructor(*(std::vector_IPRange **)(a1 - 16));
}

//----- (0045CB80) --------------------------------------------------------
int __usercall sub_45CB80@<eax>(int a1@<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 16) & 1;
  if ( result )
    result = sub_40B190((std::ios_base *)(*(_DWORD *)(a1 - 20) + 92));
  return result;
}

//----- (0045CB9A) --------------------------------------------------------
char *__usercall sub_45CB9A@<eax>(int a1@<ebp>)
{
  return sub_40B2E0((char *)(*(_DWORD *)(a1 - 20) + 8));
}

//----- (0045CBA6) --------------------------------------------------------
int __usercall sub_45CBA6@<eax>(int a1@<ebp>)
{
  return sub_41F440(*(_DWORD *)(a1 - 20) + 8);
}

//----- (0045CBC0) --------------------------------------------------------
char *__usercall sub_45CBC0@<eax>(int a1@<ebp>)
{
  return sub_40B2E0((char *)(*(_DWORD *)(a1 - 16) - 84));
}

//----- (0045CBE9) --------------------------------------------------------
int __usercall sub_45CBE9@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(*(_DWORD *)(a1 - 24) + 76));
}

//----- (0045CC00) --------------------------------------------------------
int __usercall sub_45CC00@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 - 20));
}

//----- (0045CC30) --------------------------------------------------------
int __usercall sub_45CC30@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 - 28));
}

//----- (0045CC50) --------------------------------------------------------
int __usercall sub_45CC50@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 28));
}

//----- (0045CC79) --------------------------------------------------------
int __usercall sub_45CC79@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(*(_DWORD *)(a1 - 16) + 76));
}

//----- (0045CC90) --------------------------------------------------------
int __usercall sub_45CC90@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 - 16));
}

//----- (0045CC99) --------------------------------------------------------
void __usercall sub_45CC99(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 - 32));
}

//----- (0045CCC0) --------------------------------------------------------
int __usercall sub_45CCC0@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 20));
}

//----- (0045CCE9) --------------------------------------------------------
void __usercall sub_45CCE9(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 - 44));
}

//----- (0045CD09) --------------------------------------------------------
int __usercall sub_45CD09@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045CD12) --------------------------------------------------------
int __usercall sub_45CD12@<eax>(int a1@<ebp>)
{
  return std::_Locinfo::~_Locinfo((std::_Locinfo *)(a1 - 80));
}

//----- (0045CD30) --------------------------------------------------------
int __usercall sub_45CD30@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045CD59) --------------------------------------------------------
void __usercall sub_45CD59(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 - 44));
}

//----- (0045CD70) --------------------------------------------------------
int __usercall sub_45CD70@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 + 12));
}

//----- (0045CD79) --------------------------------------------------------
int __usercall sub_45CD79@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045CD82) --------------------------------------------------------
int __usercall sub_45CD82@<eax>(int a1@<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 20) & 1;
  if ( result )
    result = std::locale::~locale(*(std::locale **)(a1 + 8));
  return result;
}

//----- (0045CDB9) --------------------------------------------------------
int __usercall sub_45CDB9@<eax>(int a1@<ebp>)
{
  return std::_Locinfo::~_Locinfo((std::_Locinfo *)(a1 - 76));
}

//----- (0045CDD0) --------------------------------------------------------
int __usercall sub_45CDD0@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045CDF0) --------------------------------------------------------
int __usercall sub_45CDF0@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045CE10) --------------------------------------------------------
int __usercall sub_45CE10@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045CE30) --------------------------------------------------------
int __usercall sub_45CE30@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045CE50) --------------------------------------------------------
void __usercall sub_45CE50(int a1@<ebp>)
{
  operator_delete(*(LPVOID *)(a1 - 28));
}

//----- (0045CE65) --------------------------------------------------------
int __usercall sub_45CE65@<eax>(int a1@<ebp>)
{
  return std::map_int_int::Destructor((void *)(*(_DWORD *)(a1 - 32) + 4));
}

//----- (0045CE71) --------------------------------------------------------
void __usercall sub_45CE71(int a1@<ebp>)
{
  std::map_int_sockid::Destructor((std::map_int_acc *)(*(_DWORD *)(a1 - 32) + 20));
}

//----- (0045CE7D) --------------------------------------------------------
void __usercall sub_45CE7D(int a1@<ebp>)
{
  SpinLock::Destructor((SpinLock *)(*(_DWORD *)(a1 - 32) + 36));
}

//----- (0045CE93) --------------------------------------------------------
int __usercall sub_45CE93@<eax>(int a1@<ebp>)
{
  return std::map_int_int::Destructor((void *)(*(_DWORD *)(a1 - 16) + 4));
}

//----- (0045CE9F) --------------------------------------------------------
void __usercall sub_45CE9F(int a1@<ebp>)
{
  std::map_int_sockid::Destructor((std::map_int_acc *)(*(_DWORD *)(a1 - 16) + 20));
}

//----- (0045CEAB) --------------------------------------------------------
void __usercall sub_45CEAB(int a1@<ebp>)
{
  SpinLock::Destructor((SpinLock *)(*(_DWORD *)(a1 - 16) + 36));
}

//----- (0045CED6) --------------------------------------------------------
MemoryObject *__usercall sub_45CED6@<eax>(int a1@<ebp>)
{
  return CIOSocket::Destructor(*(CIOSocket **)(a1 - 16));
}

//----- (0045CEE9) --------------------------------------------------------
MemoryObject *__usercall sub_45CEE9@<eax>(int a1@<ebp>)
{
  return CIOSocket::Destructor(*(CIOSocket **)(a1 - 16));
}

//----- (0045CF00) --------------------------------------------------------
int __usercall sub_45CF00@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 28));
}

//----- (0045CF20) --------------------------------------------------------
int __usercall sub_45CF20@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 28));
}

//----- (0045CF40) --------------------------------------------------------
int __usercall sub_45CF40@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 20));
}

//----- (0045CF60) --------------------------------------------------------
int __usercall sub_45CF60@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 20));
}

//----- (0045CF80) --------------------------------------------------------
void __usercall sub_45CF80(int a1@<ebp>)
{
  SpinLock::Destructor((SpinLock *)(*(_DWORD *)(a1 - 52) + 4));
}

//----- (0045CF8C) --------------------------------------------------------
int __usercall sub_45CF8C@<eax>(int a1@<ebp>)
{
  return std::vector_HANDLE::Destructor((std::vector_HANDLE *)(*(_DWORD *)(a1 - 52) + 48));
}

//----- (0045CF98) --------------------------------------------------------
std::vector_MemoryObject *__usercall sub_45CF98@<eax>(int a1@<ebp>)
{
  return std::vector_DNameNode::Destructor((std::vector_MemoryObject *)(*(_DWORD *)(a1 - 52) + 64));
}

//----- (0045CFA4) --------------------------------------------------------
std::vector_CIOTimer *__usercall sub_45CFA4@<eax>(int a1@<ebp>)
{
  return std::priority_queue::Destructor((std::priority_queue *)(*(_DWORD *)(a1 - 52) + 80));
}

//----- (0045CFB0) --------------------------------------------------------
void __usercall sub_45CFB0(int a1@<ebp>)
{
  operator_delete(*(LPVOID *)(a1 - 36));
}

//----- (0045CFC5) --------------------------------------------------------
void __usercall sub_45CFC5(int a1@<ebp>)
{
  SpinLock::Destructor((SpinLock *)(*(_DWORD *)(a1 - 16) + 4));
}

//----- (0045CFD1) --------------------------------------------------------
int __usercall sub_45CFD1@<eax>(int a1@<ebp>)
{
  return std::vector_HANDLE::Destructor((std::vector_HANDLE *)(*(_DWORD *)(a1 - 16) + 48));
}

//----- (0045CFDD) --------------------------------------------------------
std::vector_MemoryObject *__usercall sub_45CFDD@<eax>(int a1@<ebp>)
{
  return std::vector_DNameNode::Destructor((std::vector_MemoryObject *)(*(_DWORD *)(a1 - 16) + 64));
}

//----- (0045D000) --------------------------------------------------------
void __usercall sub_45D000(int a1@<ebp>)
{
  operator_delete(*(LPVOID *)(a1 - 28));
}

//----- (0045D015) --------------------------------------------------------
MemoryObject *__usercall sub_45D015@<eax>(int a1@<ebp>)
{
  return CIOSocket::Destructor(*(CIOSocket **)(a1 - 16));
}

//----- (0045D028) --------------------------------------------------------
MemoryObject *__usercall sub_45D028@<eax>(int a1@<ebp>)
{
  return CIOSocket::Destructor(*(CIOSocket **)(a1 - 16));
}

//----- (0045D050) --------------------------------------------------------
void __usercall sub_45D050(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 - 24));
}

//----- (0045D070) --------------------------------------------------------
void __usercall sub_45D070(int a1@<ebp>)
{
  operator_delete(*(LPVOID *)(a1 - 28));
}

//----- (0045D0B0) --------------------------------------------------------
void __usercall sub_45D0B0(int a1@<ebp>)
{
  ReadWriteLock::Destructor((ReadWriteLock *)(*(_DWORD *)(a1 - 24) + 16));
}

//----- (0045D0C6) --------------------------------------------------------
void __usercall sub_45D0C6(int a1@<ebp>)
{
  ReadWriteLock::Destructor((ReadWriteLock *)(*(_DWORD *)(a1 - 24) + 16));
}

//----- (0045D0DC) --------------------------------------------------------
void __usercall sub_45D0DC(int a1@<ebp>)
{
  SqlQuery::Destructor((SqlQuery *)(a1 - 40));
}

//----- (0045D0EF) --------------------------------------------------------
void __usercall sub_45D0EF(int a1@<ebp>)
{
  SqlQuery::Destructor((SqlQuery *)(a1 - 548));
}

//----- (0045D110) --------------------------------------------------------
int sub_45D110()
{
  return sub_41FD50();
}

//----- (0045D130) --------------------------------------------------------
void __usercall sub_45D130(int a1@<ebp>)
{
  sub_44DCB0(*(_DWORD *)(a1 - 16));
}

//----- (0045D150) --------------------------------------------------------
void __usercall sub_45D150(int a1@<ebp>)
{
  sub_44DCB0(*(_DWORD *)(a1 - 16));
}

//----- (0045D170) --------------------------------------------------------
void __usercall sub_45D170(int a1@<ebp>)
{
  sub_44DCB0(*(_DWORD *)(a1 - 20));
}

//----- (0045D190) --------------------------------------------------------
std::vector_ServerInfo *__usercall sub_45D190@<eax>(int a1@<ebp>)
{
  return std::vector_ServerInfo::Destructor2((std::vector_ServerInfo *)(*(_DWORD *)(a1 - 20) + 8));
}

//----- (0045D1A6) --------------------------------------------------------
std::vector_ServerInfo *__usercall sub_45D1A6@<eax>(int a1@<ebp>)
{
  return std::vector_ServerInfo::Destructor2((std::vector_ServerInfo *)(*(_DWORD *)(a1 - 36) + 8));
}

//----- (0045D1B2) --------------------------------------------------------
void __usercall sub_45D1B2(int a1@<ebp>)
{
  ReadWriteLock::Destructor((ReadWriteLock *)(*(_DWORD *)(a1 - 36) + 44));
}

//----- (0045D1C8) --------------------------------------------------------
void __usercall sub_45D1C8(int a1@<ebp>)
{
  SqlQuery::Destructor((SqlQuery *)(a1 - 136));
}

//----- (0045D1D4) --------------------------------------------------------
void __usercall sub_45D1D4(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 - 160));
}

//----- (0045D1EC) --------------------------------------------------------
void __usercall sub_45D1EC(int a1@<ebp>)
{
  SqlQuery::Destructor((SqlQuery *)(a1 - 160));
}

//----- (0045D1F8) --------------------------------------------------------
void __usercall sub_45D1F8(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 - 212));
}

//----- (0045D210) --------------------------------------------------------
void __usercall sub_45D210(int a1@<ebp>)
{
  ServerFrameList::Destructor((ServerFrameList *)(a1 - 2120));
}

//----- (0045D230) --------------------------------------------------------
UserInfoTable *__usercall sub_45D230@<eax>(int a1@<ebp>)
{
  return UserInfoTable::Destructor((UserInfoTable *)(a1 - 148));
}

//----- (0045D23C) --------------------------------------------------------
void __usercall sub_45D23C(int a1@<ebp>)
{
  SqlQuery::Destructor((SqlQuery *)(a1 - 4328));
}

//----- (0045D252) --------------------------------------------------------
void __usercall sub_45D252(int a1@<ebp>)
{
  SqlQuery::Destructor((SqlQuery *)(a1 - 80));
}

//----- (0045D25B) --------------------------------------------------------
int __cdecl SEH_43925D(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 44B10C: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0045D265) --------------------------------------------------------
void __usercall sub_45D265(int a1@<ebp>)
{
  SqlQuery::Destructor((SqlQuery *)(a1 - 44));
}

//----- (0045D26E) --------------------------------------------------------
int __cdecl SEH_439436(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 44B10C: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0045D278) --------------------------------------------------------
MemoryObject *__usercall sub_45D278@<eax>(int a1@<ebp>)
{
  return CIOSocket::Destructor(*(CIOSocket **)(a1 - 24));
}

//----- (0045D2A0) --------------------------------------------------------
void __usercall sub_45D2A0(int a1@<ebp>)
{
  operator_delete(*(LPVOID *)(a1 - 28));
}

//----- (0045D2CA) --------------------------------------------------------
MemoryObject *__usercall sub_45D2CA@<eax>(int a1@<ebp>)
{
  return CIOSocket::Destructor(*(CIOSocket **)(a1 - 16));
}

//----- (0045D2DD) --------------------------------------------------------
MemoryObject *__usercall sub_45D2DD@<eax>(int a1@<ebp>)
{
  return CIOSocket::Destructor(*(CIOSocket **)(a1 - 16));
}

//----- (0045D322) --------------------------------------------------------
int __usercall sub_45D322@<eax>(int a1@<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(**(_DWORD **)(a1 - 20) + 4);
  *(_DWORD *)(result + *(_DWORD *)(a1 - 20) + 4 - 4) = &std::basic_ostream<char,std::char_traits<char>>::`vftable'{for `std::basic_ios<char,std::char_traits<char>>'};
  return result;
}
// 45FADC: using guessed type int (__stdcall *std::basic_ostream<char,std::char_traits<char>>::`vftable'{for `std::basic_ios<char,std::char_traits<char>>'})(char);

//----- (0045D32D) --------------------------------------------------------
int __usercall sub_45D32D@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(*(_DWORD *)(a1 + 16) + 52));
}

//----- (0045D338) --------------------------------------------------------
int __usercall sub_45D338@<eax>(int a1@<ebp>)
{
  return sub_40B490(*(_DWORD *)(a1 + 16));
}

//----- (0045D37E) --------------------------------------------------------
int __usercall sub_45D37E@<eax>(int a1@<ebp>)
{
  return std::basic_iostream<char,std::char_traits<char>>::~basic_iostream<char,std::char_traits<char>>((char *)(*(_DWORD *)(a1 - 20) + 12));
}

//----- (0045D389) --------------------------------------------------------
int __usercall sub_45D389@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(*(_DWORD *)(a1 + 20) + 52));
}

//----- (0045D394) --------------------------------------------------------
int __usercall sub_45D394@<eax>(int a1@<ebp>)
{
  return sub_40B490(*(_DWORD *)(a1 + 20));
}

//----- (0045D3C0) --------------------------------------------------------
int __usercall sub_45D3C0@<eax>(int a1@<ebp>)
{
  return sub_40B490(*(_DWORD *)(a1 - 16));
}

//----- (0045D412) --------------------------------------------------------
char *__usercall sub_45D412@<eax>(int a1@<ebp>)
{
  return sub_40B2E0((char *)(*(_DWORD *)(a1 - 20) + 8));
}

//----- (0045D428) --------------------------------------------------------
int sub_45D428()
{
  return sub_41FD50();
}

//----- (0045D43C) --------------------------------------------------------
void __usercall sub_45D43C(int a1@<ebp>)
{
  sub_44DCB0(*(_DWORD *)(a1 - 20));
}

//----- (0045D450) --------------------------------------------------------
void __usercall sub_45D450(int a1@<ebp>)
{
  sub_44DCB0(*(_DWORD *)(a1 - 16));
}

//----- (0045D464) --------------------------------------------------------
void __usercall sub_45D464(int a1@<ebp>)
{
  sub_44DCB0(*(_DWORD *)(a1 - 16));
}

//----- (0045D478) --------------------------------------------------------
void __usercall sub_45D478(int a1@<ebp>)
{
  sub_44DCB0(*(_DWORD *)(a1 - 16));
}

//----- (0045D48C) --------------------------------------------------------
int __usercall sub_45D48C@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 - 16));
}

//----- (0045D4B8) --------------------------------------------------------
int sub_45D4B8()
{
  return sub_41FD50();
}

//----- (0045D4CC) --------------------------------------------------------
void __usercall sub_45D4CC(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 - 16));
}

//----- (0045D4E8) --------------------------------------------------------
int sub_45D4E8()
{
  return sub_41FD50();
}

//----- (0045D4F0) --------------------------------------------------------
int sub_45D4F0()
{
  return sub_41FD50();
}

//----- (0045D504) --------------------------------------------------------
int __usercall sub_45D504@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045D50C) --------------------------------------------------------
void __usercall sub_45D50C(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 - 20));
}

//----- (0045D520) --------------------------------------------------------
int __usercall sub_45D520@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045D534) --------------------------------------------------------
void *__usercall sub_45D534@<eax>(int a1@<ebp>)
{
  return sub_423630(*(void **)(a1 - 16));
}

//----- (0045D548) --------------------------------------------------------
void *__usercall sub_45D548@<eax>(int a1@<ebp>)
{
  return sub_423630(*(void **)(a1 - 20));
}

//----- (0045D550) --------------------------------------------------------
int __usercall sub_45D550@<eax>(int a1@<ebp>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 - 20);
  return sub_41FD50();
}

//----- (0045D55B) --------------------------------------------------------
int __usercall sub_45D55B@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045D570) --------------------------------------------------------
int sub_45D570()
{
  return sub_41FD50();
}

//----- (0045D584) --------------------------------------------------------
void __usercall sub_45D584(int a1@<ebp>)
{
  sub_44DCB0(*(_DWORD *)(a1 - 16));
}

//----- (0045D598) --------------------------------------------------------
int sub_45D598()
{
  return sub_41FD50();
}

//----- (0045D5B6) --------------------------------------------------------
int __usercall sub_45D5B6@<eax>(int a1@<ebp>)
{
  return std::_Locinfo::~_Locinfo((std::_Locinfo *)(a1 - 80));
}

//----- (0045D5D2) --------------------------------------------------------
int __usercall sub_45D5D2@<eax>(int a1@<ebp>)
{
  return std::_Locinfo::~_Locinfo((std::_Locinfo *)(a1 - 124));
}

//----- (0045D5DA) --------------------------------------------------------
int sub_45D5DA()
{
  return sub_41FD50();
}

//----- (0045D5E2) --------------------------------------------------------
int sub_45D5E2()
{
  return sub_41FD50();
}

//----- (0045D5FE) --------------------------------------------------------
int __usercall sub_45D5FE@<eax>(int a1@<ebp>)
{
  return std::_Locinfo::~_Locinfo((std::_Locinfo *)(a1 - 124));
}

//----- (0045D606) --------------------------------------------------------
int sub_45D606()
{
  return sub_41FD50();
}

//----- (0045D60E) --------------------------------------------------------
int sub_45D60E()
{
  return sub_41FD50();
}

//----- (0045D620) --------------------------------------------------------
void __usercall sub_45D620(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 - 16));
}

//----- (0045D63C) --------------------------------------------------------
int __usercall sub_45D63C@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 24));
}

//----- (0045D644) --------------------------------------------------------
void __usercall sub_45D644(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 12));
}

//----- (0045D64E) --------------------------------------------------------
int __usercall sub_45D64E@<eax>(int a1@<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 20) & 1;
  if ( result )
    result = std::locale::~locale(*(std::locale **)(a1 + 8));
  return result;
}

//----- (0045D678) --------------------------------------------------------
void __usercall sub_45D678(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 16));
}

//----- (0045D682) --------------------------------------------------------
int __usercall sub_45D682@<eax>(int a1@<ebp>)
{
  return unknown_libname_130(*(_DWORD *)(a1 + 16));
}
// 423680: using guessed type int __thiscall unknown_libname_130(_DWORD);

//----- (0045D68A) --------------------------------------------------------
void __usercall sub_45D68A(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 16));
}

//----- (0045D694) --------------------------------------------------------
void *__usercall sub_45D694@<eax>(int a1@<ebp>)
{
  return sub_423630(*(void **)(a1 + 16));
}

//----- (0045D69C) --------------------------------------------------------
int sub_45D69C()
{
  return sub_41FD50();
}

//----- (0045D6B8) --------------------------------------------------------
int __usercall sub_45D6B8@<eax>(int a1@<ebp>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 - 20);
  return sub_41FD50();
}

//----- (0045D6C3) --------------------------------------------------------
int __usercall sub_45D6C3@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045D6CB) --------------------------------------------------------
int __usercall sub_45D6CB@<eax>(int a1@<ebp>)
{
  return std::_Locinfo::~_Locinfo((std::_Locinfo *)(a1 - 84));
}

//----- (0045D6D3) --------------------------------------------------------
int __usercall sub_45D6D3@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 + 8));
}

//----- (0045D6E8) --------------------------------------------------------
int __usercall sub_45D6E8@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045D704) --------------------------------------------------------
int __usercall sub_45D704@<eax>(int a1@<ebp>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 - 20);
  return sub_41FD50();
}

//----- (0045D70F) --------------------------------------------------------
int __usercall sub_45D70F@<eax>(int a1@<ebp>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 - 20);
  return sub_41FD50();
}

//----- (0045D71A) --------------------------------------------------------
int __usercall sub_45D71A@<eax>(int a1@<ebp>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 - 20);
  return sub_41FD50();
}

//----- (0045D738) --------------------------------------------------------
int __usercall sub_45D738@<eax>(int a1@<ebp>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 - 16);
  return sub_41FD50();
}

//----- (0045D743) --------------------------------------------------------
int __usercall sub_45D743@<eax>(int a1@<ebp>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 - 16);
  return sub_41FD50();
}

//----- (0045D74E) --------------------------------------------------------
int __usercall sub_45D74E@<eax>(int a1@<ebp>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 - 16);
  return sub_41FD50();
}

//----- (0045D76C) --------------------------------------------------------
int __usercall sub_45D76C@<eax>(int a1@<ebp>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 - 16);
  return sub_41FD50();
}

//----- (0045D777) --------------------------------------------------------
int __usercall sub_45D777@<eax>(int a1@<ebp>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 - 16);
  return sub_41FD50();
}

//----- (0045D794) --------------------------------------------------------
int sub_45D794()
{
  return sub_41FD50();
}

//----- (0045D79C) --------------------------------------------------------
int sub_45D79C()
{
  return sub_41FD50();
}

//----- (0045D7A4) --------------------------------------------------------
int sub_45D7A4()
{
  return sub_41FD50();
}

//----- (0045D7AC) --------------------------------------------------------
int __usercall sub_45D7AC@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 - 20));
}

//----- (0045D7C0) --------------------------------------------------------
int __usercall sub_45D7C0@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 + 28));
}

//----- (0045D7D4) --------------------------------------------------------
int __usercall sub_45D7D4@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 + 28));
}

//----- (0045D7E8) --------------------------------------------------------
int __usercall sub_45D7E8@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 + 28));
}

//----- (0045D7FC) --------------------------------------------------------
int __usercall sub_45D7FC@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 + 28));
}

//----- (0045D810) --------------------------------------------------------
int __usercall sub_45D810@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 + 28));
}

//----- (0045D824) --------------------------------------------------------
int __usercall sub_45D824@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 + 28));
}

//----- (0045D838) --------------------------------------------------------
int __usercall sub_45D838@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 + 28));
}

//----- (0045D84C) --------------------------------------------------------
int __usercall sub_45D84C@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 + 32));
}

//----- (0045D868) --------------------------------------------------------
int sub_45D868()
{
  return sub_41FD50();
}

//----- (0045D870) --------------------------------------------------------
int sub_45D870()
{
  return sub_41FD50();
}

//----- (0045D878) --------------------------------------------------------
int sub_45D878()
{
  return sub_41FD50();
}

//----- (0045D894) --------------------------------------------------------
int sub_45D894()
{
  return sub_41FD50();
}

//----- (0045D8A8) --------------------------------------------------------
int __usercall sub_45D8A8@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 - 20));
}

//----- (0045D8C4) --------------------------------------------------------
int sub_45D8C4()
{
  return sub_41FD50();
}

//----- (0045D8E0) --------------------------------------------------------
void __usercall sub_45D8E0(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 16));
}

//----- (0045D8EA) --------------------------------------------------------
void *__usercall sub_45D8EA@<eax>(int a1@<ebp>)
{
  return sub_423630(*(void **)(a1 + 16));
}

//----- (0045D904) --------------------------------------------------------
void __usercall sub_45D904(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 16));
}

//----- (0045D90E) --------------------------------------------------------
void *__usercall sub_45D90E@<eax>(int a1@<ebp>)
{
  return sub_423630(*(void **)(a1 + 16));
}

//----- (0045D928) --------------------------------------------------------
void __usercall sub_45D928(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 16));
}

//----- (0045D93C) --------------------------------------------------------
int sub_45D93C()
{
  return sub_41FD50();
}

//----- (0045D958) --------------------------------------------------------
int __usercall sub_45D958@<eax>(int a1@<ebp>)
{
  return std::_Locinfo::~_Locinfo((std::_Locinfo *)(a1 - 80));
}

//----- (0045D96C) --------------------------------------------------------
int __usercall sub_45D96C@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045D980) --------------------------------------------------------
int __usercall sub_45D980@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045D994) --------------------------------------------------------
int __usercall sub_45D994@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045D9A8) --------------------------------------------------------
int __usercall sub_45D9A8@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045D9BC) --------------------------------------------------------
int __usercall sub_45D9BC@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045D9D0) --------------------------------------------------------
int __usercall sub_45D9D0@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045D9EC) --------------------------------------------------------
void __usercall sub_45D9EC(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 - 28));
}

//----- (0045D9F6) --------------------------------------------------------
void *__usercall sub_45D9F6@<eax>(int a1@<ebp>)
{
  return sub_423630(*(void **)(a1 - 28));
}

//----- (0045D9FE) --------------------------------------------------------
void __usercall sub_45D9FE(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 - 28));
}

//----- (0045DA08) --------------------------------------------------------
void __usercall sub_45DA08(int a1@<ebp>)
{
  **(_DWORD **)(a1 - 28) = &std::locale::facet::`vftable';
}
// 45FBB0: using guessed type int (__stdcall *std::locale::facet::`vftable')(int);

//----- (0045DA10) --------------------------------------------------------
void __usercall sub_45DA10(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 - 28));
}

//----- (0045DA1A) --------------------------------------------------------
void __usercall sub_45DA1A(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 - 28));
}

//----- (0045DA24) --------------------------------------------------------
void __usercall sub_45DA24(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 12));
}

//----- (0045DA2E) --------------------------------------------------------
void __usercall sub_45DA2E(int a1@<ebp>)
{
  **(_DWORD **)(a1 + 12) = &std::locale::facet::`vftable';
}
// 45FBB0: using guessed type int (__stdcall *std::locale::facet::`vftable')(int);

//----- (0045DA36) --------------------------------------------------------
void __usercall sub_45DA36(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 12));
}

//----- (0045DA40) --------------------------------------------------------
void __usercall sub_45DA40(int a1@<ebp>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 + 12);
  JUMPOUT(&loc_441D4D);
}

//----- (0045DA48) --------------------------------------------------------
void __usercall sub_45DA48(int a1@<ebp>)
{
  _Free(*(LPVOID *)(*(_DWORD *)(a1 + 12) + 8));
}

//----- (0045DA60) --------------------------------------------------------
int sub_45DA60()
{
  return sub_41FD50();
}

//----- (0045DA7C) --------------------------------------------------------
int sub_45DA7C()
{
  return std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::_Tidy(1);
}
// 445D22: using guessed type _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short>>::_Tidy(char);

//----- (0045DA84) --------------------------------------------------------
void sub_45DA84()
{
  JUMPOUT(&loc_4455F6);
}

//----- (0045DA8C) --------------------------------------------------------
void sub_45DA8C()
{
  JUMPOUT(&loc_4455F6);
}

//----- (0045DA94) --------------------------------------------------------
int __usercall sub_45DA94@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 - 20));
}

//----- (0045DAA8) --------------------------------------------------------
int __usercall sub_45DAA8@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 + 28));
}

//----- (0045DABC) --------------------------------------------------------
int __usercall sub_45DABC@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 + 28));
}

//----- (0045DAD0) --------------------------------------------------------
int __usercall sub_45DAD0@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 + 28));
}

//----- (0045DAE4) --------------------------------------------------------
int __usercall sub_45DAE4@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 + 28));
}

//----- (0045DAF8) --------------------------------------------------------
int __usercall sub_45DAF8@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 + 28));
}

//----- (0045DB0C) --------------------------------------------------------
int __usercall sub_45DB0C@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 + 28));
}

//----- (0045DB20) --------------------------------------------------------
int __usercall sub_45DB20@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 + 28));
}

//----- (0045DB34) --------------------------------------------------------
int __usercall sub_45DB34@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 + 32));
}

//----- (0045DB50) --------------------------------------------------------
void sub_45DB50()
{
  JUMPOUT(&loc_4455F6);
}

//----- (0045DB58) --------------------------------------------------------
void sub_45DB58()
{
  JUMPOUT(&loc_4455F6);
}

//----- (0045DB60) --------------------------------------------------------
void sub_45DB60()
{
  JUMPOUT(&loc_4455F6);
}

//----- (0045DB7C) --------------------------------------------------------
int __usercall sub_45DB7C@<eax>(int a1@<ebp>)
{
  int result; // eax@1
  int v2; // ecx@2

  result = *(_DWORD *)(a1 - 16) & 1;
  if ( result )
  {
    v2 = *(_DWORD *)(a1 + 8);
    JUMPOUT(&loc_4455F6);
  }
  return result;
}

//----- (0045DBA8) --------------------------------------------------------
int sub_45DBA8()
{
  return sub_41FD50();
}

//----- (0045DBBC) --------------------------------------------------------
void sub_45DBBC()
{
  JUMPOUT(&loc_4455F6);
}

//----- (0045DBD0) --------------------------------------------------------
void sub_45DBD0()
{
  JUMPOUT(&loc_4455F6);
}

//----- (0045DBEC) --------------------------------------------------------
void sub_45DBEC()
{
  JUMPOUT(&loc_4455F6);
}

//----- (0045DC08) --------------------------------------------------------
int sub_45DC08()
{
  return sub_41FD50();
}

//----- (0045DC1C) --------------------------------------------------------
int __usercall sub_45DC1C@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 - 20));
}

//----- (0045DC38) --------------------------------------------------------
int sub_45DC38()
{
  return sub_41FD50();
}

//----- (0045DC54) --------------------------------------------------------
int __usercall sub_45DC54@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 - 112));
}

//----- (0045DC5C) --------------------------------------------------------
int __usercall sub_45DC5C@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 - 104));
}

//----- (0045DC64) --------------------------------------------------------
void sub_45DC64()
{
  JUMPOUT(&loc_4455F6);
}

//----- (0045DC6C) --------------------------------------------------------
void sub_45DC6C()
{
  JUMPOUT(&loc_4455F6);
}

//----- (0045DC74) --------------------------------------------------------
int sub_45DC74()
{
  return sub_41FD50();
}

//----- (0045DC7F) --------------------------------------------------------
int sub_45DC7F()
{
  return sub_41FD50();
}

//----- (0045DC87) --------------------------------------------------------
void sub_45DC87()
{
  JUMPOUT(&loc_4455F6);
}

//----- (0045DC92) --------------------------------------------------------
void sub_45DC92()
{
  JUMPOUT(&loc_4455F6);
}

//----- (0045DC9D) --------------------------------------------------------
void sub_45DC9D()
{
  JUMPOUT(&loc_4455F6);
}

//----- (0045DCA8) --------------------------------------------------------
void sub_45DCA8()
{
  JUMPOUT(&loc_4455F6);
}

//----- (0045DCB3) --------------------------------------------------------
void sub_45DCB3()
{
  JUMPOUT(&loc_4455F6);
}

//----- (0045DCBE) --------------------------------------------------------
void sub_45DCBE()
{
  JUMPOUT(&loc_4455F6);
}

//----- (0045DCC9) --------------------------------------------------------
void sub_45DCC9()
{
  JUMPOUT(&loc_4455F6);
}

//----- (0045DCD1) --------------------------------------------------------
int __usercall sub_45DCD1@<eax>(int a1@<ebp>)
{
  int result; // eax@1
  int v2; // ecx@2

  result = *(_DWORD *)(a1 - 120) & 1;
  if ( result )
  {
    v2 = *(_DWORD *)(a1 + 8);
    JUMPOUT(&loc_4455F6);
  }
  return result;
}

//----- (0045DCFC) --------------------------------------------------------
int __usercall sub_45DCFC@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 - 48));
}

//----- (0045DD04) --------------------------------------------------------
int __usercall sub_45DD04@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 - 48));
}

//----- (0045DD0C) --------------------------------------------------------
int sub_45DD0C()
{
  return sub_41FD50();
}

//----- (0045DD17) --------------------------------------------------------
void sub_45DD17()
{
  JUMPOUT(&loc_4455F6);
}

//----- (0045DD1F) --------------------------------------------------------
void sub_45DD1F()
{
  JUMPOUT(&loc_4455F6);
}

//----- (0045DD27) --------------------------------------------------------
void sub_45DD27()
{
  JUMPOUT(&loc_4455F6);
}

//----- (0045DD2F) --------------------------------------------------------
void sub_45DD2F()
{
  JUMPOUT(&loc_4455F6);
}

//----- (0045DD3A) --------------------------------------------------------
void sub_45DD3A()
{
  JUMPOUT(&loc_4455F6);
}

//----- (0045DD4C) --------------------------------------------------------
void __usercall sub_45DD4C(int a1@<ebp>)
{
  **(_DWORD **)(a1 - 16) = &std::locale::facet::`vftable';
}
// 45FBB0: using guessed type int (__stdcall *std::locale::facet::`vftable')(int);

//----- (0045DD74) --------------------------------------------------------
void __usercall sub_45DD74(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 16));
}

//----- (0045DD90) --------------------------------------------------------
void __usercall sub_45DD90(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 16));
}

//----- (0045DD9A) --------------------------------------------------------
void *__usercall sub_45DD9A@<eax>(int a1@<ebp>)
{
  return sub_423630(*(void **)(a1 + 16));
}

//----- (0045DDB4) --------------------------------------------------------
void __usercall sub_45DDB4(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 16));
}

//----- (0045DDBE) --------------------------------------------------------
void *__usercall sub_45DDBE@<eax>(int a1@<ebp>)
{
  return sub_423630(*(void **)(a1 + 16));
}

//----- (0045DDD8) --------------------------------------------------------
void __usercall sub_45DDD8(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 16));
}

//----- (0045DDF4) --------------------------------------------------------
void __usercall sub_45DDF4(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 16));
}

//----- (0045DE10) --------------------------------------------------------
void __usercall sub_45DE10(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 16));
}

//----- (0045DE2C) --------------------------------------------------------
void __usercall sub_45DE2C(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 16));
}

//----- (0045DE36) --------------------------------------------------------
void *__usercall sub_45DE36@<eax>(int a1@<ebp>)
{
  return sub_423630(*(void **)(a1 + 16));
}

//----- (0045DE50) --------------------------------------------------------
void __usercall sub_45DE50(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 16));
}

//----- (0045DE5A) --------------------------------------------------------
void *__usercall sub_45DE5A@<eax>(int a1@<ebp>)
{
  return sub_423630(*(void **)(a1 + 16));
}

//----- (0045DE74) --------------------------------------------------------
void __usercall sub_45DE74(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 16));
}

//----- (0045DE90) --------------------------------------------------------
void __usercall sub_45DE90(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 16));
}

//----- (0045DEAC) --------------------------------------------------------
void __usercall sub_45DEAC(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 16));
}

//----- (0045DEC8) --------------------------------------------------------
void __usercall sub_45DEC8(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 16));
}

//----- (0045DEE4) --------------------------------------------------------
void __usercall sub_45DEE4(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 16));
}

//----- (0045DEF8) --------------------------------------------------------
int __usercall sub_45DEF8@<eax>(int a1@<ebp>, int a2)
{
  int v2; // ecx@1

  v2 = *(_DWORD *)(a1 - 16);
  return unknown_libname_135(a2);
}
// 423E50: using guessed type int __cdecl unknown_libname_135(_DWORD);

//----- (0045DF0C) --------------------------------------------------------
int sub_45DF0C()
{
  return sub_41FD50();
}

//----- (0045DF20) --------------------------------------------------------
int __usercall sub_45DF20@<eax>(int a1@<ebp>)
{
  return unknown_libname_130(*(_DWORD *)(a1 - 16));
}
// 423680: using guessed type int __thiscall unknown_libname_130(_DWORD);

//----- (0045DF34) --------------------------------------------------------
void __usercall sub_45DF34(int a1@<ebp>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 - 16);
  JUMPOUT(&loc_441D4D);
}

//----- (0045DF3C) --------------------------------------------------------
void __usercall sub_45DF3C(int a1@<ebp>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 - 16);
  JUMPOUT(&loc_441B73);
}

//----- (0045DF5C) --------------------------------------------------------
int __usercall sub_45DF5C@<eax>(int a1@<ebp>)
{
  return std::_Locinfo::~_Locinfo((std::_Locinfo *)(a1 - 80));
}

//----- (0045DF70) --------------------------------------------------------
void *__usercall sub_45DF70@<eax>(int a1@<ebp>)
{
  return sub_423630(*(void **)(a1 - 16));
}

//----- (0045DF8C) --------------------------------------------------------
int __usercall sub_45DF8C@<eax>(int a1@<ebp>)
{
  return std::_Locinfo::~_Locinfo((std::_Locinfo *)(a1 - 80));
}

//----- (0045DFA8) --------------------------------------------------------
int __usercall sub_45DFA8@<eax>(int a1@<ebp>)
{
  return std::_Locinfo::~_Locinfo((std::_Locinfo *)(a1 - 80));
}

//----- (0045DFBC) --------------------------------------------------------
int __usercall sub_45DFBC@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045DFD0) --------------------------------------------------------
int __usercall sub_45DFD0@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045DFE4) --------------------------------------------------------
int __usercall sub_45DFE4@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045DFF8) --------------------------------------------------------
int __usercall sub_45DFF8@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E00C) --------------------------------------------------------
int __usercall sub_45E00C@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E020) --------------------------------------------------------
int __usercall sub_45E020@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E034) --------------------------------------------------------
int __usercall sub_45E034@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E048) --------------------------------------------------------
int __usercall sub_45E048@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E05C) --------------------------------------------------------
int __usercall sub_45E05C@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E070) --------------------------------------------------------
int __usercall sub_45E070@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E084) --------------------------------------------------------
int __usercall sub_45E084@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E098) --------------------------------------------------------
int __usercall sub_45E098@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E0AC) --------------------------------------------------------
int __usercall sub_45E0AC@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E0C8) --------------------------------------------------------
int __usercall sub_45E0C8@<eax>(int a1@<ebp>)
{
  return std::_Locinfo::~_Locinfo((std::_Locinfo *)(a1 - 80));
}

//----- (0045E0DC) --------------------------------------------------------
int __usercall sub_45E0DC@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E0F0) --------------------------------------------------------
int __usercall sub_45E0F0@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E104) --------------------------------------------------------
int __usercall sub_45E104@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E118) --------------------------------------------------------
int __usercall sub_45E118@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E12C) --------------------------------------------------------
int __usercall sub_45E12C@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E140) --------------------------------------------------------
int __usercall sub_45E140@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E154) --------------------------------------------------------
int __usercall sub_45E154@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E168) --------------------------------------------------------
int __usercall sub_45E168@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E17C) --------------------------------------------------------
int __usercall sub_45E17C@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E190) --------------------------------------------------------
int __usercall sub_45E190@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E1A4) --------------------------------------------------------
int __usercall sub_45E1A4@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E1B8) --------------------------------------------------------
int __usercall sub_45E1B8@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E1CC) --------------------------------------------------------
int __usercall sub_45E1CC@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E1E8) --------------------------------------------------------
void __usercall sub_45E1E8(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 - 20));
}

//----- (0045E1F2) --------------------------------------------------------
void __usercall sub_45E1F2(int a1@<ebp>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 - 20);
  JUMPOUT(&loc_441D54);
}

//----- (0045E1FA) --------------------------------------------------------
void __usercall sub_45E1FA(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 - 20));
}

//----- (0045E204) --------------------------------------------------------
void __usercall sub_45E204(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 - 20));
}

//----- (0045E20E) --------------------------------------------------------
void __usercall sub_45E20E(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 12));
}

//----- (0045E218) --------------------------------------------------------
void __usercall sub_45E218(int a1@<ebp>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 + 12);
  JUMPOUT(&loc_441D4D);
}

//----- (0045E220) --------------------------------------------------------
void __usercall sub_45E220(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 20));
}

//----- (0045E22A) --------------------------------------------------------
void __usercall sub_45E22A(int a1@<ebp>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 + 20);
  JUMPOUT(&loc_441D4D);
}

//----- (0045E232) --------------------------------------------------------
void __usercall sub_45E232(int a1@<ebp>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 + 20);
  JUMPOUT(&loc_441B73);
}

//----- (0045E250) --------------------------------------------------------
int __usercall sub_45E250@<eax>(int a1@<ebp>)
{
  int result; // eax@1
  int v2; // ecx@2

  result = *(_DWORD *)(a1 - 16) & 1;
  if ( result )
  {
    v2 = *(_DWORD *)(a1 + 8);
    result = sub_41FD50();
  }
  return result;
}

//----- (0045E27C) --------------------------------------------------------
int sub_45E27C()
{
  return sub_41FD50();
}

//----- (0045E290) --------------------------------------------------------
int sub_45E290()
{
  return sub_41FD50();
}

//----- (0045E2A4) --------------------------------------------------------
int sub_45E2A4()
{
  return sub_41FD50();
}

//----- (0045E2C0) --------------------------------------------------------
int sub_45E2C0()
{
  return sub_41FD50();
}

//----- (0045E2D4) --------------------------------------------------------
int sub_45E2D4()
{
  return sub_41FD50();
}

//----- (0045E2F0) --------------------------------------------------------
int __usercall sub_45E2F0@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 - 72));
}

//----- (0045E2F8) --------------------------------------------------------
int __usercall sub_45E2F8@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 - 112));
}

//----- (0045E300) --------------------------------------------------------
int sub_45E300()
{
  return sub_41FD50();
}

//----- (0045E308) --------------------------------------------------------
int sub_45E308()
{
  return sub_41FD50();
}

//----- (0045E310) --------------------------------------------------------
int sub_45E310()
{
  return sub_41FD50();
}

//----- (0045E31B) --------------------------------------------------------
int sub_45E31B()
{
  return sub_41FD50();
}

//----- (0045E323) --------------------------------------------------------
int sub_45E323()
{
  return sub_41FD50();
}

//----- (0045E32E) --------------------------------------------------------
int sub_45E32E()
{
  return sub_41FD50();
}

//----- (0045E339) --------------------------------------------------------
int sub_45E339()
{
  return sub_41FD50();
}

//----- (0045E344) --------------------------------------------------------
int sub_45E344()
{
  return sub_41FD50();
}

//----- (0045E34F) --------------------------------------------------------
int sub_45E34F()
{
  return sub_41FD50();
}

//----- (0045E35A) --------------------------------------------------------
int sub_45E35A()
{
  return sub_41FD50();
}

//----- (0045E365) --------------------------------------------------------
int sub_45E365()
{
  return sub_41FD50();
}

//----- (0045E380) --------------------------------------------------------
int __usercall sub_45E380@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 - 40));
}

//----- (0045E388) --------------------------------------------------------
int __usercall sub_45E388@<eax>(int a1@<ebp>)
{
  return std::locale::~locale((std::locale *)(a1 - 40));
}

//----- (0045E390) --------------------------------------------------------
int sub_45E390()
{
  return sub_41FD50();
}

//----- (0045E39B) --------------------------------------------------------
int sub_45E39B()
{
  return sub_41FD50();
}

//----- (0045E3A3) --------------------------------------------------------
int sub_45E3A3()
{
  return sub_41FD50();
}

//----- (0045E3AB) --------------------------------------------------------
int sub_45E3AB()
{
  return sub_41FD50();
}

//----- (0045E3B3) --------------------------------------------------------
int sub_45E3B3()
{
  return sub_41FD50();
}

//----- (0045E3BE) --------------------------------------------------------
int sub_45E3BE()
{
  return sub_41FD50();
}

//----- (0045E3D0) --------------------------------------------------------
void __usercall sub_45E3D0(int a1@<ebp>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 - 16);
  JUMPOUT(&loc_4456CD);
}

//----- (0045E3EC) --------------------------------------------------------
void __usercall sub_45E3EC(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 16));
}

//----- (0045E408) --------------------------------------------------------
void __usercall sub_45E408(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 16));
}

//----- (0045E424) --------------------------------------------------------
void __usercall sub_45E424(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 16));
}

//----- (0045E42E) --------------------------------------------------------
void *__usercall sub_45E42E@<eax>(int a1@<ebp>)
{
  return sub_423630(*(void **)(a1 + 16));
}

//----- (0045E448) --------------------------------------------------------
void __usercall sub_45E448(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 16));
}

//----- (0045E452) --------------------------------------------------------
void *__usercall sub_45E452@<eax>(int a1@<ebp>)
{
  return sub_423630(*(void **)(a1 + 16));
}

//----- (0045E46C) --------------------------------------------------------
void __usercall sub_45E46C(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 16));
}

//----- (0045E488) --------------------------------------------------------
void __usercall sub_45E488(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 16));
}

//----- (0045E4A4) --------------------------------------------------------
void __usercall sub_45E4A4(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 16));
}

//----- (0045E4C0) --------------------------------------------------------
void __usercall sub_45E4C0(int a1@<ebp>)
{
  _delete_table(*(LPVOID *)(a1 + 16));
}

//----- (0045E4D4) --------------------------------------------------------
void *__usercall sub_45E4D4@<eax>(int a1@<ebp>)
{
  return sub_423630(*(void **)(a1 - 16));
}

//----- (0045E4F0) --------------------------------------------------------
int __usercall sub_45E4F0@<eax>(int a1@<ebp>)
{
  return std::_Locinfo::~_Locinfo((std::_Locinfo *)(a1 - 80));
}

//----- (0045E50C) --------------------------------------------------------
int __usercall sub_45E50C@<eax>(int a1@<ebp>)
{
  return std::_Locinfo::~_Locinfo((std::_Locinfo *)(a1 - 80));
}

//----- (0045E520) --------------------------------------------------------
void __usercall sub_45E520(int a1@<ebp>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 - 16);
  JUMPOUT(&loc_441D4D);
}

//----- (0045E528) --------------------------------------------------------
void __usercall sub_45E528(int a1@<ebp>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 - 16);
  JUMPOUT(&loc_441B73);
}

//----- (0045E540) --------------------------------------------------------
int __usercall sub_45E540@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E554) --------------------------------------------------------
int __usercall sub_45E554@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E568) --------------------------------------------------------
int __usercall sub_45E568@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E57C) --------------------------------------------------------
int __usercall sub_45E57C@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E590) --------------------------------------------------------
int __usercall sub_45E590@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E5A4) --------------------------------------------------------
int __usercall sub_45E5A4@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E5B8) --------------------------------------------------------
int __usercall sub_45E5B8@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E5CC) --------------------------------------------------------
int __usercall sub_45E5CC@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E5E8) --------------------------------------------------------
int __usercall sub_45E5E8@<eax>(int a1@<ebp>)
{
  return std::_Locinfo::~_Locinfo((std::_Locinfo *)(a1 - 80));
}

//----- (0045E5FC) --------------------------------------------------------
int __usercall sub_45E5FC@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E610) --------------------------------------------------------
int __usercall sub_45E610@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E624) --------------------------------------------------------
int __usercall sub_45E624@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E638) --------------------------------------------------------
int __usercall sub_45E638@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E64C) --------------------------------------------------------
int __usercall sub_45E64C@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E660) --------------------------------------------------------
int __usercall sub_45E660@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E674) --------------------------------------------------------
int __usercall sub_45E674@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

//----- (0045E688) --------------------------------------------------------
int __usercall sub_45E688@<eax>(int a1@<ebp>)
{
  return std::_Lockit::~_Lockit((std::_Lockit *)(a1 - 16));
}

// ALL OK, 2145 function(s) have been successfully decompiled
